(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],c=e[1],l=e[2],u=0,d=[];u<s.length;u++)i=s[u],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&d.push(a[i][0]),a[i]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(n[r]=c[r]);for(p&&p(e);d.length;)d.shift()();return o.push.apply(o,l||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var c=t[s];0!==a[c]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={3:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{1:"ae869424",2:"740f7281",4:"caf8fc57",5:"a5b5612e",6:"d5bf1f68",7:"a86160c5",8:"3d3f94c6",9:"1f823028",10:"699bbbda",11:"f91f6e4f",12:"6cc4ba8d",13:"49d5b1bc",14:"85c05523",15:"232b66f2",16:"a1560b59",17:"daf4c117",18:"ac59a2d6",19:"8201ef6f",20:"9c022358",21:"95a1d524",22:"e7ece882",23:"8099a8e8",24:"3f5d7f8a",25:"9390800f",26:"e4893c29",27:"595fa087",28:"88ce28ef",29:"22df69e7",30:"927f718e",31:"03d70665",32:"7d84a605",33:"55e34a95",34:"2771af29",35:"7b81884e",36:"42a1bdde",37:"6b544ad8",38:"96932767",39:"969153b4",40:"2ee252bf",41:"7c88ebde",42:"d589ca0d",43:"a18ff967",44:"d3cb57f7",45:"82d4166e",46:"c189a417",47:"4d36fbfa",48:"c3b8a296",49:"f2640991",50:"242c8795",51:"00774c28",52:"ba2ffb00",53:"2735a4bc",54:"09b0ed02",55:"4ba44564",56:"4c2d1c4c",57:"1de37680",58:"8adca485",59:"491c9aee",60:"bbf8a921",61:"e9660abf",62:"ba7bf299",63:"d870bbc7",64:"5cd11dc5",65:"2ad82800",66:"e6550117",67:"7a36b52f",68:"3ac2603b",69:"cf3601d4",70:"45606b8d",71:"256f5274",72:"5094085c",73:"7b561a58",74:"2a4878d4",75:"00736cf4",76:"62c36fc4",77:"91a8d068",78:"6301781e",79:"d09faabf",80:"144c8671",81:"9f03f42a",82:"0d80deae",83:"b875b795",84:"179a72ce",85:"246f28cb",86:"c97453cb",87:"a31e791f",88:"af0e1240",89:"62d4bd14",90:"77badbed",91:"6f275289",92:"3bfe1b32",93:"d75cb44c",94:"2b664e10",95:"8ebc0573",96:"1be97970",97:"bb0fb946",98:"52bb70ee",99:"3d4c6c5c",100:"1aa080c0",101:"e5c6872d",102:"aa391fd5",103:"4952e80e",104:"369f696d",105:"99e819d8",106:"26f80ac0",107:"7d05f2b6",108:"20f691e3",109:"a9ec257f",110:"b9fcbfc7",111:"af8380cc",112:"bdac5cdc",113:"49c994c0",114:"7a909846",115:"e69d8dfc"}[n]+".js"}(n);var c=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(l);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;c.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",c.name="ChunkLoadError",c.type=r,c.request=o,t[1](c)}a[n]=void 0}};var l=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/znote/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=e,s=s.slice();for(var l=0;l<s.length;l++)e(s[l]);var p=c;o.push([150,0]),t()}([function(n,e,t){"use strict";t.d(e,"e",(function(){return v})),t.d(e,"d",(function(){return y})),t.d(e,"c",(function(){return x})),t.d(e,"f",(function(){return w})),t.d(e,"a",(function(){return k})),t.d(e,"g",(function(){return S})),t.d(e,"b",(function(){return C})),t.d(e,"h",(function(){return j})),t.d(e,"i",(function(){return A}));t(13),t(175);var r=t(1),a={NotFound:()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,477)),Category:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(7)]).then(t.bind(null,478)),Layout:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(4)]).then(t.bind(null,474)),Tag:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(5)]).then(t.bind(null,479)),Tags:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(6)]).then(t.bind(null,480)),TimeLines:()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(11)]).then(t.bind(null,481))},o={"v-6885a764":()=>t.e(24).then(t.bind(null,489)),"v-27bdaeaa":()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,472)),"v-2e6c285b":()=>t.e(22).then(t.bind(null,490)),"v-7e3794d9":()=>Promise.all([t.e(0),t.e(19)]).then(t.bind(null,482)),"v-59e792f7":()=>t.e(26).then(t.bind(null,491)),"v-a03de038":()=>t.e(23).then(t.bind(null,492)),"v-59596aa5":()=>t.e(27).then(t.bind(null,493)),"v-0a438352":()=>t.e(29).then(t.bind(null,494)),"v-8b8c23d2":()=>t.e(30).then(t.bind(null,495)),"v-229bb1b7":()=>t.e(28).then(t.bind(null,496)),"v-b07ca2b2":()=>t.e(31).then(t.bind(null,497)),"v-93974ed2":()=>t.e(32).then(t.bind(null,498)),"v-6ebf631e":()=>t.e(33).then(t.bind(null,499)),"v-0b69064b":()=>t.e(35).then(t.bind(null,500)),"v-9ebad7d2":()=>t.e(34).then(t.bind(null,501)),"v-74fedb77":()=>t.e(37).then(t.bind(null,502)),"v-3c7afeb6":()=>t.e(36).then(t.bind(null,503)),"v-1c8f87f8":()=>t.e(25).then(t.bind(null,504)),"v-a3d48a82":()=>t.e(38).then(t.bind(null,505)),"v-6dc818d2":()=>t.e(39).then(t.bind(null,506)),"v-cdecc45e":()=>t.e(40).then(t.bind(null,507)),"v-8cb01f92":()=>t.e(41).then(t.bind(null,508)),"v-196b8f52":()=>t.e(43).then(t.bind(null,509)),"v-989d2c6a":()=>t.e(42).then(t.bind(null,510)),"v-04d0dd31":()=>t.e(44).then(t.bind(null,511)),"v-1ba7191d":()=>t.e(45).then(t.bind(null,512)),"v-6bf3fa77":()=>t.e(46).then(t.bind(null,513)),"v-2ed49eb7":()=>t.e(47).then(t.bind(null,514)),"v-90af05e8":()=>t.e(49).then(t.bind(null,515)),"v-73fde4d7":()=>t.e(50).then(t.bind(null,516)),"v-3e9083fd":()=>t.e(48).then(t.bind(null,517)),"v-42002a52":()=>t.e(51).then(t.bind(null,518)),"v-f59ecb92":()=>t.e(53).then(t.bind(null,519)),"v-77367395":()=>t.e(52).then(t.bind(null,520)),"v-24839ad2":()=>t.e(54).then(t.bind(null,521)),"v-6dd97e97":()=>t.e(55).then(t.bind(null,522)),"v-f711c112":()=>t.e(56).then(t.bind(null,523)),"v-1e51bcb2":()=>t.e(57).then(t.bind(null,524)),"v-2b4237af":()=>t.e(58).then(t.bind(null,525)),"v-345c456d":()=>t.e(59).then(t.bind(null,526)),"v-55af23a5":()=>t.e(60).then(t.bind(null,527)),"v-a2fc25ba":()=>t.e(61).then(t.bind(null,528)),"v-0754b6a1":()=>t.e(62).then(t.bind(null,529)),"v-8e0b6cc6":()=>t.e(64).then(t.bind(null,530)),"v-6027801f":()=>t.e(63).then(t.bind(null,531)),"v-11cd131b":()=>t.e(65).then(t.bind(null,532)),"v-65a6b7f7":()=>t.e(66).then(t.bind(null,533)),"v-24ae108a":()=>t.e(68).then(t.bind(null,534)),"v-3456e51e":()=>t.e(67).then(t.bind(null,535)),"v-d12af5d4":()=>t.e(70).then(t.bind(null,536)),"v-3c54cc77":()=>t.e(69).then(t.bind(null,537)),"v-5cb8f20a":()=>t.e(72).then(t.bind(null,538)),"v-1bebd69a":()=>t.e(73).then(t.bind(null,539)),"v-0eb0312f":()=>t.e(74).then(t.bind(null,540)),"v-1e6887d2":()=>t.e(71).then(t.bind(null,541)),"v-6a4aab62":()=>t.e(75).then(t.bind(null,542)),"v-65899d47":()=>t.e(77).then(t.bind(null,543)),"v-f1f5b922":()=>t.e(76).then(t.bind(null,544)),"v-5d97d573":()=>t.e(78).then(t.bind(null,545)),"v-5dec17bf":()=>t.e(79).then(t.bind(null,546)),"v-bed2e2f2":()=>t.e(80).then(t.bind(null,547)),"v-25eb7c17":()=>t.e(81).then(t.bind(null,548)),"v-09c6eb57":()=>t.e(82).then(t.bind(null,549)),"v-57f1379d":()=>t.e(83).then(t.bind(null,550)),"v-1cf9f311":()=>t.e(84).then(t.bind(null,551)),"v-6b8bff0f":()=>t.e(85).then(t.bind(null,552)),"v-56da6351":()=>Promise.all([t.e(0),t.e(20)]).then(t.bind(null,553)),"v-33ecb7b6":()=>t.e(86).then(t.bind(null,554)),"v-3274a2d6":()=>t.e(87).then(t.bind(null,555)),"v-b517ba06":()=>t.e(90).then(t.bind(null,556)),"v-3419df1d":()=>t.e(91).then(t.bind(null,557)),"v-28ad82bd":()=>t.e(92).then(t.bind(null,558)),"v-fd18a65e":()=>t.e(93).then(t.bind(null,559)),"v-209f2ade":()=>t.e(94).then(t.bind(null,560)),"v-193cdd9e":()=>t.e(95).then(t.bind(null,483)),"v-21bc8b46":()=>t.e(96).then(t.bind(null,561)),"v-7ad83f1b":()=>t.e(97).then(t.bind(null,562)),"v-59d18056":()=>t.e(99).then(t.bind(null,563)),"v-5cfc5853":()=>t.e(100).then(t.bind(null,564)),"v-10c74a0d":()=>t.e(101).then(t.bind(null,565)),"v-3b409fbd":()=>t.e(103).then(t.bind(null,566)),"v-0727fa02":()=>t.e(102).then(t.bind(null,567)),"v-7a153c7b":()=>t.e(104).then(t.bind(null,568)),"v-b3ebfa12":()=>t.e(105).then(t.bind(null,569)),"v-b9441912":()=>t.e(106).then(t.bind(null,570)),"v-309fb177":()=>t.e(107).then(t.bind(null,571)),"v-2830159a":()=>t.e(108).then(t.bind(null,572)),"v-5d6482c8":()=>t.e(109).then(t.bind(null,573)),"v-516caef5":()=>t.e(113).then(t.bind(null,574)),"v-90c76f52":()=>t.e(110).then(t.bind(null,575)),"v-660e1712":()=>t.e(111).then(t.bind(null,576)),"v-1f63dd63":()=>t.e(114).then(t.bind(null,577)),"v-0008eb77":()=>t.e(112).then(t.bind(null,578)),"v-4789f531":()=>t.e(89).then(t.bind(null,579)),"v-7d39c359":()=>t.e(98).then(t.bind(null,580)),"v-011bc3d7":()=>t.e(88).then(t.bind(null,581))};function i(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const s=/-(\w)/g,c=i(n=>n.replace(s,(n,e)=>e?e.toUpperCase():"")),l=/\B([A-Z])/g,p=i(n=>n.replace(l,"-$1").toLowerCase()),u=i(n=>n.charAt(0).toUpperCase()+n.slice(1));function d(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(u(c(e))):n(u(e))||n(p(e))}const m=Object.assign({},a,o),h=n=>m[n],g=n=>o[n],f=n=>a[n],b=n=>r.a.component(n);function v(n){return d(g,n)}function y(n){return d(f,n)}function x(n){return d(h,n)}function w(n){return d(b,n)}function k(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!w(n)&&x(n)){const e=await x(n)();r.a.component(n,e.default)}}))}function S(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}function C(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.key===e)return r}return{path:"",frontmatter:{}}}function j(n,e){const{$localePath:t}=n;return"object"==typeof e&&e[t]?e[t]:e}function A(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}},function(n,e,t){"use strict";t.d(e,"a",(function(){return Vt}));
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function o(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var y=v("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function k(n,e){return w.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var C=/-(\w)/g,j=S((function(n){return n.replace(C,(function(n,e){return e?e.toUpperCase():""}))})),A=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,E=S((function(n){return n.replace(T,"-$1").toLowerCase()}));var P=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function D(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function z(n,e){for(var t in e)n[t]=e[t];return n}function B(n){for(var e={},t=0;t<n.length;t++)n[t]&&z(e,n[t]);return e}function I(n,e,t){}var O=function(n,e,t){return!1},_=function(n){return n};function L(n,e){if(n===e)return!0;var t=p(n),r=p(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return L(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return L(n[t],e[t])}))}catch(n){return!1}}function F(n,e){for(var t=0;t<n.length;t++)if(L(n[t],e))return t;return-1}function M(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function R(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var N=["component","directive","filter"],q=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],U={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:I,parsePlatformTagName:_,mustUseProp:O,async:!0,_lifecycleHooks:q},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function J(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(H.source,".$_\\d]"));var W="__proto__"in{},Q="undefined"!=typeof window,K=Q&&window.navigator.userAgent.toLowerCase(),G=K&&/msie|trident/.test(K),X=K&&K.indexOf("msie 9.0")>0,Z=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Y=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(Q)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!Q&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=Q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,pn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);ln="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function dn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,r,a,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function fn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=[],yn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function wn(n){xn.push(n),yn.target=n}function kn(){xn.pop(),yn.target=xn[xn.length-1]}var Sn=Array.prototype,Cn=Object.create(Sn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Sn[n];J(Cn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));var jn=Object.getOwnPropertyNames(Cn),An={},Tn=!0;function En(n){Tn=n}var Pn={notify:I,depend:I,addSub:I,removeSub:I},Dn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Pn:new yn,this.vmCount=0,J(n,"__ob__",this),a(n)){if(!t)if(W)n.__proto__=Cn;else for(var r=0,o=jn.length;r<o;r++){J(n,s=jn[r],Cn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;Bn(n,s=i[r],An,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)zn(n[e],!1,this.mock)},n}();function zn(n,e,t){return n&&k(n,"__ob__")&&n.__ob__ instanceof Dn?n.__ob__:!Tn||!t&&on()||!a(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||Rn(n)||n instanceof mn?void 0:new Dn(n,e,t)}function Bn(n,e,t,r,o,i){var s=new yn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var l=c&&c.get,p=c&&c.set;l&&!p||t!==An&&2!==arguments.length||(t=n[e]);var u=!o&&zn(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return yn.target&&(s.depend(),u&&(u.dep.depend(),a(e)&&_n(e))),Rn(e)&&!o?e.value:e},set:function(e){var r=l?l.call(n):t;if(R(r,e)){if(p)p.call(n,e);else{if(l)return;if(!o&&Rn(r)&&!Rn(e))return void(r.value=e);t=e}u=!o&&zn(e,!1,i),s.notify()}}}),s}}function In(n,e,t){if(!Mn(n)){var r=n.__ob__;return a(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&zn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(Bn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function On(n,e){if(a(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Mn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function _n(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&_n(e)}function Ln(n){return Fn(n,!0),J(n,"__v_isShallow",!0),n}function Fn(n,e){if(!Mn(n)){zn(n,e,on());0}}function Mn(n){return!(!n||!n.__v_isReadonly)}function Rn(n){return!(!n||!0!==n.__v_isRef)}function Nn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Rn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Rn(r)&&!Rn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var qn;var Un=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=qn,!n&&qn&&(this.index=(qn.scopes||(qn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=qn;try{return qn=this,n()}finally{qn=e}}else 0},n.prototype.on=function(){qn=this},n.prototype.off=function(){qn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Hn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var $n=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Jn(n,e){function t(){var n=t.fns;if(!a(n))return Te(n,null,arguments,e,"v-on handler");for(var r=n.slice(),o=0;o<r.length;o++)Te(r[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,r,a,i){var c,l,p,u;for(c in n)l=n[c],p=e[c],u=$n(c),o(l)||(o(p)?(o(l.fns)&&(l=n[c]=Jn(l,i)),s(u.once)&&(l=n[c]=a(u.name,l,u.capture)),t(u.name,l,u.capture,u.passive,u.params)):l!==p&&(p.fns=l,n[c]=p));for(c in e)o(n[c])&&r((u=$n(c)).name,e[c],u.capture)}function Wn(n,e,t){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function c(){t.apply(this,arguments),x(r.fns,c)}o(a)?r=Jn([c]):i(a.fns)&&s(a.merged)?(r=a).fns.push(c):r=Jn([a,c]),r.merged=!0,n[e]=r}function Qn(n,e,t,r,a){if(i(e)){if(k(e,t))return n[t]=e[t],a||delete e[t],!0;if(k(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Kn(n){return c(n)?[gn(n)]:a(n)?function n(e,t){var r,l,p,u,d=[];for(r=0;r<e.length;r++)o(l=e[r])||"boolean"==typeof l||(p=d.length-1,u=d[p],a(l)?l.length>0&&(Gn((l=n(l,"".concat(t||"","_").concat(r)))[0])&&Gn(u)&&(d[p]=gn(u.text+l[0].text),l.shift()),d.push.apply(d,l)):c(l)?Gn(u)?d[p]=gn(u.text+l):""!==l&&d.push(gn(l)):Gn(l)&&Gn(u)?d[p]=gn(u.text+l.text):(s(e._isVList)&&i(l.tag)&&o(l.key)&&i(t)&&(l.key="__vlist".concat(t,"_").concat(r,"__")),d.push(l)));return d}(n):void 0}function Gn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Xn(n,e){var t,r,o,s,c=null;if(a(n)||"string"==typeof n)for(c=new Array(n.length),t=0,r=n.length;t<r;t++)c[t]=e(n[t],t);else if("number"==typeof n)for(c=new Array(n),t=0;t<n;t++)c[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){c=[];for(var l=n[Symbol.iterator](),u=l.next();!u.done;)c.push(e(u.value,c.length)),u=l.next()}else for(o=Object.keys(n),c=new Array(o.length),t=0,r=o.length;t<r;t++)s=o[t],c[t]=e(n[s],s,t);return i(c)||(c=[]),c._isVList=!0,c}function Zn(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=z(z({},r),t)),a=o(t)||(l(e)?e():e)):a=this.$slots[n]||(l(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function Yn(n){return Dt(this.$options,"filters",n,!0)||_}function ne(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,r,a){var o=U.keyCodes[e]||t;return a&&r&&!U.keyCodes[e]?ne(a,r):o?ne(o,n):r?E(r)!==e:void 0===n}function te(n,e,t,r,o){if(t)if(p(t)){a(t)&&(t=B(t));var i=void 0,s=function(a){if("class"===a||"style"===a||y(a))i=n;else{var s=n.attrs&&n.attrs.type;i=r||U.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=j(a),l=E(a);c in i||l in i||(i[a]=t[a],o&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var c in t)s(c)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||oe(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&ie(n[r],"".concat(e,"_").concat(r),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(d(e)){var t=n.on=n.on?z({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function ce(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var i=n[o];a(i)?ce(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function le(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=ae,n._n=b,n._s=f,n._l=Xn,n._t=Zn,n._q=L,n._i=F,n._m=re,n._f=Yn,n._k=ee,n._b=te,n._v=gn,n._e=hn,n._u=ce,n._g=se,n._d=le,n._p=pe}function de(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,c=t[s]||(t[s]=[]);"template"===o.tag?c.push.apply(c,o.children||[]):c.push(o)}}for(var l in t)t[l].every(me)&&delete t[l];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,a){var o,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,c=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&c===a.$key&&!i&&!a.$hasNormal)return a;for(var l in o={},e)e[l]&&"$"!==l[0]&&(o[l]=fe(n,t,l,e[l]))}else o={};for(var p in t)p in o||(o[p]=be(t,p));return e&&Object.isExtensible(e)&&(e._normalized=o),J(o,"$stable",s),J(o,"$key",c),J(o,"$hasNormal",i),o}function fe(n,e,t,r){var o=function(){var e=un;dn(n);var t=arguments.length?r.apply(null,arguments):r({}),o=(t=t&&"object"==typeof t&&!a(t)?[t]:Kn(t))&&t[0];return dn(e),t&&(!o||1===t.length&&o.isComment&&!he(o))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function be(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};J(e,"_v_attr_proxy",!0),ye(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:P(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Nn(n,e,t)}))}}}function ye(n,e,t,r,a){var o=!1;for(var i in e)i in n?e[i]!==t[i]&&(o=!0):(o=!0,xe(n,i,r,a));for(var i in n)i in e||(o=!0,delete n[i]);return o}function xe(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function Se(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function Ce(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||he(t)))return t}}function je(n,e,t,r,u,d){return(a(t)||c(t))&&(u=r,r=t,t=void 0),s(d)&&(u=2),function(n,e,t,r,c){if(i(t)&&i(t.__ob__))return hn();i(t)&&i(t.is)&&(e=t.is);if(!e)return hn();0;a(r)&&l(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===c?r=Kn(r):1===c&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var u,d;if("string"==typeof e){var m=void 0;d=n.$vnode&&n.$vnode.ns||U.getTagNamespace(e),u=U.isReservedTag(e)?new mn(U.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(m=Dt(n.$options,"components",e))?new mn(e,t,r,void 0,void 0,n):xt(m,t,n,r,e)}else u=xt(e,t,n,r);return a(u)?u:i(u)?(i(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var a=0,c=e.children.length;a<c;a++){var l=e.children[a];i(l.tag)&&(o(l.ns)||s(r)&&"svg"!==l.tag)&&n(l,t,r)}}(u,d),i(t)&&function(n){p(n.style)&&Ue(n.style);p(n.class)&&Ue(n.class)}(t),u):hn()}(n,e,t,r,u)}function Ae(n,e,t){wn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Ee(n,r,"errorCaptured hook")}}Ee(n,e,t)}finally{kn()}}function Te(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&g(o)&&!o._handled&&(o.catch((function(n){return Ae(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){Ae(n,r,a)}return o}function Ee(n,e,t){if(U.errorHandler)try{return U.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Pe(e,null,"config.errorHandler")}Pe(n,e,t)}function Pe(n,e,t){if(!Q||"undefined"==typeof console)throw n;console.error(n)}var De,ze=!1,Be=[],Ie=!1;function Oe(){Ie=!1;var n=Be.slice(0);Be.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var _e=Promise.resolve();De=function(){_e.then(Oe),Y&&setTimeout(I)},ze=!0}else if(G||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())De="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Oe)}:function(){setTimeout(Oe,0)};else{var Le=1,Fe=new MutationObserver(Oe),Me=document.createTextNode(String(Le));Fe.observe(Me,{characterData:!0}),De=function(){Le=(Le+1)%2,Me.data=String(Le)},ze=!0}function Re(n,e){var t;if(Be.push((function(){if(n)try{n.call(e)}catch(n){Ae(n,e,"nextTick")}else t&&t(e)})),Ie||(Ie=!0,De()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ne(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var r=n.$options;r[e]=At(r[e],t)}(t,n,e)}}Ne("beforeMount"),Ne("mounted"),Ne("beforeUpdate"),Ne("updated"),Ne("beforeDestroy"),Ne("destroyed"),Ne("activated"),Ne("deactivated"),Ne("serverPrefetch"),Ne("renderTracked"),Ne("renderTriggered"),Ne("errorCaptured");var qe=new ln;function Ue(n){return function n(e,t){var r,o,i=a(e);if(!i&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else if(Rn(e))n(e.value,t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,qe),qe.clear(),n}var He,$e=0,Je=function(){function n(n,e,t,r,a){var o,i;o=this,void 0===(i=qn&&!qn._vm?qn:n?n._scope:void 0)&&(i=qn),i&&i.active&&i.effects.push(o),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++$e,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="",l(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=I)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ae(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ue(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():dt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Te(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){He.$on(n,e)}function We(n,e){He.$off(n,e)}function Qe(n,e){var t=He;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Ke(n,e,t){He=n,Vn(e,t||{},Ve,We,Qe,n),He=void 0}var Ge=null;function Xe(n){var e=Ge;return Ge=n,function(){Ge=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,r){void 0===r&&(r=!0),wn();var a=un;r&&dn(n);var o=n.$options[e],i="".concat(e," hook");if(o)for(var s=0,c=o.length;s<c;s++)Te(o[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),r&&dn(a),kn()}var et=[],tt=[],rt={},at=!1,ot=!1,it=0;var st=0,ct=Date.now;if(Q&&!G){var lt=window.performance;lt&&"function"==typeof lt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return lt.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(st=ct(),ot=!0,et.sort(pt),it=0;it<et.length;it++)(n=et[it]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();it=et.length=tt.length=0,rt={},at=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),sn&&U.devtools&&sn.emit("flush")}function dt(n){var e=n.id;if(null==rt[e]&&(n!==yn.target||!n.noRecurse)){if(rt[e]=!0,ot){for(var t=et.length-1;t>it&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);at||(at=!0,Re(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){var i=n[o].from;if(i in e._provided)t[o]=e._provided[i];else if("default"in n[o]){var s=n[o].default;t[o]=l(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,o,i){var c,l=this,p=i.options;k(o,"_uid")?(c=Object.create(o))._original=o:(c=o,o=o._original);var u=s(p._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=mt(p.inject,o),this.slots=function(){return l.$slots||ge(o,n.scopedSlots,l.$slots=de(t,o)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(o,n.scopedSlots,this.slots())}}),u&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=ge(o,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,r){var i=je(c,n,e,t,r,d);return i&&!a(i)&&(i.fnScopeId=p._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,r){return je(c,n,e,t,r,d)}}function gt(n,e,t,r,a){var o=fn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function ft(n,e){for(var t in e)n[j(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ge)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){var i=a.data.scopedSlots,s=n.$scopedSlots,c=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),l=!!(o||n.$options._renderChildren||c),p=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=o;var u=a.data.attrs||r;n._attrsProxy&&ye(n._attrsProxy,u,p.data&&p.data.attrs||r,n,"$attrs")&&(l=!0),n.$attrs=u,t=t||r;var d=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,d||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,d),e&&n.$options.props){En(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var f=h[g],b=n.$options.props;m[f]=zt(f,b,e,n)}En(!0),n.$options.propsData=e}l&&(n.$slots=de(o,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Ye(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ze(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(vt);function xt(n,e,t,c,l){if(!o(n)){var u=t.$options._base;if(p(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=ke;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],a=!0,c=null,l=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==l&&(clearTimeout(l),l=null))},d=M((function(t){n.resolved=Se(t,e),a?r.length=0:u(!0)})),m=M((function(e){i(n.errorComp)&&(n.error=!0,u(!0))})),h=n(d,m);return p(h)&&(g(h)?o(n.resolved)&&h.then(d,m):g(h.component)&&(h.component.then(d,m),i(h.error)&&(n.errorComp=Se(h.error,e)),i(h.loading)&&(n.loadingComp=Se(h.loading,e),0===h.delay?n.loading=!0:c=setTimeout((function(){c=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),i(h.timeout)&&(l=setTimeout((function(){l=null,o(n.resolved)&&m(null)}),h.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,a){var o=hn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(d,e,t,c,l);e=e||{},Jt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[r],c=e.model.callback;i(s)?(a(s)?-1===s.indexOf(c):s!==c)&&(o[r]=[c].concat(s)):o[r]=c}(n.options,e);var m=function(n,e,t){var r=e.options.props;if(!o(r)){var a={},s=n.attrs,c=n.props;if(i(s)||i(c))for(var l in r){var p=E(l);Qn(a,c,l,p,!0)||Qn(a,s,l,p,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var c=n.options,l={},p=c.props;if(i(p))for(var u in p)l[u]=zt(u,p,e||r);else i(t.attrs)&&ft(l,t.attrs),i(t.props)&&ft(l,t.props);var d=new ht(t,l,s,o,n),m=c.render.call(null,d._c,d);if(m instanceof mn)return gt(m,t,d.parent,c,d);if(a(m)){for(var h=Kn(m)||[],g=new Array(h.length),f=0;f<h.length;f++)g[f]=gt(h[f],t,d.parent,c,d);return g}}(n,m,e,t,c);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var r=yt[t],a=e[r],o=vt[r];a===o||a&&a._merged||(e[r]=a?wt(o,a):o)}}(e);var b=bt(n.options)||l;return new mn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:l,children:c},d)}}}function wt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var kt=I,St=U.optionMergeStrategies;function Ct(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,a,o,i=pn?Reflect.ownKeys(e):Object.keys(e),s=0;s<i.length;s++)"__ob__"!==(r=i[s])&&(a=n[r],o=e[r],t&&k(n,r)?a!==o&&d(a)&&d(o)&&Ct(a,o):In(n,r,o));return n}function jt(n,e,t){return t?function(){var r=l(e)?e.call(t,t):e,a=l(n)?n.call(t,t):n;return r?Ct(r,a):a}:e?n?function(){return Ct(l(e)?e.call(this,this):e,l(n)?n.call(this,this):n)}:e:n}function At(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Tt(n,e,t,r){var a=Object.create(n||null);return e?z(a,e):a}St.data=function(n,e,t){return t?jt(n,e,t):e&&"function"!=typeof e?n:jt(n,e)},q.forEach((function(n){St[n]=At})),N.forEach((function(n){St[n+"s"]=Tt})),St.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var i in z(o,n),e){var s=o[i],c=e[i];s&&!a(s)&&(s=[s]),o[i]=s?s.concat(c):a(c)?c:[c]}return o},St.props=St.methods=St.inject=St.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return z(a,n),e&&z(a,e),a},St.provide=function(n,e){return n?function(){var t=Object.create(null);return Ct(t,l(n)?n.call(this):n),e&&Ct(t,l(e)?e.call(this):e,!1),t}:e};var Et=function(n,e){return void 0===e?n:e};function Pt(n,e,t){if(l(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,i={};if(a(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(i[j(o)]={type:null});else if(d(t))for(var s in t)o=t[s],i[j(s)]=d(o)?o:{type:o};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(d(t))for(var i in t){var s=t[i];r[i]=d(s)?z({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];l(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Pt(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=Pt(n,e.mixins[r],t);var i,s={};for(i in n)c(i);for(i in e)k(n,i)||c(i);function c(r){var a=St[r]||Et;s[r]=a(n[r],e[r],t,r)}return s}function Dt(n,e,t,r){if("string"==typeof t){var a=n[e];if(k(a,t))return a[t];var o=j(t);if(k(a,o))return a[o];var i=A(o);return k(a,i)?a[i]:a[t]||a[o]||a[i]}}function zt(n,e,t,r){var a=e[n],o=!k(t,n),i=t[n],s=_t(Boolean,a.type);if(s>-1)if(o&&!k(a,"default"))i=!1;else if(""===i||i===E(n)){var c=_t(String,a.type);(c<0||s<c)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return l(r)&&"Function"!==It(e.type)?r.call(n):r}(r,a,n);var p=Tn;En(!0),zn(i),En(p)}return i}var Bt=/^\s*function (\w+)/;function It(n){var e=n&&n.toString().match(Bt);return e?e[1]:""}function Ot(n,e){return It(n)===It(e)}function _t(n,e){if(!a(e))return Ot(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Ot(e[t],n))return t;return-1}var Lt={enumerable:!0,configurable:!0,get:I,set:I};function Ft(n,e,t){Lt.get=function(){return this[e][t]},Lt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Lt)}function Mt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Ln({}),a=n.$options._propKeys=[];n.$parent&&En(!1);var o=function(o){a.push(o);var i=zt(o,e,t,n);Bn(r,o,i),o in n||Ft(n,"_props",o)};for(var i in e)o(i);En(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ve(n);dn(n),wn();var a=Te(t,null,[n._props||Ln({}),r],n,"setup");if(kn(),dn(),l(a))e.render=a;else if(p(a))if(n._setupState=a,a.__sfc){var o=n._setupProxy={};for(var i in a)"__sfc"!==i&&Nn(o,a,i)}else for(var i in a)$(i)||Nn(n,a,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?I:P(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=l(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Ae(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&k(r,o)||$(o)||Ft(n,"_data",o)}var i=zn(e);i&&i.vmCount++}(n);else{var t=zn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var o=e[a],i=l(o)?o:o.get;0,r||(t[a]=new Je(n,i||I,I,Rt)),a in n||Nt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var o=0;o<r.length;o++)Ht(n,t,r[o]);else Ht(n,t,r)}}(n,e.watch)}var Rt={lazy:!0};function Nt(n,e,t){var r=!on();l(t)?(Lt.get=r?qt(e):Ut(t),Lt.set=I):(Lt.get=t.get?r&&!1!==t.cache?qt(e):Ut(t.get):I,Lt.set=t.set||I),Object.defineProperty(n,e,Lt)}function qt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Ut(n){return function(){return n.call(this,this)}}function Ht(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var $t=0;function Jt(n){var e=n.options;if(n.super){var t=Jt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&z(n.extendOptions,r),(e=n.options=Pt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Wt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=bt(n)||bt(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Pt(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Ft(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Nt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,N.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=z({},i.options),a[r]=i,i}}function Qt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Kt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Gt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var s=i.name;s&&!e(s)&&Xt(t,o,r,a)}}}function Xt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=$t++,e._isVue=!0,e.__v_skip=!0,e._scope=new Un(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Pt(Jt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=de(e._renderChildren,a),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return je(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return je(n,e,t,r,a,!0)};var o=t&&t.data;Bn(n,"$attrs",o&&o.attrs||r,null,!0),Bn(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(En(!1),Object.keys(e).forEach((function(t){Bn(n,t,e[t])})),En(!0))}(e),Mt(e),function(n){var e=n.$options.provide;if(e){var t=l(e)?e.call(n):e;if(!p(t))return;for(var r=Hn(n),a=pn?Reflect.ownKeys(t):Object.keys(t),o=0;o<a.length;o++){var i=a[o];Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=In,n.prototype.$delete=On,n.prototype.$watch=function(n,e,t){if(d(e))return Ht(this,n,e,t);(t=t||{}).user=!0;var r=new Je(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');wn(),Te(e,this,[r.value],this,a),kn()}return function(){r.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var o=0,i=n.length;o<i;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var c=s.length;c--;)if((i=s[c])===e||i.fn===e){s.splice(c,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?D(t):t;for(var r=D(arguments,1),a='event handler for "'.concat(n,'"'),o=0,i=t.length;o<i;o++)Te(t[o],e,r,e,a)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Xe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&e._isMounted&&(e.$scopedSlots=ge(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&we(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{dn(e),ke=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Ae(t,e,"render"),n=e._vnode}finally{ke=null,dn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=o,n}}(Vt);var Zt=[String,RegExp,Array],Yt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Zt,exclude:Zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,i=t.componentOptions;n[r]={name:Qt(i),tag:a,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Xt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Xt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Gt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Gt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ce(n),t=e&&e.componentOptions;if(t){var r=Qt(t),a=this.include,o=this.exclude;if(a&&(!r||!Kt(a,r))||o&&r&&Kt(o,r))return e;var i=this.cache,s=this.keys,c=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[c]?(e.componentInstance=i[c].componentInstance,x(s,c),s.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return U}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:z,mergeOptions:Pt,defineReactive:Bn},n.set=In,n.delete=On,n.nextTick=Re,n.observable=function(n){return zn(n),n},n.options=Object.create(null),N.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,z(n.options.components,Yt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=D(arguments,1);return t.unshift(this),l(n.install)?n.install.apply(n,t):l(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Pt(this.options,n),this}}(n),Wt(n),function(n){N.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&l(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:on}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:ht}),Vt.version="2.7.14";var nr=v("style,class"),er=v("input,textarea,option,select,progress"),tr=v("contenteditable,draggable,spellcheck"),rr=v("events,caret,typing,plaintext-only"),ar=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),or="http://www.w3.org/1999/xlink",ir=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sr=function(n){return ir(n)?n.slice(6,n.length):""},cr=function(n){return null==n||!1===n};function lr(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=pr(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=pr(e,t.data));return function(n,e){if(i(n)||i(e))return ur(n,dr(e));return""}(e.staticClass,e.class)}function pr(n,e){return{staticClass:ur(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function ur(n,e){return n?e?n+" "+e:n:e||""}function dr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)i(e=dr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hr=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fr=function(n){return hr(n)||gr(n)};var br=Object.create(null);var vr=v("text,number,password,search,email,tel,url");var yr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xr={create:function(n,e){wr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wr(n,!0),wr(e))},destroy:function(n){wr(n,!0)}};function wr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,o=n.componentInstance||n.elm,s=e?null:o,c=e?void 0:o;if(l(t))Te(t,r,[s],r,"template ref function");else{var p=n.data.refInFor,u="string"==typeof t||"number"==typeof t,d=Rn(t),m=r.$refs;if(u||d)if(p){var h=u?m[t]:t.value;e?a(h)&&x(h,o):a(h)?h.includes(o)||h.push(o):u?(m[t]=[o],kr(r,t,m[t])):t.value=[o]}else if(u){if(e&&m[t]!==o)return;m[t]=c,kr(r,t,s)}else if(d){if(e&&t.value!==o)return;t.value=s}else 0}}}function kr(n,e,t){var r=n._setupState;r&&k(r,e)&&(Rn(r[e])?r[e].value=t:r[e]=t)}var Sr=new mn("",{},[]),Cr=["create","activate","update","remove","destroy"];function jr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,a=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===a||vr(r)&&vr(a)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function Ar(n,e,t){var r,a,o={};for(r=e;r<=t;++r)i(a=n[r].key)&&(o[a]=r);return o}var Tr={create:Er,update:Er,destroy:function(n){Er(n,Sr)}};function Er(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===Sr,i=e===Sr,s=Dr(n.data.directives,n.context),c=Dr(e.data.directives,e.context),l=[],p=[];for(t in c)r=s[t],a=c[t],r?(a.oldValue=r.value,a.oldArg=r.arg,Br(a,"update",e,n),a.def&&a.def.componentUpdated&&p.push(a)):(Br(a,"bind",e,n),a.def&&a.def.inserted&&l.push(a));if(l.length){var u=function(){for(var t=0;t<l.length;t++)Br(l[t],"inserted",e,n)};o?Wn(e,"insert",u):u()}p.length&&Wn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)Br(p[t],"componentUpdated",e,n)}));if(!o)for(t in s)c[t]||Br(s[t],"unbind",n,n,i)}(n,e)}var Pr=Object.create(null);function Dr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Pr),a[zr(r)]=r,e._setupState&&e._setupState.__sfc){var o=r.def||Dt(e,"_setupState","v-"+r.name);r.def="function"==typeof o?{bind:o,update:o}:o}r.def=r.def||Dt(e.$options,"directives",r.name)}return a}function zr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Br(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){Ae(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ir=[xr,Tr];function Or(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,a,c=e.elm,l=n.data.attrs||{},p=e.data.attrs||{};for(r in(i(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=z({},p)),p)a=p[r],l[r]!==a&&_r(c,r,a,e.data.pre);for(r in(G||Z)&&p.value!==l.value&&_r(c,"value",p.value),l)o(p[r])&&(ir(r)?c.removeAttributeNS(or,sr(r)):tr(r)||c.removeAttribute(r))}}function _r(n,e,t,r){r||n.tagName.indexOf("-")>-1?Lr(n,e,t):ar(e)?cr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):tr(e)?n.setAttribute(e,function(n,e){return cr(e)||"false"===e?"false":"contenteditable"===n&&rr(e)?e:"true"}(e,t)):ir(e)?cr(t)?n.removeAttributeNS(or,sr(e)):n.setAttributeNS(or,e,t):Lr(n,e,t)}function Lr(n,e,t){if(cr(t))n.removeAttribute(e);else{if(G&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Fr={create:Or,update:Or};function Mr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var s=lr(e),c=t._transitionClasses;i(c)&&(s=ur(s,dr(c))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Rr,Nr={create:Mr,update:Mr};function qr(n,e,t){var r=Rr;return function a(){var o=e.apply(null,arguments);null!==o&&$r(n,a,t,r)}}var Ur=ze&&!(en&&Number(en[1])<=53);function Hr(n,e,t,r){if(Ur){var a=st,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Rr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function $r(n,e,t,r){(r||Rr).removeEventListener(n,e._wrapper||e,t)}function Jr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Rr=e.elm||n.elm,function(n){if(i(n.__r)){var e=G?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,r,Hr,$r,qr,e.context),Rr=void 0}}var Vr,Wr={create:Jr,update:Jr,destroy:function(n){return Jr(n,Sr)}};function Qr(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,a=e.elm,c=n.data.domProps||{},l=e.data.domProps||{};for(t in(i(l.__ob__)||s(l._v_attr_proxy))&&(l=e.data.domProps=z({},l)),c)t in l||(a[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===c[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var p=o(r)?"":String(r);Kr(a,p)&&(a.value=p)}else if("innerHTML"===t&&gr(a.tagName)&&o(a.innerHTML)){(Vr=Vr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Vr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;u.firstChild;)a.appendChild(u.firstChild)}else if(r!==c[t])try{a[t]=r}catch(n){}}}}function Kr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return b(t)!==b(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Gr={create:Qr,update:Qr},Xr=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Zr(n){var e=Yr(n.style);return n.staticStyle?z(n.staticStyle,e):e}function Yr(n){return Array.isArray(n)?B(n):"string"==typeof n?Xr(n):n}var na,ea=/^--/,ta=/\s*!important$/,ra=function(n,e,t){if(ea.test(e))n.style.setProperty(e,t);else if(ta.test(t))n.style.setProperty(E(e),t.replace(ta,""),"important");else{var r=oa(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},aa=["Webkit","Moz","ms"],oa=S((function(n){if(na=na||document.createElement("div").style,"filter"!==(n=j(n))&&n in na)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<aa.length;t++){var r=aa[t]+e;if(r in na)return r}}));function ia(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var a,s,c=e.elm,l=r.staticStyle,p=r.normalizedStyle||r.style||{},u=l||p,d=Yr(e.data.style)||{};e.data.normalizedStyle=i(d.__ob__)?z({},d):d;var m=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Zr(a.data))&&z(r,t);(t=Zr(n.data))&&z(r,t);for(var o=n;o=o.parent;)o.data&&(t=Zr(o.data))&&z(r,t);return r}(e,!0);for(s in u)o(m[s])&&ra(c,s,"");for(s in m)(a=m[s])!==u[s]&&ra(c,s,null==a?"":a)}}var sa={create:ia,update:ia},ca=/\s+/;function la(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ca).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function pa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ca).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ua(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&z(e,da(n.name||"v")),z(e,n),e}return"string"==typeof n?da(n):void 0}}var da=S((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ma=Q&&!X,ha="transition",ga="transitionend",fa="animation",ba="animationend";ma&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ha="WebkitTransition",ga="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fa="WebkitAnimation",ba="webkitAnimationEnd"));var va=Q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ya(n){va((function(){va(n)}))}function xa(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),la(n,e))}function wa(n,e){n._transitionClasses&&x(n._transitionClasses,e),pa(n,e)}function ka(n,e,t){var r=Ca(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var s="transition"===a?ga:ba,c=0,l=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++c>=i&&l()};setTimeout((function(){c<i&&l()}),o+1),n.addEventListener(s,p)}var Sa=/\b(transform|all)(,|$)/;function Ca(n,e){var t,r=window.getComputedStyle(n),a=(r[ha+"Delay"]||"").split(", "),o=(r[ha+"Duration"]||"").split(", "),i=ja(a,o),s=(r[fa+"Delay"]||"").split(", "),c=(r[fa+"Duration"]||"").split(", "),l=ja(s,c),p=0,u=0;return"transition"===e?i>0&&(t="transition",p=i,u=o.length):"animation"===e?l>0&&(t="animation",p=l,u=c.length):u=(t=(p=Math.max(i,l))>0?i>l?"transition":"animation":null)?"transition"===t?o.length:c.length:0,{type:t,timeout:p,propCount:u,hasTransform:"transition"===t&&Sa.test(r[ha+"Property"])}}function ja(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Aa(e)+Aa(n[t])})))}function Aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ta(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ua(n.data.transition);if(!o(r)&&!i(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,c=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,m=r.appearClass,h=r.appearToClass,g=r.appearActiveClass,f=r.beforeEnter,v=r.enter,y=r.afterEnter,x=r.enterCancelled,w=r.beforeAppear,k=r.appear,S=r.afterAppear,C=r.appearCancelled,j=r.duration,A=Ge,T=Ge.$vnode;T&&T.parent;)A=T.context,T=T.parent;var E=!A._isMounted||!n.isRootInsert;if(!E||k||""===k){var P=E&&m?m:c,D=E&&g?g:d,z=E&&h?h:u,B=E&&w||f,I=E&&l(k)?k:v,O=E&&S||y,_=E&&C||x,L=b(p(j)?j.enter:j);0;var F=!1!==a&&!X,R=Da(I),N=t._enterCb=M((function(){F&&(wa(t,z),wa(t,D)),N.cancelled?(F&&wa(t,P),_&&_(t)):O&&O(t),t._enterCb=null}));n.data.show||Wn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),I&&I(t,N)})),B&&B(t),F&&(xa(t,P),xa(t,D),ya((function(){wa(t,P),N.cancelled||(xa(t,z),R||(Pa(L)?setTimeout(N,L):ka(t,s,N)))}))),n.data.show&&(e&&e(),I&&I(t,N)),F||R||N()}}}function Ea(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ua(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var a=r.css,s=r.type,c=r.leaveClass,l=r.leaveToClass,u=r.leaveActiveClass,d=r.beforeLeave,m=r.leave,h=r.afterLeave,g=r.leaveCancelled,f=r.delayLeave,v=r.duration,y=!1!==a&&!X,x=Da(m),w=b(p(v)?v.leave:v);0;var k=t._leaveCb=M((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(wa(t,l),wa(t,u)),k.cancelled?(y&&wa(t,c),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(S):S()}function S(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),y&&(xa(t,c),xa(t,u),ya((function(){wa(t,c),k.cancelled||(xa(t,l),x||(Pa(w)?setTimeout(k,w):ka(t,s,k)))}))),m&&m(t,k),y||x||k())}}function Pa(n){return"number"==typeof n&&!isNaN(n)}function Da(n){if(o(n))return!1;var e=n.fns;return i(e)?Da(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function za(n,e){!0!==e.data.show&&Ta(e)}var Ba=function(n){var e,t,r={},l=n.modules,p=n.nodeOps;for(e=0;e<Cr.length;++e)for(r[Cr[e]]=[],t=0;t<l.length;++t)i(l[t][Cr[e]])&&r[Cr[e]].push(l[t][Cr[e]]);function u(n){var e=p.parentNode(n);i(e)&&p.removeChild(e,n)}function d(n,e,t,a,o,c,l){if(i(n.elm)&&i(c)&&(n=c[l]=fn(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(i(o)){var c=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return m(n,e),h(t,n.elm,a),s(c)&&function(n,e,t,a){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](Sr,s);e.push(s);break}h(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var u=n.data,d=n.children,f=n.tag;i(f)?(n.elm=n.ns?p.createElementNS(n.ns,f):p.createElement(f,n),y(n),g(n,d,e),i(u)&&b(n,e),h(t,n.elm,a)):s(n.isComment)?(n.elm=p.createComment(n.text),h(t,n.elm,a)):(n.elm=p.createTextNode(n.text),h(t,n.elm,a))}}function m(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(b(n,e),y(n)):(wr(n),e.push(n))}function h(n,e,t){i(n)&&(i(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function g(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else c(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function b(n,t){for(var a=0;a<r.create.length;++a)r.create[a](Sr,n);i(e=n.data.hook)&&(i(e.create)&&e.create(Sr,n),i(e.insert)&&t.push(n))}function y(n){var e;if(i(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;i(e=Ge)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function x(n,e,t,r,a,o){for(;r<=a;++r)d(t[r],o,n,e,!1,t,r)}function w(n){var e,t,a=n.data;if(i(a))for(i(e=a.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(S(r),w(r)):u(r.elm))}}function S(n,e){if(i(e)||i(n.data)){var t,a=r.remove.length+1;for(i(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,a),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&S(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else u(n.elm)}function C(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(i(o)&&jr(n,o))return a}}function j(n,e,t,a,c,l){if(n!==e){i(e.elm)&&i(a)&&(e=a[c]=fn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?E(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;i(h)&&i(m=h.hook)&&i(m=m.prepatch)&&m(n,e);var g=n.children,b=e.children;if(i(h)&&f(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);i(m=h.hook)&&i(m=m.update)&&m(n,e)}o(e.text)?i(g)&&i(b)?g!==b&&function(n,e,t,r,a){var s,c,l,u=0,m=0,h=e.length-1,g=e[0],f=e[h],b=t.length-1,v=t[0],y=t[b],w=!a;for(0;u<=h&&m<=b;)o(g)?g=e[++u]:o(f)?f=e[--h]:jr(g,v)?(j(g,v,r,t,m),g=e[++u],v=t[++m]):jr(f,y)?(j(f,y,r,t,b),f=e[--h],y=t[--b]):jr(g,y)?(j(g,y,r,t,b),w&&p.insertBefore(n,g.elm,p.nextSibling(f.elm)),g=e[++u],y=t[--b]):jr(f,v)?(j(f,v,r,t,m),w&&p.insertBefore(n,f.elm,g.elm),f=e[--h],v=t[++m]):(o(s)&&(s=Ar(e,u,h)),o(c=i(v.key)?s[v.key]:C(v,e,u,h))?d(v,r,n,g.elm,!1,t,m):jr(l=e[c],v)?(j(l,v,r,t,m),e[c]=void 0,w&&p.insertBefore(n,l.elm,g.elm)):d(v,r,n,g.elm,!1,t,m),v=t[++m]);u>h?x(n,o(t[b+1])?null:t[b+1].elm,t,m,b,r):m>b&&k(e,u,h)}(u,g,b,t,l):i(b)?(i(n.text)&&p.setTextContent(u,""),x(u,null,b,0,b.length-1,t)):i(g)?k(g,0,g.length-1):i(n.text)&&p.setTextContent(u,""):n.text!==e.text&&p.setTextContent(u,e.text),i(h)&&i(m=h.hook)&&i(m=m.postpatch)&&m(n,e)}}}function A(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var T=v("attrs,class,staticClass,staticStyle,key");function E(n,e,t,r){var a,o=e.tag,c=e.data,l=e.children;if(r=r||c&&c.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(c)&&(i(a=c.hook)&&i(a=a.init)&&a(e,!0),i(a=e.componentInstance)))return m(e,t),!0;if(i(o)){if(i(l))if(n.hasChildNodes())if(i(a=c)&&i(a=a.domProps)&&i(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var p=!0,u=n.firstChild,d=0;d<l.length;d++){if(!u||!E(u,l[d],t,r)){p=!1;break}u=u.nextSibling}if(!p||u)return!1}else g(e,l,t);if(i(c)){var h=!1;for(var f in c)if(!T(f)){h=!0,b(e,t);break}!h&&c.class&&Ue(c.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var c,l=!1,u=[];if(o(n))l=!0,d(e,u);else{var m=i(n.nodeType);if(!m&&jr(n,e))j(n,e,u,null,null,a);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&E(n,e,u))return A(e,u,!0),n;c=n,n=new mn(p.tagName(c).toLowerCase(),{},[],void 0,c)}var h=n.elm,g=p.parentNode(h);if(d(e,u,h._leaveCb?null:g,p.nextSibling(h)),i(e.parent))for(var b=e.parent,v=f(e);b;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](b);if(b.elm=e.elm,v){for(var x=0;x<r.create.length;++x)r.create[x](Sr,b);var S=b.data.hook.insert;if(S.merged)for(var C=1;C<S.fns.length;C++)S.fns[C]()}else wr(b);b=b.parent}i(g)?k([n],0,0):i(n.tag)&&w(n)}}return A(e,u,l),e.elm}i(n)&&w(n)}}({nodeOps:yr,modules:[Fr,Nr,Wr,Gr,sa,Q?{create:za,activate:za,remove:function(n,e){!0!==n.data.show?Ea(n,e):e()}}:{}].concat(Ir)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Na(n,"input")}));var Ia={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Wn(t,"postpatch",(function(){Ia.componentUpdated(n,e,t)})):Oa(n,e,t.context),n._vOptions=[].map.call(n.options,Fa)):("textarea"===t.tag||vr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Ma),n.addEventListener("compositionend",Ra),n.addEventListener("change",Ra),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Oa(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,Fa);if(a.some((function(n,e){return!L(n,r[e])})))(n.multiple?e.value.some((function(n){return La(n,a)})):e.value!==e.oldValue&&La(e.value,a))&&Na(n,"change")}}};function Oa(n,e,t){_a(n,e,t),(G||Z)&&setTimeout((function(){_a(n,e,t)}),0)}function _a(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,s=0,c=n.options.length;s<c;s++)if(i=n.options[s],a)o=F(r,Fa(i))>-1,i.selected!==o&&(i.selected=o);else if(L(Fa(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function La(n,e){return e.every((function(e){return!L(e,n)}))}function Fa(n){return"_value"in n?n._value:n.value}function Ma(n){n.target.composing=!0}function Ra(n){n.target.composing&&(n.target.composing=!1,Na(n.target,"input"))}function Na(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function qa(n){return!n.componentInstance||n.data&&n.data.transition?n:qa(n.componentInstance._vnode)}var Ua={model:Ia,show:{bind:function(n,e,t){var r=e.value,a=(t=qa(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Ta(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=qa(t)).data&&t.data.transition?(t.data.show=!0,r?Ta(t,(function(){n.style.display=n.__vOriginalDisplay})):Ea(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Ha={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function $a(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?$a(Ce(e.children)):n}function Ja(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[j(r)]=a[r];return e}function Va(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Wa=function(n){return n.tag||he(n)},Qa=function(n){return"show"===n.name},Ka={name:"transition",props:Ha,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Wa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=$a(a);if(!o)return a;if(this._leaving)return Va(n,a);var i="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?i+"comment":i+o.tag:c(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=Ja(this),l=this._vnode,p=$a(l);if(o.data.directives&&o.data.directives.some(Qa)&&(o.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,p)&&!he(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var u=p.data.transition=z({},s);if("out-in"===r)return this._leaving=!0,Wn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Va(n,a);if("in-out"===r){if(he(o))return l;var d,m=function(){d()};Wn(s,"afterEnter",m),Wn(s,"enterCancelled",m),Wn(u,"delayLeave",(function(n){d=n}))}}return a}}},Ga=z({tag:String,moveClass:String},Ha);function Xa(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Za(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ya(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),o.transitionDuration="0s"}}delete Ga.mode;var no={Transition:Ka,TransitionGroup:{props:Ga,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=Ja(this),s=0;s<a.length;s++){if((p=a[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))o.push(p),t[p.key]=p,(p.data||(p.data={})).transition=i;else;}if(r){var c=[],l=[];for(s=0;s<r.length;s++){var p;(p=r[s]).data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):l.push(p)}this.kept=n(e,null,c),this.removed=l}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xa),n.forEach(Za),n.forEach(Ya),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;xa(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(ga,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(ga,n),t._moveCb=null,wa(t,e))})}})))},methods:{hasMove:function(n,e){if(!ma)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pa(t,n)})),la(t,e),t.style.display="none",this.$el.appendChild(t);var r=Ca(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Vt.config.mustUseProp=function(n,e,t){return"value"===t&&er(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=fr,Vt.config.isReservedAttr=nr,Vt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!Q)return!0;if(fr(n))return!1;if(n=n.toLowerCase(),null!=br[n])return br[n];var e=document.createElement(n);return n.indexOf("-")>-1?br[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:br[n]=/HTMLUnknownElement/.test(e.toString())},z(Vt.options.directives,Ua),z(Vt.options.components,no),Vt.prototype.__patch__=Q?Ba:I,Vt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Je(n,r,I,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var o=0;o<a.length;o++)a[o].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&Q?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Q&&setTimeout((function(){U.devtools&&sn&&sn.emit("init",Vt)}),0)},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,s){var c,l="function"==typeof n?n.options:n;if(e&&(l.render=e,l.staticRenderFns=t,l._compiled=!0),r&&(l.functional=!0),o&&(l._scopeId="data-v-"+o),i?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},l._ssrRegister=c):a&&(c=s?function(){a.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:a),c)if(l.functional){l._injectStyles=c;var p=l.render;l.render=function(n,e){return c.call(e),p(n,e)}}else{var u=l.beforeCreate;l.beforeCreate=u?[].concat(u,c):[c]}return{exports:n,options:l}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r;
/*!
 * jQuery JavaScript Library v3.7.0
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-05-11T18:29Z
 */!function(e,t){"use strict";"object"==typeof n.exports?n.exports=e.document?t(e,!0):function(n){if(!n.document)throw new Error("jQuery requires a window with a document");return t(n)}:t(e)}("undefined"!=typeof window?window:this,(function(t,a){"use strict";var o=[],i=Object.getPrototypeOf,s=o.slice,c=o.flat?function(n){return o.flat.call(n)}:function(n){return o.concat.apply([],n)},l=o.push,p=o.indexOf,u={},d=u.toString,m=u.hasOwnProperty,h=m.toString,g=h.call(Object),f={},b=function(n){return"function"==typeof n&&"number"!=typeof n.nodeType&&"function"!=typeof n.item},v=function(n){return null!=n&&n===n.window},y=t.document,x={type:!0,src:!0,nonce:!0,noModule:!0};function w(n,e,t){var r,a,o=(t=t||y).createElement("script");if(o.text=n,e)for(r in x)(a=e[r]||e.getAttribute&&e.getAttribute(r))&&o.setAttribute(r,a);t.head.appendChild(o).parentNode.removeChild(o)}function k(n){return null==n?n+"":"object"==typeof n||"function"==typeof n?u[d.call(n)]||"object":typeof n}var S=/HTML$/i,C=function(n,e){return new C.fn.init(n,e)};function j(n){var e=!!n&&"length"in n&&n.length,t=k(n);return!b(n)&&!v(n)&&("array"===t||0===e||"number"==typeof e&&e>0&&e-1 in n)}function A(n,e){return n.nodeName&&n.nodeName.toLowerCase()===e.toLowerCase()}C.fn=C.prototype={jquery:"3.7.0",constructor:C,length:0,toArray:function(){return s.call(this)},get:function(n){return null==n?s.call(this):n<0?this[n+this.length]:this[n]},pushStack:function(n){var e=C.merge(this.constructor(),n);return e.prevObject=this,e},each:function(n){return C.each(this,n)},map:function(n){return this.pushStack(C.map(this,(function(e,t){return n.call(e,t,e)})))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(C.grep(this,(function(n,e){return(e+1)%2})))},odd:function(){return this.pushStack(C.grep(this,(function(n,e){return e%2})))},eq:function(n){var e=this.length,t=+n+(n<0?e:0);return this.pushStack(t>=0&&t<e?[this[t]]:[])},end:function(){return this.prevObject||this.constructor()},push:l,sort:o.sort,splice:o.splice},C.extend=C.fn.extend=function(){var n,e,t,r,a,o,i=arguments[0]||{},s=1,c=arguments.length,l=!1;for("boolean"==typeof i&&(l=i,i=arguments[s]||{},s++),"object"==typeof i||b(i)||(i={}),s===c&&(i=this,s--);s<c;s++)if(null!=(n=arguments[s]))for(e in n)r=n[e],"__proto__"!==e&&i!==r&&(l&&r&&(C.isPlainObject(r)||(a=Array.isArray(r)))?(t=i[e],o=a&&!Array.isArray(t)?[]:a||C.isPlainObject(t)?t:{},a=!1,i[e]=C.extend(l,o,r)):void 0!==r&&(i[e]=r));return i},C.extend({expando:"jQuery"+("3.7.0"+Math.random()).replace(/\D/g,""),isReady:!0,error:function(n){throw new Error(n)},noop:function(){},isPlainObject:function(n){var e,t;return!(!n||"[object Object]"!==d.call(n))&&(!(e=i(n))||"function"==typeof(t=m.call(e,"constructor")&&e.constructor)&&h.call(t)===g)},isEmptyObject:function(n){var e;for(e in n)return!1;return!0},globalEval:function(n,e,t){w(n,{nonce:e&&e.nonce},t)},each:function(n,e){var t,r=0;if(j(n))for(t=n.length;r<t&&!1!==e.call(n[r],r,n[r]);r++);else for(r in n)if(!1===e.call(n[r],r,n[r]))break;return n},text:function(n){var e,t="",r=0,a=n.nodeType;if(a){if(1===a||9===a||11===a)return n.textContent;if(3===a||4===a)return n.nodeValue}else for(;e=n[r++];)t+=C.text(e);return t},makeArray:function(n,e){var t=e||[];return null!=n&&(j(Object(n))?C.merge(t,"string"==typeof n?[n]:n):l.call(t,n)),t},inArray:function(n,e,t){return null==e?-1:p.call(e,n,t)},isXMLDoc:function(n){var e=n&&n.namespaceURI,t=n&&(n.ownerDocument||n).documentElement;return!S.test(e||t&&t.nodeName||"HTML")},merge:function(n,e){for(var t=+e.length,r=0,a=n.length;r<t;r++)n[a++]=e[r];return n.length=a,n},grep:function(n,e,t){for(var r=[],a=0,o=n.length,i=!t;a<o;a++)!e(n[a],a)!==i&&r.push(n[a]);return r},map:function(n,e,t){var r,a,o=0,i=[];if(j(n))for(r=n.length;o<r;o++)null!=(a=e(n[o],o,t))&&i.push(a);else for(o in n)null!=(a=e(n[o],o,t))&&i.push(a);return c(i)},guid:1,support:f}),"function"==typeof Symbol&&(C.fn[Symbol.iterator]=o[Symbol.iterator]),C.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),(function(n,e){u["[object "+e+"]"]=e.toLowerCase()}));var T=o.pop,E=o.sort,P=o.splice,D="[\\x20\\t\\r\\n\\f]",z=new RegExp("^"+D+"+|((?:^|[^\\\\])(?:\\\\.)*)"+D+"+$","g");C.contains=function(n,e){var t=e&&e.parentNode;return n===t||!(!t||1!==t.nodeType||!(n.contains?n.contains(t):n.compareDocumentPosition&&16&n.compareDocumentPosition(t)))};var B=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;function I(n,e){return e?"\0"===n?"�":n.slice(0,-1)+"\\"+n.charCodeAt(n.length-1).toString(16)+" ":"\\"+n}C.escapeSelector=function(n){return(n+"").replace(B,I)};var O=y,_=l;!function(){var n,e,r,a,i,c,l,u,d,h,g=_,b=C.expando,v=0,y=0,x=nn(),w=nn(),k=nn(),S=nn(),j=function(n,e){return n===e&&(i=!0),0},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",I="(?:\\\\[\\da-fA-F]{1,6}"+D+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",L="\\["+D+"*("+I+")(?:"+D+"*([*^$|!~]?=)"+D+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+D+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+L+")*)|.*)\\)|)",M=new RegExp(D+"+","g"),R=new RegExp("^"+D+"*,"+D+"*"),N=new RegExp("^"+D+"*([>+~]|"+D+")"+D+"*"),q=new RegExp(D+"|>"),U=new RegExp(F),H=new RegExp("^"+I+"$"),$={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+L),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+D+"*(even|odd|(([+-]|)(\\d*)n|)"+D+"*(?:([+-]|)"+D+"*(\\d+)|))"+D+"*\\)|)","i"),bool:new RegExp("^(?:"+B+")$","i"),needsContext:new RegExp("^"+D+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+D+"*((?:-\\d)?\\d*)"+D+"*\\)|)(?=[^-]|$)","i")},J=/^(?:input|select|textarea|button)$/i,V=/^h\d$/i,W=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,Q=/[+~]/,K=new RegExp("\\\\[\\da-fA-F]{1,6}"+D+"?|\\\\([^\\r\\n\\f])","g"),G=function(n,e){var t="0x"+n.slice(1)-65536;return e||(t<0?String.fromCharCode(t+65536):String.fromCharCode(t>>10|55296,1023&t|56320))},X=function(){ln()},Z=mn((function(n){return!0===n.disabled&&A(n,"fieldset")}),{dir:"parentNode",next:"legend"});try{g.apply(o=s.call(O.childNodes),O.childNodes),o[O.childNodes.length].nodeType}catch(n){g={apply:function(n,e){_.apply(n,s.call(e))},call:function(n){_.apply(n,s.call(arguments,1))}}}function Y(n,e,t,r){var a,o,i,s,l,p,m,h=e&&e.ownerDocument,v=e?e.nodeType:9;if(t=t||[],"string"!=typeof n||!n||1!==v&&9!==v&&11!==v)return t;if(!r&&(ln(e),e=e||c,u)){if(11!==v&&(l=W.exec(n)))if(a=l[1]){if(9===v){if(!(i=e.getElementById(a)))return t;if(i.id===a)return g.call(t,i),t}else if(h&&(i=h.getElementById(a))&&Y.contains(e,i)&&i.id===a)return g.call(t,i),t}else{if(l[2])return g.apply(t,e.getElementsByTagName(n)),t;if((a=l[3])&&e.getElementsByClassName)return g.apply(t,e.getElementsByClassName(a)),t}if(!(S[n+" "]||d&&d.test(n))){if(m=n,h=e,1===v&&(q.test(n)||N.test(n))){for((h=Q.test(n)&&cn(e.parentNode)||e)==e&&f.scope||((s=e.getAttribute("id"))?s=C.escapeSelector(s):e.setAttribute("id",s=b)),o=(p=un(n)).length;o--;)p[o]=(s?"#"+s:":scope")+" "+dn(p[o]);m=p.join(",")}try{return g.apply(t,h.querySelectorAll(m)),t}catch(e){S(n,!0)}finally{s===b&&e.removeAttribute("id")}}}return yn(n.replace(z,"$1"),e,t,r)}function nn(){var n=[];return function t(r,a){return n.push(r+" ")>e.cacheLength&&delete t[n.shift()],t[r+" "]=a}}function en(n){return n[b]=!0,n}function tn(n){var e=c.createElement("fieldset");try{return!!n(e)}catch(n){return!1}finally{e.parentNode&&e.parentNode.removeChild(e),e=null}}function rn(n){return function(e){return A(e,"input")&&e.type===n}}function an(n){return function(e){return(A(e,"input")||A(e,"button"))&&e.type===n}}function on(n){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===n:e.disabled===n:e.isDisabled===n||e.isDisabled!==!n&&Z(e)===n:e.disabled===n:"label"in e&&e.disabled===n}}function sn(n){return en((function(e){return e=+e,en((function(t,r){for(var a,o=n([],t.length,e),i=o.length;i--;)t[a=o[i]]&&(t[a]=!(r[a]=t[a]))}))}))}function cn(n){return n&&void 0!==n.getElementsByTagName&&n}function ln(n){var t,r=n?n.ownerDocument||n:O;return r!=c&&9===r.nodeType&&r.documentElement?(l=(c=r).documentElement,u=!C.isXMLDoc(c),h=l.matches||l.webkitMatchesSelector||l.msMatchesSelector,O!=c&&(t=c.defaultView)&&t.top!==t&&t.addEventListener("unload",X),f.getById=tn((function(n){return l.appendChild(n).id=C.expando,!c.getElementsByName||!c.getElementsByName(C.expando).length})),f.disconnectedMatch=tn((function(n){return h.call(n,"*")})),f.scope=tn((function(){return c.querySelectorAll(":scope")})),f.cssHas=tn((function(){try{return c.querySelector(":has(*,:jqfake)"),!1}catch(n){return!0}})),f.getById?(e.filter.ID=function(n){var e=n.replace(K,G);return function(n){return n.getAttribute("id")===e}},e.find.ID=function(n,e){if(void 0!==e.getElementById&&u){var t=e.getElementById(n);return t?[t]:[]}}):(e.filter.ID=function(n){var e=n.replace(K,G);return function(n){var t=void 0!==n.getAttributeNode&&n.getAttributeNode("id");return t&&t.value===e}},e.find.ID=function(n,e){if(void 0!==e.getElementById&&u){var t,r,a,o=e.getElementById(n);if(o){if((t=o.getAttributeNode("id"))&&t.value===n)return[o];for(a=e.getElementsByName(n),r=0;o=a[r++];)if((t=o.getAttributeNode("id"))&&t.value===n)return[o]}return[]}}),e.find.TAG=function(n,e){return void 0!==e.getElementsByTagName?e.getElementsByTagName(n):e.querySelectorAll(n)},e.find.CLASS=function(n,e){if(void 0!==e.getElementsByClassName&&u)return e.getElementsByClassName(n)},d=[],tn((function(n){var e;l.appendChild(n).innerHTML="<a id='"+b+"' href='' disabled='disabled'></a><select id='"+b+"-\r\\' disabled='disabled'><option selected=''></option></select>",n.querySelectorAll("[selected]").length||d.push("\\["+D+"*(?:value|"+B+")"),n.querySelectorAll("[id~="+b+"-]").length||d.push("~="),n.querySelectorAll("a#"+b+"+*").length||d.push(".#.+[+~]"),n.querySelectorAll(":checked").length||d.push(":checked"),(e=c.createElement("input")).setAttribute("type","hidden"),n.appendChild(e).setAttribute("name","D"),l.appendChild(n).disabled=!0,2!==n.querySelectorAll(":disabled").length&&d.push(":enabled",":disabled"),(e=c.createElement("input")).setAttribute("name",""),n.appendChild(e),n.querySelectorAll("[name='']").length||d.push("\\["+D+"*name"+D+"*="+D+"*(?:''|\"\")")})),f.cssHas||d.push(":has"),d=d.length&&new RegExp(d.join("|")),j=function(n,e){if(n===e)return i=!0,0;var t=!n.compareDocumentPosition-!e.compareDocumentPosition;return t||(1&(t=(n.ownerDocument||n)==(e.ownerDocument||e)?n.compareDocumentPosition(e):1)||!f.sortDetached&&e.compareDocumentPosition(n)===t?n===c||n.ownerDocument==O&&Y.contains(O,n)?-1:e===c||e.ownerDocument==O&&Y.contains(O,e)?1:a?p.call(a,n)-p.call(a,e):0:4&t?-1:1)},c):c}for(n in Y.matches=function(n,e){return Y(n,null,null,e)},Y.matchesSelector=function(n,e){if(ln(n),u&&!S[e+" "]&&(!d||!d.test(e)))try{var t=h.call(n,e);if(t||f.disconnectedMatch||n.document&&11!==n.document.nodeType)return t}catch(n){S(e,!0)}return Y(e,c,null,[n]).length>0},Y.contains=function(n,e){return(n.ownerDocument||n)!=c&&ln(n),C.contains(n,e)},Y.attr=function(n,t){(n.ownerDocument||n)!=c&&ln(n);var r=e.attrHandle[t.toLowerCase()],a=r&&m.call(e.attrHandle,t.toLowerCase())?r(n,t,!u):void 0;return void 0!==a?a:n.getAttribute(t)},Y.error=function(n){throw new Error("Syntax error, unrecognized expression: "+n)},C.uniqueSort=function(n){var e,t=[],r=0,o=0;if(i=!f.sortStable,a=!f.sortStable&&s.call(n,0),E.call(n,j),i){for(;e=n[o++];)e===n[o]&&(r=t.push(o));for(;r--;)P.call(n,t[r],1)}return a=null,n},C.fn.uniqueSort=function(){return this.pushStack(C.uniqueSort(s.apply(this)))},(e=C.expr={cacheLength:50,createPseudo:en,match:$,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(n){return n[1]=n[1].replace(K,G),n[3]=(n[3]||n[4]||n[5]||"").replace(K,G),"~="===n[2]&&(n[3]=" "+n[3]+" "),n.slice(0,4)},CHILD:function(n){return n[1]=n[1].toLowerCase(),"nth"===n[1].slice(0,3)?(n[3]||Y.error(n[0]),n[4]=+(n[4]?n[5]+(n[6]||1):2*("even"===n[3]||"odd"===n[3])),n[5]=+(n[7]+n[8]||"odd"===n[3])):n[3]&&Y.error(n[0]),n},PSEUDO:function(n){var e,t=!n[6]&&n[2];return $.CHILD.test(n[0])?null:(n[3]?n[2]=n[4]||n[5]||"":t&&U.test(t)&&(e=un(t,!0))&&(e=t.indexOf(")",t.length-e)-t.length)&&(n[0]=n[0].slice(0,e),n[2]=t.slice(0,e)),n.slice(0,3))}},filter:{TAG:function(n){var e=n.replace(K,G).toLowerCase();return"*"===n?function(){return!0}:function(n){return A(n,e)}},CLASS:function(n){var e=x[n+" "];return e||(e=new RegExp("(^|"+D+")"+n+"("+D+"|$)"))&&x(n,(function(n){return e.test("string"==typeof n.className&&n.className||void 0!==n.getAttribute&&n.getAttribute("class")||"")}))},ATTR:function(n,e,t){return function(r){var a=Y.attr(r,n);return null==a?"!="===e:!e||(a+="","="===e?a===t:"!="===e?a!==t:"^="===e?t&&0===a.indexOf(t):"*="===e?t&&a.indexOf(t)>-1:"$="===e?t&&a.slice(-t.length)===t:"~="===e?(" "+a.replace(M," ")+" ").indexOf(t)>-1:"|="===e&&(a===t||a.slice(0,t.length+1)===t+"-"))}},CHILD:function(n,e,t,r,a){var o="nth"!==n.slice(0,3),i="last"!==n.slice(-4),s="of-type"===e;return 1===r&&0===a?function(n){return!!n.parentNode}:function(e,t,c){var l,p,u,d,m,h=o!==i?"nextSibling":"previousSibling",g=e.parentNode,f=s&&e.nodeName.toLowerCase(),y=!c&&!s,x=!1;if(g){if(o){for(;h;){for(u=e;u=u[h];)if(s?A(u,f):1===u.nodeType)return!1;m=h="only"===n&&!m&&"nextSibling"}return!0}if(m=[i?g.firstChild:g.lastChild],i&&y){for(x=(d=(l=(p=g[b]||(g[b]={}))[n]||[])[0]===v&&l[1])&&l[2],u=d&&g.childNodes[d];u=++d&&u&&u[h]||(x=d=0)||m.pop();)if(1===u.nodeType&&++x&&u===e){p[n]=[v,d,x];break}}else if(y&&(x=d=(l=(p=e[b]||(e[b]={}))[n]||[])[0]===v&&l[1]),!1===x)for(;(u=++d&&u&&u[h]||(x=d=0)||m.pop())&&(!(s?A(u,f):1===u.nodeType)||!++x||(y&&((p=u[b]||(u[b]={}))[n]=[v,x]),u!==e)););return(x-=a)===r||x%r==0&&x/r>=0}}},PSEUDO:function(n,t){var r,a=e.pseudos[n]||e.setFilters[n.toLowerCase()]||Y.error("unsupported pseudo: "+n);return a[b]?a(t):a.length>1?(r=[n,n,"",t],e.setFilters.hasOwnProperty(n.toLowerCase())?en((function(n,e){for(var r,o=a(n,t),i=o.length;i--;)n[r=p.call(n,o[i])]=!(e[r]=o[i])})):function(n){return a(n,0,r)}):a}},pseudos:{not:en((function(n){var e=[],t=[],r=vn(n.replace(z,"$1"));return r[b]?en((function(n,e,t,a){for(var o,i=r(n,null,a,[]),s=n.length;s--;)(o=i[s])&&(n[s]=!(e[s]=o))})):function(n,a,o){return e[0]=n,r(e,null,o,t),e[0]=null,!t.pop()}})),has:en((function(n){return function(e){return Y(n,e).length>0}})),contains:en((function(n){return n=n.replace(K,G),function(e){return(e.textContent||C.text(e)).indexOf(n)>-1}})),lang:en((function(n){return H.test(n||"")||Y.error("unsupported lang: "+n),n=n.replace(K,G).toLowerCase(),function(e){var t;do{if(t=u?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}})),target:function(n){var e=t.location&&t.location.hash;return e&&e.slice(1)===n.id},root:function(n){return n===l},focus:function(n){return n===function(){try{return c.activeElement}catch(n){}}()&&c.hasFocus()&&!!(n.type||n.href||~n.tabIndex)},enabled:on(!1),disabled:on(!0),checked:function(n){return A(n,"input")&&!!n.checked||A(n,"option")&&!!n.selected},selected:function(n){return n.parentNode&&n.parentNode.selectedIndex,!0===n.selected},empty:function(n){for(n=n.firstChild;n;n=n.nextSibling)if(n.nodeType<6)return!1;return!0},parent:function(n){return!e.pseudos.empty(n)},header:function(n){return V.test(n.nodeName)},input:function(n){return J.test(n.nodeName)},button:function(n){return A(n,"input")&&"button"===n.type||A(n,"button")},text:function(n){var e;return A(n,"input")&&"text"===n.type&&(null==(e=n.getAttribute("type"))||"text"===e.toLowerCase())},first:sn((function(){return[0]})),last:sn((function(n,e){return[e-1]})),eq:sn((function(n,e,t){return[t<0?t+e:t]})),even:sn((function(n,e){for(var t=0;t<e;t+=2)n.push(t);return n})),odd:sn((function(n,e){for(var t=1;t<e;t+=2)n.push(t);return n})),lt:sn((function(n,e,t){var r;for(r=t<0?t+e:t>e?e:t;--r>=0;)n.push(r);return n})),gt:sn((function(n,e,t){for(var r=t<0?t+e:t;++r<e;)n.push(r);return n}))}}).pseudos.nth=e.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})e.pseudos[n]=rn(n);for(n in{submit:!0,reset:!0})e.pseudos[n]=an(n);function pn(){}function un(n,t){var r,a,o,i,s,c,l,p=w[n+" "];if(p)return t?0:p.slice(0);for(s=n,c=[],l=e.preFilter;s;){for(i in r&&!(a=R.exec(s))||(a&&(s=s.slice(a[0].length)||s),c.push(o=[])),r=!1,(a=N.exec(s))&&(r=a.shift(),o.push({value:r,type:a[0].replace(z," ")}),s=s.slice(r.length)),e.filter)!(a=$[i].exec(s))||l[i]&&!(a=l[i](a))||(r=a.shift(),o.push({value:r,type:i,matches:a}),s=s.slice(r.length));if(!r)break}return t?s.length:s?Y.error(n):w(n,c).slice(0)}function dn(n){for(var e=0,t=n.length,r="";e<t;e++)r+=n[e].value;return r}function mn(n,e,t){var r=e.dir,a=e.next,o=a||r,i=t&&"parentNode"===o,s=y++;return e.first?function(e,t,a){for(;e=e[r];)if(1===e.nodeType||i)return n(e,t,a);return!1}:function(e,t,c){var l,p,u=[v,s];if(c){for(;e=e[r];)if((1===e.nodeType||i)&&n(e,t,c))return!0}else for(;e=e[r];)if(1===e.nodeType||i)if(p=e[b]||(e[b]={}),a&&A(e,a))e=e[r]||e;else{if((l=p[o])&&l[0]===v&&l[1]===s)return u[2]=l[2];if(p[o]=u,u[2]=n(e,t,c))return!0}return!1}}function hn(n){return n.length>1?function(e,t,r){for(var a=n.length;a--;)if(!n[a](e,t,r))return!1;return!0}:n[0]}function gn(n,e,t,r,a){for(var o,i=[],s=0,c=n.length,l=null!=e;s<c;s++)(o=n[s])&&(t&&!t(o,r,a)||(i.push(o),l&&e.push(s)));return i}function fn(n,e,t,r,a,o){return r&&!r[b]&&(r=fn(r)),a&&!a[b]&&(a=fn(a,o)),en((function(o,i,s,c){var l,u,d,m,h=[],f=[],b=i.length,v=o||function(n,e,t){for(var r=0,a=e.length;r<a;r++)Y(n,e[r],t);return t}(e||"*",s.nodeType?[s]:s,[]),y=!n||!o&&e?v:gn(v,h,n,s,c);if(t?t(y,m=a||(o?n:b||r)?[]:i,s,c):m=y,r)for(l=gn(m,f),r(l,[],s,c),u=l.length;u--;)(d=l[u])&&(m[f[u]]=!(y[f[u]]=d));if(o){if(a||n){if(a){for(l=[],u=m.length;u--;)(d=m[u])&&l.push(y[u]=d);a(null,m=[],l,c)}for(u=m.length;u--;)(d=m[u])&&(l=a?p.call(o,d):h[u])>-1&&(o[l]=!(i[l]=d))}}else m=gn(m===i?m.splice(b,m.length):m),a?a(null,i,m,c):g.apply(i,m)}))}function bn(n){for(var t,a,o,i=n.length,s=e.relative[n[0].type],c=s||e.relative[" "],l=s?1:0,u=mn((function(n){return n===t}),c,!0),d=mn((function(n){return p.call(t,n)>-1}),c,!0),m=[function(n,e,a){var o=!s&&(a||e!=r)||((t=e).nodeType?u(n,e,a):d(n,e,a));return t=null,o}];l<i;l++)if(a=e.relative[n[l].type])m=[mn(hn(m),a)];else{if((a=e.filter[n[l].type].apply(null,n[l].matches))[b]){for(o=++l;o<i&&!e.relative[n[o].type];o++);return fn(l>1&&hn(m),l>1&&dn(n.slice(0,l-1).concat({value:" "===n[l-2].type?"*":""})).replace(z,"$1"),a,l<o&&bn(n.slice(l,o)),o<i&&bn(n=n.slice(o)),o<i&&dn(n))}m.push(a)}return hn(m)}function vn(n,t){var a,o=[],i=[],s=k[n+" "];if(!s){for(t||(t=un(n)),a=t.length;a--;)(s=bn(t[a]))[b]?o.push(s):i.push(s);(s=k(n,function(n,t){var a=t.length>0,o=n.length>0,i=function(i,s,l,p,d){var m,h,f,b=0,y="0",x=i&&[],w=[],k=r,S=i||o&&e.find.TAG("*",d),j=v+=null==k?1:Math.random()||.1,A=S.length;for(d&&(r=s==c||s||d);y!==A&&null!=(m=S[y]);y++){if(o&&m){for(h=0,s||m.ownerDocument==c||(ln(m),l=!u);f=n[h++];)if(f(m,s||c,l)){g.call(p,m);break}d&&(v=j)}a&&((m=!f&&m)&&b--,i&&x.push(m))}if(b+=y,a&&y!==b){for(h=0;f=t[h++];)f(x,w,s,l);if(i){if(b>0)for(;y--;)x[y]||w[y]||(w[y]=T.call(p));w=gn(w)}g.apply(p,w),d&&!i&&w.length>0&&b+t.length>1&&C.uniqueSort(p)}return d&&(v=j,r=k),x};return a?en(i):i}(i,o))).selector=n}return s}function yn(n,t,r,a){var o,i,s,c,l,p="function"==typeof n&&n,d=!a&&un(n=p.selector||n);if(r=r||[],1===d.length){if((i=d[0]=d[0].slice(0)).length>2&&"ID"===(s=i[0]).type&&9===t.nodeType&&u&&e.relative[i[1].type]){if(!(t=(e.find.ID(s.matches[0].replace(K,G),t)||[])[0]))return r;p&&(t=t.parentNode),n=n.slice(i.shift().value.length)}for(o=$.needsContext.test(n)?0:i.length;o--&&(s=i[o],!e.relative[c=s.type]);)if((l=e.find[c])&&(a=l(s.matches[0].replace(K,G),Q.test(i[0].type)&&cn(t.parentNode)||t))){if(i.splice(o,1),!(n=a.length&&dn(i)))return g.apply(r,a),r;break}}return(p||vn(n,d))(a,t,!u,r,!t||Q.test(n)&&cn(t.parentNode)||t),r}pn.prototype=e.filters=e.pseudos,e.setFilters=new pn,f.sortStable=b.split("").sort(j).join("")===b,ln(),f.sortDetached=tn((function(n){return 1&n.compareDocumentPosition(c.createElement("fieldset"))})),C.find=Y,C.expr[":"]=C.expr.pseudos,C.unique=C.uniqueSort,Y.compile=vn,Y.select=yn,Y.setDocument=ln,Y.escape=C.escapeSelector,Y.getText=C.text,Y.isXML=C.isXMLDoc,Y.selectors=C.expr,Y.support=C.support,Y.uniqueSort=C.uniqueSort}();var L=function(n,e,t){for(var r=[],a=void 0!==t;(n=n[e])&&9!==n.nodeType;)if(1===n.nodeType){if(a&&C(n).is(t))break;r.push(n)}return r},F=function(n,e){for(var t=[];n;n=n.nextSibling)1===n.nodeType&&n!==e&&t.push(n);return t},M=C.expr.match.needsContext,R=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function N(n,e,t){return b(e)?C.grep(n,(function(n,r){return!!e.call(n,r,n)!==t})):e.nodeType?C.grep(n,(function(n){return n===e!==t})):"string"!=typeof e?C.grep(n,(function(n){return p.call(e,n)>-1!==t})):C.filter(e,n,t)}C.filter=function(n,e,t){var r=e[0];return t&&(n=":not("+n+")"),1===e.length&&1===r.nodeType?C.find.matchesSelector(r,n)?[r]:[]:C.find.matches(n,C.grep(e,(function(n){return 1===n.nodeType})))},C.fn.extend({find:function(n){var e,t,r=this.length,a=this;if("string"!=typeof n)return this.pushStack(C(n).filter((function(){for(e=0;e<r;e++)if(C.contains(a[e],this))return!0})));for(t=this.pushStack([]),e=0;e<r;e++)C.find(n,a[e],t);return r>1?C.uniqueSort(t):t},filter:function(n){return this.pushStack(N(this,n||[],!1))},not:function(n){return this.pushStack(N(this,n||[],!0))},is:function(n){return!!N(this,"string"==typeof n&&M.test(n)?C(n):n||[],!1).length}});var q,U=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(C.fn.init=function(n,e,t){var r,a;if(!n)return this;if(t=t||q,"string"==typeof n){if(!(r="<"===n[0]&&">"===n[n.length-1]&&n.length>=3?[null,n,null]:U.exec(n))||!r[1]&&e)return!e||e.jquery?(e||t).find(n):this.constructor(e).find(n);if(r[1]){if(e=e instanceof C?e[0]:e,C.merge(this,C.parseHTML(r[1],e&&e.nodeType?e.ownerDocument||e:y,!0)),R.test(r[1])&&C.isPlainObject(e))for(r in e)b(this[r])?this[r](e[r]):this.attr(r,e[r]);return this}return(a=y.getElementById(r[2]))&&(this[0]=a,this.length=1),this}return n.nodeType?(this[0]=n,this.length=1,this):b(n)?void 0!==t.ready?t.ready(n):n(C):C.makeArray(n,this)}).prototype=C.fn,q=C(y);var H=/^(?:parents|prev(?:Until|All))/,$={children:!0,contents:!0,next:!0,prev:!0};function J(n,e){for(;(n=n[e])&&1!==n.nodeType;);return n}C.fn.extend({has:function(n){var e=C(n,this),t=e.length;return this.filter((function(){for(var n=0;n<t;n++)if(C.contains(this,e[n]))return!0}))},closest:function(n,e){var t,r=0,a=this.length,o=[],i="string"!=typeof n&&C(n);if(!M.test(n))for(;r<a;r++)for(t=this[r];t&&t!==e;t=t.parentNode)if(t.nodeType<11&&(i?i.index(t)>-1:1===t.nodeType&&C.find.matchesSelector(t,n))){o.push(t);break}return this.pushStack(o.length>1?C.uniqueSort(o):o)},index:function(n){return n?"string"==typeof n?p.call(C(n),this[0]):p.call(this,n.jquery?n[0]:n):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(n,e){return this.pushStack(C.uniqueSort(C.merge(this.get(),C(n,e))))},addBack:function(n){return this.add(null==n?this.prevObject:this.prevObject.filter(n))}}),C.each({parent:function(n){var e=n.parentNode;return e&&11!==e.nodeType?e:null},parents:function(n){return L(n,"parentNode")},parentsUntil:function(n,e,t){return L(n,"parentNode",t)},next:function(n){return J(n,"nextSibling")},prev:function(n){return J(n,"previousSibling")},nextAll:function(n){return L(n,"nextSibling")},prevAll:function(n){return L(n,"previousSibling")},nextUntil:function(n,e,t){return L(n,"nextSibling",t)},prevUntil:function(n,e,t){return L(n,"previousSibling",t)},siblings:function(n){return F((n.parentNode||{}).firstChild,n)},children:function(n){return F(n.firstChild)},contents:function(n){return null!=n.contentDocument&&i(n.contentDocument)?n.contentDocument:(A(n,"template")&&(n=n.content||n),C.merge([],n.childNodes))}},(function(n,e){C.fn[n]=function(t,r){var a=C.map(this,e,t);return"Until"!==n.slice(-5)&&(r=t),r&&"string"==typeof r&&(a=C.filter(r,a)),this.length>1&&($[n]||C.uniqueSort(a),H.test(n)&&a.reverse()),this.pushStack(a)}}));var V=/[^\x20\t\r\n\f]+/g;function W(n){return n}function Q(n){throw n}function K(n,e,t,r){var a;try{n&&b(a=n.promise)?a.call(n).done(e).fail(t):n&&b(a=n.then)?a.call(n,e,t):e.apply(void 0,[n].slice(r))}catch(n){t.apply(void 0,[n])}}C.Callbacks=function(n){n="string"==typeof n?function(n){var e={};return C.each(n.match(V)||[],(function(n,t){e[t]=!0})),e}(n):C.extend({},n);var e,t,r,a,o=[],i=[],s=-1,c=function(){for(a=a||n.once,r=e=!0;i.length;s=-1)for(t=i.shift();++s<o.length;)!1===o[s].apply(t[0],t[1])&&n.stopOnFalse&&(s=o.length,t=!1);n.memory||(t=!1),e=!1,a&&(o=t?[]:"")},l={add:function(){return o&&(t&&!e&&(s=o.length-1,i.push(t)),function e(t){C.each(t,(function(t,r){b(r)?n.unique&&l.has(r)||o.push(r):r&&r.length&&"string"!==k(r)&&e(r)}))}(arguments),t&&!e&&c()),this},remove:function(){return C.each(arguments,(function(n,e){for(var t;(t=C.inArray(e,o,t))>-1;)o.splice(t,1),t<=s&&s--})),this},has:function(n){return n?C.inArray(n,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return a=i=[],o=t="",this},disabled:function(){return!o},lock:function(){return a=i=[],t||e||(o=t=""),this},locked:function(){return!!a},fireWith:function(n,t){return a||(t=[n,(t=t||[]).slice?t.slice():t],i.push(t),e||c()),this},fire:function(){return l.fireWith(this,arguments),this},fired:function(){return!!r}};return l},C.extend({Deferred:function(n){var e=[["notify","progress",C.Callbacks("memory"),C.Callbacks("memory"),2],["resolve","done",C.Callbacks("once memory"),C.Callbacks("once memory"),0,"resolved"],["reject","fail",C.Callbacks("once memory"),C.Callbacks("once memory"),1,"rejected"]],r="pending",a={state:function(){return r},always:function(){return o.done(arguments).fail(arguments),this},catch:function(n){return a.then(null,n)},pipe:function(){var n=arguments;return C.Deferred((function(t){C.each(e,(function(e,r){var a=b(n[r[4]])&&n[r[4]];o[r[1]]((function(){var n=a&&a.apply(this,arguments);n&&b(n.promise)?n.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[r[0]+"With"](this,a?[n]:arguments)}))})),n=null})).promise()},then:function(n,r,a){var o=0;function i(n,e,r,a){return function(){var s=this,c=arguments,l=function(){var t,l;if(!(n<o)){if((t=r.apply(s,c))===e.promise())throw new TypeError("Thenable self-resolution");l=t&&("object"==typeof t||"function"==typeof t)&&t.then,b(l)?a?l.call(t,i(o,e,W,a),i(o,e,Q,a)):(o++,l.call(t,i(o,e,W,a),i(o,e,Q,a),i(o,e,W,e.notifyWith))):(r!==W&&(s=void 0,c=[t]),(a||e.resolveWith)(s,c))}},p=a?l:function(){try{l()}catch(t){C.Deferred.exceptionHook&&C.Deferred.exceptionHook(t,p.error),n+1>=o&&(r!==Q&&(s=void 0,c=[t]),e.rejectWith(s,c))}};n?p():(C.Deferred.getErrorHook?p.error=C.Deferred.getErrorHook():C.Deferred.getStackHook&&(p.error=C.Deferred.getStackHook()),t.setTimeout(p))}}return C.Deferred((function(t){e[0][3].add(i(0,t,b(a)?a:W,t.notifyWith)),e[1][3].add(i(0,t,b(n)?n:W)),e[2][3].add(i(0,t,b(r)?r:Q))})).promise()},promise:function(n){return null!=n?C.extend(n,a):a}},o={};return C.each(e,(function(n,t){var i=t[2],s=t[5];a[t[1]]=i.add,s&&i.add((function(){r=s}),e[3-n][2].disable,e[3-n][3].disable,e[0][2].lock,e[0][3].lock),i.add(t[3].fire),o[t[0]]=function(){return o[t[0]+"With"](this===o?void 0:this,arguments),this},o[t[0]+"With"]=i.fireWith})),a.promise(o),n&&n.call(o,o),o},when:function(n){var e=arguments.length,t=e,r=Array(t),a=s.call(arguments),o=C.Deferred(),i=function(n){return function(t){r[n]=this,a[n]=arguments.length>1?s.call(arguments):t,--e||o.resolveWith(r,a)}};if(e<=1&&(K(n,o.done(i(t)).resolve,o.reject,!e),"pending"===o.state()||b(a[t]&&a[t].then)))return o.then();for(;t--;)K(a[t],i(t),o.reject);return o.promise()}});var G=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;C.Deferred.exceptionHook=function(n,e){t.console&&t.console.warn&&n&&G.test(n.name)&&t.console.warn("jQuery.Deferred exception: "+n.message,n.stack,e)},C.readyException=function(n){t.setTimeout((function(){throw n}))};var X=C.Deferred();function Z(){y.removeEventListener("DOMContentLoaded",Z),t.removeEventListener("load",Z),C.ready()}C.fn.ready=function(n){return X.then(n).catch((function(n){C.readyException(n)})),this},C.extend({isReady:!1,readyWait:1,ready:function(n){(!0===n?--C.readyWait:C.isReady)||(C.isReady=!0,!0!==n&&--C.readyWait>0||X.resolveWith(y,[C]))}}),C.ready.then=X.then,"complete"===y.readyState||"loading"!==y.readyState&&!y.documentElement.doScroll?t.setTimeout(C.ready):(y.addEventListener("DOMContentLoaded",Z),t.addEventListener("load",Z));var Y=function(n,e,t,r,a,o,i){var s=0,c=n.length,l=null==t;if("object"===k(t))for(s in a=!0,t)Y(n,e,s,t[s],!0,o,i);else if(void 0!==r&&(a=!0,b(r)||(i=!0),l&&(i?(e.call(n,r),e=null):(l=e,e=function(n,e,t){return l.call(C(n),t)})),e))for(;s<c;s++)e(n[s],t,i?r:r.call(n[s],s,e(n[s],t)));return a?n:l?e.call(n):c?e(n[0],t):o},nn=/^-ms-/,en=/-([a-z])/g;function tn(n,e){return e.toUpperCase()}function rn(n){return n.replace(nn,"ms-").replace(en,tn)}var an=function(n){return 1===n.nodeType||9===n.nodeType||!+n.nodeType};function on(){this.expando=C.expando+on.uid++}on.uid=1,on.prototype={cache:function(n){var e=n[this.expando];return e||(e={},an(n)&&(n.nodeType?n[this.expando]=e:Object.defineProperty(n,this.expando,{value:e,configurable:!0}))),e},set:function(n,e,t){var r,a=this.cache(n);if("string"==typeof e)a[rn(e)]=t;else for(r in e)a[rn(r)]=e[r];return a},get:function(n,e){return void 0===e?this.cache(n):n[this.expando]&&n[this.expando][rn(e)]},access:function(n,e,t){return void 0===e||e&&"string"==typeof e&&void 0===t?this.get(n,e):(this.set(n,e,t),void 0!==t?t:e)},remove:function(n,e){var t,r=n[this.expando];if(void 0!==r){if(void 0!==e){t=(e=Array.isArray(e)?e.map(rn):(e=rn(e))in r?[e]:e.match(V)||[]).length;for(;t--;)delete r[e[t]]}(void 0===e||C.isEmptyObject(r))&&(n.nodeType?n[this.expando]=void 0:delete n[this.expando])}},hasData:function(n){var e=n[this.expando];return void 0!==e&&!C.isEmptyObject(e)}};var sn=new on,cn=new on,ln=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,pn=/[A-Z]/g;function un(n,e,t){var r;if(void 0===t&&1===n.nodeType)if(r="data-"+e.replace(pn,"-$&").toLowerCase(),"string"==typeof(t=n.getAttribute(r))){try{t=function(n){return"true"===n||"false"!==n&&("null"===n?null:n===+n+""?+n:ln.test(n)?JSON.parse(n):n)}(t)}catch(n){}cn.set(n,e,t)}else t=void 0;return t}C.extend({hasData:function(n){return cn.hasData(n)||sn.hasData(n)},data:function(n,e,t){return cn.access(n,e,t)},removeData:function(n,e){cn.remove(n,e)},_data:function(n,e,t){return sn.access(n,e,t)},_removeData:function(n,e){sn.remove(n,e)}}),C.fn.extend({data:function(n,e){var t,r,a,o=this[0],i=o&&o.attributes;if(void 0===n){if(this.length&&(a=cn.get(o),1===o.nodeType&&!sn.get(o,"hasDataAttrs"))){for(t=i.length;t--;)i[t]&&0===(r=i[t].name).indexOf("data-")&&(r=rn(r.slice(5)),un(o,r,a[r]));sn.set(o,"hasDataAttrs",!0)}return a}return"object"==typeof n?this.each((function(){cn.set(this,n)})):Y(this,(function(e){var t;if(o&&void 0===e)return void 0!==(t=cn.get(o,n))||void 0!==(t=un(o,n))?t:void 0;this.each((function(){cn.set(this,n,e)}))}),null,e,arguments.length>1,null,!0)},removeData:function(n){return this.each((function(){cn.remove(this,n)}))}}),C.extend({queue:function(n,e,t){var r;if(n)return e=(e||"fx")+"queue",r=sn.get(n,e),t&&(!r||Array.isArray(t)?r=sn.access(n,e,C.makeArray(t)):r.push(t)),r||[]},dequeue:function(n,e){e=e||"fx";var t=C.queue(n,e),r=t.length,a=t.shift(),o=C._queueHooks(n,e);"inprogress"===a&&(a=t.shift(),r--),a&&("fx"===e&&t.unshift("inprogress"),delete o.stop,a.call(n,(function(){C.dequeue(n,e)}),o)),!r&&o&&o.empty.fire()},_queueHooks:function(n,e){var t=e+"queueHooks";return sn.get(n,t)||sn.access(n,t,{empty:C.Callbacks("once memory").add((function(){sn.remove(n,[e+"queue",t])}))})}}),C.fn.extend({queue:function(n,e){var t=2;return"string"!=typeof n&&(e=n,n="fx",t--),arguments.length<t?C.queue(this[0],n):void 0===e?this:this.each((function(){var t=C.queue(this,n,e);C._queueHooks(this,n),"fx"===n&&"inprogress"!==t[0]&&C.dequeue(this,n)}))},dequeue:function(n){return this.each((function(){C.dequeue(this,n)}))},clearQueue:function(n){return this.queue(n||"fx",[])},promise:function(n,e){var t,r=1,a=C.Deferred(),o=this,i=this.length,s=function(){--r||a.resolveWith(o,[o])};for("string"!=typeof n&&(e=n,n=void 0),n=n||"fx";i--;)(t=sn.get(o[i],n+"queueHooks"))&&t.empty&&(r++,t.empty.add(s));return s(),a.promise(e)}});var dn=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,mn=new RegExp("^(?:([+-])=|)("+dn+")([a-z%]*)$","i"),hn=["Top","Right","Bottom","Left"],gn=y.documentElement,fn=function(n){return C.contains(n.ownerDocument,n)},bn={composed:!0};gn.getRootNode&&(fn=function(n){return C.contains(n.ownerDocument,n)||n.getRootNode(bn)===n.ownerDocument});var vn=function(n,e){return"none"===(n=e||n).style.display||""===n.style.display&&fn(n)&&"none"===C.css(n,"display")};function yn(n,e,t,r){var a,o,i=20,s=r?function(){return r.cur()}:function(){return C.css(n,e,"")},c=s(),l=t&&t[3]||(C.cssNumber[e]?"":"px"),p=n.nodeType&&(C.cssNumber[e]||"px"!==l&&+c)&&mn.exec(C.css(n,e));if(p&&p[3]!==l){for(c/=2,l=l||p[3],p=+c||1;i--;)C.style(n,e,p+l),(1-o)*(1-(o=s()/c||.5))<=0&&(i=0),p/=o;p*=2,C.style(n,e,p+l),t=t||[]}return t&&(p=+p||+c||0,a=t[1]?p+(t[1]+1)*t[2]:+t[2],r&&(r.unit=l,r.start=p,r.end=a)),a}var xn={};function wn(n){var e,t=n.ownerDocument,r=n.nodeName,a=xn[r];return a||(e=t.body.appendChild(t.createElement(r)),a=C.css(e,"display"),e.parentNode.removeChild(e),"none"===a&&(a="block"),xn[r]=a,a)}function kn(n,e){for(var t,r,a=[],o=0,i=n.length;o<i;o++)(r=n[o]).style&&(t=r.style.display,e?("none"===t&&(a[o]=sn.get(r,"display")||null,a[o]||(r.style.display="")),""===r.style.display&&vn(r)&&(a[o]=wn(r))):"none"!==t&&(a[o]="none",sn.set(r,"display",t)));for(o=0;o<i;o++)null!=a[o]&&(n[o].style.display=a[o]);return n}C.fn.extend({show:function(){return kn(this,!0)},hide:function(){return kn(this)},toggle:function(n){return"boolean"==typeof n?n?this.show():this.hide():this.each((function(){vn(this)?C(this).show():C(this).hide()}))}});var Sn,Cn,jn=/^(?:checkbox|radio)$/i,An=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,Tn=/^$|^module$|\/(?:java|ecma)script/i;Sn=y.createDocumentFragment().appendChild(y.createElement("div")),(Cn=y.createElement("input")).setAttribute("type","radio"),Cn.setAttribute("checked","checked"),Cn.setAttribute("name","t"),Sn.appendChild(Cn),f.checkClone=Sn.cloneNode(!0).cloneNode(!0).lastChild.checked,Sn.innerHTML="<textarea>x</textarea>",f.noCloneChecked=!!Sn.cloneNode(!0).lastChild.defaultValue,Sn.innerHTML="<option></option>",f.option=!!Sn.lastChild;var En={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function Pn(n,e){var t;return t=void 0!==n.getElementsByTagName?n.getElementsByTagName(e||"*"):void 0!==n.querySelectorAll?n.querySelectorAll(e||"*"):[],void 0===e||e&&A(n,e)?C.merge([n],t):t}function Dn(n,e){for(var t=0,r=n.length;t<r;t++)sn.set(n[t],"globalEval",!e||sn.get(e[t],"globalEval"))}En.tbody=En.tfoot=En.colgroup=En.caption=En.thead,En.th=En.td,f.option||(En.optgroup=En.option=[1,"<select multiple='multiple'>","</select>"]);var zn=/<|&#?\w+;/;function Bn(n,e,t,r,a){for(var o,i,s,c,l,p,u=e.createDocumentFragment(),d=[],m=0,h=n.length;m<h;m++)if((o=n[m])||0===o)if("object"===k(o))C.merge(d,o.nodeType?[o]:o);else if(zn.test(o)){for(i=i||u.appendChild(e.createElement("div")),s=(An.exec(o)||["",""])[1].toLowerCase(),c=En[s]||En._default,i.innerHTML=c[1]+C.htmlPrefilter(o)+c[2],p=c[0];p--;)i=i.lastChild;C.merge(d,i.childNodes),(i=u.firstChild).textContent=""}else d.push(e.createTextNode(o));for(u.textContent="",m=0;o=d[m++];)if(r&&C.inArray(o,r)>-1)a&&a.push(o);else if(l=fn(o),i=Pn(u.appendChild(o),"script"),l&&Dn(i),t)for(p=0;o=i[p++];)Tn.test(o.type||"")&&t.push(o);return u}var In=/^([^.]*)(?:\.(.+)|)/;function On(){return!0}function _n(){return!1}function Ln(n,e,t,r,a,o){var i,s;if("object"==typeof e){for(s in"string"!=typeof t&&(r=r||t,t=void 0),e)Ln(n,s,t,r,e[s],o);return n}if(null==r&&null==a?(a=t,r=t=void 0):null==a&&("string"==typeof t?(a=r,r=void 0):(a=r,r=t,t=void 0)),!1===a)a=_n;else if(!a)return n;return 1===o&&(i=a,(a=function(n){return C().off(n),i.apply(this,arguments)}).guid=i.guid||(i.guid=C.guid++)),n.each((function(){C.event.add(this,e,a,r,t)}))}function Fn(n,e,t){t?(sn.set(n,e,!1),C.event.add(n,e,{namespace:!1,handler:function(n){var t,r=sn.get(this,e);if(1&n.isTrigger&&this[e]){if(r)(C.event.special[e]||{}).delegateType&&n.stopPropagation();else if(r=s.call(arguments),sn.set(this,e,r),this[e](),t=sn.get(this,e),sn.set(this,e,!1),r!==t)return n.stopImmediatePropagation(),n.preventDefault(),t}else r&&(sn.set(this,e,C.event.trigger(r[0],r.slice(1),this)),n.stopPropagation(),n.isImmediatePropagationStopped=On)}})):void 0===sn.get(n,e)&&C.event.add(n,e,On)}C.event={global:{},add:function(n,e,t,r,a){var o,i,s,c,l,p,u,d,m,h,g,f=sn.get(n);if(an(n))for(t.handler&&(t=(o=t).handler,a=o.selector),a&&C.find.matchesSelector(gn,a),t.guid||(t.guid=C.guid++),(c=f.events)||(c=f.events=Object.create(null)),(i=f.handle)||(i=f.handle=function(e){return void 0!==C&&C.event.triggered!==e.type?C.event.dispatch.apply(n,arguments):void 0}),l=(e=(e||"").match(V)||[""]).length;l--;)m=g=(s=In.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),m&&(u=C.event.special[m]||{},m=(a?u.delegateType:u.bindType)||m,u=C.event.special[m]||{},p=C.extend({type:m,origType:g,data:r,handler:t,guid:t.guid,selector:a,needsContext:a&&C.expr.match.needsContext.test(a),namespace:h.join(".")},o),(d=c[m])||((d=c[m]=[]).delegateCount=0,u.setup&&!1!==u.setup.call(n,r,h,i)||n.addEventListener&&n.addEventListener(m,i)),u.add&&(u.add.call(n,p),p.handler.guid||(p.handler.guid=t.guid)),a?d.splice(d.delegateCount++,0,p):d.push(p),C.event.global[m]=!0)},remove:function(n,e,t,r,a){var o,i,s,c,l,p,u,d,m,h,g,f=sn.hasData(n)&&sn.get(n);if(f&&(c=f.events)){for(l=(e=(e||"").match(V)||[""]).length;l--;)if(m=g=(s=In.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),m){for(u=C.event.special[m]||{},d=c[m=(r?u.delegateType:u.bindType)||m]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=o=d.length;o--;)p=d[o],!a&&g!==p.origType||t&&t.guid!==p.guid||s&&!s.test(p.namespace)||r&&r!==p.selector&&("**"!==r||!p.selector)||(d.splice(o,1),p.selector&&d.delegateCount--,u.remove&&u.remove.call(n,p));i&&!d.length&&(u.teardown&&!1!==u.teardown.call(n,h,f.handle)||C.removeEvent(n,m,f.handle),delete c[m])}else for(m in c)C.event.remove(n,m+e[l],t,r,!0);C.isEmptyObject(c)&&sn.remove(n,"handle events")}},dispatch:function(n){var e,t,r,a,o,i,s=new Array(arguments.length),c=C.event.fix(n),l=(sn.get(this,"events")||Object.create(null))[c.type]||[],p=C.event.special[c.type]||{};for(s[0]=c,e=1;e<arguments.length;e++)s[e]=arguments[e];if(c.delegateTarget=this,!p.preDispatch||!1!==p.preDispatch.call(this,c)){for(i=C.event.handlers.call(this,c,l),e=0;(a=i[e++])&&!c.isPropagationStopped();)for(c.currentTarget=a.elem,t=0;(o=a.handlers[t++])&&!c.isImmediatePropagationStopped();)c.rnamespace&&!1!==o.namespace&&!c.rnamespace.test(o.namespace)||(c.handleObj=o,c.data=o.data,void 0!==(r=((C.event.special[o.origType]||{}).handle||o.handler).apply(a.elem,s))&&!1===(c.result=r)&&(c.preventDefault(),c.stopPropagation()));return p.postDispatch&&p.postDispatch.call(this,c),c.result}},handlers:function(n,e){var t,r,a,o,i,s=[],c=e.delegateCount,l=n.target;if(c&&l.nodeType&&!("click"===n.type&&n.button>=1))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==n.type||!0!==l.disabled)){for(o=[],i={},t=0;t<c;t++)void 0===i[a=(r=e[t]).selector+" "]&&(i[a]=r.needsContext?C(a,this).index(l)>-1:C.find(a,this,null,[l]).length),i[a]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,c<e.length&&s.push({elem:l,handlers:e.slice(c)}),s},addProp:function(n,e){Object.defineProperty(C.Event.prototype,n,{enumerable:!0,configurable:!0,get:b(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[n]},set:function(e){Object.defineProperty(this,n,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(n){return n[C.expando]?n:new C.Event(n)},special:{load:{noBubble:!0},click:{setup:function(n){var e=this||n;return jn.test(e.type)&&e.click&&A(e,"input")&&Fn(e,"click",!0),!1},trigger:function(n){var e=this||n;return jn.test(e.type)&&e.click&&A(e,"input")&&Fn(e,"click"),!0},_default:function(n){var e=n.target;return jn.test(e.type)&&e.click&&A(e,"input")&&sn.get(e,"click")||A(e,"a")}},beforeunload:{postDispatch:function(n){void 0!==n.result&&n.originalEvent&&(n.originalEvent.returnValue=n.result)}}}},C.removeEvent=function(n,e,t){n.removeEventListener&&n.removeEventListener(e,t)},C.Event=function(n,e){if(!(this instanceof C.Event))return new C.Event(n,e);n&&n.type?(this.originalEvent=n,this.type=n.type,this.isDefaultPrevented=n.defaultPrevented||void 0===n.defaultPrevented&&!1===n.returnValue?On:_n,this.target=n.target&&3===n.target.nodeType?n.target.parentNode:n.target,this.currentTarget=n.currentTarget,this.relatedTarget=n.relatedTarget):this.type=n,e&&C.extend(this,e),this.timeStamp=n&&n.timeStamp||Date.now(),this[C.expando]=!0},C.Event.prototype={constructor:C.Event,isDefaultPrevented:_n,isPropagationStopped:_n,isImmediatePropagationStopped:_n,isSimulated:!1,preventDefault:function(){var n=this.originalEvent;this.isDefaultPrevented=On,n&&!this.isSimulated&&n.preventDefault()},stopPropagation:function(){var n=this.originalEvent;this.isPropagationStopped=On,n&&!this.isSimulated&&n.stopPropagation()},stopImmediatePropagation:function(){var n=this.originalEvent;this.isImmediatePropagationStopped=On,n&&!this.isSimulated&&n.stopImmediatePropagation(),this.stopPropagation()}},C.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,char:!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},C.event.addProp),C.each({focus:"focusin",blur:"focusout"},(function(n,e){function t(n){if(y.documentMode){var t=sn.get(this,"handle"),r=C.event.fix(n);r.type="focusin"===n.type?"focus":"blur",r.isSimulated=!0,t(n),r.target===r.currentTarget&&t(r)}else C.event.simulate(e,n.target,C.event.fix(n))}C.event.special[n]={setup:function(){var r;if(Fn(this,n,!0),!y.documentMode)return!1;(r=sn.get(this,e))||this.addEventListener(e,t),sn.set(this,e,(r||0)+1)},trigger:function(){return Fn(this,n),!0},teardown:function(){var n;if(!y.documentMode)return!1;(n=sn.get(this,e)-1)?sn.set(this,e,n):(this.removeEventListener(e,t),sn.remove(this,e))},_default:function(e){return sn.get(e.target,n)},delegateType:e},C.event.special[e]={setup:function(){var r=this.ownerDocument||this.document||this,a=y.documentMode?this:r,o=sn.get(a,e);o||(y.documentMode?this.addEventListener(e,t):r.addEventListener(n,t,!0)),sn.set(a,e,(o||0)+1)},teardown:function(){var r=this.ownerDocument||this.document||this,a=y.documentMode?this:r,o=sn.get(a,e)-1;o?sn.set(a,e,o):(y.documentMode?this.removeEventListener(e,t):r.removeEventListener(n,t,!0),sn.remove(a,e))}}})),C.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},(function(n,e){C.event.special[n]={delegateType:e,bindType:e,handle:function(n){var t,r=this,a=n.relatedTarget,o=n.handleObj;return a&&(a===r||C.contains(r,a))||(n.type=o.origType,t=o.handler.apply(this,arguments),n.type=e),t}}})),C.fn.extend({on:function(n,e,t,r){return Ln(this,n,e,t,r)},one:function(n,e,t,r){return Ln(this,n,e,t,r,1)},off:function(n,e,t){var r,a;if(n&&n.preventDefault&&n.handleObj)return r=n.handleObj,C(n.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof n){for(a in n)this.off(a,e,n[a]);return this}return!1!==e&&"function"!=typeof e||(t=e,e=void 0),!1===t&&(t=_n),this.each((function(){C.event.remove(this,n,t,e)}))}});var Mn=/<script|<style|<link/i,Rn=/checked\s*(?:[^=]|=\s*.checked.)/i,Nn=/^\s*<!\[CDATA\[|\]\]>\s*$/g;function qn(n,e){return A(n,"table")&&A(11!==e.nodeType?e:e.firstChild,"tr")&&C(n).children("tbody")[0]||n}function Un(n){return n.type=(null!==n.getAttribute("type"))+"/"+n.type,n}function Hn(n){return"true/"===(n.type||"").slice(0,5)?n.type=n.type.slice(5):n.removeAttribute("type"),n}function $n(n,e){var t,r,a,o,i,s;if(1===e.nodeType){if(sn.hasData(n)&&(s=sn.get(n).events))for(a in sn.remove(e,"handle events"),s)for(t=0,r=s[a].length;t<r;t++)C.event.add(e,a,s[a][t]);cn.hasData(n)&&(o=cn.access(n),i=C.extend({},o),cn.set(e,i))}}function Jn(n,e){var t=e.nodeName.toLowerCase();"input"===t&&jn.test(n.type)?e.checked=n.checked:"input"!==t&&"textarea"!==t||(e.defaultValue=n.defaultValue)}function Vn(n,e,t,r){e=c(e);var a,o,i,s,l,p,u=0,d=n.length,m=d-1,h=e[0],g=b(h);if(g||d>1&&"string"==typeof h&&!f.checkClone&&Rn.test(h))return n.each((function(a){var o=n.eq(a);g&&(e[0]=h.call(this,a,o.html())),Vn(o,e,t,r)}));if(d&&(o=(a=Bn(e,n[0].ownerDocument,!1,n,r)).firstChild,1===a.childNodes.length&&(a=o),o||r)){for(s=(i=C.map(Pn(a,"script"),Un)).length;u<d;u++)l=a,u!==m&&(l=C.clone(l,!0,!0),s&&C.merge(i,Pn(l,"script"))),t.call(n[u],l,u);if(s)for(p=i[i.length-1].ownerDocument,C.map(i,Hn),u=0;u<s;u++)l=i[u],Tn.test(l.type||"")&&!sn.access(l,"globalEval")&&C.contains(p,l)&&(l.src&&"module"!==(l.type||"").toLowerCase()?C._evalUrl&&!l.noModule&&C._evalUrl(l.src,{nonce:l.nonce||l.getAttribute("nonce")},p):w(l.textContent.replace(Nn,""),l,p))}return n}function Wn(n,e,t){for(var r,a=e?C.filter(e,n):n,o=0;null!=(r=a[o]);o++)t||1!==r.nodeType||C.cleanData(Pn(r)),r.parentNode&&(t&&fn(r)&&Dn(Pn(r,"script")),r.parentNode.removeChild(r));return n}C.extend({htmlPrefilter:function(n){return n},clone:function(n,e,t){var r,a,o,i,s=n.cloneNode(!0),c=fn(n);if(!(f.noCloneChecked||1!==n.nodeType&&11!==n.nodeType||C.isXMLDoc(n)))for(i=Pn(s),r=0,a=(o=Pn(n)).length;r<a;r++)Jn(o[r],i[r]);if(e)if(t)for(o=o||Pn(n),i=i||Pn(s),r=0,a=o.length;r<a;r++)$n(o[r],i[r]);else $n(n,s);return(i=Pn(s,"script")).length>0&&Dn(i,!c&&Pn(n,"script")),s},cleanData:function(n){for(var e,t,r,a=C.event.special,o=0;void 0!==(t=n[o]);o++)if(an(t)){if(e=t[sn.expando]){if(e.events)for(r in e.events)a[r]?C.event.remove(t,r):C.removeEvent(t,r,e.handle);t[sn.expando]=void 0}t[cn.expando]&&(t[cn.expando]=void 0)}}}),C.fn.extend({detach:function(n){return Wn(this,n,!0)},remove:function(n){return Wn(this,n)},text:function(n){return Y(this,(function(n){return void 0===n?C.text(this):this.empty().each((function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=n)}))}),null,n,arguments.length)},append:function(){return Vn(this,arguments,(function(n){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qn(this,n).appendChild(n)}))},prepend:function(){return Vn(this,arguments,(function(n){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var e=qn(this,n);e.insertBefore(n,e.firstChild)}}))},before:function(){return Vn(this,arguments,(function(n){this.parentNode&&this.parentNode.insertBefore(n,this)}))},after:function(){return Vn(this,arguments,(function(n){this.parentNode&&this.parentNode.insertBefore(n,this.nextSibling)}))},empty:function(){for(var n,e=0;null!=(n=this[e]);e++)1===n.nodeType&&(C.cleanData(Pn(n,!1)),n.textContent="");return this},clone:function(n,e){return n=null!=n&&n,e=null==e?n:e,this.map((function(){return C.clone(this,n,e)}))},html:function(n){return Y(this,(function(n){var e=this[0]||{},t=0,r=this.length;if(void 0===n&&1===e.nodeType)return e.innerHTML;if("string"==typeof n&&!Mn.test(n)&&!En[(An.exec(n)||["",""])[1].toLowerCase()]){n=C.htmlPrefilter(n);try{for(;t<r;t++)1===(e=this[t]||{}).nodeType&&(C.cleanData(Pn(e,!1)),e.innerHTML=n);e=0}catch(n){}}e&&this.empty().append(n)}),null,n,arguments.length)},replaceWith:function(){var n=[];return Vn(this,arguments,(function(e){var t=this.parentNode;C.inArray(this,n)<0&&(C.cleanData(Pn(this)),t&&t.replaceChild(e,this))}),n)}}),C.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},(function(n,e){C.fn[n]=function(n){for(var t,r=[],a=C(n),o=a.length-1,i=0;i<=o;i++)t=i===o?this:this.clone(!0),C(a[i])[e](t),l.apply(r,t.get());return this.pushStack(r)}}));var Qn=new RegExp("^("+dn+")(?!px)[a-z%]+$","i"),Kn=/^--/,Gn=function(n){var e=n.ownerDocument.defaultView;return e&&e.opener||(e=t),e.getComputedStyle(n)},Xn=function(n,e,t){var r,a,o={};for(a in e)o[a]=n.style[a],n.style[a]=e[a];for(a in r=t.call(n),e)n.style[a]=o[a];return r},Zn=new RegExp(hn.join("|"),"i");function Yn(n,e,t){var r,a,o,i,s=Kn.test(e),c=n.style;return(t=t||Gn(n))&&(i=t.getPropertyValue(e)||t[e],s&&i&&(i=i.replace(z,"$1")||void 0),""!==i||fn(n)||(i=C.style(n,e)),!f.pixelBoxStyles()&&Qn.test(i)&&Zn.test(e)&&(r=c.width,a=c.minWidth,o=c.maxWidth,c.minWidth=c.maxWidth=c.width=i,i=t.width,c.width=r,c.minWidth=a,c.maxWidth=o)),void 0!==i?i+"":i}function ne(n,e){return{get:function(){if(!n())return(this.get=e).apply(this,arguments);delete this.get}}}!function(){function n(){if(p){l.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",p.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",gn.appendChild(l).appendChild(p);var n=t.getComputedStyle(p);r="1%"!==n.top,c=12===e(n.marginLeft),p.style.right="60%",i=36===e(n.right),a=36===e(n.width),p.style.position="absolute",o=12===e(p.offsetWidth/3),gn.removeChild(l),p=null}}function e(n){return Math.round(parseFloat(n))}var r,a,o,i,s,c,l=y.createElement("div"),p=y.createElement("div");p.style&&(p.style.backgroundClip="content-box",p.cloneNode(!0).style.backgroundClip="",f.clearCloneStyle="content-box"===p.style.backgroundClip,C.extend(f,{boxSizingReliable:function(){return n(),a},pixelBoxStyles:function(){return n(),i},pixelPosition:function(){return n(),r},reliableMarginLeft:function(){return n(),c},scrollboxSize:function(){return n(),o},reliableTrDimensions:function(){var n,e,r,a;return null==s&&(n=y.createElement("table"),e=y.createElement("tr"),r=y.createElement("div"),n.style.cssText="position:absolute;left:-11111px;border-collapse:separate",e.style.cssText="border:1px solid",e.style.height="1px",r.style.height="9px",r.style.display="block",gn.appendChild(n).appendChild(e).appendChild(r),a=t.getComputedStyle(e),s=parseInt(a.height,10)+parseInt(a.borderTopWidth,10)+parseInt(a.borderBottomWidth,10)===e.offsetHeight,gn.removeChild(n)),s}}))}();var ee=["Webkit","Moz","ms"],te=y.createElement("div").style,re={};function ae(n){var e=C.cssProps[n]||re[n];return e||(n in te?n:re[n]=function(n){for(var e=n[0].toUpperCase()+n.slice(1),t=ee.length;t--;)if((n=ee[t]+e)in te)return n}(n)||n)}var oe=/^(none|table(?!-c[ea]).+)/,ie={position:"absolute",visibility:"hidden",display:"block"},se={letterSpacing:"0",fontWeight:"400"};function ce(n,e,t){var r=mn.exec(e);return r?Math.max(0,r[2]-(t||0))+(r[3]||"px"):e}function le(n,e,t,r,a,o){var i="width"===e?1:0,s=0,c=0,l=0;if(t===(r?"border":"content"))return 0;for(;i<4;i+=2)"margin"===t&&(l+=C.css(n,t+hn[i],!0,a)),r?("content"===t&&(c-=C.css(n,"padding"+hn[i],!0,a)),"margin"!==t&&(c-=C.css(n,"border"+hn[i]+"Width",!0,a))):(c+=C.css(n,"padding"+hn[i],!0,a),"padding"!==t?c+=C.css(n,"border"+hn[i]+"Width",!0,a):s+=C.css(n,"border"+hn[i]+"Width",!0,a));return!r&&o>=0&&(c+=Math.max(0,Math.ceil(n["offset"+e[0].toUpperCase()+e.slice(1)]-o-c-s-.5))||0),c+l}function pe(n,e,t){var r=Gn(n),a=(!f.boxSizingReliable()||t)&&"border-box"===C.css(n,"boxSizing",!1,r),o=a,i=Yn(n,e,r),s="offset"+e[0].toUpperCase()+e.slice(1);if(Qn.test(i)){if(!t)return i;i="auto"}return(!f.boxSizingReliable()&&a||!f.reliableTrDimensions()&&A(n,"tr")||"auto"===i||!parseFloat(i)&&"inline"===C.css(n,"display",!1,r))&&n.getClientRects().length&&(a="border-box"===C.css(n,"boxSizing",!1,r),(o=s in n)&&(i=n[s])),(i=parseFloat(i)||0)+le(n,e,t||(a?"border":"content"),o,r,i)+"px"}function ue(n,e,t,r,a){return new ue.prototype.init(n,e,t,r,a)}C.extend({cssHooks:{opacity:{get:function(n,e){if(e){var t=Yn(n,"opacity");return""===t?"1":t}}}},cssNumber:{animationIterationCount:!0,aspectRatio:!0,borderImageSlice:!0,columnCount:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,scale:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeMiterlimit:!0,strokeOpacity:!0},cssProps:{},style:function(n,e,t,r){if(n&&3!==n.nodeType&&8!==n.nodeType&&n.style){var a,o,i,s=rn(e),c=Kn.test(e),l=n.style;if(c||(e=ae(s)),i=C.cssHooks[e]||C.cssHooks[s],void 0===t)return i&&"get"in i&&void 0!==(a=i.get(n,!1,r))?a:l[e];"string"===(o=typeof t)&&(a=mn.exec(t))&&a[1]&&(t=yn(n,e,a),o="number"),null!=t&&t==t&&("number"!==o||c||(t+=a&&a[3]||(C.cssNumber[s]?"":"px")),f.clearCloneStyle||""!==t||0!==e.indexOf("background")||(l[e]="inherit"),i&&"set"in i&&void 0===(t=i.set(n,t,r))||(c?l.setProperty(e,t):l[e]=t))}},css:function(n,e,t,r){var a,o,i,s=rn(e);return Kn.test(e)||(e=ae(s)),(i=C.cssHooks[e]||C.cssHooks[s])&&"get"in i&&(a=i.get(n,!0,t)),void 0===a&&(a=Yn(n,e,r)),"normal"===a&&e in se&&(a=se[e]),""===t||t?(o=parseFloat(a),!0===t||isFinite(o)?o||0:a):a}}),C.each(["height","width"],(function(n,e){C.cssHooks[e]={get:function(n,t,r){if(t)return!oe.test(C.css(n,"display"))||n.getClientRects().length&&n.getBoundingClientRect().width?pe(n,e,r):Xn(n,ie,(function(){return pe(n,e,r)}))},set:function(n,t,r){var a,o=Gn(n),i=!f.scrollboxSize()&&"absolute"===o.position,s=(i||r)&&"border-box"===C.css(n,"boxSizing",!1,o),c=r?le(n,e,r,s,o):0;return s&&i&&(c-=Math.ceil(n["offset"+e[0].toUpperCase()+e.slice(1)]-parseFloat(o[e])-le(n,e,"border",!1,o)-.5)),c&&(a=mn.exec(t))&&"px"!==(a[3]||"px")&&(n.style[e]=t,t=C.css(n,e)),ce(0,t,c)}}})),C.cssHooks.marginLeft=ne(f.reliableMarginLeft,(function(n,e){if(e)return(parseFloat(Yn(n,"marginLeft"))||n.getBoundingClientRect().left-Xn(n,{marginLeft:0},(function(){return n.getBoundingClientRect().left})))+"px"})),C.each({margin:"",padding:"",border:"Width"},(function(n,e){C.cssHooks[n+e]={expand:function(t){for(var r=0,a={},o="string"==typeof t?t.split(" "):[t];r<4;r++)a[n+hn[r]+e]=o[r]||o[r-2]||o[0];return a}},"margin"!==n&&(C.cssHooks[n+e].set=ce)})),C.fn.extend({css:function(n,e){return Y(this,(function(n,e,t){var r,a,o={},i=0;if(Array.isArray(e)){for(r=Gn(n),a=e.length;i<a;i++)o[e[i]]=C.css(n,e[i],!1,r);return o}return void 0!==t?C.style(n,e,t):C.css(n,e)}),n,e,arguments.length>1)}}),C.Tween=ue,ue.prototype={constructor:ue,init:function(n,e,t,r,a,o){this.elem=n,this.prop=t,this.easing=a||C.easing._default,this.options=e,this.start=this.now=this.cur(),this.end=r,this.unit=o||(C.cssNumber[t]?"":"px")},cur:function(){var n=ue.propHooks[this.prop];return n&&n.get?n.get(this):ue.propHooks._default.get(this)},run:function(n){var e,t=ue.propHooks[this.prop];return this.options.duration?this.pos=e=C.easing[this.easing](n,this.options.duration*n,0,1,this.options.duration):this.pos=e=n,this.now=(this.end-this.start)*e+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),t&&t.set?t.set(this):ue.propHooks._default.set(this),this}},ue.prototype.init.prototype=ue.prototype,ue.propHooks={_default:{get:function(n){var e;return 1!==n.elem.nodeType||null!=n.elem[n.prop]&&null==n.elem.style[n.prop]?n.elem[n.prop]:(e=C.css(n.elem,n.prop,""))&&"auto"!==e?e:0},set:function(n){C.fx.step[n.prop]?C.fx.step[n.prop](n):1!==n.elem.nodeType||!C.cssHooks[n.prop]&&null==n.elem.style[ae(n.prop)]?n.elem[n.prop]=n.now:C.style(n.elem,n.prop,n.now+n.unit)}}},ue.propHooks.scrollTop=ue.propHooks.scrollLeft={set:function(n){n.elem.nodeType&&n.elem.parentNode&&(n.elem[n.prop]=n.now)}},C.easing={linear:function(n){return n},swing:function(n){return.5-Math.cos(n*Math.PI)/2},_default:"swing"},C.fx=ue.prototype.init,C.fx.step={};var de,me,he=/^(?:toggle|show|hide)$/,ge=/queueHooks$/;function fe(){me&&(!1===y.hidden&&t.requestAnimationFrame?t.requestAnimationFrame(fe):t.setTimeout(fe,C.fx.interval),C.fx.tick())}function be(){return t.setTimeout((function(){de=void 0})),de=Date.now()}function ve(n,e){var t,r=0,a={height:n};for(e=e?1:0;r<4;r+=2-e)a["margin"+(t=hn[r])]=a["padding"+t]=n;return e&&(a.opacity=a.width=n),a}function ye(n,e,t){for(var r,a=(xe.tweeners[e]||[]).concat(xe.tweeners["*"]),o=0,i=a.length;o<i;o++)if(r=a[o].call(t,e,n))return r}function xe(n,e,t){var r,a,o=0,i=xe.prefilters.length,s=C.Deferred().always((function(){delete c.elem})),c=function(){if(a)return!1;for(var e=de||be(),t=Math.max(0,l.startTime+l.duration-e),r=1-(t/l.duration||0),o=0,i=l.tweens.length;o<i;o++)l.tweens[o].run(r);return s.notifyWith(n,[l,r,t]),r<1&&i?t:(i||s.notifyWith(n,[l,1,0]),s.resolveWith(n,[l]),!1)},l=s.promise({elem:n,props:C.extend({},e),opts:C.extend(!0,{specialEasing:{},easing:C.easing._default},t),originalProperties:e,originalOptions:t,startTime:de||be(),duration:t.duration,tweens:[],createTween:function(e,t){var r=C.Tween(n,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(r),r},stop:function(e){var t=0,r=e?l.tweens.length:0;if(a)return this;for(a=!0;t<r;t++)l.tweens[t].run(1);return e?(s.notifyWith(n,[l,1,0]),s.resolveWith(n,[l,e])):s.rejectWith(n,[l,e]),this}}),p=l.props;for(!function(n,e){var t,r,a,o,i;for(t in n)if(a=e[r=rn(t)],o=n[t],Array.isArray(o)&&(a=o[1],o=n[t]=o[0]),t!==r&&(n[r]=o,delete n[t]),(i=C.cssHooks[r])&&"expand"in i)for(t in o=i.expand(o),delete n[r],o)t in n||(n[t]=o[t],e[t]=a);else e[r]=a}(p,l.opts.specialEasing);o<i;o++)if(r=xe.prefilters[o].call(l,n,p,l.opts))return b(r.stop)&&(C._queueHooks(l.elem,l.opts.queue).stop=r.stop.bind(r)),r;return C.map(p,ye,l),b(l.opts.start)&&l.opts.start.call(n,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),C.fx.timer(C.extend(c,{elem:n,anim:l,queue:l.opts.queue})),l}C.Animation=C.extend(xe,{tweeners:{"*":[function(n,e){var t=this.createTween(n,e);return yn(t.elem,n,mn.exec(e),t),t}]},tweener:function(n,e){b(n)?(e=n,n=["*"]):n=n.match(V);for(var t,r=0,a=n.length;r<a;r++)t=n[r],xe.tweeners[t]=xe.tweeners[t]||[],xe.tweeners[t].unshift(e)},prefilters:[function(n,e,t){var r,a,o,i,s,c,l,p,u="width"in e||"height"in e,d=this,m={},h=n.style,g=n.nodeType&&vn(n),f=sn.get(n,"fxshow");for(r in t.queue||(null==(i=C._queueHooks(n,"fx")).unqueued&&(i.unqueued=0,s=i.empty.fire,i.empty.fire=function(){i.unqueued||s()}),i.unqueued++,d.always((function(){d.always((function(){i.unqueued--,C.queue(n,"fx").length||i.empty.fire()}))}))),e)if(a=e[r],he.test(a)){if(delete e[r],o=o||"toggle"===a,a===(g?"hide":"show")){if("show"!==a||!f||void 0===f[r])continue;g=!0}m[r]=f&&f[r]||C.style(n,r)}if((c=!C.isEmptyObject(e))||!C.isEmptyObject(m))for(r in u&&1===n.nodeType&&(t.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=f&&f.display)&&(l=sn.get(n,"display")),"none"===(p=C.css(n,"display"))&&(l?p=l:(kn([n],!0),l=n.style.display||l,p=C.css(n,"display"),kn([n]))),("inline"===p||"inline-block"===p&&null!=l)&&"none"===C.css(n,"float")&&(c||(d.done((function(){h.display=l})),null==l&&(p=h.display,l="none"===p?"":p)),h.display="inline-block")),t.overflow&&(h.overflow="hidden",d.always((function(){h.overflow=t.overflow[0],h.overflowX=t.overflow[1],h.overflowY=t.overflow[2]}))),c=!1,m)c||(f?"hidden"in f&&(g=f.hidden):f=sn.access(n,"fxshow",{display:l}),o&&(f.hidden=!g),g&&kn([n],!0),d.done((function(){for(r in g||kn([n]),sn.remove(n,"fxshow"),m)C.style(n,r,m[r])}))),c=ye(g?f[r]:0,r,d),r in f||(f[r]=c.start,g&&(c.end=c.start,c.start=0))}],prefilter:function(n,e){e?xe.prefilters.unshift(n):xe.prefilters.push(n)}}),C.speed=function(n,e,t){var r=n&&"object"==typeof n?C.extend({},n):{complete:t||!t&&e||b(n)&&n,duration:n,easing:t&&e||e&&!b(e)&&e};return C.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in C.fx.speeds?r.duration=C.fx.speeds[r.duration]:r.duration=C.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){b(r.old)&&r.old.call(this),r.queue&&C.dequeue(this,r.queue)},r},C.fn.extend({fadeTo:function(n,e,t,r){return this.filter(vn).css("opacity",0).show().end().animate({opacity:e},n,t,r)},animate:function(n,e,t,r){var a=C.isEmptyObject(n),o=C.speed(e,t,r),i=function(){var e=xe(this,C.extend({},n),o);(a||sn.get(this,"finish"))&&e.stop(!0)};return i.finish=i,a||!1===o.queue?this.each(i):this.queue(o.queue,i)},stop:function(n,e,t){var r=function(n){var e=n.stop;delete n.stop,e(t)};return"string"!=typeof n&&(t=e,e=n,n=void 0),e&&this.queue(n||"fx",[]),this.each((function(){var e=!0,a=null!=n&&n+"queueHooks",o=C.timers,i=sn.get(this);if(a)i[a]&&i[a].stop&&r(i[a]);else for(a in i)i[a]&&i[a].stop&&ge.test(a)&&r(i[a]);for(a=o.length;a--;)o[a].elem!==this||null!=n&&o[a].queue!==n||(o[a].anim.stop(t),e=!1,o.splice(a,1));!e&&t||C.dequeue(this,n)}))},finish:function(n){return!1!==n&&(n=n||"fx"),this.each((function(){var e,t=sn.get(this),r=t[n+"queue"],a=t[n+"queueHooks"],o=C.timers,i=r?r.length:0;for(t.finish=!0,C.queue(this,n,[]),a&&a.stop&&a.stop.call(this,!0),e=o.length;e--;)o[e].elem===this&&o[e].queue===n&&(o[e].anim.stop(!0),o.splice(e,1));for(e=0;e<i;e++)r[e]&&r[e].finish&&r[e].finish.call(this);delete t.finish}))}}),C.each(["toggle","show","hide"],(function(n,e){var t=C.fn[e];C.fn[e]=function(n,r,a){return null==n||"boolean"==typeof n?t.apply(this,arguments):this.animate(ve(e,!0),n,r,a)}})),C.each({slideDown:ve("show"),slideUp:ve("hide"),slideToggle:ve("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},(function(n,e){C.fn[n]=function(n,t,r){return this.animate(e,n,t,r)}})),C.timers=[],C.fx.tick=function(){var n,e=0,t=C.timers;for(de=Date.now();e<t.length;e++)(n=t[e])()||t[e]!==n||t.splice(e--,1);t.length||C.fx.stop(),de=void 0},C.fx.timer=function(n){C.timers.push(n),C.fx.start()},C.fx.interval=13,C.fx.start=function(){me||(me=!0,fe())},C.fx.stop=function(){me=null},C.fx.speeds={slow:600,fast:200,_default:400},C.fn.delay=function(n,e){return n=C.fx&&C.fx.speeds[n]||n,e=e||"fx",this.queue(e,(function(e,r){var a=t.setTimeout(e,n);r.stop=function(){t.clearTimeout(a)}}))},function(){var n=y.createElement("input"),e=y.createElement("select").appendChild(y.createElement("option"));n.type="checkbox",f.checkOn=""!==n.value,f.optSelected=e.selected,(n=y.createElement("input")).value="t",n.type="radio",f.radioValue="t"===n.value}();var we,ke=C.expr.attrHandle;C.fn.extend({attr:function(n,e){return Y(this,C.attr,n,e,arguments.length>1)},removeAttr:function(n){return this.each((function(){C.removeAttr(this,n)}))}}),C.extend({attr:function(n,e,t){var r,a,o=n.nodeType;if(3!==o&&8!==o&&2!==o)return void 0===n.getAttribute?C.prop(n,e,t):(1===o&&C.isXMLDoc(n)||(a=C.attrHooks[e.toLowerCase()]||(C.expr.match.bool.test(e)?we:void 0)),void 0!==t?null===t?void C.removeAttr(n,e):a&&"set"in a&&void 0!==(r=a.set(n,t,e))?r:(n.setAttribute(e,t+""),t):a&&"get"in a&&null!==(r=a.get(n,e))?r:null==(r=C.find.attr(n,e))?void 0:r)},attrHooks:{type:{set:function(n,e){if(!f.radioValue&&"radio"===e&&A(n,"input")){var t=n.value;return n.setAttribute("type",e),t&&(n.value=t),e}}}},removeAttr:function(n,e){var t,r=0,a=e&&e.match(V);if(a&&1===n.nodeType)for(;t=a[r++];)n.removeAttribute(t)}}),we={set:function(n,e,t){return!1===e?C.removeAttr(n,t):n.setAttribute(t,t),t}},C.each(C.expr.match.bool.source.match(/\w+/g),(function(n,e){var t=ke[e]||C.find.attr;ke[e]=function(n,e,r){var a,o,i=e.toLowerCase();return r||(o=ke[i],ke[i]=a,a=null!=t(n,e,r)?i:null,ke[i]=o),a}}));var Se=/^(?:input|select|textarea|button)$/i,Ce=/^(?:a|area)$/i;function je(n){return(n.match(V)||[]).join(" ")}function Ae(n){return n.getAttribute&&n.getAttribute("class")||""}function Te(n){return Array.isArray(n)?n:"string"==typeof n&&n.match(V)||[]}C.fn.extend({prop:function(n,e){return Y(this,C.prop,n,e,arguments.length>1)},removeProp:function(n){return this.each((function(){delete this[C.propFix[n]||n]}))}}),C.extend({prop:function(n,e,t){var r,a,o=n.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&C.isXMLDoc(n)||(e=C.propFix[e]||e,a=C.propHooks[e]),void 0!==t?a&&"set"in a&&void 0!==(r=a.set(n,t,e))?r:n[e]=t:a&&"get"in a&&null!==(r=a.get(n,e))?r:n[e]},propHooks:{tabIndex:{get:function(n){var e=C.find.attr(n,"tabindex");return e?parseInt(e,10):Se.test(n.nodeName)||Ce.test(n.nodeName)&&n.href?0:-1}}},propFix:{for:"htmlFor",class:"className"}}),f.optSelected||(C.propHooks.selected={get:function(n){var e=n.parentNode;return e&&e.parentNode&&e.parentNode.selectedIndex,null},set:function(n){var e=n.parentNode;e&&(e.selectedIndex,e.parentNode&&e.parentNode.selectedIndex)}}),C.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],(function(){C.propFix[this.toLowerCase()]=this})),C.fn.extend({addClass:function(n){var e,t,r,a,o,i;return b(n)?this.each((function(e){C(this).addClass(n.call(this,e,Ae(this)))})):(e=Te(n)).length?this.each((function(){if(r=Ae(this),t=1===this.nodeType&&" "+je(r)+" "){for(o=0;o<e.length;o++)a=e[o],t.indexOf(" "+a+" ")<0&&(t+=a+" ");i=je(t),r!==i&&this.setAttribute("class",i)}})):this},removeClass:function(n){var e,t,r,a,o,i;return b(n)?this.each((function(e){C(this).removeClass(n.call(this,e,Ae(this)))})):arguments.length?(e=Te(n)).length?this.each((function(){if(r=Ae(this),t=1===this.nodeType&&" "+je(r)+" "){for(o=0;o<e.length;o++)for(a=e[o];t.indexOf(" "+a+" ")>-1;)t=t.replace(" "+a+" "," ");i=je(t),r!==i&&this.setAttribute("class",i)}})):this:this.attr("class","")},toggleClass:function(n,e){var t,r,a,o,i=typeof n,s="string"===i||Array.isArray(n);return b(n)?this.each((function(t){C(this).toggleClass(n.call(this,t,Ae(this),e),e)})):"boolean"==typeof e&&s?e?this.addClass(n):this.removeClass(n):(t=Te(n),this.each((function(){if(s)for(o=C(this),a=0;a<t.length;a++)r=t[a],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==n&&"boolean"!==i||((r=Ae(this))&&sn.set(this,"__className__",r),this.setAttribute&&this.setAttribute("class",r||!1===n?"":sn.get(this,"__className__")||""))})))},hasClass:function(n){var e,t,r=0;for(e=" "+n+" ";t=this[r++];)if(1===t.nodeType&&(" "+je(Ae(t))+" ").indexOf(e)>-1)return!0;return!1}});var Ee=/\r/g;C.fn.extend({val:function(n){var e,t,r,a=this[0];return arguments.length?(r=b(n),this.each((function(t){var a;1===this.nodeType&&(null==(a=r?n.call(this,t,C(this).val()):n)?a="":"number"==typeof a?a+="":Array.isArray(a)&&(a=C.map(a,(function(n){return null==n?"":n+""}))),(e=C.valHooks[this.type]||C.valHooks[this.nodeName.toLowerCase()])&&"set"in e&&void 0!==e.set(this,a,"value")||(this.value=a))}))):a?(e=C.valHooks[a.type]||C.valHooks[a.nodeName.toLowerCase()])&&"get"in e&&void 0!==(t=e.get(a,"value"))?t:"string"==typeof(t=a.value)?t.replace(Ee,""):null==t?"":t:void 0}}),C.extend({valHooks:{option:{get:function(n){var e=C.find.attr(n,"value");return null!=e?e:je(C.text(n))}},select:{get:function(n){var e,t,r,a=n.options,o=n.selectedIndex,i="select-one"===n.type,s=i?null:[],c=i?o+1:a.length;for(r=o<0?c:i?o:0;r<c;r++)if(((t=a[r]).selected||r===o)&&!t.disabled&&(!t.parentNode.disabled||!A(t.parentNode,"optgroup"))){if(e=C(t).val(),i)return e;s.push(e)}return s},set:function(n,e){for(var t,r,a=n.options,o=C.makeArray(e),i=a.length;i--;)((r=a[i]).selected=C.inArray(C.valHooks.option.get(r),o)>-1)&&(t=!0);return t||(n.selectedIndex=-1),o}}}}),C.each(["radio","checkbox"],(function(){C.valHooks[this]={set:function(n,e){if(Array.isArray(e))return n.checked=C.inArray(C(n).val(),e)>-1}},f.checkOn||(C.valHooks[this].get=function(n){return null===n.getAttribute("value")?"on":n.value})}));var Pe=t.location,De={guid:Date.now()},ze=/\?/;C.parseXML=function(n){var e,r;if(!n||"string"!=typeof n)return null;try{e=(new t.DOMParser).parseFromString(n,"text/xml")}catch(n){}return r=e&&e.getElementsByTagName("parsererror")[0],e&&!r||C.error("Invalid XML: "+(r?C.map(r.childNodes,(function(n){return n.textContent})).join("\n"):n)),e};var Be=/^(?:focusinfocus|focusoutblur)$/,Ie=function(n){n.stopPropagation()};C.extend(C.event,{trigger:function(n,e,r,a){var o,i,s,c,l,p,u,d,h=[r||y],g=m.call(n,"type")?n.type:n,f=m.call(n,"namespace")?n.namespace.split("."):[];if(i=d=s=r=r||y,3!==r.nodeType&&8!==r.nodeType&&!Be.test(g+C.event.triggered)&&(g.indexOf(".")>-1&&(f=g.split("."),g=f.shift(),f.sort()),l=g.indexOf(":")<0&&"on"+g,(n=n[C.expando]?n:new C.Event(g,"object"==typeof n&&n)).isTrigger=a?2:3,n.namespace=f.join("."),n.rnamespace=n.namespace?new RegExp("(^|\\.)"+f.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=void 0,n.target||(n.target=r),e=null==e?[n]:C.makeArray(e,[n]),u=C.event.special[g]||{},a||!u.trigger||!1!==u.trigger.apply(r,e))){if(!a&&!u.noBubble&&!v(r)){for(c=u.delegateType||g,Be.test(c+g)||(i=i.parentNode);i;i=i.parentNode)h.push(i),s=i;s===(r.ownerDocument||y)&&h.push(s.defaultView||s.parentWindow||t)}for(o=0;(i=h[o++])&&!n.isPropagationStopped();)d=i,n.type=o>1?c:u.bindType||g,(p=(sn.get(i,"events")||Object.create(null))[n.type]&&sn.get(i,"handle"))&&p.apply(i,e),(p=l&&i[l])&&p.apply&&an(i)&&(n.result=p.apply(i,e),!1===n.result&&n.preventDefault());return n.type=g,a||n.isDefaultPrevented()||u._default&&!1!==u._default.apply(h.pop(),e)||!an(r)||l&&b(r[g])&&!v(r)&&((s=r[l])&&(r[l]=null),C.event.triggered=g,n.isPropagationStopped()&&d.addEventListener(g,Ie),r[g](),n.isPropagationStopped()&&d.removeEventListener(g,Ie),C.event.triggered=void 0,s&&(r[l]=s)),n.result}},simulate:function(n,e,t){var r=C.extend(new C.Event,t,{type:n,isSimulated:!0});C.event.trigger(r,null,e)}}),C.fn.extend({trigger:function(n,e){return this.each((function(){C.event.trigger(n,e,this)}))},triggerHandler:function(n,e){var t=this[0];if(t)return C.event.trigger(n,e,t,!0)}});var Oe=/\[\]$/,_e=/\r?\n/g,Le=/^(?:submit|button|image|reset|file)$/i,Fe=/^(?:input|select|textarea|keygen)/i;function Me(n,e,t,r){var a;if(Array.isArray(e))C.each(e,(function(e,a){t||Oe.test(n)?r(n,a):Me(n+"["+("object"==typeof a&&null!=a?e:"")+"]",a,t,r)}));else if(t||"object"!==k(e))r(n,e);else for(a in e)Me(n+"["+a+"]",e[a],t,r)}C.param=function(n,e){var t,r=[],a=function(n,e){var t=b(e)?e():e;r[r.length]=encodeURIComponent(n)+"="+encodeURIComponent(null==t?"":t)};if(null==n)return"";if(Array.isArray(n)||n.jquery&&!C.isPlainObject(n))C.each(n,(function(){a(this.name,this.value)}));else for(t in n)Me(t,n[t],e,a);return r.join("&")},C.fn.extend({serialize:function(){return C.param(this.serializeArray())},serializeArray:function(){return this.map((function(){var n=C.prop(this,"elements");return n?C.makeArray(n):this})).filter((function(){var n=this.type;return this.name&&!C(this).is(":disabled")&&Fe.test(this.nodeName)&&!Le.test(n)&&(this.checked||!jn.test(n))})).map((function(n,e){var t=C(this).val();return null==t?null:Array.isArray(t)?C.map(t,(function(n){return{name:e.name,value:n.replace(_e,"\r\n")}})):{name:e.name,value:t.replace(_e,"\r\n")}})).get()}});var Re=/%20/g,Ne=/#.*$/,qe=/([?&])_=[^&]*/,Ue=/^(.*?):[ \t]*([^\r\n]*)$/gm,He=/^(?:GET|HEAD)$/,$e=/^\/\//,Je={},Ve={},We="*/".concat("*"),Qe=y.createElement("a");function Ke(n){return function(e,t){"string"!=typeof e&&(t=e,e="*");var r,a=0,o=e.toLowerCase().match(V)||[];if(b(t))for(;r=o[a++];)"+"===r[0]?(r=r.slice(1)||"*",(n[r]=n[r]||[]).unshift(t)):(n[r]=n[r]||[]).push(t)}}function Ge(n,e,t,r){var a={},o=n===Ve;function i(s){var c;return a[s]=!0,C.each(n[s]||[],(function(n,s){var l=s(e,t,r);return"string"!=typeof l||o||a[l]?o?!(c=l):void 0:(e.dataTypes.unshift(l),i(l),!1)})),c}return i(e.dataTypes[0])||!a["*"]&&i("*")}function Xe(n,e){var t,r,a=C.ajaxSettings.flatOptions||{};for(t in e)void 0!==e[t]&&((a[t]?n:r||(r={}))[t]=e[t]);return r&&C.extend(!0,n,r),n}Qe.href=Pe.href,C.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Pe.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Pe.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":We,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":C.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(n,e){return e?Xe(Xe(n,C.ajaxSettings),e):Xe(C.ajaxSettings,n)},ajaxPrefilter:Ke(Je),ajaxTransport:Ke(Ve),ajax:function(n,e){"object"==typeof n&&(e=n,n=void 0),e=e||{};var r,a,o,i,s,c,l,p,u,d,m=C.ajaxSetup({},e),h=m.context||m,g=m.context&&(h.nodeType||h.jquery)?C(h):C.event,f=C.Deferred(),b=C.Callbacks("once memory"),v=m.statusCode||{},x={},w={},k="canceled",S={readyState:0,getResponseHeader:function(n){var e;if(l){if(!i)for(i={};e=Ue.exec(o);)i[e[1].toLowerCase()+" "]=(i[e[1].toLowerCase()+" "]||[]).concat(e[2]);e=i[n.toLowerCase()+" "]}return null==e?null:e.join(", ")},getAllResponseHeaders:function(){return l?o:null},setRequestHeader:function(n,e){return null==l&&(n=w[n.toLowerCase()]=w[n.toLowerCase()]||n,x[n]=e),this},overrideMimeType:function(n){return null==l&&(m.mimeType=n),this},statusCode:function(n){var e;if(n)if(l)S.always(n[S.status]);else for(e in n)v[e]=[v[e],n[e]];return this},abort:function(n){var e=n||k;return r&&r.abort(e),j(0,e),this}};if(f.promise(S),m.url=((n||m.url||Pe.href)+"").replace($e,Pe.protocol+"//"),m.type=e.method||e.type||m.method||m.type,m.dataTypes=(m.dataType||"*").toLowerCase().match(V)||[""],null==m.crossDomain){c=y.createElement("a");try{c.href=m.url,c.href=c.href,m.crossDomain=Qe.protocol+"//"+Qe.host!=c.protocol+"//"+c.host}catch(n){m.crossDomain=!0}}if(m.data&&m.processData&&"string"!=typeof m.data&&(m.data=C.param(m.data,m.traditional)),Ge(Je,m,e,S),l)return S;for(u in(p=C.event&&m.global)&&0==C.active++&&C.event.trigger("ajaxStart"),m.type=m.type.toUpperCase(),m.hasContent=!He.test(m.type),a=m.url.replace(Ne,""),m.hasContent?m.data&&m.processData&&0===(m.contentType||"").indexOf("application/x-www-form-urlencoded")&&(m.data=m.data.replace(Re,"+")):(d=m.url.slice(a.length),m.data&&(m.processData||"string"==typeof m.data)&&(a+=(ze.test(a)?"&":"?")+m.data,delete m.data),!1===m.cache&&(a=a.replace(qe,"$1"),d=(ze.test(a)?"&":"?")+"_="+De.guid+++d),m.url=a+d),m.ifModified&&(C.lastModified[a]&&S.setRequestHeader("If-Modified-Since",C.lastModified[a]),C.etag[a]&&S.setRequestHeader("If-None-Match",C.etag[a])),(m.data&&m.hasContent&&!1!==m.contentType||e.contentType)&&S.setRequestHeader("Content-Type",m.contentType),S.setRequestHeader("Accept",m.dataTypes[0]&&m.accepts[m.dataTypes[0]]?m.accepts[m.dataTypes[0]]+("*"!==m.dataTypes[0]?", "+We+"; q=0.01":""):m.accepts["*"]),m.headers)S.setRequestHeader(u,m.headers[u]);if(m.beforeSend&&(!1===m.beforeSend.call(h,S,m)||l))return S.abort();if(k="abort",b.add(m.complete),S.done(m.success),S.fail(m.error),r=Ge(Ve,m,e,S)){if(S.readyState=1,p&&g.trigger("ajaxSend",[S,m]),l)return S;m.async&&m.timeout>0&&(s=t.setTimeout((function(){S.abort("timeout")}),m.timeout));try{l=!1,r.send(x,j)}catch(n){if(l)throw n;j(-1,n)}}else j(-1,"No Transport");function j(n,e,i,c){var u,d,y,x,w,k=e;l||(l=!0,s&&t.clearTimeout(s),r=void 0,o=c||"",S.readyState=n>0?4:0,u=n>=200&&n<300||304===n,i&&(x=function(n,e,t){for(var r,a,o,i,s=n.contents,c=n.dataTypes;"*"===c[0];)c.shift(),void 0===r&&(r=n.mimeType||e.getResponseHeader("Content-Type"));if(r)for(a in s)if(s[a]&&s[a].test(r)){c.unshift(a);break}if(c[0]in t)o=c[0];else{for(a in t){if(!c[0]||n.converters[a+" "+c[0]]){o=a;break}i||(i=a)}o=o||i}if(o)return o!==c[0]&&c.unshift(o),t[o]}(m,S,i)),!u&&C.inArray("script",m.dataTypes)>-1&&C.inArray("json",m.dataTypes)<0&&(m.converters["text script"]=function(){}),x=function(n,e,t,r){var a,o,i,s,c,l={},p=n.dataTypes.slice();if(p[1])for(i in n.converters)l[i.toLowerCase()]=n.converters[i];for(o=p.shift();o;)if(n.responseFields[o]&&(t[n.responseFields[o]]=e),!c&&r&&n.dataFilter&&(e=n.dataFilter(e,n.dataType)),c=o,o=p.shift())if("*"===o)o=c;else if("*"!==c&&c!==o){if(!(i=l[c+" "+o]||l["* "+o]))for(a in l)if((s=a.split(" "))[1]===o&&(i=l[c+" "+s[0]]||l["* "+s[0]])){!0===i?i=l[a]:!0!==l[a]&&(o=s[0],p.unshift(s[1]));break}if(!0!==i)if(i&&n.throws)e=i(e);else try{e=i(e)}catch(n){return{state:"parsererror",error:i?n:"No conversion from "+c+" to "+o}}}return{state:"success",data:e}}(m,x,S,u),u?(m.ifModified&&((w=S.getResponseHeader("Last-Modified"))&&(C.lastModified[a]=w),(w=S.getResponseHeader("etag"))&&(C.etag[a]=w)),204===n||"HEAD"===m.type?k="nocontent":304===n?k="notmodified":(k=x.state,d=x.data,u=!(y=x.error))):(y=k,!n&&k||(k="error",n<0&&(n=0))),S.status=n,S.statusText=(e||k)+"",u?f.resolveWith(h,[d,k,S]):f.rejectWith(h,[S,k,y]),S.statusCode(v),v=void 0,p&&g.trigger(u?"ajaxSuccess":"ajaxError",[S,m,u?d:y]),b.fireWith(h,[S,k]),p&&(g.trigger("ajaxComplete",[S,m]),--C.active||C.event.trigger("ajaxStop")))}return S},getJSON:function(n,e,t){return C.get(n,e,t,"json")},getScript:function(n,e){return C.get(n,void 0,e,"script")}}),C.each(["get","post"],(function(n,e){C[e]=function(n,t,r,a){return b(t)&&(a=a||r,r=t,t=void 0),C.ajax(C.extend({url:n,type:e,dataType:a,data:t,success:r},C.isPlainObject(n)&&n))}})),C.ajaxPrefilter((function(n){var e;for(e in n.headers)"content-type"===e.toLowerCase()&&(n.contentType=n.headers[e]||"")})),C._evalUrl=function(n,e,t){return C.ajax({url:n,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(n){C.globalEval(n,e,t)}})},C.fn.extend({wrapAll:function(n){var e;return this[0]&&(b(n)&&(n=n.call(this[0])),e=C(n,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&e.insertBefore(this[0]),e.map((function(){for(var n=this;n.firstElementChild;)n=n.firstElementChild;return n})).append(this)),this},wrapInner:function(n){return b(n)?this.each((function(e){C(this).wrapInner(n.call(this,e))})):this.each((function(){var e=C(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)}))},wrap:function(n){var e=b(n);return this.each((function(t){C(this).wrapAll(e?n.call(this,t):n)}))},unwrap:function(n){return this.parent(n).not("body").each((function(){C(this).replaceWith(this.childNodes)})),this}}),C.expr.pseudos.hidden=function(n){return!C.expr.pseudos.visible(n)},C.expr.pseudos.visible=function(n){return!!(n.offsetWidth||n.offsetHeight||n.getClientRects().length)},C.ajaxSettings.xhr=function(){try{return new t.XMLHttpRequest}catch(n){}};var Ze={0:200,1223:204},Ye=C.ajaxSettings.xhr();f.cors=!!Ye&&"withCredentials"in Ye,f.ajax=Ye=!!Ye,C.ajaxTransport((function(n){var e,r;if(f.cors||Ye&&!n.crossDomain)return{send:function(a,o){var i,s=n.xhr();if(s.open(n.type,n.url,n.async,n.username,n.password),n.xhrFields)for(i in n.xhrFields)s[i]=n.xhrFields[i];for(i in n.mimeType&&s.overrideMimeType&&s.overrideMimeType(n.mimeType),n.crossDomain||a["X-Requested-With"]||(a["X-Requested-With"]="XMLHttpRequest"),a)s.setRequestHeader(i,a[i]);e=function(n){return function(){e&&(e=r=s.onload=s.onerror=s.onabort=s.ontimeout=s.onreadystatechange=null,"abort"===n?s.abort():"error"===n?"number"!=typeof s.status?o(0,"error"):o(s.status,s.statusText):o(Ze[s.status]||s.status,s.statusText,"text"!==(s.responseType||"text")||"string"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=e(),r=s.onerror=s.ontimeout=e("error"),void 0!==s.onabort?s.onabort=r:s.onreadystatechange=function(){4===s.readyState&&t.setTimeout((function(){e&&r()}))},e=e("abort");try{s.send(n.hasContent&&n.data||null)}catch(n){if(e)throw n}},abort:function(){e&&e()}}})),C.ajaxPrefilter((function(n){n.crossDomain&&(n.contents.script=!1)})),C.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(n){return C.globalEval(n),n}}}),C.ajaxPrefilter("script",(function(n){void 0===n.cache&&(n.cache=!1),n.crossDomain&&(n.type="GET")})),C.ajaxTransport("script",(function(n){var e,t;if(n.crossDomain||n.scriptAttrs)return{send:function(r,a){e=C("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",t=function(n){e.remove(),t=null,n&&a("error"===n.type?404:200,n.type)}),y.head.appendChild(e[0])},abort:function(){t&&t()}}}));var nt,et=[],tt=/(=)\?(?=&|$)|\?\?/;C.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var n=et.pop()||C.expando+"_"+De.guid++;return this[n]=!0,n}}),C.ajaxPrefilter("json jsonp",(function(n,e,r){var a,o,i,s=!1!==n.jsonp&&(tt.test(n.url)?"url":"string"==typeof n.data&&0===(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&tt.test(n.data)&&"data");if(s||"jsonp"===n.dataTypes[0])return a=n.jsonpCallback=b(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,s?n[s]=n[s].replace(tt,"$1"+a):!1!==n.jsonp&&(n.url+=(ze.test(n.url)?"&":"?")+n.jsonp+"="+a),n.converters["script json"]=function(){return i||C.error(a+" was not called"),i[0]},n.dataTypes[0]="json",o=t[a],t[a]=function(){i=arguments},r.always((function(){void 0===o?C(t).removeProp(a):t[a]=o,n[a]&&(n.jsonpCallback=e.jsonpCallback,et.push(a)),i&&b(o)&&o(i[0]),i=o=void 0})),"script"})),f.createHTMLDocument=((nt=y.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===nt.childNodes.length),C.parseHTML=function(n,e,t){return"string"!=typeof n?[]:("boolean"==typeof e&&(t=e,e=!1),e||(f.createHTMLDocument?((r=(e=y.implementation.createHTMLDocument("")).createElement("base")).href=y.location.href,e.head.appendChild(r)):e=y),o=!t&&[],(a=R.exec(n))?[e.createElement(a[1])]:(a=Bn([n],e,o),o&&o.length&&C(o).remove(),C.merge([],a.childNodes)));var r,a,o},C.fn.load=function(n,e,t){var r,a,o,i=this,s=n.indexOf(" ");return s>-1&&(r=je(n.slice(s)),n=n.slice(0,s)),b(e)?(t=e,e=void 0):e&&"object"==typeof e&&(a="POST"),i.length>0&&C.ajax({url:n,type:a||"GET",dataType:"html",data:e}).done((function(n){o=arguments,i.html(r?C("<div>").append(C.parseHTML(n)).find(r):n)})).always(t&&function(n,e){i.each((function(){t.apply(this,o||[n.responseText,e,n])}))}),this},C.expr.pseudos.animated=function(n){return C.grep(C.timers,(function(e){return n===e.elem})).length},C.offset={setOffset:function(n,e,t){var r,a,o,i,s,c,l=C.css(n,"position"),p=C(n),u={};"static"===l&&(n.style.position="relative"),s=p.offset(),o=C.css(n,"top"),c=C.css(n,"left"),("absolute"===l||"fixed"===l)&&(o+c).indexOf("auto")>-1?(i=(r=p.position()).top,a=r.left):(i=parseFloat(o)||0,a=parseFloat(c)||0),b(e)&&(e=e.call(n,t,C.extend({},s))),null!=e.top&&(u.top=e.top-s.top+i),null!=e.left&&(u.left=e.left-s.left+a),"using"in e?e.using.call(n,u):p.css(u)}},C.fn.extend({offset:function(n){if(arguments.length)return void 0===n?this:this.each((function(e){C.offset.setOffset(this,n,e)}));var e,t,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),t=r.ownerDocument.defaultView,{top:e.top+t.pageYOffset,left:e.left+t.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var n,e,t,r=this[0],a={top:0,left:0};if("fixed"===C.css(r,"position"))e=r.getBoundingClientRect();else{for(e=this.offset(),t=r.ownerDocument,n=r.offsetParent||t.documentElement;n&&(n===t.body||n===t.documentElement)&&"static"===C.css(n,"position");)n=n.parentNode;n&&n!==r&&1===n.nodeType&&((a=C(n).offset()).top+=C.css(n,"borderTopWidth",!0),a.left+=C.css(n,"borderLeftWidth",!0))}return{top:e.top-a.top-C.css(r,"marginTop",!0),left:e.left-a.left-C.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map((function(){for(var n=this.offsetParent;n&&"static"===C.css(n,"position");)n=n.offsetParent;return n||gn}))}}),C.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},(function(n,e){var t="pageYOffset"===e;C.fn[n]=function(r){return Y(this,(function(n,r,a){var o;if(v(n)?o=n:9===n.nodeType&&(o=n.defaultView),void 0===a)return o?o[e]:n[r];o?o.scrollTo(t?o.pageXOffset:a,t?a:o.pageYOffset):n[r]=a}),n,r,arguments.length)}})),C.each(["top","left"],(function(n,e){C.cssHooks[e]=ne(f.pixelPosition,(function(n,t){if(t)return t=Yn(n,e),Qn.test(t)?C(n).position()[e]+"px":t}))})),C.each({Height:"height",Width:"width"},(function(n,e){C.each({padding:"inner"+n,content:e,"":"outer"+n},(function(t,r){C.fn[r]=function(a,o){var i=arguments.length&&(t||"boolean"!=typeof a),s=t||(!0===a||!0===o?"margin":"border");return Y(this,(function(e,t,a){var o;return v(e)?0===r.indexOf("outer")?e["inner"+n]:e.document.documentElement["client"+n]:9===e.nodeType?(o=e.documentElement,Math.max(e.body["scroll"+n],o["scroll"+n],e.body["offset"+n],o["offset"+n],o["client"+n])):void 0===a?C.css(e,t,s):C.style(e,t,a,s)}),e,i?a:void 0,i)}}))})),C.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],(function(n,e){C.fn[e]=function(n){return this.on(e,n)}})),C.fn.extend({bind:function(n,e,t){return this.on(n,null,e,t)},unbind:function(n,e){return this.off(n,null,e)},delegate:function(n,e,t,r){return this.on(e,n,t,r)},undelegate:function(n,e,t){return 1===arguments.length?this.off(n,"**"):this.off(e,n||"**",t)},hover:function(n,e){return this.mouseenter(n).mouseleave(e||n)}}),C.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),(function(n,e){C.fn[e]=function(n,t){return arguments.length>0?this.on(e,null,n,t):this.trigger(e)}}));var rt=/^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;C.proxy=function(n,e){var t,r,a;if("string"==typeof e&&(t=n[e],e=n,n=t),b(n))return r=s.call(arguments,2),(a=function(){return n.apply(e||this,r.concat(s.call(arguments)))}).guid=n.guid=n.guid||C.guid++,a},C.holdReady=function(n){n?C.readyWait++:C.ready(!0)},C.isArray=Array.isArray,C.parseJSON=JSON.parse,C.nodeName=A,C.isFunction=b,C.isWindow=v,C.camelCase=rn,C.type=k,C.now=Date.now,C.isNumeric=function(n){var e=C.type(n);return("number"===e||"string"===e)&&!isNaN(n-parseFloat(n))},C.trim=function(n){return null==n?"":(n+"").replace(rt,"$1")},void 0===(r=function(){return C}.apply(e,[]))||(n.exports=r);var at=t.jQuery,ot=t.$;return C.noConflict=function(n){return t.$===C&&(t.$=ot),n&&t.jQuery===C&&(t.jQuery=at),C},void 0===a&&(t.jQuery=t.$=C),C}))},function(n,e,t){n.exports=t(315)},function(n,e,t){"use strict";var r=t(116),a=Object.prototype.toString;function o(n){return Array.isArray(n)}function i(n){return void 0===n}function s(n){return"[object ArrayBuffer]"===a.call(n)}function c(n){return null!==n&&"object"==typeof n}function l(n){if("[object Object]"!==a.call(n))return!1;var e=Object.getPrototypeOf(n);return null===e||e===Object.prototype}function p(n){return"[object Function]"===a.call(n)}function u(n,e){if(null!=n)if("object"!=typeof n&&(n=[n]),o(n))for(var t=0,r=n.length;t<r;t++)e.call(null,n[t],t,n);else for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&e.call(null,n[a],a,n)}n.exports={isArray:o,isArrayBuffer:s,isBuffer:function(n){return null!==n&&!i(n)&&null!==n.constructor&&!i(n.constructor)&&"function"==typeof n.constructor.isBuffer&&n.constructor.isBuffer(n)},isFormData:function(n){return"[object FormData]"===a.call(n)},isArrayBufferView:function(n){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(n):n&&n.buffer&&s(n.buffer)},isString:function(n){return"string"==typeof n},isNumber:function(n){return"number"==typeof n},isObject:c,isPlainObject:l,isUndefined:i,isDate:function(n){return"[object Date]"===a.call(n)},isFile:function(n){return"[object File]"===a.call(n)},isBlob:function(n){return"[object Blob]"===a.call(n)},isFunction:p,isStream:function(n){return c(n)&&p(n.pipe)},isURLSearchParams:function(n){return"[object URLSearchParams]"===a.call(n)},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:u,merge:function n(){var e={};function t(t,r){l(e[r])&&l(t)?e[r]=n(e[r],t):l(t)?e[r]=n({},t):o(t)?e[r]=t.slice():e[r]=t}for(var r=0,a=arguments.length;r<a;r++)u(arguments[r],t);return e},extend:function(n,e,t){return u(e,(function(e,a){n[a]=t&&"function"==typeof e?r(e,t):e})),n},trim:function(n){return n.trim?n.trim():n.replace(/^\s+|\s+$/g,"")},stripBOM:function(n){return 65279===n.charCodeAt(0)&&(n=n.slice(1)),n}}},function(n,e,t){"use strict";var r=t(72),a=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var r=t(43),a=Function.prototype,o=a.call,i=r&&a.bind.bind(o,o);n.exports=r?i:function(n){return function(){return o.apply(n,arguments)}}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var r=function(n){return n&&n.Math==Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||function(){return this}()||this||Function("return this")()},function(n,e,t){"use strict";var r=t(8);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(89),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var r=t(22),a=t(30),o=t(31),i=t(172),s=t(174);r({target:"Array",proto:!0,arity:1,forced:t(8)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=a(this),t=o(e),r=arguments.length;s(t+r);for(var c=0;c<r;c++)e[t]=arguments[c],t++;return i(e,t),t}})},function(n,e,t){"use strict";var r=t(7),a=t(30),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(a(n),e)}},function(n,e,t){"use strict";var r=t(6),a=t(72),o=a.all;n.exports=a.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===o}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(207),a=t(210);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){var r=t(303),a=t(114),o=/[T ]/,i=/:/,s=/^(\d{2})$/,c=[/^([+-]\d{2})$/,/^([+-]\d{3})$/,/^([+-]\d{4})$/],l=/^(\d{4})/,p=[/^([+-]\d{4})/,/^([+-]\d{5})/,/^([+-]\d{6})/],u=/^-(\d{2})$/,d=/^-?(\d{3})$/,m=/^-?(\d{2})-?(\d{2})$/,h=/^-?W(\d{2})$/,g=/^-?W(\d{2})-?(\d{1})$/,f=/^(\d{2}([.,]\d*)?)$/,b=/^(\d{2}):?(\d{2}([.,]\d*)?)$/,v=/^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,y=/([Z+-].*)$/,x=/^(Z)$/,w=/^([+-])(\d{2})$/,k=/^([+-])(\d{2}):?(\d{2})$/;function S(n,e,t){e=e||0,t=t||0;var r=new Date(0);r.setUTCFullYear(n,0,4);var a=7*e+t+1-(r.getUTCDay()||7);return r.setUTCDate(r.getUTCDate()+a),r}n.exports=function(n,e){if(a(n))return new Date(n.getTime());if("string"!=typeof n)return new Date(n);var t=(e||{}).additionalDigits;t=null==t?2:Number(t);var C=function(n){var e,t={},r=n.split(o);i.test(r[0])?(t.date=null,e=r[0]):(t.date=r[0],e=r[1]);if(e){var a=y.exec(e);a?(t.time=e.replace(a[1],""),t.timezone=a[1]):t.time=e}return t}(n),j=function(n,e){var t,r=c[e],a=p[e];if(t=l.exec(n)||a.exec(n)){var o=t[1];return{year:parseInt(o,10),restDateString:n.slice(o.length)}}if(t=s.exec(n)||r.exec(n)){var i=t[1];return{year:100*parseInt(i,10),restDateString:n.slice(i.length)}}return{year:null}}(C.date,t),A=j.year,T=function(n,e){if(null===e)return null;var t,r,a,o;if(0===n.length)return(r=new Date(0)).setUTCFullYear(e),r;if(t=u.exec(n))return r=new Date(0),a=parseInt(t[1],10)-1,r.setUTCFullYear(e,a),r;if(t=d.exec(n)){r=new Date(0);var i=parseInt(t[1],10);return r.setUTCFullYear(e,0,i),r}if(t=m.exec(n)){r=new Date(0),a=parseInt(t[1],10)-1;var s=parseInt(t[2],10);return r.setUTCFullYear(e,a,s),r}if(t=h.exec(n))return o=parseInt(t[1],10)-1,S(e,o);if(t=g.exec(n)){o=parseInt(t[1],10)-1;var c=parseInt(t[2],10)-1;return S(e,o,c)}return null}(j.restDateString,A);if(T){var E,P=T.getTime(),D=0;if(C.time&&(D=function(n){var e,t,r;if(e=f.exec(n))return(t=parseFloat(e[1].replace(",",".")))%24*36e5;if(e=b.exec(n))return t=parseInt(e[1],10),r=parseFloat(e[2].replace(",",".")),t%24*36e5+6e4*r;if(e=v.exec(n)){t=parseInt(e[1],10),r=parseInt(e[2],10);var a=parseFloat(e[3].replace(",","."));return t%24*36e5+6e4*r+1e3*a}return null}(C.time)),C.timezone)E=6e4*function(n){var e,t;if(e=x.exec(n))return 0;if(e=w.exec(n))return t=60*parseInt(e[2],10),"+"===e[1]?-t:t;if(e=k.exec(n))return t=60*parseInt(e[2],10)+parseInt(e[3],10),"+"===e[1]?-t:t;return 0}(C.timezone);else{var z=P+D,B=new Date(z);E=r(B);var I=new Date(z);I.setDate(B.getDate()+1);var O=r(I)-r(B);O>0&&(E+=O)}return new Date(P+D+E)}return new Date(n)}},function(n,e,t){"use strict";var r=t(10),a=t(81),o=t(83),i=t(24),s=t(71),c=TypeError,l=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=r?o?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=p(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return l(n,e,t)}:l:function(n,e,t){if(i(n),e=s(e),i(t),a)try{return l(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var r=t(300),a=t(301),o=t(113);n.exports={formats:o,parse:a,stringify:r}},function(n,e,t){"use strict";var r=t(1);e.a=new r.a},function(n,e,t){"use strict";var r=t(9),a=t(69).f,o=t(23),i=t(147),s=t(50),c=t(85),l=t(168);n.exports=function(n,e){var t,p,u,d,m,h=n.target,g=n.global,f=n.stat;if(t=g?r:f?r[h]||s(h,{}):(r[h]||{}).prototype)for(p in e){if(d=e[p],u=n.dontCallGetSet?(m=a(t,p))&&m.value:t[p],!l(g?p:h+(f?".":"#")+p,n.forced)&&void 0!==u){if(typeof d==typeof u)continue;c(d,u)}(n.sham||u&&u.sham)&&o(d,"sham",!0),i(t,p,d,n)}}},function(n,e,t){"use strict";var r=t(10),a=t(18),o=t(47);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var r=t(15),a=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(11).Symbol;n.exports=r},function(n,e,t){var r=t(25),a=t(192),o=t(193),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a})),t.d(e,"c",(function(){return o})),t.d(e,"b",(function(){return i}));var r=t(28);function a(n,e){return n=n.filter((t,r)=>{const{title:a,frontmatter:{home:o,date:i,publish:s}}=t;return n.indexOf(t)===r&&(!0===e?!(1==o||null==a||void 0===i||!1===s):!(1==o||null==a||!1===s))})}function o(n){n.sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(r.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(r.a)(n,e)})}function i(n){n.sort((n,e)=>Object(r.a)(n,e))}},function(n,e,t){"use strict";t.d(e,"f",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"k",(function(){return i})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return l})),t.d(e,"j",(function(){return p})),t.d(e,"c",(function(){return u})),t.d(e,"g",(function(){return d})),t.d(e,"m",(function(){return m})),t.d(e,"n",(function(){return h})),t.d(e,"e",(function(){return g})),t.d(e,"l",(function(){return f})),t.d(e,"d",(function(){return b})),t.d(e,"a",(function(){return y}));t(13);const r=/#.*$/,a=/\.(md|html)$/,o=/\/$/,i=/^(https?:|mailto:|tel:)/;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function c(n){return i.test(n)}function l(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function u(n){if(c(n))return n;const e=n.match(r),t=e?e[0]:"",a=s(n);return o.test(a)?n:a+".html"+t}function d(n,e){const t=n.hash,a=function(n){const e=n.match(r);if(e)return e[0]}(e);if(a&&t!==a)return!1;return s(n.path)===s(e)}function m(n,e,t){t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:a,themeConfig:o}=t,i=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||i.sidebar||o.sidebar))return function(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}(n);const s=i.sidebar||o.sidebar;if(s){const{base:n,config:t}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return t?t.map(e=>function n(e,t,r,a=1){if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,children:o.map(e=>n(e,t,r,a+1)),collapsable:!1!==e.collapsable}}}(e,a,n)):[]}return[]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function f(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n,e="yyyy-MM-dd hh:mm:ss"){n=n.replace(/-/g,"/");const t=new Date(n);/(y+)/.test(e)&&(e=e.replace(RegExp.$1,t.getFullYear()+"").substr(4-RegExp.$1.length));const r={"M+":t.getMonth()+1,"d+":t.getDate(),"h+":t.getHours(),"m+":t.getMinutes(),"s+":t.getSeconds()};for(const n in r)if(RegExp(`(${n})`).test(e)){const t=r[n]+"";e=e.replace(RegExp.$1,2===t.length?t:"0"+t)}return e}function v(n){return new Date(n.frontmatter.date).getTime()}function y(n,e){return v(e)-v(n)}},function(n,e,t){"use strict";var r=t(7),a=r({}.toString),o=r("".slice);n.exports=function(n){return o(a(n),8,-1)}},function(n,e,t){"use strict";var r=t(48),a=Object;n.exports=function(n){return a(r(n))}},function(n,e,t){"use strict";var r=t(166);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(67),a=t(48);n.exports=function(n){return r(a(n))}},function(n,e,t){"use strict";var r=t(9),a=t(6),o=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(9),a=t(78),o=t(14),i=t(80),s=t(76),c=t(75),l=r.Symbol,p=a("wks"),u=c?l.for||l:l&&l.withoutSetter||i;n.exports=function(n){return o(p,n)||(p[n]=s&&o(l,n)?l[n]:u("Symbol."+n)),p[n]}},function(n,e,t){"use strict";var r=t(165);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(197),a=t(198),o=t(199),i=t(200),s=t(201);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e,t){var r=t(91);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(16)(Object,"create");n.exports=r},function(n,e,t){var r=t(219);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(60);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";function r(n){this.message=n}r.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},r.prototype.__CANCEL__=!0,n.exports=r},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var c=t.render(!e),l=c.querySelector(r.barSelector),p=r.speed,u=r.easing;return c.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(l,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,p,u)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),c=n?"-100":o(t.status||0),p=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&d(a),p!=document.body&&l(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function c(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function l(n,e){var t=u(n),r=t+e;c(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=u(n);c(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){"use strict";var r=t(8);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";var r=t(6),a=t(155),o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not a function")}},function(n,e,t){"use strict";var r=t(22),a=t(169).left,o=t(170),i=t(77);r({target:"Array",proto:!0,forced:!t(171)&&i>79&&i<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(43),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var r=t(70),a=TypeError;n.exports=function(n){if(r(n))throw a("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(9),a=t(50),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){"use strict";var r=t(9),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(191),a=t(19),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,c=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,e,t){var r=t(16)(t(11),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(211),a=t(218),o=t(220),i=t(221),s=t(222);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(12),a=t(60),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(26),a=t(19);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(308);n.exports=function(n){return r(n,{weekStartsOn:1})}},function(n,e,t){"use strict";var r=t(5),a=t(320),o=t(118),i=t(119),s={"Content-Type":"application/x-www-form-urlencoded"};function c(n,e){!r.isUndefined(n)&&r.isUndefined(n["Content-Type"])&&(n["Content-Type"]=e)}var l,p={transitional:i,adapter:(("undefined"!=typeof XMLHttpRequest||"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process))&&(l=t(120)),l),transformRequest:[function(n,e){return a(e,"Accept"),a(e,"Content-Type"),r.isFormData(n)||r.isArrayBuffer(n)||r.isBuffer(n)||r.isStream(n)||r.isFile(n)||r.isBlob(n)?n:r.isArrayBufferView(n)?n.buffer:r.isURLSearchParams(n)?(c(e,"application/x-www-form-urlencoded;charset=utf-8"),n.toString()):r.isObject(n)||e&&"application/json"===e["Content-Type"]?(c(e,"application/json"),function(n,e,t){if(r.isString(n))try{return(e||JSON.parse)(n),r.trim(n)}catch(n){if("SyntaxError"!==n.name)throw n}return(t||JSON.stringify)(n)}(n)):n}],transformResponse:[function(n){var e=this.transitional||p.transitional,t=e&&e.silentJSONParsing,a=e&&e.forcedJSONParsing,i=!t&&"json"===this.responseType;if(i||a&&r.isString(n)&&n.length)try{return JSON.parse(n)}catch(n){if(i){if("SyntaxError"===n.name)throw o(n,this,"E_JSON_PARSE");throw n}}return n}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,validateStatus:function(n){return n>=200&&n<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};r.forEach(["delete","get","head"],(function(n){p.headers[n]={}})),r.forEach(["post","put","patch"],(function(n){p.headers[n]=r.merge(s)})),n.exports=p},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAACMCAYAAACksC0pAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALjSURBVHhe7doxbuswFETRSG68pVTZ+y+SJdmVE/GDC0hzBxnynoqpBGhIaoy84/vyBnu9Xv9ut9vH/HN5j8fj836/v88/Mc/n8+uca9RxHPgm2VUkwN2kNux4TiTA65Y+5nIL53m+5hI1nuMJLGeAgKu0xW42AwQEiv1/10bJBLhhC0198z2BBFtoueUC3I0BlkvdOLZQyGiHc4myhXJsoc2CG9YWSkgFeJ6nJYZgCy1nCy23XIC7tVBPYL/YhjVAwGiHc4mK/Uc+daX8FbZQ/YrfQEhqpGIwQEDqkzE2SiTA3X5GJHkCAcuVmN1aqIO95ZIb1gABqQD9GQG5XuxcsRyp4KSuUE8gwRZabrkAd2OA5Wyh5Rzs7WcLbRbcsLZQQipAB3shttByttByywW4Wwv1BPaLbVgDBDjYW84WWs5vYLnkjWOAgFSADvYuwBMISG1YWyhkvNi5RNlCIZaYcqkAx3MMEHC92LliOVLBSV2hnkBCasPGSowtlGELLWeAEFtoOQd7+9lCmwU3rC2UkApwjG54AgGpAG2hEFtoueUC3K2FegL7xTasAQJGO5xLlCMVEFtoOb+B5ZI3jgECUgE62LsATyAgtWFtoRBHKspZYsqlAhzPMUDA9WLniuVIBSd1hXoCCakNGysxtlCGLbScAUJsoeUc7O1nC20W3LC2UEIqwDG64QkEpAK0hUJsoeWWC3C3FuoJ7BfbsAYIGO1wLlGOVEBsoeX8BpZL3jgGCEgF6GDvAjyBgOVKzG4tNDVSEfsZsRtLTLlUgOM5Bgi4XuxcsRyp4KSuUE8gwRZabrkAd2OA5Wyh5Rzs7WcLbRbcsLZQQipAB3shttByttByywW4Wwv1BPaLbVgDBDjYW84Wql/xGwgZ85pziTNAQOqT4WDvAjyBgOVKzG4t1MHecskNa4CAVID+jIBcL3auWI5UcFJXqCeQYAstt1yAuzHAcrbQcg729rOFNstt2LfvHxY+GuRFc4rhAAAAAElFTkSuQmCC"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALUAAAByCAYAAAAVvpClAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAq+SURBVHhe7Z3psx1FGcZvtptAIAsGIhDgGqJRSCC4YSitsspPqH+Ef5r/gh/0m37RKlfihoJaBa6oBMyVJUBY4vNMv+d6zzkzZ3qm39l6nl9VV3fP2Wbefk5PT/fb3VtCCNEVB2/vA/mL4bAQ0+Ru0/IS9poQk+O8aXgJHD8TXhZiWlw1Da9hrwsxGY6bdkvB65fC24SYBg+Ydiux94mWHLRY9MNlaPYflhZi0twZ6uB68N5z4SOiLQcsFt1xBlq9bulaDgBLipao+dEtjzYU9FVLigRUK3TDEYj5lqWjgagPIfoo5ERbVFP7c6KNoA0J2gGJ2hd21/3X0o1ALf2IJUUiY29+DHV+/LMfQWCNG1N7HoaY37d0K/SA6MfQhrwD4SjCMYjin8WREQB9fQvRHxB+hfAuj22Ao4NvWboV+L2vIPoRk8WBaTKaQaO+jXgXw5gEXAWE9hQiinoTjbrr5gDs9hCidyzc5LG+6UPU2wj3TEHIC1Awn0d0DWFT7XMJ1/RbS4sNwJ70OHwDIamJFkuXoj6FQr9h6UmBQthkFzaVWAuJFsC0pxC1epiOpYvej5ModDJVQfPOUgXvOBJ0ArDfLsWB5McQOqlUPUXNGozsWn5yQNAPI6q6RT6Ga3vd0iIR2PI1BPYsPYjgKm6vL9vBCb5s6ckCUfNPvtqOTu6uE/XA9icQvRlyaaSK+igKvK7LazLAsKv2SO6uE81AEbCLt+2IbEFK8+N0ZoJmd+N+DknQ/QObv4fodMi1o62on8CP/8fSubDap3q/xaJnTFtPILRqSTT9ENem+NDSWVHS9DiM8HVc73dCVgwBiqXsOWcjTUSdraBJiagJDcpeDw2yDAiKhn44H4RcPbHNj9wFza68Mtjl9DxePxuyYgigPfY+0dc8iihR5yxoo+729iqEfbelxQBAg6ypo/Qa86anLc4WGOxvltzEW3YbFAMRW7nWiZpOOz+xtEC7DsImj1pe9Az0WPvQuEnUXLRwFg9IECmdbJrwEj5D3wUxDM9aXEpl70fMP8ITiIT9whzMYWAHfJ+0vdZtmKnvcxUAevkEoj+H3DKlou5D0Dip84joYJ/DqN2TMFndhIJKYIuvIfpByE0S9ulzeJuTjl8pjvQA7MaWxppWy0TNmSkujiVl4ES4AlGOS2/dC7u9aunGwC5NxgymQJI9Yimz21qbuitB47d37ARyXUvuOi7vuKXbwGHhnKA9yKpPjTc7Fu+xqvIvQNQ/s7QbuDBOsM3G+akGVhRXYMfnQjYeKsCSOdLZTKhVuy3V1N6Cxm9dsh+ci6AJRyGv4bLp/N6UnHcP2KUWwBXLuwHdLrWr9xS++kIqOHk+CE5+4kAijWsnlrolc+Yc7BIz4BXNfrt1Imp8f2V3ywyhX3a0M85MRE3oj+/qvryw3aL5cZ/FyeB7n0EkQf+fD2lscMHydcxltPIGbNLJAFahbOdaurTvUBTcB1P/29KV8B9gyTnwadjkBUsnAbM9huiFtS69FPCl7L6RoKuht1+MU9SdFs+BF2GTb1g6Cfw5fs+42GW1OJIITuyziN4OObGBhVMU7VUKimRudvy+xR4cOuAoag6V5u537Q2X/i0djKLqLTkXHoIt/mrpJFyaH7A/R8Mk6Oa8AttVjUJ+0uK54NbF59WmftFi0ZybrJUBe432QK31R0vOBtigalpdI1yaHywRS4o0HkFxFN2hMOkDiCazUqwXLnpM/RIYn8PBvbkbzgROMp1lc24sola/tPCEK8smLcTpIWo1PYQrqZpMelCEnr9kSSFGQ2rvhwZbhDuoLJN2/k0VdefTdcQsSZq3mipqbk4jhDdJO56lijr180KUkbTRkUQpxkiSLiVqkR0StciOVFHHbEYvRFOGG3wBTRdWFCKG6AXWy5CoxRg5aXErUkWdssyWEFUkLeqTJOrbt2//wpJCeJK0FYm89MToGNRLz0hq/wixQnIl6SFqLiAyV7YtFn4k7zSsOYrt2T+fkGsk/4VpkYaHHj1qasLdAWbFQtDE0powkY7Lln4uokahui7LOgVQO3/KkgWwwY8RWMvMackwby5anIRL84OgkLlmw6zEXWU72EIz7JvTaMnjTRxEAXC5sGRwQlwyijs0zR7YgkuJPRVyIpLLFifD5ofn+hLcOm02oEKoHFGFsK8hsCZ3qTQyhxvR/tLSSaBMijU7mPhMcSQRnNh3Ebm0iybCTYsrgU3eR+S2qH2GsNnhOi1w8aDothYeTpDfdU/I5Q8qhNodAmATLrSu/czL+arFyaAszhZxkQMwvMsD4wL8AIXdyRZjY6OJ7WAXulXKDz1wEaZzq1Bh20LPe116yLu2/XCy3KRmdv3XdcAufIaRy+7W1gVnQe9tErq/n9p9QUKcNLv4ngy5fIFB77VkFLAL72Bc1XSucBPaP1nai70R3bXhbfyYazNkAQr+NKLdkMuPNnaDTT6HiE/9ndh8hByHmZIWqikDdryE6Hcht1xTF+AN3APRHVzMDSv4LCcWwG6N70gwx3MIbF/PYRSSvjLugjb2BE1KHZFMfJ0CEfCW/VrI5UGK3XK0h/EgzPJ3S7sDu3FCwdKfZa2mJnhj6XFPcKHXKQKC7McReHKTduWE3VoPPsEMXGorl+ePE6FkCzoTtLFW+29yGd3BCb1sadEj+HPQ3eBWyDVmU5l6wwqJTSee7zb08i8e7AvYqfRa6wzwLE70e5YWPYLyatPPfxLlle3D+H5gnxOI3gy5ZWr/1TBS5+1rUQ4KjqOQL4VcPXMpK9iFzk/Ph9w6UbcqCXtYUIh0nq91y5xDOcEWnIzx05ArJ7b9xe2etfnngKAw157ySziHcsrapx12qNVsbC/HR/guuVAOCMTK9mPdIi+xldQkgQaj9NrUCIdhXLpSioFAwXLLbA42rDlFoWyybX7guqMdwZr2R39gXy4GArr9DaJvInQ+ljAGoLdnrIaO9mxse7vi5y7DwL8OWdE3KOhVX5rsnntwjRyM4p+4EaltsNMwJF1MRc/YHXN/7ZVVWeD6WvvjezxYcCTpPUuLHkCBcxTvnZALoAyyaU/j+o4haq0pj3bZLZwE0Zp6PQA7s896SdDAo3IaHFzbWQoJyaRK0vNh4w2czyEEzXbpANh1xwq8bBBm8jbHpbF2dtlstqt/OP8sp3BHfD1kRQoo8E3tyyOwc1vnp8HBtfEO7zqbvI/bFsU9iwm4XYBCvwPRuyG3zlTb0riumBHSVvTR17mLCyDbCEnbHswJ2OpxGg3JKkHzNU4Hmwy4nPsRjtp1dTULZtAHDLahOLXrGCqbrh3JJwXKPGYWzBXYzWVVoy7BtXAtDg7xrz7cdsaQoi6Dd46pdk3xvL8Mof0wZNsBEdyF6O2Qq4QVwhUErpvx7eLICMC5cwYT2/dcuWqwbt6xiXrSQGCt/5AQxNOIfo4Q8x3883PqG/1wooePHaFuhvhd0TMPU9RtwGfnvAaIO6qpnTBxNgY1tHuX1tyRqH1o5UwEQS+aEMKRPrr05sAXLY4CYr6AwApFgu4A1dQONGl6QMu5LlozGlRTpxPtdwFBs19eghbjhrV0HXib234mQnQNt3bYCN6j7rqeUfMjjcctLgXNDY4Oaus5MR2sMl4DL10N7xBiWpwxDS+B4+fDy0JMDNPwEjhMH2EhJgs95PZAXs8no2Br638Xmb1wGMv52wAAAABJRU5ErkJggg=="},function(n,e,t){"use strict";var r=t(183),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){"use strict";var r=t(7),a=t(8),o=t(29),i=Object,s=r("".split);n.exports=a((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):i(n)}:i},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var r=t(10),a=t(46),o=t(151),i=t(47),s=t(32),c=t(71),l=t(14),p=t(81),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=s(n),e=c(e),p)try{return u(n,e)}catch(n){}if(l(n,e))return i(!a(o.f,n,e),n[e])}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var r=t(152),a=t(73);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e,t){"use strict";var r="object"==typeof document&&document.all,a=void 0===r&&void 0!==r;n.exports={all:r,IS_HTMLDDA:a}},function(n,e,t){"use strict";var r=t(33),a=t(6),o=t(74),i=t(75),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&o(e.prototype,s(n))}},function(n,e,t){"use strict";var r=t(7);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(76);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var r=t(77),a=t(8),o=t(9).String;n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){"use strict";var r,a,o=t(9),i=t(153),s=o.process,c=o.Deno,l=s&&s.versions||c&&c.version,p=l&&l.v8;p&&(a=(r=p.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){"use strict";var r=t(79),a=t(49);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.32.0",mode:r?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var r=t(7),a=0,o=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++a+o,36)}},function(n,e,t){"use strict";var r=t(10),a=t(8),o=t(82);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var r=t(9),a=t(15),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){"use strict";var r=t(10),a=t(8);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var r=t(78),a=t(80),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){"use strict";var r=t(14),a=t(161),o=t(69),i=t(18);n.exports=function(n,e,t){for(var s=a(e),c=i.f,l=o.f,p=0;p<s.length;p++){var u=s[p];r(n,u)||t&&r(t,u)||c(n,u,l(e,u))}}},function(n,e,t){"use strict";var r=t(7),a=t(14),o=t(32),i=t(163).indexOf,s=t(51),c=r([].push);n.exports=function(n,e){var t,r=o(n),l=0,p=[];for(t in r)!a(s,t)&&a(r,t)&&c(p,t);for(;e.length>l;)a(r,t=e[l++])&&(~i(p,t)||c(p,t));return p}},function(n,e,t){"use strict";var r=t(178),a=t(24),o=t(179);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(36),a=t(202),o=t(203),i=t(204),s=t(205),c=t(206);function l(n){var e=this.__data__=new r(n);this.size=e.size}l.prototype.clear=a,l.prototype.delete=o,l.prototype.get=i,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(26),a=t(55);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(223),a=t(19);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,s))}},function(n,e,t){var r=t(96),a=t(226),o=t(97);n.exports=function(n,e,t,i,s,c){var l=1&t,p=n.length,u=e.length;if(p!=u&&!(l&&u>p))return!1;var d=c.get(n),m=c.get(e);if(d&&m)return d==e&&m==n;var h=-1,g=!0,f=2&t?new r:void 0;for(c.set(n,e),c.set(e,n);++h<p;){var b=n[h],v=e[h];if(i)var y=l?i(v,b,h,e,n,c):i(b,v,h,n,e,c);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!a(e,(function(n,e){if(!o(f,e)&&(b===n||s(b,n,t,i,c)))return f.push(e)}))){g=!1;break}}else if(b!==v&&!s(b,v,t,i,c)){g=!1;break}}return c.delete(n),c.delete(e),g}},function(n,e,t){var r=t(56),a=t(224),o=t(225);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(236),a=t(242),o=t(102);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(11),a=t(238),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?r.Buffer:void 0,c=(s?s.isBuffer:void 0)||a;n.exports=c}).call(this,t(68)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(239),a=t(240),o=t(241),i=o&&o.isTypedArray,s=i?a(i):r;n.exports=s},function(n,e,t){var r=t(92),a=t(58);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(16)(t(11),"Set");n.exports=r},function(n,e,t){var r=t(55);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(107),a=t(40);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(12),a=t(59),o=t(253),i=t(256);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";var r=Object.prototype.hasOwnProperty,a=function(){for(var n=[],e=0;e<256;++e)n.push("%"+((e<16?"0":"")+e.toString(16)).toUpperCase());return n}(),o=function(n,e){for(var t=e&&e.plainObjects?Object.create(null):{},r=0;r<n.length;++r)void 0!==n[r]&&(t[r]=n[r]);return t};n.exports={arrayToObject:o,assign:function(n,e){return Object.keys(e).reduce((function(n,t){return n[t]=e[t],n}),n)},compact:function(n){for(var e=[{obj:{o:n},prop:"o"}],t=[],r=0;r<e.length;++r)for(var a=e[r],o=a.obj[a.prop],i=Object.keys(o),s=0;s<i.length;++s){var c=i[s],l=o[c];"object"==typeof l&&null!==l&&-1===t.indexOf(l)&&(e.push({obj:o,prop:c}),t.push(l))}return function(n){for(var e;n.length;){var t=n.pop();if(e=t.obj[t.prop],Array.isArray(e)){for(var r=[],a=0;a<e.length;++a)void 0!==e[a]&&r.push(e[a]);t.obj[t.prop]=r}}return e}(e)},decode:function(n){try{return decodeURIComponent(n.replace(/\+/g," "))}catch(e){return n}},encode:function(n){if(0===n.length)return n;for(var e="string"==typeof n?n:String(n),t="",r=0;r<e.length;++r){var o=e.charCodeAt(r);45===o||46===o||95===o||126===o||o>=48&&o<=57||o>=65&&o<=90||o>=97&&o<=122?t+=e.charAt(r):o<128?t+=a[o]:o<2048?t+=a[192|o>>6]+a[128|63&o]:o<55296||o>=57344?t+=a[224|o>>12]+a[128|o>>6&63]+a[128|63&o]:(r+=1,o=65536+((1023&o)<<10|1023&e.charCodeAt(r)),t+=a[240|o>>18]+a[128|o>>12&63]+a[128|o>>6&63]+a[128|63&o])}return t},isBuffer:function(n){return null!=n&&!!(n.constructor&&n.constructor.isBuffer&&n.constructor.isBuffer(n))},isRegExp:function(n){return"[object RegExp]"===Object.prototype.toString.call(n)},merge:function n(e,t,a){if(!t)return e;if("object"!=typeof t){if(Array.isArray(e))e.push(t);else{if(!e||"object"!=typeof e)return[e,t];(a&&(a.plainObjects||a.allowPrototypes)||!r.call(Object.prototype,t))&&(e[t]=!0)}return e}if(!e||"object"!=typeof e)return[e].concat(t);var i=e;return Array.isArray(e)&&!Array.isArray(t)&&(i=o(e,a)),Array.isArray(e)&&Array.isArray(t)?(t.forEach((function(t,o){if(r.call(e,o)){var i=e[o];i&&"object"==typeof i&&t&&"object"==typeof t?e[o]=n(i,t,a):e.push(t)}else e[o]=t})),e):Object.keys(t).reduce((function(e,o){var i=t[o];return r.call(e,o)?e[o]=n(e[o],i,a):e[o]=i,e}),i)}}},function(n,e,t){"use strict";var r=String.prototype.replace,a=/%20/g;n.exports={default:"RFC3986",formatters:{RFC1738:function(n){return r.call(n,a,"+")},RFC3986:function(n){return String(n)}},RFC1738:"RFC1738",RFC3986:"RFC3986"}},function(n,e){n.exports=function(n){return n instanceof Date}},function(n,e,t){var r=t(17),a=t(62);n.exports=function(n){var e=r(n),t=e.getFullYear(),o=new Date(0);o.setFullYear(t+1,0,4),o.setHours(0,0,0,0);var i=a(o),s=new Date(0);s.setFullYear(t,0,4),s.setHours(0,0,0,0);var c=a(s);return e.getTime()>=i.getTime()?t+1:e.getTime()>=c.getTime()?t:t-1}},function(n,e,t){"use strict";n.exports=function(n,e){return function(){for(var t=new Array(arguments.length),r=0;r<t.length;r++)t[r]=arguments[r];return n.apply(e,t)}}},function(n,e,t){"use strict";var r=t(5);function a(n){return encodeURIComponent(n).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}n.exports=function(n,e,t){if(!e)return n;var o;if(t)o=t(e);else if(r.isURLSearchParams(e))o=e.toString();else{var i=[];r.forEach(e,(function(n,e){null!=n&&(r.isArray(n)?e+="[]":n=[n],r.forEach(n,(function(n){r.isDate(n)?n=n.toISOString():r.isObject(n)&&(n=JSON.stringify(n)),i.push(a(e)+"="+a(n))})))})),o=i.join("&")}if(o){var s=n.indexOf("#");-1!==s&&(n=n.slice(0,s)),n+=(-1===n.indexOf("?")?"?":"&")+o}return n}},function(n,e,t){"use strict";n.exports=function(n,e,t,r,a){return n.config=e,t&&(n.code=t),n.request=r,n.response=a,n.isAxiosError=!0,n.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}},n}},function(n,e,t){"use strict";n.exports={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1}},function(n,e,t){"use strict";var r=t(5),a=t(321),o=t(322),i=t(117),s=t(323),c=t(326),l=t(327),p=t(121),u=t(119),d=t(41);n.exports=function(n){return new Promise((function(e,t){var m,h=n.data,g=n.headers,f=n.responseType;function b(){n.cancelToken&&n.cancelToken.unsubscribe(m),n.signal&&n.signal.removeEventListener("abort",m)}r.isFormData(h)&&delete g["Content-Type"];var v=new XMLHttpRequest;if(n.auth){var y=n.auth.username||"",x=n.auth.password?unescape(encodeURIComponent(n.auth.password)):"";g.Authorization="Basic "+btoa(y+":"+x)}var w=s(n.baseURL,n.url);function k(){if(v){var r="getAllResponseHeaders"in v?c(v.getAllResponseHeaders()):null,o={data:f&&"text"!==f&&"json"!==f?v.response:v.responseText,status:v.status,statusText:v.statusText,headers:r,config:n,request:v};a((function(n){e(n),b()}),(function(n){t(n),b()}),o),v=null}}if(v.open(n.method.toUpperCase(),i(w,n.params,n.paramsSerializer),!0),v.timeout=n.timeout,"onloadend"in v?v.onloadend=k:v.onreadystatechange=function(){v&&4===v.readyState&&(0!==v.status||v.responseURL&&0===v.responseURL.indexOf("file:"))&&setTimeout(k)},v.onabort=function(){v&&(t(p("Request aborted",n,"ECONNABORTED",v)),v=null)},v.onerror=function(){t(p("Network Error",n,null,v)),v=null},v.ontimeout=function(){var e=n.timeout?"timeout of "+n.timeout+"ms exceeded":"timeout exceeded",r=n.transitional||u;n.timeoutErrorMessage&&(e=n.timeoutErrorMessage),t(p(e,n,r.clarifyTimeoutError?"ETIMEDOUT":"ECONNABORTED",v)),v=null},r.isStandardBrowserEnv()){var S=(n.withCredentials||l(w))&&n.xsrfCookieName?o.read(n.xsrfCookieName):void 0;S&&(g[n.xsrfHeaderName]=S)}"setRequestHeader"in v&&r.forEach(g,(function(n,e){void 0===h&&"content-type"===e.toLowerCase()?delete g[e]:v.setRequestHeader(e,n)})),r.isUndefined(n.withCredentials)||(v.withCredentials=!!n.withCredentials),f&&"json"!==f&&(v.responseType=n.responseType),"function"==typeof n.onDownloadProgress&&v.addEventListener("progress",n.onDownloadProgress),"function"==typeof n.onUploadProgress&&v.upload&&v.upload.addEventListener("progress",n.onUploadProgress),(n.cancelToken||n.signal)&&(m=function(n){v&&(t(!n||n&&n.type?new d("canceled"):n),v.abort(),v=null)},n.cancelToken&&n.cancelToken.subscribe(m),n.signal&&(n.signal.aborted?m():n.signal.addEventListener("abort",m))),h||(h=null),v.send(h)}))}},function(n,e,t){"use strict";var r=t(118);n.exports=function(n,e,t,a,o){var i=new Error(n);return r(i,e,t,a,o)}},function(n,e,t){"use strict";n.exports=function(n){return!(!n||!n.__CANCEL__)}},function(n,e,t){"use strict";var r=t(5);n.exports=function(n,e){e=e||{};var t={};function a(n,e){return r.isPlainObject(n)&&r.isPlainObject(e)?r.merge(n,e):r.isPlainObject(e)?r.merge({},e):r.isArray(e)?e.slice():e}function o(t){return r.isUndefined(e[t])?r.isUndefined(n[t])?void 0:a(void 0,n[t]):a(n[t],e[t])}function i(n){if(!r.isUndefined(e[n]))return a(void 0,e[n])}function s(t){return r.isUndefined(e[t])?r.isUndefined(n[t])?void 0:a(void 0,n[t]):a(void 0,e[t])}function c(t){return t in e?a(n[t],e[t]):t in n?a(void 0,n[t]):void 0}var l={url:i,method:i,data:i,baseURL:s,transformRequest:s,transformResponse:s,paramsSerializer:s,timeout:s,timeoutMessage:s,withCredentials:s,adapter:s,responseType:s,xsrfCookieName:s,xsrfHeaderName:s,onUploadProgress:s,onDownloadProgress:s,decompress:s,maxContentLength:s,maxBodyLength:s,transport:s,httpAgent:s,httpsAgent:s,cancelToken:s,socketPath:s,responseEncoding:s,validateStatus:c};return r.forEach(Object.keys(n).concat(Object.keys(e)),(function(n){var e=l[n]||o,a=e(n);r.isUndefined(a)&&e!==c||(t[n]=a)})),t}},function(n,e){n.exports={version:"0.26.1"}},function(n,e,t){},function(n,e,t){n.exports=function(){"use strict";var n=6e4,e=36e5,t="millisecond",r="second",a="minute",o="hour",i="day",s="week",c="month",l="quarter",p="year",u="date",d="Invalid Date",m=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,h=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,g={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(n){var e=["th","st","nd","rd"],t=n%100;return"["+n+(e[(t-20)%10]||e[t]||e[0])+"]"}},f=function(n,e,t){var r=String(n);return!r||r.length>=e?n:""+Array(e+1-r.length).join(t)+n},b={s:f,z:function(n){var e=-n.utcOffset(),t=Math.abs(e),r=Math.floor(t/60),a=t%60;return(e<=0?"+":"-")+f(r,2,"0")+":"+f(a,2,"0")},m:function n(e,t){if(e.date()<t.date())return-n(t,e);var r=12*(t.year()-e.year())+(t.month()-e.month()),a=e.clone().add(r,c),o=t-a<0,i=e.clone().add(r+(o?-1:1),c);return+(-(r+(t-a)/(o?a-i:i-a))||0)},a:function(n){return n<0?Math.ceil(n)||0:Math.floor(n)},p:function(n){return{M:c,y:p,w:s,d:i,D:u,h:o,m:a,s:r,ms:t,Q:l}[n]||String(n||"").toLowerCase().replace(/s$/,"")},u:function(n){return void 0===n}},v="en",y={};y[v]=g;var x=function(n){return n instanceof C},w=function n(e,t,r){var a;if(!e)return v;if("string"==typeof e){var o=e.toLowerCase();y[o]&&(a=o),t&&(y[o]=t,a=o);var i=e.split("-");if(!a&&i.length>1)return n(i[0])}else{var s=e.name;y[s]=e,a=s}return!r&&a&&(v=a),a||!r&&v},k=function(n,e){if(x(n))return n.clone();var t="object"==typeof e?e:{};return t.date=n,t.args=arguments,new C(t)},S=b;S.l=w,S.i=x,S.w=function(n,e){return k(n,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var C=function(){function g(n){this.$L=w(n.locale,null,!0),this.parse(n)}var f=g.prototype;return f.parse=function(n){this.$d=function(n){var e=n.date,t=n.utc;if(null===e)return new Date(NaN);if(S.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(m);if(r){var a=r[2]-1||0,o=(r[7]||"0").substring(0,3);return t?new Date(Date.UTC(r[1],a,r[3]||1,r[4]||0,r[5]||0,r[6]||0,o)):new Date(r[1],a,r[3]||1,r[4]||0,r[5]||0,r[6]||0,o)}}return new Date(e)}(n),this.$x=n.x||{},this.init()},f.init=function(){var n=this.$d;this.$y=n.getFullYear(),this.$M=n.getMonth(),this.$D=n.getDate(),this.$W=n.getDay(),this.$H=n.getHours(),this.$m=n.getMinutes(),this.$s=n.getSeconds(),this.$ms=n.getMilliseconds()},f.$utils=function(){return S},f.isValid=function(){return!(this.$d.toString()===d)},f.isSame=function(n,e){var t=k(n);return this.startOf(e)<=t&&t<=this.endOf(e)},f.isAfter=function(n,e){return k(n)<this.startOf(e)},f.isBefore=function(n,e){return this.endOf(e)<k(n)},f.$g=function(n,e,t){return S.u(n)?this[e]:this.set(t,n)},f.unix=function(){return Math.floor(this.valueOf()/1e3)},f.valueOf=function(){return this.$d.getTime()},f.startOf=function(n,e){var t=this,l=!!S.u(e)||e,d=S.p(n),m=function(n,e){var r=S.w(t.$u?Date.UTC(t.$y,e,n):new Date(t.$y,e,n),t);return l?r:r.endOf(i)},h=function(n,e){return S.w(t.toDate()[n].apply(t.toDate("s"),(l?[0,0,0,0]:[23,59,59,999]).slice(e)),t)},g=this.$W,f=this.$M,b=this.$D,v="set"+(this.$u?"UTC":"");switch(d){case p:return l?m(1,0):m(31,11);case c:return l?m(1,f):m(0,f+1);case s:var y=this.$locale().weekStart||0,x=(g<y?g+7:g)-y;return m(l?b-x:b+(6-x),f);case i:case u:return h(v+"Hours",0);case o:return h(v+"Minutes",1);case a:return h(v+"Seconds",2);case r:return h(v+"Milliseconds",3);default:return this.clone()}},f.endOf=function(n){return this.startOf(n,!1)},f.$set=function(n,e){var s,l=S.p(n),d="set"+(this.$u?"UTC":""),m=(s={},s[i]=d+"Date",s[u]=d+"Date",s[c]=d+"Month",s[p]=d+"FullYear",s[o]=d+"Hours",s[a]=d+"Minutes",s[r]=d+"Seconds",s[t]=d+"Milliseconds",s)[l],h=l===i?this.$D+(e-this.$W):e;if(l===c||l===p){var g=this.clone().set(u,1);g.$d[m](h),g.init(),this.$d=g.set(u,Math.min(this.$D,g.daysInMonth())).$d}else m&&this.$d[m](h);return this.init(),this},f.set=function(n,e){return this.clone().$set(n,e)},f.get=function(n){return this[S.p(n)]()},f.add=function(t,l){var u,d=this;t=Number(t);var m=S.p(l),h=function(n){var e=k(d);return S.w(e.date(e.date()+Math.round(n*t)),d)};if(m===c)return this.set(c,this.$M+t);if(m===p)return this.set(p,this.$y+t);if(m===i)return h(1);if(m===s)return h(7);var g=(u={},u[a]=n,u[o]=e,u[r]=1e3,u)[m]||1,f=this.$d.getTime()+t*g;return S.w(f,this)},f.subtract=function(n,e){return this.add(-1*n,e)},f.format=function(n){var e=this,t=this.$locale();if(!this.isValid())return t.invalidDate||d;var r=n||"YYYY-MM-DDTHH:mm:ssZ",a=S.z(this),o=this.$H,i=this.$m,s=this.$M,c=t.weekdays,l=t.months,p=t.meridiem,u=function(n,t,a,o){return n&&(n[t]||n(e,r))||a[t].slice(0,o)},m=function(n){return S.s(o%12||12,n,"0")},g=p||function(n,e,t){var r=n<12?"AM":"PM";return t?r.toLowerCase():r};return r.replace(h,(function(n,r){return r||function(n){switch(n){case"YY":return String(e.$y).slice(-2);case"YYYY":return S.s(e.$y,4,"0");case"M":return s+1;case"MM":return S.s(s+1,2,"0");case"MMM":return u(t.monthsShort,s,l,3);case"MMMM":return u(l,s);case"D":return e.$D;case"DD":return S.s(e.$D,2,"0");case"d":return String(e.$W);case"dd":return u(t.weekdaysMin,e.$W,c,2);case"ddd":return u(t.weekdaysShort,e.$W,c,3);case"dddd":return c[e.$W];case"H":return String(o);case"HH":return S.s(o,2,"0");case"h":return m(1);case"hh":return m(2);case"a":return g(o,i,!0);case"A":return g(o,i,!1);case"m":return String(i);case"mm":return S.s(i,2,"0");case"s":return String(e.$s);case"ss":return S.s(e.$s,2,"0");case"SSS":return S.s(e.$ms,3,"0");case"Z":return a}return null}(n)||a.replace(":","")}))},f.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},f.diff=function(t,u,d){var m,h=this,g=S.p(u),f=k(t),b=(f.utcOffset()-this.utcOffset())*n,v=this-f,y=function(){return S.m(h,f)};switch(g){case p:m=y()/12;break;case c:m=y();break;case l:m=y()/3;break;case s:m=(v-b)/6048e5;break;case i:m=(v-b)/864e5;break;case o:m=v/e;break;case a:m=v/n;break;case r:m=v/1e3;break;default:m=v}return d?m:S.a(m)},f.daysInMonth=function(){return this.endOf(c).$D},f.$locale=function(){return y[this.$L]},f.locale=function(n,e){if(!n)return this.$L;var t=this.clone(),r=w(n,e,!0);return r&&(t.$L=r),t},f.clone=function(){return S.w(this.$d,this)},f.toDate=function(){return new Date(this.valueOf())},f.toJSON=function(){return this.isValid()?this.toISOString():null},f.toISOString=function(){return this.$d.toISOString()},f.toString=function(){return this.$d.toUTCString()},g}(),j=C.prototype;return k.prototype=j,[["$ms",t],["$s",r],["$m",a],["$H",o],["$W",i],["$M",c],["$y",p],["$D",u]].forEach((function(n){j[n[1]]=function(e){return this.$g(e,n[0],n[1])}})),k.extend=function(n,e){return n.$i||(n(e,C,k),n.$i=!0),k},k.locale=w,k.isDayjs=x,k.unix=function(n){return k(1e3*n)},k.en=y[v],k.Ls=y,k.p={},k}()},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(189),a=t(194),o=t(265),i=t(273),s=t(282),c=t(283),l=o((function(n){var e=c(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),a(e,2))}));n.exports=l},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var o="",i=0,s=0;for(i=a.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(o+=t.substring(s,i)),s=i+1,o+=e}return s!==i?o+t.substring(s,i):o}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),p=Object.prototype.toString,u=Math.max,d=Math.min,m=function(){return l.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,s,c,l=0,p=!1,f=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=r,o=a;return r=a=void 0,l=e,i=n.apply(o,t)}function y(n){return l=n,s=setTimeout(w,e),p?v(n):i}function x(n){var t=n-c;return void 0===c||t>=e||t<0||f&&n-l>=o}function w(){var n=m();if(x(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-c);return f?d(t,o-(n-l)):t}(n))}function k(n){return s=void 0,b&&r?v(n):(r=a=void 0,i)}function S(){var n=m(),t=x(n);if(r=arguments,a=this,c=n,t){if(void 0===s)return y(c);if(f)return s=setTimeout(w,e),v(c)}return void 0===s&&(s=setTimeout(w,e)),i}return e=g(e)||0,h(t)&&(p=!!t.leading,o=(f="maxWait"in t)?u(g(t.maxWait)||0,e):o,b="trailing"in t?!!t.trailing:b),S.cancel=function(){void 0!==s&&clearTimeout(s),l=0,r=c=a=s=void 0},S.flush=function(){return void 0===s?i:k(m())},S}},function(n,e,t){!function(){"use strict";n.exports={polyfill:function(){var n=window,e=document;if(!("scrollBehavior"in e.documentElement.style)||!0===n.__forceSmoothScrollPolyfill__){var t,r=n.HTMLElement||n.Element,a={scroll:n.scroll||n.scrollTo,scrollBy:n.scrollBy,elementScroll:r.prototype.scroll||s,scrollIntoView:r.prototype.scrollIntoView},o=n.performance&&n.performance.now?n.performance.now.bind(n.performance):Date.now,i=(t=n.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(t)?1:0);n.scroll=n.scrollTo=function(){void 0!==arguments[0]&&(!0!==c(arguments[0])?h.call(n,e.body,void 0!==arguments[0].left?~~arguments[0].left:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:n.scrollY||n.pageYOffset):a.scroll.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:n.scrollY||n.pageYOffset))},n.scrollBy=function(){void 0!==arguments[0]&&(c(arguments[0])?a.scrollBy.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):h.call(n,e.body,~~arguments[0].left+(n.scrollX||n.pageXOffset),~~arguments[0].top+(n.scrollY||n.pageYOffset)))},r.prototype.scroll=r.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==c(arguments[0])){var n=arguments[0].left,e=arguments[0].top;h.call(this,this,void 0===n?this.scrollLeft:~~n,void 0===e?this.scrollTop:~~e)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!=typeof arguments[0]?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},r.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==c(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},r.prototype.scrollIntoView=function(){if(!0!==c(arguments[0])){var t=d(this),r=t.getBoundingClientRect(),o=this.getBoundingClientRect();t!==e.body?(h.call(this,t,t.scrollLeft+o.left-r.left,t.scrollTop+o.top-r.top),"fixed"!==n.getComputedStyle(t).position&&n.scrollBy({left:r.left,top:r.top,behavior:"smooth"})):n.scrollBy({left:o.left,top:o.top,behavior:"smooth"})}else a.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function s(n,e){this.scrollLeft=n,this.scrollTop=e}function c(n){if(null===n||"object"!=typeof n||void 0===n.behavior||"auto"===n.behavior||"instant"===n.behavior)return!0;if("object"==typeof n&&"smooth"===n.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+n.behavior+" is not a valid value for enumeration ScrollBehavior.")}function l(n,e){return"Y"===e?n.clientHeight+i<n.scrollHeight:"X"===e?n.clientWidth+i<n.scrollWidth:void 0}function p(e,t){var r=n.getComputedStyle(e,null)["overflow"+t];return"auto"===r||"scroll"===r}function u(n){var e=l(n,"Y")&&p(n,"Y"),t=l(n,"X")&&p(n,"X");return e||t}function d(n){for(;n!==e.body&&!1===u(n);)n=n.parentNode||n.host;return n}function m(e){var t,r,a,i,s=(o()-e.startTime)/468;i=s=s>1?1:s,t=.5*(1-Math.cos(Math.PI*i)),r=e.startX+(e.x-e.startX)*t,a=e.startY+(e.y-e.startY)*t,e.method.call(e.scrollable,r,a),r===e.x&&a===e.y||n.requestAnimationFrame(m.bind(n,e))}function h(t,r,i){var c,l,p,u,d=o();t===e.body?(c=n,l=n.scrollX||n.pageXOffset,p=n.scrollY||n.pageYOffset,u=a.scroll):(c=t,l=t.scrollLeft,p=t.scrollTop,u=s),m({scrollable:c,method:u,startTime:d,startX:l,startY:p,x:r,y:i})}}}}()},function(n,e,t){var r=t(302),a=t(307),o=t(115),i=t(17),s=t(310),c=t(311);var l={M:function(n){return n.getMonth()+1},MM:function(n){return d(n.getMonth()+1,2)},Q:function(n){return Math.ceil((n.getMonth()+1)/3)},D:function(n){return n.getDate()},DD:function(n){return d(n.getDate(),2)},DDD:function(n){return r(n)},DDDD:function(n){return d(r(n),3)},d:function(n){return n.getDay()},E:function(n){return n.getDay()||7},W:function(n){return a(n)},WW:function(n){return d(a(n),2)},YY:function(n){return d(n.getFullYear(),4).substr(2)},YYYY:function(n){return d(n.getFullYear(),4)},GG:function(n){return String(o(n)).substr(2)},GGGG:function(n){return o(n)},H:function(n){return n.getHours()},HH:function(n){return d(n.getHours(),2)},h:function(n){var e=n.getHours();return 0===e?12:e>12?e%12:e},hh:function(n){return d(l.h(n),2)},m:function(n){return n.getMinutes()},mm:function(n){return d(n.getMinutes(),2)},s:function(n){return n.getSeconds()},ss:function(n){return d(n.getSeconds(),2)},S:function(n){return Math.floor(n.getMilliseconds()/100)},SS:function(n){return d(Math.floor(n.getMilliseconds()/10),2)},SSS:function(n){return d(n.getMilliseconds(),3)},Z:function(n){return u(n.getTimezoneOffset(),":")},ZZ:function(n){return u(n.getTimezoneOffset())},X:function(n){return Math.floor(n.getTime()/1e3)},x:function(n){return n.getTime()}};function p(n){return n.match(/\[[\s\S]/)?n.replace(/^\[|]$/g,""):n.replace(/\\/g,"")}function u(n,e){e=e||"";var t=n>0?"-":"+",r=Math.abs(n),a=r%60;return t+d(Math.floor(r/60),2)+e+d(a,2)}function d(n,e){for(var t=Math.abs(n).toString();t.length<e;)t="0"+t;return t}n.exports=function(n,e,t){var r=e?String(e):"YYYY-MM-DDTHH:mm:ss.SSSZ",a=(t||{}).locale,o=c.format.formatters,u=c.format.formattingTokensRegExp;a&&a.format&&a.format.formatters&&(o=a.format.formatters,a.format.formattingTokensRegExp&&(u=a.format.formattingTokensRegExp));var d=i(n);return s(d)?function(n,e,t){var r,a,o=n.match(t),i=o.length;for(r=0;r<i;r++)a=e[o[r]]||l[o[r]],o[r]=a||p(o[r]);return function(n){for(var e="",t=0;t<i;t++)o[t]instanceof Function?e+=o[t](n,l):e+=o[t];return e}}(r,o,u)(d):"Invalid Date"}},function(n,e,t){function r(){var n;try{n=e.storage.debug}catch(n){}return!n&&"undefined"!=typeof process&&"env"in process&&(n=process.env.DEBUG),n}(e=n.exports=t(335)).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},e.formatArgs=function(n){var t=this.useColors;if(n[0]=(t?"%c":"")+this.namespace+(t?" %c":" ")+n[0]+(t?"%c ":" ")+"+"+e.humanize(this.diff),!t)return;var r="color: "+this.color;n.splice(1,0,r,"color: inherit");var a=0,o=0;n[0].replace(/%[a-zA-Z%]/g,(function(n){"%%"!==n&&(a++,"%c"===n&&(o=a))})),n.splice(o,0,r)},e.save=function(n){try{null==n?e.storage.removeItem("debug"):e.storage.debug=n}catch(n){}},e.load=r,e.useColors=function(){if("undefined"!=typeof window&&window.process&&"renderer"===window.process.type)return!0;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(n){}}(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(n){try{return JSON.stringify(n)}catch(n){return"[UnexpectedJSONParseError]: "+n.message}},e.enable(r())},function(n,e,t){n.exports=t.p+"assets/img/pan.07613e22.png"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHsAAACYCAYAAADEF5ZTAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAOfSURBVHhe7drJTuNAFEZhm0m8/9MiJKBTaV914XYSl13DHc63iWHB5vdxxRLzz8V0x3yxXMK4h2MLRrdv99iC0e16Wj53K705oEdx2Tkqt6W47ByV23Kq7ByV61dtbMHoelUfWzC6PqfO7Hta3UQ4rlnZOSrXoVnZOSrXoUvZa5Q+Rpey1yh9jCFl56i8nyFl56i8n+Fl56i8reFl56i8LVVlr1F6XarKXqP0ulSXnaPy81SXnaPy88yUnaPyY0yOLRi9jOmxBaPvY+bMvsfDDduDi7JzVH6bi7JzVH6bu7JzVP6bu7JzVP6b67LXopfuuuy16KWHKjsXsfJQZeci3uRhy16LUHrYstci3PSUvcFr5ZS9wWsAlP2Ap8op+wFPMVB2AeuVM/YBVkdn7BOsjc6ZfYK1UCi7EguVU3YlFqKh7Aa0Vs7YDWkbnbE70DI6Z3YHWoKi7M5GVs7Yg4wYnbEH6zk6Z/ZgPWOjbEVaV87YCrUance4Qq0CpGzlalbO2EbUGJ3HuBE1oqRsg45WztiGlY7OY9yw0lAp24k9lVO2E3uipWyntkqnbKe2IqbsAKRyyg5AgqbsQCg7kPpjf31NPx8f10/oUnXs68jPz9P8/n79vP4MNaqOPb++Lld/zS8vyxU0qFv26rse3/10qXtmr8/p7+/lAhrUf/W6/Lmfz89pfntLb/PLL6EB79mB1H/1glqMHQhjB8LYgTB2IIwdCK9eAfDPC0HI0AllO5WPLCjboa2hE8p25NbIgrEdeDSyYGzD9o4sOLONKh06oWxjjowsGNuIMyMLxlauxsiCM1uxmkMnlK1Q7ZEFZSty2fip1dAJZSvQcuAcZQ/Wa+iEsgfpObJg7M5GjCwYu5ORIwvO7A40DJ1QdkNaRhaM3YC2kQWP8cq0Dp1QdgWaB85R9klWhk4o+yBLIwvKPsDi0AllF7A6smDsHayPLBj7Di8jC87sG7wNnVB2xuPAOcpeeB86CV92hJFF6LIjDZ2ELDvayCLU2FFHFiHGjj6ycH9mM/Q/bstm5P+5LJuht7kpm4Efc1E2Q+9jumxGLmO2bIYuZ6psBj7HTNkMfZ76shm5HtVlM3Rd6spm4HZUlc3Qbakom5H7GF42Q/czrGxG7q/72Iw8TrexGXm8Lmc2Q+vQtGxG1qXJ2IysU9WxGVm3amc2Q+t3umxGtuPw2IxsT/HYjGxX0ZnN0LbtKpuRfbg7NiP7cvMxztDeTNMfNxjouxAtsQIAAAAASUVORK5CYII="},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAKsSURBVFhHzZjLThRBFIYZQENIxAXCUgNuvL0BGF1A8IKyM+Ed9C2MvoAbY3SL8ALgzgiTGOOChQILgYgbYzRRWZloxu8rzkRHZGa6Z6D5ky+dOtXnkq7uquoqdWRUpVIZ4jIBo3AWTsExUNvwHlZhCZ6VSqVNrk2rqYIooovLLbgNp2EBnsNbMOF3UH1gwefhMlyBdXgAcxT3i2tropgxWIUyTMGR6Goo7w0ffY0xFl3ZhXMPPIRNuBHm3DJGxDJmT5ibEw4D8ArmwGFoi4wVMY09EOb68kZYg7uQ+aVvJGNGbHPUL4obeuEl3A/Tvskckas3TLtF5yN4Cm1/Mv/KHDBjzjDVig6/pg1o2zvTSOaKnLVfH4ZOWIGWv6asIuckOCU41+2IxjQ4s+YSvknRzCxcF2E6msmwBFPRzCx8k6KZWbjehHK1MQQfoTsZcgjfpGhmFq7dYA3DnbRdbxZYZ36m3gIUuedhwoJGwIWyaFnDiAW5MrtqFy1rOOf4fYYTO7Z8wj8pmrmEez98cbb8QbuPcfS6p1pNSPy6sz/hj3LZdshUS8naKipzyPqjmUs+PRXNXMI9DZlP6AO47Sxa1rBlQStwQUvBSl+7BbmGXdJSsPwpKDt2w3B4lg6+xg1s7+B66i1G12A9akkVHrrtRxe4SZoM04HJnJH7zwZNYShyCzseplrR8QRmornvMhc8juZu0XmQv0H3Itfev0GKGw7Pj2JV3DgIr2EW2v0rbUxjD4a5RtXVvkbMB5+4XISvsIxzy19fxFgGY45Gjuwi0Dj4eF+AJxhZj2P00dcY//+a/lJT7wiBqgdWd2AY3JC7B34Dnph9A3UcPFFzsXZtSjMweGA1y1NpeGCV+aWlOLcJV8EjvTNwEqrvmSdpW7AGzvzzFOEJW5Pq6PgNYhdl8cqxD7MAAAAASUVORK5CYII="},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM8AAACyCAYAAADlPZtAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABtPSURBVHhe7Z1bbGXXWce3LzNjjy/x2GZiT+aWSTwzTVIlpG0QBUIihQgRBBVNnwAh8YLEAwKpSBFQeOGBl74iSpSiRNAoQqIdQUUaTRO1HSj0ASltaGjuaWYSe+Lx/XJ8m8P32z5/z/L2PvaxvY/PPud8P+nL3nuttY8z56z//r513S1RFJ0cHh4+3tLSMm/njlMXrK6uHpmeni4sLS29b5dL66kHS4sJ51PvvPNOV0dHx3IpzXHyTsuVK1euPfnkk21jY2Nzdv3xevLB0moeZ86Eg3KLbm51YERLM5cvX75qwiFaWjWrCS0nTpy4cO3atT4753/McfIMwlkze8Me+jN2vN2MiGnS7MBpLR0dp14YKwlHICigLieNPOVnDn/AceoBRECY9mF8tQ7R0iGzIyl22Iy8djMJKVMknjCmdHPLoxGuvWdeh6MgHaF0m3UF1mnWYUZeW8kyF5DaPLfZOf8jjpNHqPzvm3A+Wr/coLujo+Pz7e3tZyxvpZS2QbFYbF1cXLy6trb2TbukXUQdv0leFnjY5uQdhDNhltYd3fL0008vzs7OTs/MzCRtytJnH3/88fNWDufgYZtbUxkVnmGUq+ZZ0rqkD7W1tb1px++ZfT9h3zUbNTeD+Gj3cMwU9zxOXpGnuGbCWSidb8FCMspRj5OGWPQZyetM4EMdJ49QN2+UbL9UpZ67eJw8Qr3E2xCuhb1ruULiSYs33dxqYUD7hnCtJhM+K8U9j5M3EBChWk2m3OwG9zxueTJQuKbr3OKex8kL9ITRvvlpnts5IaHncZxaQzunbhZlsp4ndJtubrUwHuLMIhg3qxs8bHNqDXVw0ezDemjnhLh4nFpCO4eJmggn193Sabh4nFqCeJjwORVf7YHW1tZMp9zsBoknGYO6uVXbqPTTZh/tJ1xbWYlXItREQO55nFpAZS+Y0bu2r27piYmJeLa0iejABeSex60WxvSbURMOHQX7ofD1r3/951566aW7TDxrBy0g9zzOQUMFv2HCoWt6vyyMjo5+4ctf/vIXL126NLK8vGz6OTgBuXicg4T6Nms2Gl9lwPnz52f7+vo+9ZWvfOWvXnjhhYdMQEsLCwutdozzq1nBXTzOQYFHoDuadk5m+wgUCoWWc+fORXffffc9zz777Jeee+65h5eWlhZXV1fjtlBmfygFiSctLnVzy8qAeoxw6CjIDAvTopmZmairqysaGRk59fzzz//FV7/61V9ZNCy71T2PU+9Qz66bcOiazhT7TDZ9j+bm5qLOzk7CuKFvfOMbf/bMM8/8qmUvleRTlXaQi8epNoRPrM2p2mbsCKhYLEbW1okFdOHChUET0J++8sorv3iorU0vMMhcQBJPmqt1c9uvUWGZJc0WuVVfZiABHT16lDbQiZdffvn33nrrLbaeImTk/yVTAbnncaoFFTWr8ZyyIJgQrgnhuru7o37D3NKvWfInyDKrinjCp4WbW1aW3JS9KiCYUEQS0OHDh6MTw8M9lvTnZhfJMsvMYbjn2SU3b27+oZxUqFdTJpyqr8+5efPmhnj0u4RtoCNHjkTHjx//WUv+G7MTZhTKxAO5eCpkbW0tWlpejj76aDy6MTEdLa+suojSoWLSzknuK101+G0QEYQiIg0BjYyMRKdPn37Mkv7ajA3gM6n3+hD+mlsZsx+hODk1W3zpWz8ovv76+8Ur3/th8bUfvV1cXV1LLd/kxjRnxnMO5I1tEgsWeiGBsAjhLl68GA0NDf2uJT1Fstm+dxB1z1MBa/aj/OT/fmpPsFPRY499Onriic9G778/Fs3MzG/6oZwYFrZlOhC6HYRora2tsXBkoN+F/KWlpYgx0/vuuy8aHBz8Y0v+HTMEtK/67+KpAH6HxcJS1NfHa2Ci6NCh9qi7uzMqLC3Hj1onhqf4gXQQpIFIJB4JZ5OACoU47/777+818D6fMUNAe/Y+Lp4KYLHiieHB6LXX3rE2z43o9dffs6fZsj3FbmMHlVKppoZ6xEBoFjOl9wQCKScgndP+oQfu1KlT91pZBDRIEbM9/YgSDx/gVsba29qKd4+cLJ64Y7D44x+/W5ycnC3+/Gfvi9PTyjeZUfHoIGD6zXrMVAMkHkI42jmYRAOcISraP6dPn45Onjz5W5b0B2a8ehF2LSD3PBVy+NCh6Pz509HDDz8QfeahT0TH+nqitrZ44m4zQ/2hg4Cl1FvezHbQSDwc5YGSFCx8w+65556op6fnTyzpETOEs2fxhE8StzKGp7H2TvFQe3vRfqTUMk1kQO1EOFWbQbAf8DwK4WSIa35+3tqth6K77rprwP7fv2RFeSW9BFSxiNzzOHsFAX1sla8mHQRCYzwSB+B5YEM0gQdS2o0bN6ITJ05EZ86c+SVL/n0z3p69q1DCxePsFUSTix0+w/AMYSAehW9cxwIL2kCksw6IDoTz58/TifBFS77fbFdjP77drttejDCNCZ+c1xS1bZIdBBIQdhMBlcpRBlP4Rrv14sWLfVb+L+22XXkf9zzObuCprA6Cqi8xqBSJAiQOneuIuJIgMMK34eFhet/oOHjSrOLBUxePUykIh4qFcHK3NS7iCAWCYBBHSBy+mdBAIsMI4U6dOtVp3uiPLOu4GTfuGL65eJxKoCLxGGcGQdk3U9cCtW1AAkIQIAFRBpQvAYnZ2dmot7eX3rd77fIPzSryPi4epxKonbzqsKY9a+UIPYxCuFAgzAKhDGnsd6AyEhnQeWDe59CRI0e+YJcsnuMDttWHMino5pZmwEbsbFR4q7blCIQhASEMCScpIsqQlha+MXG0vb09Onv2LMu2mX0Nt1SZgnseZzuoPIRphGu3amEOodcMcUg8EgVwJHTbrgzXCGh4eLi1q6vr85b0abNtwzcXj1MOhMPOM7nqWSuHRCBxEJ4pDfjHqH2UzNeRaTtMHDUB4X2eMKPrmltTPZDEw91ubqHlZs7adlDxVfnlXYA0RCJUBvGIsHMBuGbtDzMPuru7f9OS7jGjwLbicRxBRaHCMEv6wBa17ReJSN5F4onTyS+VIY8y5Knto3uBjgN2Hx0YGHjALj9rdsQs1fu4eJwQCYc5a3NxSs6RSIQEIkJhgMTDMRSPIJxDQCdPniSE+21LYtOQLcIBF48jVEEmrWJlvi1utVDoFYoEYWBcI46kdyEPuE4TEOJh37djx47heRj7oe2zRSsuHieEcZyarQbdK2Hl1zHsHJCBjuRjlA+Ne2j34IGYtmNtKHreWH9fVjx8olvzGrAalHBN13UBYki2XbAQliQoX8j7kJ4cOEVUTBodHBxk3c/nrBjrfdrNNgnIPY9DHaBjgA6C3HdJp5EmGEAgCEHCCAWifM4lPlAeYz7kDw0N9dolb1zYErq5eJobHr+M5eBxct0lXY5keCYQAemxQOw6Oa6zkWfnulf5ojRoyt9gtjV7HeB9NjoPXDzNDRsTIpy66ZJOggCAyh8KRHAdCkRwzr0Sn8rJSGOzEN640NPT80m75YIZenHxOPEDedwqSa5mSe+FsPLLg5CmvJhE/nrSevtGoZ167oTKHz9+nLEeZhzAhmZ0wh1uzWHAccIqVl2M5eyEBEJlD4Uh4r31zNbMM4Vd29yHcIDrZGiH0W09ODhIoUfNNoVu7nmai9JjOH6DATOlGwYJKPQgGOnxhFDL4zr0LmEZ0sP7gHTmu3V0dNDrds6SRuKMhHgo7dbYJqatUtTdWM52UNnVdkE8MtLZvwCUh0CUh5EusYDSQ4Ph4WF63X7ZjIaTe54mgx981qyhhCMQAUg4Qh5H6Dw8cq/Ct6RnAnrdBgYGeDXJL8QJ66Gbe54mMWAQlA6CWzWrwZAXSVopc0NgYXimfN0r8VEGSGPGAS8Kbm9vv9uSTpJsVpKb08hQY9iwoyGFo8ovQhGIUCAgcSTTOZKO6XOA8qwy7e7u/hm7vC9ONFw8jQ21gsFPhHMgL5uqBVRyVXS1fbim0ktaEgiEwgnv0+dwn8QXXvf19fVbEhNFuck9TwMj4TAIyiyChkSVHCQEID2+LgkCWkoCAY7hOeJCQAgrFI6OhG69vb1M0eHFwOgmFg8l3BrLQB4nd3usZY2EQOWXB1H4FQoAyGc8R3lKh7RzlaE8Lwe27/OUJcd7u7nnaTzwODw6GQSt22k3e0EVXWHWhgeJ/7seuoVlOILSdE5eKDzgnDcrHD16dMguz5Ik8VDKrf4NqDFsE1X3024qQZU9NNK0zECQFooBVFaGuATXYT5iIr+jowOvg/fxDoMGgl+e2sHsAbqlm4Iw/AqNih6KKUxnxkGYJjgPw76wDJ9DWnd39zEregflXTyNwYZwzBgIbSokEIkFwoofEqYlhRWSTJcns3YPmsH7tLl4GgN+YZZQz9qTdXMtaHCo3HiEUAg6D492sm4G3idZViiPzxTKJ4193QzGe7q9zdMYhmgI1zhvKqj8Eo9MosBiAnFwhkCA+ySMUECCtDAfK+06ylu0+9zz1D8L9mPyGvemBZFICJwvLy/HbRdmQ8eV3srIWJ4gIUB4jqgwriVCXQNHetwsdMPzHHPx1C88PhEOby9oWuRhMNolvGtnYGAgunDhQjyhc2ZmJhZSiAQhUUAoEEzi4ah0zvE87e3tzDTo9bCtPg1YyNaQM6R3g0SD5+E4MjISnTt3Lvrwww+jS5cuRZOTk7G3kCggPCbTQ+8D4bm8m4mnxy673PPUH3gc3gnalG2cNBAQHufixYvxZoX//uKL0ZUrV6KF0ivjIe6OtIovgXDkPkzpyiMNwnRMZU087OPm4qkzJBxmD5Raw80N3gDh4G1o4+BtPrx2LRbREbsWespQ+YVEofPwGIpKSFQWunXaocPDtvoxYLoN2+G6cEqoch87diy6fPlyND01FXV3dW3bMQC6DtPD/BCVkaCsDYVu4gEfJ//gcZjgicepy40JqwWzne+9997o3XffjcbGxqLOo0dpqKw/cUqVHhPhdfJcx6QJeZ5SB0S7e578G7hwysC+avDqq6/GC9ZU2Wm7hCSFkHYepsnLAMeUMhvicfIJNYClBYRqLpwU7rzzzmh8fDxaXFiIBSPRpFV8SJ6H5XRMlhHyPCU2OsBvlXDyAL8HtYBFbHichl0Ful9YY0O4RscBX1i5ih+KIjyHMF2EZXSOISAP2/Jt/C4IB4/jwtkBBkLZYgqvE3+BpYoO4Tkkz8NyOmJJDwaJtJsetuUPF84uYFNCdvUEqnRLqfKXs7hccA5hfpi3Xbrh4skZPNroHGAA1IVTAfS2EUbFXmdrBS/bBkqWA6Xrs4TSE+cunhzBr4zHQTh1+bqPWkGPWywRKnacsi6asNJDeB6SLKeOgWS6KOWvSjyUcKutucfZA8xnY4DU1BKtBZVeAkiKSOe6DlF6Oc9DOtA5Yay4eGpvgGBmXDi75+23346n4hwOJ38GFT0pgiRJcQHnSg+9kI6WxkyPZQ/bagu/MCEam697qLYHGOOhQp8+cyZu/8SVO6j0EoEoVf6y4gqvIRRXqYsab0cPRcHFUzskHG/j7ANmFbzxxhvxxNCenp5oxQRkNX2LCEJhhOcQXkt0QFp4LcGZeFgOsuDiqQ187/I4PnNgH7DkYHR0NPrggw+iBx98MGo1MRVKHghLepgwPS1Px2S+0jiaeNhoZa7VErjD7eCMX8Q7BzICz8BShDfffDPuPHjooYfiTTp4n6jEsC4B+/JL18B9EgXovFyaYPmD/R0WIU675zlYJBz3OFXgtddei5deP/zww9GpU6fiAVQqeygAesqSoZjySMdIg1A04f1mH9upi+eAYRyHXjUXToaoIY9YEBBtoAceeCB69NFHo66urmjVKnwoIB01uApJoZAuYSmPazYXMfA8sy6eg8PbOFUirNxw7dq16MUXX4y9Tk9vb/wiX6FwDUJhAOfyShKO4BqxlcTDpitrEg+l3KpnCtVuxQtOpqiiS0C0f0hbv7qVD5xj8li6xiQuPicUEGXp2TPvRk/bKLe5eKprwKOKTQldOFUmFIEqfXwen23OTyNMD8uF7SATD15nk3ic7OHbxuPQxnHhVJE0McirQDK/nEhgu2u8mYmHzoKrXLt4qoOE03R7Rx80ydArbNOEpOWF1xx1jpfBwrJc096xe/A6H5m556kCCIftoVw4NUCCoLKntWkw0jHKKH870VGOsaPFxUUiiPfMeDD6rOoqGMKZd+EcHBJFKAAJQ6Tl6Rr0GUnBAeVZ7r2wsMDrW94i22yjt83JBhdODaGyI5IQCQDSvEsoEuA86ZWAe+fn5+ks+HGc4OLJlEX7wtl43YVzgCTFokq/iYRAkmX4DGYOUIY8jmF55s8xY3tlZYWOgnfN+KMungzgW0Y0TfEO0DxCRQ9FlCYAqOSaeyUu5TNLYW5ujpHWH5lxZMDbB0n3YcAvhnAI15waQkUvrfDcJADYTjScb5ePKPmsqakp3vP6XySZISDvbdsj/DJ8ibRvmup17XlFFZ6KniYGeSa1Z1QmeZTouMboZUOUhULhuiX/r9kW8XCnW2UGPOLm7IuOJzo5tQVhqPKDxKG0+GgWCkPH8F6ExbmuyWOJ9+zsLAn/Y0aEQTc1v797nj0g4fjqzxwQVnbEoa5mQR7LstOI80wgGPdKXKA85rPNzMzgaV4248gDM44PXTy7Q8LhS3RygDyHKr6EJJLXgvS0PKXxufGy7pUVxnc+sCS6qHlgYnEhF0/lSDjxU8fJH+EAZ3iMhVXyLEnBcF0urbOzk5CN8+9aMrOpN0I2sw3xcOFW3njaIJz1VqeTe0JRyCsJpYs0UTG2Q/rExMSKeSFCNto7dA5tEY9THoRDr5oLJ8ektXVCS+YTlmGky1SW3rXe3t54Iujq6up/W3HCNsbxqAsb9cDFk44eVTQOfdZAzknzHCH8mMl8rpPtJcHr4hETb9I2IX3Lklh2HU8GNdv4IBfPVvRNFuxLdeHUAar8CEGiwEiP8xL5OhdhOvfR1gFr7zAdh1kFTAjd1N4BiYcEt3Vwy4jGBz/rgGQ4BqFAYgHFV+uQhkBgQ1wlSOfz2MpqamqKkO2blnzNDOEQhWwK3d3zbEbC4ctyGoDYq5TOhcQVCkew9IB08zoseqO9wwaHPEgJ2VLFoydvM5uEQ6PQqVPkVZKE3khIPKGY8Dp0Ty8uLn7Hkhjb4UGqkG0T7nnWkXB88LOOSQpD4hBpwhGIju5pbHp6mg6C/zCbNMPrbAyMhrh41p8oCGfLk8WpL7YTByAQyoTlBOV5SVbJ6/ynJf3AjHaOxna20Ox7VfNEYRFbuq936oYwXEsTTnGHfGZP43UmDLuke5q2DssQ1FFAfdlEs3oevj2EQ3e0C6fOSQonKY40TwNK534GRc3rFJeWlgjXvm9GO0cdBak0q3gQDZb+rTp1w07CgVA8dEWHZbiflaIcx3lTVhS9YMZsAgwBpXodaDbx8CUs2ZeHK3YajJ2Ek5aPaFizMz09fXN1dfXfLOl1M+axIZ5Ng6JJmkk8fAl4GxdOA5I2WJokKR6E09/fH79dYXJy8h1L+hczvA0zqLcMiibRX6RiNbLxBKFjwLuiG5A0jwKbvE5CXOQxIIqNjY2tmZCeteQxM6bi4Hk2zWNLoxk8D8IhVPOu6AYk2YYRiEPiScsnjU6CmZkZFrxdtiRmEyAcLHVcJ0mjex71qLlwmggJJ000QLh27NixeOnB+Pj4qJX9miXTWTBjVnZQNEkjex6+gGX7Anf8EpzGQh5HAgpFhHCYgsO4zvXr11dMQIRrb5tNmzGuU5FwoBHFwz8c0bhwmhAJB5KdCOSxVoe9CVirUygUCNdeMWMbXXmdiqOURhOPhMPTw2kyEIfEk9b7Rtptt90WrxC1cO1NK/tPlszrQsJOgoppJPHQrUjHgPeoNSGhcMIwLUS9axMTE1NW9h8t6SdmdEuHXdMVRysSDzfUq4H3qDUxtGNCj5MUD3nsv8Zg6NjY2KqFa5csmXAN0YThmupTRdS75+FbWrUvy+eoNSkIR6SFaoCY+vr68DjMJPiO3fO8JSMaOgm0sceuhAP1Lh68DSPCTpNTTjh4nYH+ft5yQCcBi9ueNmOdDqa92MIopmLqVTz8Q+kY8PaNsyVMA4VxTPqcX1igW5qOgb8zY1MP9a5tO/FzJyQeKa8eTO0bF45Tto0DCId88ziszfl7M3bCQThcVzQFZzvqSTyAcPA43r5xtoXOAQZC52ZnqSssM2BlKAvdsC0bGO6FegrbeEqsmHAkJMdJBY/DLIKZmZnlwvLyDy0J4eBx1M7ZccZ0JdSDeBALPWouHGdbCNfYhwDxjI2NLfb3939roL//VcuiVw2Pw2AowslkSCPv4pFwvH3j7AjCwUZHR1dXVlaeHxoa+lcTEm0bxLPr6Tc7kWfx4FZp32T2j3UaD43z4G1KHqcwNzfHtJuvmeeZsvAN8TDhk5416lJm0UtexcM34mGasyPseMPyAvaXNuEslITDIOiNgYGBqSOdnXibffespSHx8KF5MUTjM6KdimBBG+tyLFSbMuH8gyX9sxkdA2PHjx+fNlGpV031KzPy5Hn4h9G+8TDNqZipqamjV69evT4/P/+3dsmcNToGWE49efvtty8eamtDOBJPpuRFPArTXDjObjhsonnV2j3P2Pm3zeiOjoVjVjh79qw5pbWqRTC1DtsAweBxdO04lcKLdNjdk3eGIpzrZgiHQdBoaGiIkI7pB1vn72RArT1P3A3twnH2SJsZomHe2sdmdElvdEcfPny4WFiu3k5jtRIPYvH2jbNfqL+M3xCqIZytvWrBkoWsqYV4JJzq/aucZoH6y6wBJnpmPo6zEwctHgTjYZqTFbRlEM2BCwckHv5otc3bN041UJh24PXqIDyPhONhmtNQVFs8CGbNvY3TiFRLPIgF0bhwnIalGm0eeRsP05yGJmvPU3Rv4zQLWYonFk7p3HEanizEg5eJ2zfrl47THOxXPB6mOU3LfsTjYZrT1OxVPB6mOU1Paynk2o15mObkhqeeeqp0ti0Mm2ReZ3fjebx94+SOBx98MF7oViwWW0OLM2F9A3iiJCzTulupeG6aaHzQ08kbSzdu3PjU9evXn7Tjb4Q2Pj7+ObORlaUlNgBh8mjm9bflzJkzd75ncL6etAU8jnsbJ4/0mP262Umz8FWaqq+sNP2pGfsbsGiO9OxEhHjMzbUk3R5ppSKOk1eOm50w6zbrDYzro2ZHzBBQuxlRVqZ1OjVsI0Rzb+PUAYiBkIyNCkIjjTYOXoYyHLGqtnkI0TKPDR2nihCuIRitKJWRRp5ElDmthQKbjcR428apZ6i7SQMdq8InH3nkEWJCx6k37jKj3VMTiAfvMOs346U/jlMvdJgRkr1vRpjmOE59EEX/D+KD7nWBGZg/AAAAAElFTkSuQmCC"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAANrSURBVFhHzZhLSFVBGMe9aiXSY+FjmWj0onbZzihCsaJyF7SqrVC0a1ktorYt2kSYG0F010YNhKIUxCKN8hFRkqsyi7JA5L76/ed8x9Sb3jP3Xq0//Dgz33zzzdxz58wrVuSpdDpdy6MZGmA/1MA2kH7CR5iAAXgUi8WmeEZWpA7RiRIe5+AS7II+eAJjoAbnQNoO6vABOAYn4D3chW46l+SZn+hMI0zAILTAJivKKvlaHdVVjEYr8heVy+AeTMEZM+csxbBYillm5miiQhUMQzfobyiIFMtiKnaVmdeWHGESboL3oM8mxbTYamPtTuFQDkNw20zrJrVhbZWbKVMU3ocuKPibWSm1AZ1q00zLRYG+Jg26go2ZbFJb8EFtmykQhmIYh7y/Jl+pTdCUoLkuEJnzoJk1kuLxeM/nmW/9o6/e7TZTXqLtZ+qDZZ1hAFosm1X4ppPJZDqeSMwnEolrqVRqsxXlJMKdhcEwUwufoNQZIgjfldIrP2rF3qJuKagPdcXktd70sc4kXKmfLsIs7IPHBGyHShX4yNruhWb1rgMUOLLwd7J0JbRBSjb0BS6A19RhdTqUGIHDZo8k/J0s60S2AV67gkB6Y3utOKvwrYeXSsyC12vG38myi8Kk1f0q/FI5WoAbkHUxxacCviqhSlvMHkn4O1k2QxTVwEPnFGjYilYVPpthQYPa5e1ZKGkjlgqSTkvTa4te6S+rsGwk4e9k2UVhKoErMKdylNNfpkFdb/ZIwt/Jsk5kD8FzVxAol0E9or9sHA46aw4iyFa4Q3II9MM0L2kaOc788pZnVGkfPqaArdAe2KIJ/1DaL08HSTcP5TQxSla3VYk6yHfp0O5Pp4ycRN3FpSM0eC+upnm4DoVbXCUyXtsPfHugH/aYKS8RJ2P7oc9VK/ZpM22Y1Ka1/WeDJmHQFlbbyX+xhW0y03JR8AA6LbvuUlvQZtlMUbiRx6Bb1tbqxyAJh//noBgKx2p4ATqjFfoorZiKXW3mZQpX+2Viyp/hcQS+wyiV8/76LMYoKGaDteEvAjWBXu9T0BnK9zpGdVRXMf7+NS1RpDFCoPDC6jJoeteGXBdWb0A3Zj9A2gG6UdNiraXkFIQXVl28lawXVt6Dls7phuwk6EpPp42dEI4z3aRNwyRo5u+lEx5XekVFvwGChLxotSbj3gAAAABJRU5ErkJggg=="},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJgAAABsCAYAAACWwXsuAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAOjSURBVHhe7d1JaxRBGIfx6YxJUFBQL4KexBXxIEjiQsAYcvAL+GlFPYkgeBIvCp7UmwcVFHH7v101GJNZeqmaeSvz/ECqa5a++FDVmUlmBs6t/9lHt10IdwH9rMWmDtB9RIZehrGlifQYIkMnVWxoJj32YngKvKri6IXF9TseN1JV1SUNb8IM3rgKLK5KrSkyW8nehhk8cRNY17hGiMwnF4H1jWuEyPxZiePCpIrL6FR2LXY5zODBQgNLGdcen+MIBxYWWI64tEVuavgYZvBgIddgmeLa0PAizODF3AMjruUy1y0yU1y3NBCXU3NbwVi5ltO8VrAHcUwmXtATFwa7tnqlpHNaXMBgOzaRjM5p11zAYCs2kYzOSVyo3YlNJKNz3g6nxrLLERfXXKhtxCaS0TmJC7UbsYlkdE6uuVC7HptIxs4ZTo2SpXgl/6p6eB2Pk6iq6qGGZ/q3Vt+AUg37BpY8Lhwufd4qukZcmKVrYHZB/yoeAxN1Ceym4noZj4Gp2ga2qbj4DQY01iawu4rreTwGGmn0U6TCstelgNZmBkZc6GPaFll/yk08BjqZFNiK2mr1KTfAOOO2SIvrVzwGetm/gtknCxIXktm7gllcP+MxkMQoMOJCFrZFrhIXcuGlCGTV5q0ioLXkK1hVVSc0fLHD+gYsNYsgZQhstwAAAAAAAAAAAAAAAAAAAAAAAACw1PjLbmRj36lOYMiKjw5ANlrBrrCCIQvFdV7DOwJDcorrnIb3dswWiaQU11kNdVyGwJCM4jqj4UOYBWyRSEJxndbwKcz+ITD0priOa/gaZv9ji0QviuuYhrFxGQJDZ4rrqIZvYTYegaETxbWu4XuYTUZgaE1xrWr4EWbTERhaUVxHNDT+XgUCQ2OKa6ih1XdZERgaUVzWSuuveCQwzBTj6vR6KYFhKsVl36PQ+cX41F/EgPmq/+NzvRsT4+qFuArnOS5DYAXzHpchsEKVEJchsAKVEpfhp8jC5IhLXe3kiMuwghUkU1z3NTwJs/QIrBAlxmXYIguQKa4dDVnjMqxgzmWM63GY5UVgjpUel2GLdCpTXLsa5haXYQVzKGNcj8JsfljBfBkeprgMgflxUm01/lXkphTXtoaFxGXYIp3ItHJZXE/DbDFYwZxQDKfiYRIe4oI/9TVYXzrPvXA64KCV2Eknej5xYaZOkel5ti0CjbSKTI+3N66BVhpFpsexcqGzqZHpfq650NvYyHT7Vrjbq8HgL2v6ILWlOg1gAAAAAElFTkSuQmCC"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAXi0lEQVR4Xu2dC5QlRXnHv6/vTpbVVSISyZGoQSR4VFCTFQ3uzFTVnd1Z9oAQjICK+JYoenzgGxUQRVkiiBqiPMQHYuShwV1XFuZ29XVwAVkSRYhKghpRoy7Ek13Yx+zc/nJq984yDPPoR1Xdrr5fn7PnoFP1r+pf9e/2uxqBF2sExsfHn7Br164hRPxbADgCAD4qpUysNcBBzgm02+2D0jQdIqIXmjFE5y3WvIE4jg3IYUQcAgDz3/tPW2XJglR7AzjzzDOjZrO5oiuFGcMXAMDiqV6zIAXGL47j4SiKVhLRKAD8zTwRLEgBvq6rrF279jFLly5dCQBm/My/g+ZqkwXJOBpxHI9Ok+LZGauxIBlBuS52ww037Ld48eLdUiCi+XF7cpY2WZB5KGmtnwEAJwHAiQDwnCxAZ5RhQQpAs1ml3W4f2el0Toqi6EQielLebBZkFmJJkhxFREYKI8fe49G8cAGABSkArWyV9evXL16yZMnUD9tRZfJYkC69DRs2PGnx4sUnpml6EiIeWQYqn6RbopczRmtt9vJTP2xm71966XtBxsbGnthoNN5MRG9GxEzHpTmo8x4kB6yiRdvt9mFm/My/ohl8kj6DgNZ6KSJOQZ3zKkZJ4CxISYDzVR8fH/+ryclJI4X5V+ZQeM5m+m4PsmnTpoEtW7aYvYWB+kyH42eiWRAHgL///e8/bWJiYvcYEtHjHTSxN7KvBNFan9r9tXmuS6h8DuKG7saNG/ebmJh4e/dQ6s/ctPLI1L4QpNVqDUVR9AEAWOUDKgtin7LW+mRE/AARPct++tyJtRbkpptu2nfRokVGjPf5hMqC2KNtTsA7nc4HEPHl9lKzJ9VWkCRJXk5ERo7DsuOwXpLPQUog1VqbHzYzhvuWiClVtXaCjI2NPavRaBioJ5ciY6cyC1KAo9Z6Vfdwyjw82NOlVoJorU8joo8i4n49pfpw4yxIjoEwVxi3bt36CQA4PUc1p0VrIcjY2NgBURR9AhFf65RW/nAWJCMzrfWLAOCT5tWBjFW8FAtekHa7vTpNUwO2l+cacw0WC5JhM9Zav7Urx2MzFPdaJGhB4jj+CCKe7ZVYvsZYkHl4aa3/vCvGq/Nh9Vc6SEG6J+Jmr3GMP1SFWmJB5sCmtT4aAMz5RpHXCAoNRpFKwQnSvWF0XtYXXopAsViHBZkFZqvVOiuKojMtcnYWFZQgWutzAOBDzmjYD2ZBpjHVWu+PiBcR0Svso3aTGIwgcRxfjYgvc4PBWSoL0kVr3uxL0/QiAFjmjLaD4MoL0v3VaRHR4Q7W33UkCwIAWuvXENFFiOj0yVsXg1lpQeI4fjEitlw96+8C6IzMvhckjuNzzV1xD6ydNFFZQeI4fh0iXu5krf2F9q0grVbrwCiKzCHVS/3htt9SJQWJ49g8LvJh+6vrPbEvBWm1Wn/daDSuCPSw+BEbSeUE0Vr/Y5WexSmpVN8JYibVQ8QvA8DTSrKrRPVKCZIkyT8R0VsqQcZOJ/pKEK21QMTriKgqD4uWHsXKCKK1vgIAXlN6jaoV0DeCGDkA4EYAGKjWEJTrTSUE0Vr/S3c+o3JrU73afSFIVw5dPfzle9RzQbTW3w7gmaqipGsvSJ3lMIPeU0G01mMA0Cy69QVQr9aC1F2OngpS48Oq6d7WVpAbb7zxyQMDA78J4EeqVBd7sgep0X2OheDXUhCt9T5E9BAiRgsBCP3v3gVpt9unpGlqrpP3w1JXQTYt8OGg2oytV0Ha7fbxaZpeVxt6C69I7QTRWl8GAK9feNXrUcKbIO12e2WaphvqgS3zWtRKkCRJziaij2Re+xoU9CJI9ys/4/1wzEpE10RRdI0Q4poabB97V0Fr/XYA+HSd1mmOddlsxhARrzEfYHUuyPe+973DO53ONwHg4DrDNVDTNL1wZGTklrqtZ6vVelUURV+p23rNXB8iuhARL5BS/nrqb04F2bRp02O2bt1qHj94cV3hIqIR4sK67TGmxitJksE0TW9AxMfUdQzn+3FzKojW+nMAcFpNwd5PROcrpdbUdP2g+/WtG0J7TTbHePw7AKyRUppHnWZdnAmitX4DAFyao7PBFEXEL6ZpukYp9bNgOl2go3EcfwURX1WgaqWrIOK2Tqdz/rZt29Ycc8wx2+brrBNBtNbLEPFGInpCpUnl79wDRHSqUqr2l6q11u/vzluVn1K1a9wSRdFpw8PDZu+x4GJdEK31oq4ccsHWAyqAiD+OouikoaGh/wio24W6GsfxsYj4r4UqV7vSdVLKv8/TReuCJElyARG9M08nql7WnMQppU6oej9t9K/dbh/S6XTMSfnTbeRVJQMR3yuEOD9vf6wKUtPHSD4kpfx4XrChltdarwUAMy1onZZBKeXNRVbImiDd+x3mku4BRTpSxTpEdLpS6oIq9s1Fn+I4XoOI73GR3avMRYsWLRscHLyjaPvWBEmS5BtEVJvDEER8ixDin4uCDa2e+aoTAHw3tH7P119EPFIIUerGrRVBtNZm+vov1QUuEZ2mlLq4LuuTZT201knVPl6Tpd9zlSEioZRql8kwdUsLYqYGBYBxAHhm2c5UpP47pZT98MzRXtxJkryHiGpzwxMRVwohbrKxPdkQpDbzWCHi+4QQtdlQsmwgcRw/GxHND1wt7lkR0dFKqe9kWfcsZUoJ0mq1VBRFZu7cOiwfllJ+rA4rkmcdtNZfrcgXgfN0e9ayiHi8EOJbpYOmBZQSRGttrlqtsNmhHmV9QUr5Dz1qu2fNdr8lf1XPOmCxYVfnjYUF0Vq/wzzFanEdexV1++Tk5IoVK1b8X6860It2b7311sfv2LFjvA7z5wLAZVLKN7rgWEgQc7c1TVNz3Br6PY9Jswc0L8a4gFvlTK21+T6ged4q9OWOnTt3rly1atX/uliRQoLEcXwJIjox1sVKzpXZbzcCpziY2dejKCp888znGC3QFhHRCqWUs/Pg3ILEcfxCRLy1QpCKduVKKWXtHuXOAiOO44sR8c1Zyla5DBG9VymV+/mqPOuUW5CaTDJ998DAwMrly5f/Ng+sOpTVWj8HEe8goj8JeX2I6OtKKecfA80liNZ6efemYMhswfa18pBgaK3NTVAzAUPIy0+jKFo5PDx8n+uVyCVIHMdfQ0Tn1rpcaTNtjVLKfE6675Y4jg81ew8AeGzIKx9F0bHDw8Nm0nPnS2ZBanJT8Hop5XHOqVa0Aa21OV5/d0W7l6lbaZqe3Ww2z8pU2EKhzIIE+p3y6YgoTdPlzWZzowVuwUW02+2DiMicewT7SAkR/ds+++yz/Mgjj9zuawAyCRLH8SgimtktQl4+KaUM9nPEZcEnSfJxIvpg2Zxe1o+i6MTh4eGrffYhkyBaa/N8S8iHJncvWrRocHBw8I8+4ValLa31X5i9ByI+qSp9KtCPr0kpTy5Qr1SVBQVJkuQoIlpfqpUeVyaiVyulaj8z4FyYW63WWVEUndnjYSjcPBFtaTQay4eHh39cOKRgxQUF0Vqbt+pCfpDvWinlywryqUU1rfWdAHBYqCuDiGcIIc7tRf/nFURrvZSIfoaIT+5F58q2SUQTURQtF0LcXjYr1PrtdvslaZpeH2r/AeA2AFgupTTPzXlf5hUkjuNXIOLXvPfKUoNEdI5Sqq+m65+JTmttXoU2r0QHubh4xyMPiIX2ICF/nvmHAGCme3kwD5A6lW23209J09RMdLc0xPVCxCuEEK/rZd/nFMTAJaKfElGQs3qbO/5CiK/3Em6v2w78mx4PdA+tftpLjnMKorU2s7Kb2dlDXMaklHV407EU+yRJ2kQ0VCqkd5Urcd9qPkHMjcHR3vEp3jIivk4IcUXxhPBrtlqtoSiKSk970ysSURQd3ovLujPXd1ZBxsbGDm80Gj/qFZwy7SLiPQceeODhhxxyyM4yOaHXDfmpXUS8SgjxyiqMwayCaK3PAIAgZ/jw/TBbFQZxlitX5qTcnJw/pYr9W6hPVXodYS5BzHSNL1poRSr49x3dXfN/VrBv3rrUbrdPSNP0G94atNvQzVLKQbuRxdMeJcjY2NizGo3G3cUje1eTiL6ilAr2mr8tclrrzwLAW23l+cyp2pzIjxIk5KtXRHScUirku8ZWtkWttfl60vOshHkMQcRf7dq16/AqTcE0myDXAsBLPXKx1dTdUsrn2AoLNac7JdM9gfa/Epd2p7N7hCBEhO1223y9db/QAPNjJXtGLEmSNxHRF0IbP9PfqlzanVOQVqt1VBRFoT7a/nwppXm8pK+XUOfardKl3TkFCfja+Q1SyqP62ozuymutfwEAfxkaiypd2p1PkFDfG3i3lPJToW0Utvvb/ZTBXbZzPeTd97jHPe7gZcuW7fLQVq4m9p6DtFqtp0VR9MtctatTmA+vAEBrbS7tmku8oS1fklK+toqd3itIwCd3t0spj6giXN99SpLkOiI63ne7Fto7WUpZyfeOpgsSKtzKXRq0sMEUitBam0kp/rRQ5R5VQsRtRHSwlPJ3PerCvM3uFURr/XMAOKiKnZyvT0Q04nJ271B4jI+PP3VycvK/Q+nvtH6ulVK+pKr93i3I+vXrFy9ZsmRHVTs5T79+LaUM8oE826wDnrus0hdYdguitTaPJZjHE4JaiOgapVRtvs1eBn6oX/yq+hHAlCAnAUBwr6ci4ruEEHX4DFwZN3bX1Vp/HgBOLR3kN8Bc1t2vyvMG7BYkSZKzzaznftmUb63RaDx3aGjI3Lvp+yWO4zYihvZ6beWvQO4WJNCJqfn8Y9rPQpIkvyei0KYW/byUstJfupo6xAruDjoiflUIcUrf7zoAYGxs7ImNRuP+0FikaXpKs9k032mv7DIliDkWXFTZXs7esXdIKS8KrM9OuhvH8YsR8WYn4Q5Dieh5SqlKz32AWutnAEBwr6gS0bFKKS9fGXK4jViJ1lq/AQAutRLmMWT79u37rl69eovHJnM3hUmSHENEIW5oh0kpQ3wwL/cgLVQhjuNPmSt6C5Wr0t+J6AGl1P5V6tNsfTGCvIeI1lS9ozP7NzExsXR0dPSh0Prtor9JknyHiFa7yHaViYi3CyEq/wydOcT6JAC8zxUIF7lE9Ael1AEuskPM1FoHNwsNIl4thDix6rzNHuQzRPS2qnd0ev+I6DalVIjTEjnBHOj3P86TUr7fCRCLoUaQy4mopzNo510fc86klDo2b726lk+S5F4ienpI60dE71JKVf4pCHOIFdwnDhDxi0KI14e0Qbjsq9baPCoe1CEnIp4ihKj0PRAzZkaQtQBwtMsBtJ2NiGuEEEGdN9lmMD1Pa701tG+ARFE0Ojw8fKNLLjayjSAxAEgbYR4zKv2ItEcOu5vSWqfmx853u2Xam5ycNBPEef8oZ94+YxzHtyFi5S+3TV8x/jjOwzQ2bty4ZOfOndvyDnyvy3c6nf1HRkbMR3IqvRhB7kLEZ1e6l4/uXBB7PCll4pqr1trcbNvsuh0H+UGMobmK9XMiCu5VWwcDZjsykVI63wgCn43GNnPreUaQEB+Ttg7CQaAXQUKejd8Bc+uR5iTdfAX2sdaTOdCLIEmSvICIfsC43RAwgpCb6L5P9SKI1lqYC1l9T9sRABbEEVjzJrOPcxAWxN0AmmQWxB1fFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5QsyDu2HpLZkHcoWZB3LH1lsyCuEPNgrhj6y2ZBXGHmgVxx9ZbMgviDjUL4o6tt2QWxB1qFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5QsyDu2HpLZkHcoWZB3LH1lsyCuEPNgrhj6y2ZBXGHmgVxx9ZbMgviDjUL4o6tt2QWxB1qFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5QsyDu2HpLZkHcoWZB3LH1lsyCuEPNgrhj6y2ZBXGHmgVxx9ZbMgviDjUL4o6tt2QWxB1qFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5QsyDu2HpLZkHcoWZB3LH1lsyCuEPNgrhj6y2ZBXGHmgVxx9ZbMgviDjUL4o6tt2QWxB1qFsQdW2/JLIg71CyIO7beklkQd6hZEHdsvSWzIO5Qf0dKebS7+D3J/I1Cp4QfZEHc8f2GlPIkd/EsiGu2APB7FsQd5cullG9wF8+CuGYLAPeyII4oI+JnhBBvdxS/N5YPsdwRJqI7WRBHfBHxXCHEGY7iWRDXYM030hE3siDuQL9DSnmRu3g+xHLNFhGvZkEcUSaiY5VS33YUz3sQ12ABgIg+woK4A32YlPIud/G8B3HNFgD+jgVxRHliYmLp6OjoQ47ieQ/iGuye/ENYEAegiegPSqkDHEQ/KpKvYjmjvENKuYQFccCXiG5TSr3IQTQL4gPqnitYtwshjmBBHAAnok8opT7oIJoF8QF1TxufllK+kwVxABwRh4QQ4w6iWRAfUAEgTdPjm83mt1gQ+8AfkFLubz929kQ+B3FDemJi4qmjo6P3sSD2+V4ppXyV/VgWxBdTAPihlPL5pj0WxDJ1IjpVKXWJ5dg543gPYp80EV2qlHoTC2KfbSdN00Obzea99qN5D+KLKRG9Uil1FQtin/j1Usrj7MfOnch7EOu0f7d9+/ZDV69evYUFsc4W3iilvMx+LAvikellUso3TrXH5yCWyCPiFiI6VEr5O0uRmWJ4D5IJU+ZCRHScUup6FiQzsmwFEfEqIcQrs5W2V4oFscfSvEG4efPmQ0844YQOC2KV6+6wY6SU6+zHzp/Igtgjnqbp2c1m86zpiXyIZYEvIq4VQrzEQlTuCBYkN7JZKyDib6MoWjY0NPQ/LIgdptNTerL3MB1gQewM5mx7D5PMe5CSfHu592BBSg5et/pcew8WxA7fnu09WBA7AzjX3oMFKcm3V1eupnebD7HKDSIi/mRycnJwZGTkgdmS+BCrIF9z3yOKosGhoaE7C0ZYqcaClMb4Ginll+dKYUEK8iWiM5RS5xasbq0aC1IK5bVSypfNl8CCFON7y+bNmwen31AqFlO+FgtSmOEOABiUUm5iQQoznL3izMcRLMfnimNBcuHaW3i+E/PpibwHycnXTCamlDonZzVnxVmQQmgXPLSaSmVB8vH18kmDPF1iQfLQ2j1byU927dq1asWKFb/KUpMFyUJpzzSUdxPRaLPZ/E3GKl6KsSD5MCPiaiHEd7PWYkEykiKiVUqpDRmLeyvGgmRHTUTvVUqdn70GP2qSldXbpJSfy1rYZzkWJBttRLxECHFqttIPl+I9yALEiOhCpdS78oL1VZ4FyUR6TEq5IlPJGYVYkHmoEdE3lVIvLQLWVx0WZH7SiPhzIcTBRceDBZmDHCLGQohmUbC+6rEg85OWUmKZsWBBZqHn6/uCZQZuqi4LMifF26WUR5RlzILMIEhEpymlLi4L1ld9FuTRpBHxYiHEaTbGgAV5JMV5n+y0Adx2BgvyKKLnSSnfb4szC7LnWxC/AIDThRDfsgXWVw4L8jDpIvc5FhonFgRgXafTOX1kZOSehWBV8e8syJ7HR7o/cJnvkGcdy34XxOruOCt0m+VYELh2cnLy9KzPVuVl35eCIOI9RHSOlPLKvMCqVr6PBdmRpul5M+exsj0+fScIIl6wc+fO80ZHR/9gG2Yv8vpUkGsBwOz9533ZycZ49JMgGxDxPCGEtgGuKhn9JIg51yAiI8ac75DbHpd+EOQOIrrE50dtbA/SfHn9IIiZt6rT6VxKRJ+da/YRV8zrLEitxZjaIOosyJQYAwMDX5g5JagrIWbm1k4QIvoBAFxe1z3GzAGsqSD3pml6ZS/FmOJcC0HM236IaGZWXyelvNnXr0sV2qmRIOa7KuuIaN3999+/rgozxpjxDVYQRLwlTdNbAWBDFd/08yVP4ILcDQC3ElG8Y8eOdVOfPfPFLks7oQjyRwD4ESJuTNN048DAwMbBwUHz//X9EpAgOxDxx+YQmIg2mrGUUv6y6gPYa0E6iPgQET0EALv/mf9GxPuIyEzp+aNGo3Hn8PDwfVUH2av+VUSQB7vj96AZvyiKzP/+dZqmdxkpAOAuKeV/9YpRmXb/H5nfEvrBefTTAAAAAElFTkSuQmCC"},function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAAAXNSR0IArs4c6QAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAFGxJREFUeAHtnQuUVVUZx2FmmCFBWgaZmrjSzDIFNV8wQjC8RdHlI0tzRaZmWaay8lWpaLZAXVSuQnKlhcZSwHRVuJBhBuaBUhD2kHyUmpnhSlMsFFB59fuGe+He4d4z93H2Ofs759trDZx7Ht/+7/+3//vbj/Po3UtpamtrOxToR+7YsWNITU3NkWwfuH379v69e/fux3Z//rL/sxlbaiK1x5a75xl3dHQM3rZt21BgHoXfhuLLwRn/ie/6yTb7ZLs2rqLUxZVxOfkiho9AVCOEyd8JIgqu7ys2+N2L313mZNuSnwysWLFiny1btjTSmDWKL0F5FA3aPrk+y92WUmT9GmeJvBTI4sWLB/Tt2/dUCBsDOcP4OyJLng+kxekwTXkvX758IngnIophW7duHS4+1OY/bwSycOHC2kGDBokoToVU+dtPU2UwrDsZINqPYOtUhCC+PEL2ahPFzpLs/Dd2gXR2du5P6L2EVuZ8IH00F5xt62GAaPFl0F7I3wmCOhvxZVtzik0gWWHQD70YcRygmcQ0YxdhIAYRx7FJ5CFygbS2tg6E0MuywtAcfpNYIUotU9KFkeUhUoHQP52KOK5BFIebMLIu0PV/e3t7E767BtQyAE98ikQgCOM4mBRSzzZh6KxTzc3N+zY0NEjjNk1nCSpD7Vwgy5Ytmw40EUfXukVlMO2qOBmggTufyH894jgsThxx5O1MIC0tLQfV1dXNolBnx1EwyzMcBhDHTCxJ5AjHoDIrTgRCP/VkeJgFqYcr48PgZhhgMuWw2tpaaeBkTSq1KXSBMLtxFcK4LbWMJqDgNHBnUAxp4A5OQHGqKkKoAsmG46oQ2cWxMoAPpyKMubGC8CjzmrCw0OrMxpYMxi0pZYDofynQ5yqF7wR2KBGEVmc1rc7xThCa0UgYoIG7Ax9+I5LMFGVStUAQRzqnNxQ5uSeoiGMZ4pA7py11Y6CqLhbEvtDNnv1UxgDdqodMHMWdVrFAiBwtEHtIcdN2xHcGEMf3WQA803ecceKrSCBEjrsAPS5O4JZ3dQzQwH0dcVxZnZXkX122QDLrHHJ7syWlDOBDudHwR0rhRwq7LIEQOU6m1bFFwEhdFG5m3Bv3YSzKCrmlEhgoeRZL7q3CnhFbAqk+n8LDaeLDrkdhfcbpC7aSI4jceMig3O6t8sVzFeCga3U9l322gktTe0lJAsncsm535SquJojjdLrHNysuQizQe+xiMduRfdgpFoCWafUMyBtjEIfdBlQBlaVEEHvYqQJifbqE1ymJD4f7hEkLlkCBED2mUhDrWmnxZgGcvD1mKANzix4FuCllV1GBZN4+YsSWwqLH5/D2GHkacIDHEL2GVlQg9Fkvs1krr33XIzh6APKGw/N6PNFOKMpAQYHIS9143PLiolfZARUM0MjZHQ9VeqqgQORVoLQ89rbDKsmN8/JM9JgSJ4Yk5L2HQCx6JMGtXe/GtegRgiv3EIhFjxBYjdmERY/wHJAnEFlQyrxlPbwczFLkDDD2ODfyTBOaYZ5A5PsclNM+QaDY2UQP+a5Kqt9lFab78gRCy2PEhsluPLZkatfWPULifpdA5LNn2DSBhERsjGbMhyGSv0sg8k1A7Npnz0IkN2pT3HUt3WMTSIjE7xIINkeHaNdMxcAAXeSxZFsbQ9aJzXKXQCDXXvym3M34cKTyIngHv0sgfBxlMMiO9g6dASqXAXmrvqUQGegSCI/TykNRlhQzwAs1JHoMVFwEL6F3CYTFwU97ic5AlcwAt7Vb9CiZrdJP7BIIfdeTSr/EzvSUgTGe4lINq0sgLCwNUV0KAy8MpP5jNy6qQQ23JhyKYfvApgt2I7LJJEs/egH7RpRdqrKRCHJkqkqcwMLW19db9HDk1xrrXjliNkKz+PCQCLNLVVZMYNVYBFHucrpXFkEc+VC6WAc6sm1mI2LAxh/uiK5h/ry/O/NmOSIGzIeOiK6h9ennyLaZjYgBxiDmQ0dcSxfLWh9H5EZo1nzoiGwRiLU+jsiN0KwJxBHZFkEcERuxWWvkHBEuArFkDBgDRRgwgRQhxnYbA8KACcTqgTEQwIAJJIAcO2QMmECsDhgDAQyYQALIsUPGgAnE6oAxEMCACSSAHDtkDJhArA4YAwEMmEACyLFDxoAJxOqAMRDAgAkkgBw7ZAyYQKwOGAMBDJhAAsixQ8aACcTqgDEQwIAJJIAcO2QMmECsDhgDAQyYQALIsUPGgAnE6oAxEMCACSSAHDtkDJhArA4YAwEMmEACyLFDxoAJxOqAMRDAgAkkgBw7ZAyYQKwOGAMBDJhAAsixQ8aACcTqgDEQwIAJJIAcO2QMmECsDhgDAQyYQALIsUPGgAnE6oAxEMCACSSAHDtkDJhArA4YAwEMmEACyLFDxoAJxOqAMRDAgAkkgBw7ZAyYQBzWAb5Bv9GheTPtnoGNJhCHJG/dutUE4pBf16algTOBOGTZIohDcqMxvbGOfJqiyavqXNqqthCxgZqamqgiyE0UTf58T6p8uH379k29fWdU8LW2tg6sra19XQPWXIwNDQ17NTY2bs7dl9bt9vb2c3fs2HG/pvKDd7WKLhZAD9BEbAbrDhPHbq9p9KGaMUh9ff3+u6lWsxVV90oFIVS2fVUAzQepY5BO6/OhfNwqfplA8t00KP+nil86BMJgSR25NoOVLwCtPlQxBqGyqYsgRD2LIPkaUedD4OuIIAjk4HyuVfwygeS7SZ0PaeQ2qYgg8KyOXES9Pr9+pPdXc3NzP/hQN0gH8xsqBEL/9RBt1QvMz2rD7Aovs5DqGrgMF896L5DFixcPQMkDXTnPlV0wP+PKtja7dFXUNXDCMbif8V4gffv2Vdn6CLnaKrIrvDQWGn24tamp6XnvBUJFG+rKcS7tWhdrN7sI5Njdv9RsdTVw3guEG/4a1VCaAUqFeG3cuHFvaMPtCi+NXJMr2w7tdo0hvRcIBKhrfSx67K62nZ2d0gM4cPceHVvZMaTXAmlra+sPnUfroHQ3yiy5u/ekd4vGYqzG0mfHkF4LBJAnQm4fhQTbFG/GafhwuEL/CWT/u1i0xOqihzCbbX1k21IvlQLZvHmzikH6KI0VjIUxm+LFccuXL5fulbrxB5hfnDx58rtS97ztYjH+2I8IorH/+t8RI0b8U8hNe8J/4zRyAO4/ZnF7KxAAjqWrslcWqJb/IXe5FqwR4NTYwPXCh81ZbnwWiMrWB1GrejFBtiKE/T89ABk/Hh+23Sjs8bomvwWyZs0amblS2fqYQHZVYZX+A/3asWPHvpQthZcRZMOGDRMAODgLUtH//xgzZsxTivC6hKqyBwAheV1kLwXC7SXnufScQ9uPObStxnSmezVJDeAcoCxs7upeyW7vBNLR0TGEbopKgSDsFTlcp3YT/52psfAMztfTA1iSi907gaBgleLIkGoDdIigoqkUiIwfwb7DW4G0tLS8H4BaBfKnUaNGPZdLbhq3WRw8nXIfobTsezRwXkWQPn36nIeKD1JKro0/djpOZfQQ6Nu2bfNbIFrHHkKujT969WL8+DF6AOcIHwrT73iG5+nuuL2JIITmUwA3ojtAJb9fZuy0WAlWZzBZYPs8xvs6y8Ct4UcKmfdGIIqndoXXh3l++e1CBKdl33PPPdfAG/jP1VpeuleLCmH3QiCap3aFVKLHw4XITdO+devWyfjxMKVlbqZ79WQh7F4IRPPULn3uTm5N6CxEbpr2aR4/4qeC0UP8F7tAWHX9BDguFjAaExUj9dFDPo6D71TeWkIDt4nu/W+K1b3YBQLAqwE3sBhAz/e/DbmpFggNXH8aCfGhygT2RaxfvVwMfKwCoeU5A4AXFAOnYP9DQeQqwF81xIw4VD4aLYUHf9HoIcdjEwgtTx3grhEQWlPaowcNnDzvodaH1L9X6MH4KZBM1+pEreIA91qiRyC5istWEnSJHvixvqSTPTxJxNHT9HwsEUSmdZm5UtvyiK/TPrXLwu4XoOFsD+t9yZB6ih5iKBaBiDgAN6Dkknh2Ii3na3Sv7vYMVmRwVqxYsQ/+UzswzxD1q9GjRz/aE2mRC4TocQ6g5JYEtUnEQWj+l9oCVAmcW0pEHFrv2O0qPY3cT0qhIVKBrFy58n0s6avuWtFyvslfaqPHsmXLGqlYqn0I/gfHjBmT9+RgMbFEKhDeViddq08VA6NhPy3PPQzOX9SA1QVGoqdEj94ubEdlky5+SdFD8EQmELpWp0HujVGR4CifjQgktdGDgfn18CoPRKlN+O9+bg3KezFDUGEiEQjiGIxqbw0CouTY3YTmvyrBGipMeRyB6H9zqEZjMEYZ5pSTbSQCYdwh4pB7rtQmiH0P8KmMHo899tgBlD8JDdxcJlfKevLTuUBoea6CXLXPCWQVTQS8B3L/kv2dpv+3bNki4lA9ayX+KnXmKte3TgWCOMYmpOURclMZPfDhNCrM+bmVRuM2/vsp3eNV5WKvK/eCUs9fsmTJBzLiUD3jkSnvTAZ2fyi17Ek5j/vlRlOWJHStXuVpx9sr8YszgTQ0NAix6r4v2J1ERP4kn6Ke0X1/0n/LK5go4238OasjEXI4k6n5il7J5KSLRVi+lMJfFCEBLrOaOWzYsA0uM/DRdl1dnTRwKt/O3o3PFsaOP+y2r+SfoQtEnvGg1Z1dMgK/T5zH/ToP+A0xfHR0rb6D1UvCtxy9RSZXZlaTa6gCIXKcwmAoKU/YvUlZqiK3GsfEdS0NnKyUfzeu/EPOd1Y5i4KF8g6tfwmx46lQBd8tVChj3/cRBWcQmlP1KQMixxX4MAmDcqle8pXaqhu4UGaYiByjqFDtgiohqQNxjE5IWUoqhowbE9Q1ljJ/ER/eW1LhA06qOoIQOYbT6rQH5KHxUNUtj6ZC48Ov4sOkjBvl7fILGTtWLQ7xYVVjEB6cORZiV2qqDD1hpTy30/LkfSOip2s0HydyTKPMd2ouQzfsr3JT7Pe67av4Z8VdLPqrI8g1aR+MeQRxTKmYTWUX4sNvA/kWZbAD4SKOqax53Bd4UhkHK4oghOSryCNR4qAV/Tvkym0VqUiIYyEFTZQ46Fr9IExxSEUoewwCsb+kMp2VwFo0rdLVVk1cdHZ2fpK1gfn4cIgm3D1hRRxtlEmmqENNJQuEZzqOgVgZyA0PFYEfxq7jRrZf+wHFHQrGG2fx6MFd5KD1TZYFyUEcsmZ1Nd3jrQVPqGJnjwJZtGjRXqSrASDdqr2qyMvLSynXLxBHometEMbH6T6KD7/kpROqBJURx5oqzRS8PFAgdKc+x1USto4BREEDyneuISpeqbwMgfARh7zc7Sr8NyjwRL0HZxM57nYFv6BAWltbh3N7sFScz7jKOG67VBh5q/c0vgvxRtxYXOTPRIr47krKmcQucZayx/fee+/Qxx1Z4/J/nkCIGAdC6DRanES3qlJwyvkVFpMSNRMn5co2bpQvsY2blJP0Ao34pccdd9ymnT/d/Nu1DoIwRguhCENI/aCbrLyyegVh+Q6vEFUJRiJGRhRJF4Y0btsRx0hmHZ0vUtchjq7BBeKo0kU6LqecNxM5EiMOadxgvo1Ko8MBIaBEHCdHIQ6BWtFCYQhljMvEPYhD+7u54uLOi3wZN56FOJZGBSZNAnmCbtVFURFr+YTPAOKYijgifd4oFQKRPivuknvHLCllAB9+F3HcFzX8VAiEt5EPJnq8EzW5ll9oDCxgMfeG0KyVYSgNAmmaMGHCK2VwYqf6xcAyGjdZsI4lJV0gcNvUHguzlmkYDCzCf+PCMFSpjSQLxMRRaa3w47oFOPC0uKEkUSBbINXEEXfNqi5/ecl0bN2qXOiJEgiLgOsp3ATIbc8tpG3rYQAf3on/LvAFcZIE8hJ35p5p4vClalWEYxYLuV+r6EpHFyVCILQ6T4o4mArscMSTmXXMgKxz0Lh903E2ZZvPu5u37Kv9uOAhnpK7nDforfMDjqEolwHEcSGN28/KvS6K81ULBGJnQOy3oiDK8nDCwLv4cCw+fNyJ9RCMqhQIpG6gW3U5xM4NgQMzEQMD0i3OiOP1GLIvOUuNAlnD7c6Xc1+O82cBSmbRTiyXgQcZjJ9T7kVxnK9qkE6rcz8kRfYsQBwOSUGetzAYVyEO8YWaCMIs1U0MxKenoAIlsog0bq/QpboGcczTVEANEUS+LDvFxKGpWu2BdRF3VI/XJg4phe8R5F4wXgux/96DctuhggGixo1MptysAmwBkL4KZCNYRRg/LoDZdulgYC1PAF7LZMpiHXALo/SxiyWr4eNMHIUdpmEvUePnLN6O1y4O4dq3CDKLF4Fdx7uO5I5cS8oYQBjrGYzfQJdqtjLoReF6IRBI7YRc+SbgkqJI7YDvDMxjpnEGb6p82neg5eCLWyD/A+wMFo2S8uHIcrhPyrlraeDEhw8kpUC55YhNIESMB1gRn0E/dW0uINtWxcCtTN/OGD9+vDR0iUyRC4TW5mnpTtFPnZdIRtNRqCXSnWJtqjPpxY1SIP9BHHPq6+vvaGxslCf/LOlj4M9AnsNYUT7Ck4rkXCCIYgMRQ4Qx56STTnopFawmr5DPig8HDBgwJ20zjC4F8i71ZA7jjDkjR478W/LqTCpK9KJEfREHXeK3U1HiboV0IhAhVf5sAN6NbSU/EcQr4j8W++Yk9QNDpboiTIE8T6bz+VvAlJ/cYGhJGQMIYyW3h8x/7733FkycOPE1ZfCdwA1DII+CbMHmzZvnT548WbpVlnQxID6bT8SQF7WJLy3lMFCRQCDzNab5FjC+mE83yp7syyFU0aZE+QX8zUcYEv0tFWCgZIEgCnngRT5c0vzOO+8snTRpkk3VFiDU811P4cdmGrelDLqbPcfqBbyeBPIiKIXI5rfeemvplClTNnmB2kCUw8ATOaKw94aVwxzndheI9Ed/D6GdDNY6+cZ2y/Tp0+XjM5b0MCBvCVlFtJdV7g4ixSo90P1DWgeRTwBrNaJYJaJgTCFRw5IuBtqAuxpf/rZPnz6drDu9qQu+v2j/D2LV2rfc/KKHAAAAAElFTkSuQmCC"},function(n,e,t){"use strict";t.r(e);var r={props:["html"],created(){this.location=window.location}},a=t(2),o=Object(a.a)(r,(function(){var n=this,e=n._self._c;return e("div",[e("div",{domProps:{innerHTML:n._s(n.html)}}),n._v(" "),e("p",[e("br"),n._v("\n——————————\n作者：zhāngpéngjūn\n链接："),e("a",{attrs:{href:n.location}},[n._v(n._s(n.location))]),n._v("\n来源：znote\n版权声明：著作权归原作者所有，商业转载请联系作者获得授权，非商业转载请注明出处。\n——————————\n")])])}),[],!1,null,"55aa8206",null);e.default=o.exports},function(n,e,t){"use strict";var r=t(6),a=t(18),o=t(148),i=t(50);n.exports=function(n,e,t,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:e;if(r(t)&&o(t,l,s),s.global)c?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(c=!0):delete n[e]}catch(n){}c?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";var r=t(7),a=t(8),o=t(6),i=t(14),s=t(10),c=t(157).CONFIGURABLE,l=t(158),p=t(159),u=p.enforce,d=p.get,m=String,h=Object.defineProperty,g=r("".slice),f=r("".replace),b=r([].join),v=s&&!a((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===g(m(e),0,7)&&(e="["+f(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||c&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&i(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return i(r,"source")||(r.source=b(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return o(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){"use strict";var r=t(34),a=t(292),o=t(18).f,i=r("unscopables"),s=Array.prototype;null==s[i]&&o(s,i,{configurable:!0,value:a(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){n.exports=t(342)},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){"use strict";var r=t(46),a=t(15),o=t(73),i=t(154),s=t(156),c=t(34),l=TypeError,p=c("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,c=i(n,p);if(c){if(void 0===e&&(e="default"),t=r(c,n,e),!a(t)||o(t))return t;throw l("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){"use strict";var r=t(44),a=t(70);n.exports=function(n,e){var t=n[e];return a(t)?void 0:r(t)}},function(n,e,t){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var r=t(46),a=t(6),o=t(15),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!o(s=r(t,n)))return s;if(a(t=n.valueOf)&&!o(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!o(s=r(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){"use strict";var r=t(10),a=t(14),o=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=a(o,"name"),c=s&&"something"===function(){}.name,l=s&&(!r||r&&i(o,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(n,e,t){"use strict";var r=t(7),a=t(6),o=t(49),i=r(Function.toString);a(o.inspectSource)||(o.inspectSource=function(n){return i(n)}),n.exports=o.inspectSource},function(n,e,t){"use strict";var r,a,o,i=t(160),s=t(9),c=t(15),l=t(23),p=t(14),u=t(49),d=t(84),m=t(51),h=s.TypeError,g=s.WeakMap;if(i||u.state){var f=u.state||(u.state=new g);f.get=f.get,f.has=f.has,f.set=f.set,r=function(n,e){if(f.has(n))throw h("Object already initialized");return e.facade=n,f.set(n,e),e},a=function(n){return f.get(n)||{}},o=function(n){return f.has(n)}}else{var b=d("state");m[b]=!0,r=function(n,e){if(p(n,b))throw h("Object already initialized");return e.facade=n,l(n,b,e),e},a=function(n){return p(n,b)?n[b]:{}},o=function(n){return p(n,b)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=a(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(9),a=t(6),o=r.WeakMap;n.exports=a(o)&&/native code/.test(String(o))},function(n,e,t){"use strict";var r=t(33),a=t(7),o=t(162),i=t(167),s=t(24),c=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=i.f;return t?c(e,t(n)):e}},function(n,e,t){"use strict";var r=t(86),a=t(52).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){"use strict";var r=t(32),a=t(164),o=t(31),i=function(n){return function(e,t,i){var s,c=r(e),l=o(c),p=a(i,l);if(n&&t!=t){for(;l>p;)if((s=c[p++])!=s)return!0}else for(;l>p;p++)if((n||p in c)&&c[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){"use strict";var r=t(35),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e,t){"use strict";var r=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:r)(e)}},function(n,e,t){"use strict";var r=t(35),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var r=t(8),a=t(6),o=/#|\.prototype\./,i=function(n,e){var t=c[s(n)];return t==p||t!=l&&(a(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(o,".").toLowerCase()},c=i.data={},l=i.NATIVE="N",p=i.POLYFILL="P";n.exports=i},function(n,e,t){"use strict";var r=t(44),a=t(30),o=t(67),i=t(31),s=TypeError,c=function(n){return function(e,t,c,l){r(t);var p=a(e),u=o(p),d=i(p),m=n?d-1:0,h=n?-1:1;if(c<2)for(;;){if(m in u){l=u[m],m+=h;break}if(m+=h,n?m<0:d<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:d>m;m+=h)m in u&&(l=t(l,u[m],m,p));return l}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r=t(8);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(29);n.exports="undefined"!=typeof process&&"process"==r(process)},function(n,e,t){"use strict";var r=t(10),a=t(173),o=TypeError,i=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(a(n)&&!i(n,"length").writable)throw o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var r=t(29);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,e,t){"use strict";var r=t(22),a=t(9),o=t(176),i=t(177),s=a.WebAssembly,c=7!==Error("e",{cause:7}).cause,l=function(n,e){var t={};t[n]=i(n,e,c),r({global:!0,constructor:!0,arity:1,forced:c},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,c),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},t)}};l("Error",(function(n){return function(e){return o(n,this,arguments)}})),l("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),l("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),l("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),l("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),l("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),l("URIError",(function(n){return function(e){return o(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){"use strict";var r=t(43),a=Function.prototype,o=a.apply,i=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(o):function(){return i.apply(o,arguments)})},function(n,e,t){"use strict";var r=t(33),a=t(14),o=t(23),i=t(74),s=t(87),c=t(85),l=t(180),p=t(181),u=t(182),d=t(185),m=t(186),h=t(10),g=t(79);n.exports=function(n,e,t,f){var b=f?2:1,v=n.split("."),y=v[v.length-1],x=r.apply(null,v);if(x){var w=x.prototype;if(!g&&a(w,"cause")&&delete w.cause,!t)return x;var k=r("Error"),S=e((function(n,e){var t=u(f?e:n,void 0),r=f?new x(n):new x;return void 0!==t&&o(r,"message",t),m(r,S,r.stack,2),this&&i(w,this)&&p(r,this,S),arguments.length>b&&d(r,arguments[b]),r}));if(S.prototype=w,"Error"!==y?s?s(S,k):c(S,k,{name:!0}):h&&"stackTraceLimit"in x&&(l(S,x,"stackTraceLimit"),l(S,x,"prepareStackTrace")),c(S,x),!g)try{w.name!==y&&o(w,"name",y),w.constructor=S}catch(n){}return S}}},function(n,e,t){"use strict";var r=t(7),a=t(44);n.exports=function(n,e,t){try{return r(a(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var r=t(6),a=String,o=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){"use strict";var r=t(18).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(6),a=t(15),o=t(87);n.exports=function(n,e,t){var i,s;return o&&r(i=e.constructor)&&i!==t&&a(s=i.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){"use strict";var r=t(66);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(184),a=t(6),o=t(29),i=t(34)("toStringTag"),s=Object,c="Arguments"==o(function(){return arguments}());n.exports=r?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:c?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r={};r[t(34)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){"use strict";var r=t(15),a=t(23);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){"use strict";var r=t(23),a=t(187),o=t(188),i=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(i?i(n,e):r(n,"stack",a(t,s)))}},function(n,e,t){"use strict";var r=t(7),a=Error,o=r("".replace),i=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(i);n.exports=function(n,e){if(c&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){"use strict";var r=t(8),a=t(47);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(88),a=t(190);n.exports=function n(e,t,o,i,s){var c=-1,l=e.length;for(o||(o=a),s||(s=[]);++c<l;){var p=e[c];t>0&&o(p)?t>1?n(p,t-1,o,i,s):r(s,p):i||(s[s.length]=p)}return s}},function(n,e,t){var r=t(25),a=t(53),o=t(12),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(26),a=t(19);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(25),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(195),a=t(251),o=t(61),i=t(12),s=t(262);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(196),a=t(250),o=t(105);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(90),a=t(94);n.exports=function(n,e,t,o){var i=t.length,s=i,c=!o;if(null==n)return!s;for(n=Object(n);i--;){var l=t[i];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++i<s;){var p=(l=t[i])[0],u=n[p],d=l[1];if(c&&l[2]){if(void 0===u&&!(p in n))return!1}else{var m=new r;if(o)var h=o(u,d,p,n,e,m);if(!(void 0===h?a(d,u,3,o,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(37),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(37);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(37);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(37);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(36);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(36),a=t(54),o=t(56);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(92),a=t(208),o=t(55),i=t(93),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,p=c.toString,u=l.hasOwnProperty,d=RegExp("^"+p.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?d:s).test(i(n))}},function(n,e,t){var r,a=t(209),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(11)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(212),a=t(36),o=t(54);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(213),a=t(214),o=t(215),i=t(216),s=t(217);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e,t){var r=t(38);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(38),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(38),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(38);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(39);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(39);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(39);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(39);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(90),a=t(95),o=t(227),i=t(230),s=t(246),c=t(12),l=t(99),p=t(101),u="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=c(n),b=c(e),v=f?"[object Array]":s(n),y=b?"[object Array]":s(e),x=(v="[object Arguments]"==v?u:v)==u,w=(y="[object Arguments]"==y?u:y)==u,k=v==y;if(k&&l(n)){if(!l(e))return!1;f=!0,x=!1}if(k&&!x)return g||(g=new r),f||p(n)?a(n,e,t,m,h,g):o(n,e,v,t,m,h,g);if(!(1&t)){var S=x&&d.call(n,"__wrapped__"),C=w&&d.call(e,"__wrapped__");if(S||C){var j=S?n.value():n,A=C?e.value():e;return g||(g=new r),h(j,A,t,m,g)}}return!!k&&(g||(g=new r),i(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(25),a=t(228),o=t(91),i=t(95),s=t(229),c=t(57),l=r?r.prototype:void 0,p=l?l.valueOf:void 0;n.exports=function(n,e,t,r,l,u,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&r;if(m||(m=c),n.size!=e.size&&!h)return!1;var g=d.get(n);if(g)return g==e;r|=2,d.set(n,e);var f=i(m(n),m(e),r,l,u,d);return d.delete(n),f;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(11).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(231),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var c=1&t,l=r(n),p=l.length;if(p!=r(e).length&&!c)return!1;for(var u=p;u--;){var d=l[u];if(!(c?d in e:a.call(e,d)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var g=!0;s.set(n,e),s.set(e,n);for(var f=c;++u<p;){var b=n[d=l[u]],v=e[d];if(o)var y=c?o(v,b,d,e,n,s):o(b,v,d,n,e,s);if(!(void 0===y?b===v||i(b,v,t,o,s):y)){g=!1;break}f||(f="constructor"==d)}if(g&&!f){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(g=!1)}return s.delete(n),s.delete(e),g}},function(n,e,t){var r=t(232),a=t(233),o=t(98);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(88),a=t(12);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(234),a=t(235),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(237),a=t(53),o=t(12),i=t(99),s=t(100),c=t(101),l=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),p=!t&&a(n),u=!t&&!p&&i(n),d=!t&&!p&&!u&&c(n),m=t||p||u||d,h=m?r(n.length,String):[],g=h.length;for(var f in n)!e&&!l.call(n,f)||m&&("length"==f||u&&("offset"==f||"parent"==f)||d&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(26),a=t(58),o=t(19),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(89),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===a&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(68)(n))},function(n,e,t){var r=t(243),a=t(244),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(245)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(247),a=t(54),o=t(248),i=t(103),s=t(249),c=t(26),l=t(93),p=l(r),u=l(a),d=l(o),m=l(i),h=l(s),g=c;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=g(new a)||o&&"[object Promise]"!=g(o.resolve())||i&&"[object Set]"!=g(new i)||s&&"[object WeakMap]"!=g(new s))&&(g=function(n){var e=c(n),t="[object Object]"==e?n.constructor:void 0,r=t?l(t):"";if(r)switch(r){case p:return"[object DataView]";case u:return"[object Map]";case d:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var r=t(16)(t(11),"DataView");n.exports=r},function(n,e,t){var r=t(16)(t(11),"Promise");n.exports=r},function(n,e,t){var r=t(16)(t(11),"WeakMap");n.exports=r},function(n,e,t){var r=t(104),a=t(98);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(94),a=t(252),o=t(259),i=t(59),s=t(104),c=t(105),l=t(40);n.exports=function(n,e){return i(n)&&s(e)?c(l(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(106);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(254),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(255);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(56);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(257);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(25),a=t(258),o=t(12),i=t(60),s=r?r.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return c?c.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(260),a=t(261);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(107),a=t(53),o=t(12),i=t(100),s=t(58),c=t(40);n.exports=function(n,e,t){for(var l=-1,p=(e=r(e,n)).length,u=!1;++l<p;){var d=c(e[l]);if(!(u=null!=n&&t(n,d)))break;n=n[d]}return u||++l!=p?u:!!(p=null==n?0:n.length)&&s(p)&&i(d,p)&&(o(n)||a(n))}},function(n,e,t){var r=t(263),a=t(264),o=t(59),i=t(40);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(106);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(61),a=t(266),o=t(268);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(267),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=a(o.length-e,0),c=Array(s);++i<s;)c[i]=o[e+i];i=-1;for(var l=Array(e+1);++i<e;)l[i]=o[i];return l[e]=t(c),r(n,this,l)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(269),a=t(272)(r);n.exports=a},function(n,e,t){var r=t(270),a=t(271),o=t(61),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(16),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(96),a=t(274),o=t(279),i=t(97),s=t(280),c=t(57);n.exports=function(n,e,t){var l=-1,p=a,u=n.length,d=!0,m=[],h=m;if(t)d=!1,p=o;else if(u>=200){var g=e?null:s(n);if(g)return c(g);d=!1,p=i,h=new r}else h=e?[]:m;n:for(;++l<u;){var f=n[l],b=e?e(f):f;if(f=t||0!==f?f:0,d&&b==b){for(var v=h.length;v--;)if(h[v]===b)continue n;e&&h.push(b),m.push(f)}else p(h,b,t)||(h!==m&&h.push(b),m.push(f))}return m}},function(n,e,t){var r=t(275);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(276),a=t(277),o=t(278);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(103),a=t(281),o=t(57),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(102),a=t(19);n.exports=function(n){return a(n)&&r(n)}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(108)},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(109)},function(n,e,t){"use strict";var r=t(22),a=t(30),o=t(31),i=t(35),s=t(149);r({target:"Array",proto:!0},{at:function(n){var e=a(this),t=o(e),r=i(n),s=r>=0?r:t+r;return s<0||s>=t?void 0:e[s]}}),s("at")},function(n,e,t){"use strict";var r,a=t(24),o=t(293),i=t(52),s=t(51),c=t(295),l=t(82),p=t(84),u=p("IE_PROTO"),d=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},g=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;g="undefined"!=typeof document?document.domain&&r?h(r):((e=l("iframe")).style.display="none",c.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(r);for(var t=i.length;t--;)delete g.prototype[i[t]];return g()};s[u]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(d.prototype=a(n),t=new d,d.prototype=null,t[u]=n):t=g(),void 0===e?t:o.f(t,e)}},function(n,e,t){"use strict";var r=t(10),a=t(83),o=t(18),i=t(24),s=t(32),c=t(294);e.f=r&&!a?Object.defineProperties:function(n,e){i(n);for(var t,r=s(e),a=c(e),l=a.length,p=0;l>p;)o.f(n,t=a[p++],r[t]);return n}},function(n,e,t){"use strict";var r=t(86),a=t(52);n.exports=Object.keys||function(n){return r(n,a)}},function(n,e,t){"use strict";var r=t(33);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(22),a=t(7),o=t(48),i=t(35),s=t(66),c=t(8),l=a("".charAt);r({target:"String",proto:!0,forced:c((function(){return"\ud842"!=="𠮷".at(-2)}))},{at:function(n){var e=s(o(this)),t=e.length,r=i(n),a=r>=0?r:t+r;return a<0||a>=t?void 0:l(e,a)}})},function(n,e,t){"use strict";t(110)},function(n,e,t){
/*!
 * Valine v1.5.1
 * (c) 2017-2022 xCss
 * Released under the GPL-2.0 License.
 * Last Update: 2022-7-21 3:43:59 ├F10: PM┤
 */
n.exports=function(n){function e(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,e),a.l=!0,a.exports}var t={};return e.m=n,e.c=t,e.i=function(n){return n},e.d=function(n,t,r){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:r})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=108)}([function(n,e,t){"use strict";var r=SyntaxError,a=Function,o=TypeError,i=function(n){try{return a('"use strict"; return ('+n+").constructor;")()}catch(n){}},s=Object.getOwnPropertyDescriptor;if(s)try{s({},"")}catch(n){s=null}var c=function(){throw new o},l=s?function(){try{return c}catch(n){try{return s(arguments,"callee").get}catch(n){return c}}}():c,p=t(22)(),u=Object.getPrototypeOf||function(n){return n.__proto__},d={},m="undefined"==typeof Uint8Array?void 0:u(Uint8Array),h={"%AggregateError%":"undefined"==typeof AggregateError?void 0:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?void 0:ArrayBuffer,"%ArrayIteratorPrototype%":p?u([][Symbol.iterator]()):void 0,"%AsyncFromSyncIteratorPrototype%":void 0,"%AsyncFunction%":d,"%AsyncGenerator%":d,"%AsyncGeneratorFunction%":d,"%AsyncIteratorPrototype%":d,"%Atomics%":"undefined"==typeof Atomics?void 0:Atomics,"%BigInt%":"undefined"==typeof BigInt?void 0:BigInt,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?void 0:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?void 0:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?void 0:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry,"%Function%":a,"%GeneratorFunction%":d,"%Int8Array%":"undefined"==typeof Int8Array?void 0:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?void 0:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?void 0:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":p?u(u([][Symbol.iterator]())):void 0,"%JSON%":"object"==typeof JSON?JSON:void 0,"%Map%":"undefined"==typeof Map?void 0:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&p?u((new Map)[Symbol.iterator]()):void 0,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?void 0:Promise,"%Proxy%":"undefined"==typeof Proxy?void 0:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?void 0:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?void 0:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&p?u((new Set)[Symbol.iterator]()):void 0,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?void 0:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":p?u(""[Symbol.iterator]()):void 0,"%Symbol%":p?Symbol:void 0,"%SyntaxError%":r,"%ThrowTypeError%":l,"%TypedArray%":m,"%TypeError%":o,"%Uint8Array%":"undefined"==typeof Uint8Array?void 0:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?void 0:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?void 0:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?void 0:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?void 0:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?void 0:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?void 0:WeakSet},g=function n(e){var t;if("%AsyncFunction%"===e)t=i("async function () {}");else if("%GeneratorFunction%"===e)t=i("function* () {}");else if("%AsyncGeneratorFunction%"===e)t=i("async function* () {}");else if("%AsyncGenerator%"===e){var r=n("%AsyncGeneratorFunction%");r&&(t=r.prototype)}else if("%AsyncIteratorPrototype%"===e){var a=n("%AsyncGenerator%");a&&(t=u(a.prototype))}return h[e]=t,t},f={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},b=t(9),v=t(25),y=b.call(Function.call,Array.prototype.concat),x=b.call(Function.apply,Array.prototype.splice),w=b.call(Function.call,String.prototype.replace),k=b.call(Function.call,String.prototype.slice),S=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,C=/\\(\\)?/g,j=function(n){var e=k(n,0,1),t=k(n,-1);if("%"===e&&"%"!==t)throw new r("invalid intrinsic syntax, expected closing `%`");if("%"===t&&"%"!==e)throw new r("invalid intrinsic syntax, expected opening `%`");var a=[];return w(n,S,(function(n,e,t,r){a[a.length]=t?w(r,C,"$1"):e||n})),a},A=function(n,e){var t,a=n;if(v(f,a)&&(a="%"+(t=f[a])[0]+"%"),v(h,a)){var i=h[a];if(i===d&&(i=g(a)),void 0===i&&!e)throw new o("intrinsic "+n+" exists, but is not available. Please file an issue!");return{alias:t,name:a,value:i}}throw new r("intrinsic "+n+" does not exist!")};n.exports=function(n,e){if("string"!=typeof n||0===n.length)throw new o("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof e)throw new o('"allowMissing" argument must be a boolean');var t=j(n),a=t.length>0?t[0]:"",i=A("%"+a+"%",e),c=i.name,l=i.value,p=!1,u=i.alias;u&&(a=u[0],x(t,y([0,1],u)));for(var d=1,m=!0;d<t.length;d+=1){var g=t[d],f=k(g,0,1),b=k(g,-1);if(('"'===f||"'"===f||"`"===f||'"'===b||"'"===b||"`"===b)&&f!==b)throw new r("property names with quotes must have matching quotes");if("constructor"!==g&&m||(p=!0),v(h,c="%"+(a+="."+g)+"%"))l=h[c];else if(null!=l){if(!(g in l)){if(!e)throw new o("base intrinsic for "+n+" exists, but the property is not available.");return}if(s&&d+1>=t.length){var w=s(l,g);l=(m=!!w)&&"get"in w&&!("originalValue"in w.get)?w.get:l[g]}else m=v(l,g),l=l[g];m&&!p&&(h[c]=l)}}return l}},function(n,e,t){"use strict";var r=t(0),a=t(4),o=a(r("String.prototype.indexOf"));n.exports=function(n,e){var t=r(n,!!e);return"function"==typeof t&&o(n,".prototype.")>-1?a(t):t}},function(n,e,t){"use strict";var r=t(88),a="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),o=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,c=s&&function(){var n={};try{for(var e in s(n,"x",{enumerable:!1,value:n}),n)return!1;return n.x===n}catch(n){return!1}}(),l=function(n,e,t,r){(!(e in n)||function(n){return"function"==typeof n&&"[object Function]"===o.call(n)}(r)&&r())&&(c?s(n,e,{configurable:!0,enumerable:!1,value:t,writable:!0}):n[e]=t)},p=function(n,e){var t=arguments.length>2?arguments[2]:{},o=r(e);a&&(o=i.call(o,Object.getOwnPropertySymbols(e)));for(var s=0;s<o.length;s+=1)l(n,o[s],e[o[s]],t[o[s]])};p.supportsDescriptors=!!c,n.exports=p},function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},o=r(t(85)),i=r(t(49)),s=r(t(46)),c=r(t(48)),l=r(t(45)),p=document,u=navigator,d=/[&<>"'`\\]/g,m=RegExp(d.source),h=/&(?:amp|lt|gt|quot|#39|#x60|#x5c);/g,g=RegExp(h.source),f={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#x60;","\\":"&#x5c;"},b={};for(var v in f)b[f[v]]=v;var y=null;Array.prototype.forEach||(Array.prototype.forEach=function(n,e){var t,r;if(null==this)throw new TypeError(" this is null or not defined");var a=Object(this),o=a.length>>>0;if("function"!=typeof n)throw new TypeError(n+" is not a function");for(arguments.length>1&&(t=e),r=0;r<o;){var i;r in a&&(i=a[r],n.call(t,i,r,a)),r++}}),window.NodeList&&!NodeList.prototype.forEach&&(NodeList.prototype.forEach=Array.prototype.forEach),String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}),(0,o.default)(i.default.fn,{prepend:function(n){return n instanceof HTMLElement||(n=n[0]),this.forEach((function(e){e.insertAdjacentElement("afterBegin",n)})),this},append:function(n){return n instanceof HTMLElement||(n=n[0]),this.forEach((function(e){e.insertAdjacentElement("beforeEnd",n)})),this},remove:function(){return this.forEach((function(n){try{n.parentNode.removeChild(n)}catch(n){}})),this},find:function(n){return(0,i.default)(n,this)},show:function(){return this.forEach((function(n){n.style.display="block"})),this},hide:function(){return this.forEach((function(n){n.style.display="none"})),this},on:function(n,e,t){return i.default.fn.off(n,e,t),this.forEach((function(r){n.split(" ").forEach((function(n){r.addEventListener?r.addEventListener(n,e,t||!1):r.attachEvent?r.attachEvent("on"+n,e):r["on"+n]=e}))})),this},off:function(n,e,t){return this.forEach((function(r){n.split(" ").forEach((function(n){r.removeEventListener?r.removeEventListener(n,e,t||!1):r.detachEvent?r.detachEvent("on"+n,e):r["on"+n]=null}))})),this},html:function(n){return void 0!==n?(this.forEach((function(e){e.innerHTML=n})),this):this[0].innerHTML},text:function(n){return void 0!==n?(this.forEach((function(e){e.innerText=n})),this):this[0].innerText},empty:function(n){return n=n||0,this.forEach((function(e){setTimeout((function(n){e.innerText=""}),n)})),this},val:function(n){return void 0!==n?(this.forEach((function(e){e.value=n})),this):this[0].value||""},attr:function(){var n=arguments;if("object"==a(arguments[0])){var e=arguments[0],t=this;return Object.keys(e).forEach((function(n){t.forEach((function(t){t.setAttribute(n,e[n])}))})),this}return"string"==typeof arguments[0]&&arguments.length<2?this[0].getAttribute(arguments[0])||"":(this.forEach((function(e){e.setAttribute(n[0],n[1])})),this)},removeAttr:function(n){return this.forEach((function(e){var t,r=0,a=n&&n.match(/[^\x20\t\r\n\f\*\/\\]+/g);if(a&&1===e.nodeType)for(;t=a[r++];)e.removeAttribute(t)})),this},hasClass:function(n){return!!this[0]&&new RegExp("(\\s|^)"+n+"(\\s|$)").test(this[0].getAttribute("class"))},addClass:function(n){return this.forEach((function(e){var t=(0,i.default)(e),r=t.attr("class");t.hasClass(n)||t.attr("class",r+=" "+n)})),this},removeClass:function(n){return this.forEach((function(e){var t=(0,i.default)(e),r=t.attr("class");if(t.hasClass(n)){var a=new RegExp("(\\s|^)"+n+"(\\s|$)");t.attr("class",r.replace(a,""))}})),this}}),(0,o.default)(i.default,{extend:o.default,noop:function(){},navi:u,ua:u.userAgent,lang:u.language||u.languages[0],detect:s.default,store:c.default,escape:function(n){return n&&m.test(n)?n.replace(d,(function(n){return f[n]})):n},unescape:function(n){return n&&g.test(n)?n.replace(h,(function(n){return b[n]})):n},dynamicLoadSource:function(n,e){if((0,i.default)('script[src="'+n+'"]').length)e&&e();else{var t=p.createElement("script");t.onload=t.onreadystatechange=function(){this.onload=this.onreadystatechange=null,e&&e(),(0,i.default)(t).remove()},t.async=!0,t.setAttribute("referrerPolicy","no-referrer"),(0,i.default)("head")[0].appendChild(t),t.src=n}},sdkLoader:function(n,e,t){e in window&&window[e]?(y&&clearTimeout(y),t&&t()):i.default.dynamicLoadSource(n,(function(){y=setTimeout(i.default.sdkLoader(n,e,t),100)}))},deleteInWin:function(n,e){var t=function(e){if(n in window)try{delete window[n]}catch(e){window[n]=null}};0===e?t():setTimeout(t,e||500)},ajax:l.default}),e.default=i.default},function(n,e,t){"use strict";var r=t(9),a=t(0),o=a("%Function.prototype.apply%"),i=a("%Function.prototype.call%"),s=a("%Reflect.apply%",!0)||r.call(i,o),c=a("%Object.getOwnPropertyDescriptor%",!0),l=a("%Object.defineProperty%",!0),p=a("%Math.max%");if(l)try{l({},"a",{value:1})}catch(n){l=null}n.exports=function(n){var e=s(r,i,arguments);return c&&l&&c(e,"length").configurable&&l(e,"length",{value:1+p(0,n.length-(arguments.length-1))}),e};var u=function(){return s(r,o,arguments)};l?l(n.exports,"apply",{value:u}):n.exports.apply=u},function(n,e,t){"use strict";n.exports=t(62)},function(n,e,t){"use strict";e.__esModule=!0,e.DEFAULT_EMOJI_CDN="//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",e.DB_NAME="Comment",e.CONFIG={lang:"zh-CN",langMode:null,appId:"",appKey:"",clazzName:"Comment",meta:["nick","mail","link"],path:location.pathname,placeholder:"Just Go Go",pageSize:10,recordIP:!0,serverURLs:"",visitor:!1,mathJax:!1,emojiCDN:"",emojiMaps:void 0,enableQQ:!1,requiredFields:[]},e.defaultMeta=["nick","mail","link"],e.QQCacheKey="_v_Cache_Q",e.MetaCacheKey="_v_Cache_Meta",e.RandomStr=function(n){return(Date.now()+Math.round(1e3*Math.random())).toString(32)},e.VERSION="1.5.1"},function(n,e,t){var r=t(16),a=t(50);for(var o in(e=n.exports=function(n,e){return new a(e).process(n)}).FilterCSS=a,r)e[o]=r[o];"undefined"!=typeof window&&(window.filterCSS=n.exports)},function(n,e,t){"use strict";var r=t(66);n.exports=function(n){return"symbol"==typeof n?"Symbol":"bigint"==typeof n?"BigInt":r(n)}},function(n,e,t){"use strict";var r=t(78);n.exports=Function.prototype.bind||r},function(n,e,t){"use strict";var r,a,o=Function.prototype.toString,i="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof i&&"function"==typeof Object.defineProperty)try{r=Object.defineProperty({},"length",{get:function(){throw a}}),a={},i((function(){throw 42}),null,r)}catch(n){n!==a&&(i=null)}else i=null;var s=/^\s*class\b/,c=function(n){try{var e=o.call(n);return s.test(e)}catch(n){return!1}},l=Object.prototype.toString,p="function"==typeof Symbol&&!!Symbol.toStringTag,u="object"==typeof document&&void 0===document.all&&void 0!==document.all?document.all:{};n.exports=i?function(n){if(n===u)return!0;if(!n)return!1;if("function"!=typeof n&&"object"!=typeof n)return!1;if("function"==typeof n&&!n.prototype)return!0;try{i(n,null,r)}catch(n){if(n!==a)return!1}return!c(n)}:function(n){if(n===u)return!0;if(!n)return!1;if("function"!=typeof n&&"object"!=typeof n)return!1;if("function"==typeof n&&!n.prototype)return!0;if(p)return function(n){try{return!c(n)&&(o.call(n),!0)}catch(n){return!1}}(n);if(c(n))return!1;var e=l.call(n);return"[object Function]"===e||"[object GeneratorFunction]"===e}},function(n,e){n.exports={indexOf:function(n,e){var t,r;if(Array.prototype.indexOf)return n.indexOf(e);for(t=0,r=n.length;t<r;t++)if(n[t]===e)return t;return-1},forEach:function(n,e,t){var r,a;if(Array.prototype.forEach)return n.forEach(e,t);for(r=0,a=n.length;r<a;r++)e.call(t,n[r],r,n)},trim:function(n){return String.prototype.trim?n.trim():n.replace(/(^\s*)|(\s*$)/g,"")},spaceIndex:function(n){var e=/\s|\n|\t/.exec(n);return e?e.index:-1}}},function(n,e,t){"use strict";e.__esModule=!0;var r={cdn:t(6).DEFAULT_EMOJI_CDN,maps:t(97),parse:function(n,e){return String(n).replace(new RegExp(":("+Object.keys(r.maps).join("|")+"):","ig"),(function(n,t){return r.maps[t]?r.build(t,e):n}))},build:function(n,e){var t=/^(https?:)?\/\//i,a=r.maps[n],o=t.test(a)?a:r.cdn+a,i=' <img alt="'+n+'" referrerpolicy="no-referrer" class="vemoji" src="'+o+'" />';return t.test(o)?i:""}};e.default=r},function(n,e,t){"use strict";e.__esModule=!0;var r=function(n){return n&&n.__esModule?n:{default:n}}(t(95));e.default=function(n){return(0,r.default)(n,{onTagAttr:function(n,e,t,r){return a(n,e,t,r)},onIgnoreTagAttr:function(n,e,t,r){return a(n,e,t,r)}}).replace(/\<\/?div\>/gi,"")};var a=function(n,e,t,a){if(/video|audio/i.test(n))return"";if(/code|pre|span/i.test(n)){if("style"==e){var o=t.match(/color:([#a-z0-9]{3,7}|\s+[#a-z0-9]{3,8})/gi);return o&&o.length?'style="'+o[0]+'"':""}if("class"==e)return e+"='"+r.default.escapeAttrValue(t)+"'"}return"a"===n&&"class"==e&&"at"===t?e+"='"+r.default.escapeAttrValue(t)+"'":"img"===n&&/src|class/i.test(e)?e+"='"+r.default.escapeAttrValue(t)+"' referrerPolicy='no-referrer'":void 0}},function(n,e,t){"use strict";var r=t(0),a=t(1),o=r("%TypeError%"),i=t(52),s=t(18),c=t(53),l=t(55),p=t(56),u=t(60),d=t(20),m=t(81),h=a("String.prototype.split"),g=Object("a"),f="a"!==g[0]||!(0 in g);n.exports=function(n){var e,t=u(this),r=f&&m(this)?h(this,""):t,a=p(r);if(!l(n))throw new o("Array.prototype.forEach callback must be a function");arguments.length>1&&(e=arguments[1]);for(var g=0;g<a;){var b=d(g);if(c(r,b)){var v=s(r,b);i(n,e,[v,g,r])}g+=1}}},function(n,e,t){"use strict";var r=t(75),a=t(14);n.exports=function(){var n=Array.prototype.forEach;return r(n)?n:a}},function(n,e){function t(){var n={"align-content":!1,"align-items":!1,"align-self":!1,"alignment-adjust":!1,"alignment-baseline":!1,all:!1,"anchor-point":!1,animation:!1,"animation-delay":!1,"animation-direction":!1,"animation-duration":!1,"animation-fill-mode":!1,"animation-iteration-count":!1,"animation-name":!1,"animation-play-state":!1,"animation-timing-function":!1,azimuth:!1,"backface-visibility":!1,background:!0,"background-attachment":!0,"background-clip":!0,"background-color":!0,"background-image":!0,"background-origin":!0,"background-position":!0,"background-repeat":!0,"background-size":!0,"baseline-shift":!1,binding:!1,bleed:!1,"bookmark-label":!1,"bookmark-level":!1,"bookmark-state":!1,border:!0,"border-bottom":!0,"border-bottom-color":!0,"border-bottom-left-radius":!0,"border-bottom-right-radius":!0,"border-bottom-style":!0,"border-bottom-width":!0,"border-collapse":!0,"border-color":!0,"border-image":!0,"border-image-outset":!0,"border-image-repeat":!0,"border-image-slice":!0,"border-image-source":!0,"border-image-width":!0,"border-left":!0,"border-left-color":!0,"border-left-style":!0,"border-left-width":!0,"border-radius":!0,"border-right":!0,"border-right-color":!0,"border-right-style":!0,"border-right-width":!0,"border-spacing":!0,"border-style":!0,"border-top":!0,"border-top-color":!0,"border-top-left-radius":!0,"border-top-right-radius":!0,"border-top-style":!0,"border-top-width":!0,"border-width":!0,bottom:!1,"box-decoration-break":!0,"box-shadow":!0,"box-sizing":!0,"box-snap":!0,"box-suppress":!0,"break-after":!0,"break-before":!0,"break-inside":!0,"caption-side":!1,chains:!1,clear:!0,clip:!1,"clip-path":!1,"clip-rule":!1,color:!0,"color-interpolation-filters":!0,"column-count":!1,"column-fill":!1,"column-gap":!1,"column-rule":!1,"column-rule-color":!1,"column-rule-style":!1,"column-rule-width":!1,"column-span":!1,"column-width":!1,columns:!1,contain:!1,content:!1,"counter-increment":!1,"counter-reset":!1,"counter-set":!1,crop:!1,cue:!1,"cue-after":!1,"cue-before":!1,cursor:!1,direction:!1,display:!0,"display-inside":!0,"display-list":!0,"display-outside":!0,"dominant-baseline":!1,elevation:!1,"empty-cells":!1,filter:!1,flex:!1,"flex-basis":!1,"flex-direction":!1,"flex-flow":!1,"flex-grow":!1,"flex-shrink":!1,"flex-wrap":!1,float:!1,"float-offset":!1,"flood-color":!1,"flood-opacity":!1,"flow-from":!1,"flow-into":!1,font:!0,"font-family":!0,"font-feature-settings":!0,"font-kerning":!0,"font-language-override":!0,"font-size":!0,"font-size-adjust":!0,"font-stretch":!0,"font-style":!0,"font-synthesis":!0,"font-variant":!0,"font-variant-alternates":!0,"font-variant-caps":!0,"font-variant-east-asian":!0,"font-variant-ligatures":!0,"font-variant-numeric":!0,"font-variant-position":!0,"font-weight":!0,grid:!1,"grid-area":!1,"grid-auto-columns":!1,"grid-auto-flow":!1,"grid-auto-rows":!1,"grid-column":!1,"grid-column-end":!1,"grid-column-start":!1,"grid-row":!1,"grid-row-end":!1,"grid-row-start":!1,"grid-template":!1,"grid-template-areas":!1,"grid-template-columns":!1,"grid-template-rows":!1,"hanging-punctuation":!1,height:!0,hyphens:!1,icon:!1,"image-orientation":!1,"image-resolution":!1,"ime-mode":!1,"initial-letters":!1,"inline-box-align":!1,"justify-content":!1,"justify-items":!1,"justify-self":!1,left:!1,"letter-spacing":!0,"lighting-color":!0,"line-box-contain":!1,"line-break":!1,"line-grid":!1,"line-height":!1,"line-snap":!1,"line-stacking":!1,"line-stacking-ruby":!1,"line-stacking-shift":!1,"line-stacking-strategy":!1,"list-style":!0,"list-style-image":!0,"list-style-position":!0,"list-style-type":!0,margin:!0,"margin-bottom":!0,"margin-left":!0,"margin-right":!0,"margin-top":!0,"marker-offset":!1,"marker-side":!1,marks:!1,mask:!1,"mask-box":!1,"mask-box-outset":!1,"mask-box-repeat":!1,"mask-box-slice":!1,"mask-box-source":!1,"mask-box-width":!1,"mask-clip":!1,"mask-image":!1,"mask-origin":!1,"mask-position":!1,"mask-repeat":!1,"mask-size":!1,"mask-source-type":!1,"mask-type":!1,"max-height":!0,"max-lines":!1,"max-width":!0,"min-height":!0,"min-width":!0,"move-to":!1,"nav-down":!1,"nav-index":!1,"nav-left":!1,"nav-right":!1,"nav-up":!1,"object-fit":!1,"object-position":!1,opacity:!1,order:!1,orphans:!1,outline:!1,"outline-color":!1,"outline-offset":!1,"outline-style":!1,"outline-width":!1,overflow:!1,"overflow-wrap":!1,"overflow-x":!1,"overflow-y":!1,padding:!0,"padding-bottom":!0,"padding-left":!0,"padding-right":!0,"padding-top":!0,page:!1,"page-break-after":!1,"page-break-before":!1,"page-break-inside":!1,"page-policy":!1,pause:!1,"pause-after":!1,"pause-before":!1,perspective:!1,"perspective-origin":!1,pitch:!1,"pitch-range":!1,"play-during":!1,position:!1,"presentation-level":!1,quotes:!1,"region-fragment":!1,resize:!1,rest:!1,"rest-after":!1,"rest-before":!1,richness:!1,right:!1,rotation:!1,"rotation-point":!1,"ruby-align":!1,"ruby-merge":!1,"ruby-position":!1,"shape-image-threshold":!1,"shape-outside":!1,"shape-margin":!1,size:!1,speak:!1,"speak-as":!1,"speak-header":!1,"speak-numeral":!1,"speak-punctuation":!1,"speech-rate":!1,stress:!1,"string-set":!1,"tab-size":!1,"table-layout":!1,"text-align":!0,"text-align-last":!0,"text-combine-upright":!0,"text-decoration":!0,"text-decoration-color":!0,"text-decoration-line":!0,"text-decoration-skip":!0,"text-decoration-style":!0,"text-emphasis":!0,"text-emphasis-color":!0,"text-emphasis-position":!0,"text-emphasis-style":!0,"text-height":!0,"text-indent":!0,"text-justify":!0,"text-orientation":!0,"text-overflow":!0,"text-shadow":!0,"text-space-collapse":!0,"text-transform":!0,"text-underline-position":!0,"text-wrap":!0,top:!1,transform:!1,"transform-origin":!1,"transform-style":!1,transition:!1,"transition-delay":!1,"transition-duration":!1,"transition-property":!1,"transition-timing-function":!1,"unicode-bidi":!1,"vertical-align":!1,visibility:!1,"voice-balance":!1,"voice-duration":!1,"voice-family":!1,"voice-pitch":!1,"voice-range":!1,"voice-rate":!1,"voice-stress":!1,"voice-volume":!1,volume:!1,"white-space":!1,widows:!1,width:!0,"will-change":!1,"word-break":!0,"word-spacing":!0,"word-wrap":!0,"wrap-flow":!1,"wrap-through":!1,"writing-mode":!1,"z-index":!1};return n}var r=/javascript\s*\:/gim;e.whiteList=t(),e.getDefaultWhiteList=t,e.onAttr=function(n,e,t){},e.onIgnoreAttr=function(n,e,t){},e.safeAttrValue=function(n,e){return r.test(e)?"":e}},function(n,e){n.exports={indexOf:function(n,e){var t,r;if(Array.prototype.indexOf)return n.indexOf(e);for(t=0,r=n.length;t<r;t++)if(n[t]===e)return t;return-1},forEach:function(n,e,t){var r,a;if(Array.prototype.forEach)return n.forEach(e,t);for(r=0,a=n.length;r<a;r++)e.call(t,n[r],r,n)},trim:function(n){return String.prototype.trim?n.trim():n.replace(/(^\s*)|(\s*$)/g,"")},trimRight:function(n){return String.prototype.trimRight?n.trimRight():n.replace(/(\s*$)/g,"")}}},function(n,e,t){"use strict";var r=t(0)("%TypeError%"),a=t(86),o=t(19),i=t(8);n.exports=function(n,e){if("Object"!==i(n))throw new r("Assertion failed: Type(O) is not Object");if(!o(e))throw new r("Assertion failed: IsPropertyKey(P) is not true, got "+a(e));return n[e]}},function(n,e,t){"use strict";n.exports=function(n){return"string"==typeof n||"symbol"==typeof n}},function(n,e,t){"use strict";var r=t(0),a=r("%String%"),o=r("%TypeError%");n.exports=function(n){if("symbol"==typeof n)throw new o("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){"use strict";n.exports=function(n){return null===n||"function"!=typeof n&&"object"!=typeof n}},function(n,e,t){"use strict";var r="undefined"!=typeof Symbol&&Symbol,a=t(23);n.exports=function(){return"function"==typeof r&&"function"==typeof Symbol&&"symbol"==typeof r("foo")&&"symbol"==typeof Symbol("bar")&&a()}},function(n,e,t){"use strict";n.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var n={},e=Symbol("test"),t=Object(e);if("string"==typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;for(e in n[e]=42,n)return!1;if("function"==typeof Object.keys&&0!==Object.keys(n).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(n).length)return!1;var r=Object.getOwnPropertySymbols(n);if(1!==r.length||r[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(n,e))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var a=Object.getOwnPropertyDescriptor(n,e);if(42!==a.value||!0!==a.enumerable)return!1}return!0}},function(n,e,t){"use strict";var r=t(23);n.exports=function(){return r()&&!!Symbol.toStringTag}},function(n,e,t){"use strict";var r=t(9);n.exports=r.call(Function.call,Object.prototype.hasOwnProperty)},function(n,e,t){"use strict";var r=Object.prototype.toString;n.exports=function(n){var e=r.call(n),t="[object Arguments]"===e;return t||(t="[object Array]"!==e&&null!==n&&"object"==typeof n&&"number"==typeof n.length&&n.length>=0&&"[object Function]"===r.call(n.callee)),t}},function(n,e,t){"use strict";var r=t(5),a=t(1),o=a("Object.prototype.propertyIsEnumerable"),i=a("Array.prototype.push");n.exports=function(n){var e=r(n),t=[];for(var a in e)o(e,a)&&i(t,[a,e[a]]);return t}},function(n,e,t){"use strict";var r=t(27);n.exports=function(){return"function"==typeof Object.entries?Object.entries:r}},function(n,e,t){"use strict";var r=t(5),a=t(20),o=t(1)("String.prototype.replace"),i=/^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/,s=/[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;n.exports=function(){var n=a(r(this));return o(o(n,i,""),s,"")}},function(n,e,t){"use strict";var r=t(29);n.exports=function(){return String.prototype.trim&&"​"==="​".trim()?String.prototype.trim:r}},function(n,e,t){function r(){return{a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],figcaption:[],figure:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height"],ins:["datetime"],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],summary:[],sup:[],strong:[],strike:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","crossorigin","loop","muted","playsinline","poster","preload","src","height","width"]}}function a(n){return n.replace(f,"&lt;").replace(b,"&gt;")}function o(n){return n.replace(v,"&quot;")}function i(n){return n.replace(y,'"')}function s(n){return n.replace(x,(function(n,e){return"x"===e[0]||"X"===e[0]?String.fromCharCode(parseInt(e.substr(1),16)):String.fromCharCode(parseInt(e,10))}))}function c(n){return n.replace(w,":").replace(k," ")}function l(n){for(var e="",t=0,r=n.length;t<r;t++)e+=n.charCodeAt(t)<32?" ":n.charAt(t);return h.trim(e)}function p(n){return l(n=c(n=s(n=i(n))))}function u(n){return a(n=o(n))}var d=t(7).FilterCSS,m=t(7).getDefaultWhiteList,h=t(11),g=new d,f=/</g,b=/>/g,v=/"/g,y=/&quot;/g,x=/&#([a-zA-Z0-9]*);?/gim,w=/&colon;?/gim,k=/&newline;?/gim,S=/((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi,C=/e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi,j=/u\s*r\s*l\s*\(.*/gi;e.whiteList={a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],figcaption:[],figure:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height"],ins:["datetime"],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],summary:[],sup:[],strong:[],strike:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","crossorigin","loop","muted","playsinline","poster","preload","src","height","width"]},e.getDefaultWhiteList=r,e.onTag=function(n,e,t){},e.onIgnoreTag=function(n,e,t){},e.onTagAttr=function(n,e,t){},e.onIgnoreTagAttr=function(n,e,t){},e.safeAttrValue=function(n,e,t,r){if(t=p(t),"href"===e||"src"===e){if("#"===(t=h.trim(t)))return"#";if("http://"!==t.substr(0,7)&&"https://"!==t.substr(0,8)&&"mailto:"!==t.substr(0,7)&&"tel:"!==t.substr(0,4)&&"data:image/"!==t.substr(0,11)&&"ftp://"!==t.substr(0,6)&&"./"!==t.substr(0,2)&&"../"!==t.substr(0,3)&&"#"!==t[0]&&"/"!==t[0])return""}else if("background"===e){if(S.lastIndex=0,S.test(t))return""}else if("style"===e){if(C.lastIndex=0,C.test(t))return"";if(j.lastIndex=0,j.test(t)&&(S.lastIndex=0,S.test(t)))return"";!1!==r&&(t=(r=r||g).process(t))}return u(t)},e.escapeHtml=a,e.escapeQuote=o,e.unescapeQuote=i,e.escapeHtmlEntities=s,e.escapeDangerHtml5Entities=c,e.clearNonPrintableCharacter=l,e.friendlyAttrValue=p,e.escapeAttrValue=u,e.onIgnoreTagStripAll=function(){return""},e.StripTagBody=function(n,e){function t(e){return!!r||-1!==h.indexOf(n,e)}"function"!=typeof e&&(e=function(){});var r=!Array.isArray(n),a=[],o=!1;return{onIgnoreTag:function(n,r,i){if(t(n)){if(i.isClosing){var s="[/removed]",c=i.position+s.length;return a.push([!1!==o?o:i.position,c]),o=!1,s}return o||(o=i.position),"[removed]"}return e(n,r,i)},remove:function(n){var e="",t=0;return h.forEach(a,(function(r){e+=n.slice(t,r[0]),t=r[1]})),e+=n.slice(t)}}},e.stripCommentTag=function(n){for(var e="",t=0;t<n.length;){var r=n.indexOf("\x3c!--",t);if(-1===r){e+=n.slice(t);break}e+=n.slice(t,r);var a=n.indexOf("--\x3e",r);if(-1===a)break;t=a+3}return e},e.stripBlankChar=function(n){var e=n.split("");return(e=e.filter((function(n){var e=n.charCodeAt(0);return!(127===e||e<=31&&10!==e&&13!==e)}))).join("")},e.cssFilter=g,e.getDefaultCSSWhiteList=m},function(n,e,t){function r(n){var e=c.spaceIndex(n);if(-1===e)var t=n.slice(1,-1);else t=n.slice(1,e+1);return"/"===(t=c.trim(t).toLowerCase()).slice(0,1)&&(t=t.slice(1)),"/"===t.slice(-1)&&(t=t.slice(0,-1)),t}function a(n){return"</"===n.slice(0,2)}function o(n,e){for(;e<n.length;e++){var t=n[e];if(" "!==t)return"="===t?e:-1}}function i(n,e){for(;e>0;e--){var t=n[e];if(" "!==t)return"="===t?e:-1}}function s(n){return function(n){return'"'===n[0]&&'"'===n[n.length-1]||"'"===n[0]&&"'"===n[n.length-1]}(n)?n.substr(1,n.length-2):n}var c=t(11),l=/[^a-zA-Z0-9_:\.\-]/gim;e.parseTag=function(n,e,t){"use strict";var o="",i=0,s=!1,c=!1,l=0,p=n.length,u="",d="";n:for(l=0;l<p;l++){var m=n.charAt(l);if(!1===s){if("<"===m){s=l;continue}}else if(!1===c){if("<"===m){o+=t(n.slice(i,l)),s=l,i=l;continue}if(">"===m){o+=t(n.slice(i,s)),u=r(d=n.slice(s,l+1)),o+=e(s,o.length,u,d,a(d)),i=l+1,s=!1;continue}if('"'===m||"'"===m)for(var h=1,g=n.charAt(l-h);""===g.trim()||"="===g;){if("="===g){c=m;continue n}g=n.charAt(l-++h)}}else if(m===c){c=!1;continue}}return i<n.length&&(o+=t(n.substr(i))),o},e.parseAttr=function(n,e){"use strict";function t(n,t){if(!((n=(n=c.trim(n)).replace(l,"").toLowerCase()).length<1)){var r=e(n,t||"");r&&a.push(r)}}for(var r=0,a=[],p=!1,u=n.length,d=0;d<u;d++){var m,h=n.charAt(d);if(!1!==p||"="!==h)if(!1===p||d!==r||'"'!==h&&"'"!==h||"="!==n.charAt(d-1)){if(/\s|\n|\t/.test(h)){if(n=n.replace(/\s|\n|\t/g," "),!1===p){if(-1===(m=o(n,d))){t(c.trim(n.slice(r,d))),p=!1,r=d+1;continue}d=m-1;continue}if(-1===(m=i(n,d-1))){t(p,s(c.trim(n.slice(r,d)))),p=!1,r=d+1;continue}}}else{if(-1===(m=n.indexOf(h,d+1)))break;t(p,c.trim(n.slice(r+1,m))),p=!1,r=(d=m)+1}else p=n.slice(r,d),r=d+1}return r<n.length&&(!1===p?t(n.slice(r)):t(p,s(c.trim(n.slice(r))))),c.trim(a.join(" "))}},function(n,e,t){var r,a,o;
/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/a=[n,e],r=function(n,e){"use strict";function t(n){function e(e){var t=n.style.width;n.style.width="0px",n.offsetWidth,n.style.width=t,n.style.overflowY=e}function t(){if(0!==n.scrollHeight){var e=function(n){for(var e=[];n&&n.parentNode&&n.parentNode instanceof Element;)n.parentNode.scrollTop&&e.push({node:n.parentNode,scrollTop:n.parentNode.scrollTop}),n=n.parentNode;return e}(n),t=document.documentElement&&document.documentElement.scrollTop;n.style.height="",n.style.height=n.scrollHeight+a+"px",s=n.clientWidth,e.forEach((function(n){n.node.scrollTop=n.scrollTop})),t&&(document.documentElement.scrollTop=t)}}function r(){t();var r=Math.round(parseFloat(n.style.height)),a=window.getComputedStyle(n,null),o="content-box"===a.boxSizing?Math.round(parseFloat(a.height)):n.offsetHeight;if(o<r?"hidden"===a.overflowY&&(e("scroll"),t(),o="content-box"===a.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight):"hidden"!==a.overflowY&&(e("hidden"),t(),o="content-box"===a.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight),c!==o){c=o;var s=i("autosize:resized");try{n.dispatchEvent(s)}catch(n){}}}if(n&&n.nodeName&&"TEXTAREA"===n.nodeName&&!o.has(n)){var a=null,s=null,c=null,l=function(){n.clientWidth!==s&&r()},p=function(e){window.removeEventListener("resize",l,!1),n.removeEventListener("input",r,!1),n.removeEventListener("keyup",r,!1),n.removeEventListener("autosize:destroy",p,!1),n.removeEventListener("autosize:update",r,!1),Object.keys(e).forEach((function(t){n.style[t]=e[t]})),o.delete(n)}.bind(n,{height:n.style.height,resize:n.style.resize,overflowY:n.style.overflowY,overflowX:n.style.overflowX,wordWrap:n.style.wordWrap});n.addEventListener("autosize:destroy",p,!1),"onpropertychange"in n&&"oninput"in n&&n.addEventListener("keyup",r,!1),window.addEventListener("resize",l,!1),n.addEventListener("input",r,!1),n.addEventListener("autosize:update",r,!1),n.style.overflowX="hidden",n.style.wordWrap="break-word",o.set(n,{destroy:p,update:r}),function(){var e=window.getComputedStyle(n,null);"vertical"===e.resize?n.style.resize="none":"both"===e.resize&&(n.style.resize="horizontal"),a="content-box"===e.boxSizing?-(parseFloat(e.paddingTop)+parseFloat(e.paddingBottom)):parseFloat(e.borderTopWidth)+parseFloat(e.borderBottomWidth),isNaN(a)&&(a=0),r()}()}}function r(n){var e=o.get(n);e&&e.destroy()}function a(n){var e=o.get(n);e&&e.update()}var o="function"==typeof Map?new Map:function(){var n=[],e=[];return{has:function(e){return n.indexOf(e)>-1},get:function(t){return e[n.indexOf(t)]},set:function(t,r){-1===n.indexOf(t)&&(n.push(t),e.push(r))},delete:function(t){var r=n.indexOf(t);r>-1&&(n.splice(r,1),e.splice(r,1))}}}(),i=function(n){return new Event(n,{bubbles:!0})};try{new Event("test")}catch(n){i=function(n){var e=document.createEvent("Event");return e.initEvent(n,!0,!1),e}}var s=null;"undefined"==typeof window||"function"!=typeof window.getComputedStyle?((s=function(n){return n}).destroy=function(n){return n},s.update=function(n){return n}):((s=function(n,e){return n&&Array.prototype.forEach.call(n.length?n:[n],(function(n){return t(n)})),n}).destroy=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],r),n},s.update=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],a),n}),e.default=s,n.exports=e.default},void 0!==(o="function"==typeof r?r.apply(e,a):r)&&(n.exports=o)},function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{default:n}}function a(n){return!!n&&this.init(n),this}function o(n){return new a(n)}var i=r(t(42)),s=r(t(33)),c=r(t(37)),l=r(t(12)),p=t(6),u=r(t(41)),d=r(t(36)),m=t(40),h=r(t(38)),g=r(t(3)),f=r(t(39)),b=r(t(13)),v=(r(t(35)),{comment:"",nick:"",mail:"",link:"",ua:g.default.ua,url:"",QQAvatar:""}),y="",x={},w={cdn:"https://gravatar.loli.net/avatar/",ds:["mp","identicon","monsterid","wavatar","robohash","retro",""],params:"",hide:!1};a.prototype.init=function(n){if("undefined"==typeof document)throw new Error("Sorry, Valine does not support Server-side rendering.");var e=this;return n&&(n=g.default.extend(p.CONFIG,n),e.i18n=(0,c.default)(n.lang||g.default.lang,n.langMode),e.cfg=n,l.default.maps=!!n.emojiMaps&&n.emojiMaps||l.default.maps,l.default.cdn=!!n.emojiCDN&&n.emojiCDN||l.default.cdn,e._init()),e},a.prototype._init=function(){var n=this;try{var e=n.cfg,t=e.avatar,r=e.avatarForce,a=e.avatar_cdn,o=e.visitor,i=e.path,s=void 0===i?location.pathname:i,c=e.pageSize,l=e.recordIP;n.cfg.path=s.replace(/index\.html?$/,"");var u=w.ds,f=r?"&q="+(0,p.RandomStr)():"";w.params="?d="+(u.indexOf(t)>-1?t:"mp")+"&v="+p.VERSION+f,w.hide="hide"===t,w.cdn=/^https?\:\/\//.test(a)?a:w.cdn,n.cfg.pageSize=isNaN(c)||c<1?10:c,l&&(0,m.recordIPFn)((function(n){return v.ip=n}));var b=n.cfg.el||null,y=(0,g.default)(b);if(b=b instanceof HTMLElement?b:y[y.length-1]||null){n.$el=(0,g.default)(b),n.$el.addClass("v").attr("data-class","v"),w.hide&&n.$el.addClass("hide-avatar"),n.cfg.meta=(n.cfg.guest_info||n.cfg.meta||p.defaultMeta).filter((function(n){return p.defaultMeta.indexOf(n)>-1})),n.cfg.requiredFields=n.cfg.requiredFields.filter((function(n){return p.defaultMeta.indexOf(n)>-1}));var x=(0==n.cfg.meta.length?p.defaultMeta:n.cfg.meta).map((function(e){var t="mail"==e?"email":"text";return p.defaultMeta.indexOf(e)>-1?'<input name="'+e+'" placeholder="'+n.i18n.t(e)+'" class="v'+e+' vinput" type="'+t+'">':""})),k='<div class="vpanel"><div class="vwrap"><p class="cancel-reply text-right" style="display:none;" title="'+n.i18n.t("cancelReply")+'"><svg class="vicon cancel-reply-btn" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4220" width="22" height="22"><path d="M796.454 985H227.545c-50.183 0-97.481-19.662-133.183-55.363-35.7-35.701-55.362-83-55.362-133.183V227.545c0-50.183 19.662-97.481 55.363-133.183 35.701-35.7 83-55.362 133.182-55.362h568.909c50.183 0 97.481 19.662 133.183 55.363 35.701 35.702 55.363 83 55.363 133.183v568.909c0 50.183-19.662 97.481-55.363 133.183S846.637 985 796.454 985zM227.545 91C152.254 91 91 152.254 91 227.545v568.909C91 871.746 152.254 933 227.545 933h568.909C871.746 933 933 871.746 933 796.454V227.545C933 152.254 871.746 91 796.454 91H227.545z" p-id="4221"></path><path d="M568.569 512l170.267-170.267c15.556-15.556 15.556-41.012 0-56.569s-41.012-15.556-56.569 0L512 455.431 341.733 285.165c-15.556-15.556-41.012-15.556-56.569 0s-15.556 41.012 0 56.569L455.431 512 285.165 682.267c-15.556 15.556-15.556 41.012 0 56.569 15.556 15.556 41.012 15.556 56.569 0L512 568.569l170.267 170.267c15.556 15.556 41.012 15.556 56.569 0 15.556-15.556 15.556-41.012 0-56.569L568.569 512z" p-id="4222" ></path></svg></p><div class="vheader item'+x.length+'">'+x.join("")+'</div><div class="vedit"><textarea id="veditor" class="veditor vinput" placeholder="'+n.cfg.placeholder+'"></textarea><div class="vrow"><div class="vcol vcol-60 status-bar"></div><div class="vcol vcol-40 vctrl text-right"><span title="'+n.i18n.t("emoji")+'"  class="vicon vemoji-btn"><svg  viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16172" width="22" height="22" ><path d="M512 1024a512 512 0 1 1 512-512 512 512 0 0 1-512 512zM512 56.888889a455.111111 455.111111 0 1 0 455.111111 455.111111 455.111111 455.111111 0 0 0-455.111111-455.111111zM312.888889 512A85.333333 85.333333 0 1 1 398.222222 426.666667 85.333333 85.333333 0 0 1 312.888889 512z" p-id="16173"></path><path d="M512 768A142.222222 142.222222 0 0 1 369.777778 625.777778a28.444444 28.444444 0 0 1 56.888889 0 85.333333 85.333333 0 0 0 170.666666 0 28.444444 28.444444 0 0 1 56.888889 0A142.222222 142.222222 0 0 1 512 768z" p-id="16174"></path><path d="M782.222222 391.964444l-113.777778 59.733334a29.013333 29.013333 0 0 1-38.684444-10.808889 28.444444 28.444444 0 0 1 10.24-38.684445l113.777778-56.888888a28.444444 28.444444 0 0 1 38.684444 10.24 28.444444 28.444444 0 0 1-10.24 36.408888z" p-id="16175"></path><path d="M640.568889 451.697778l113.777778 56.888889a27.875556 27.875556 0 0 0 38.684444-10.24 27.875556 27.875556 0 0 0-10.24-38.684445l-113.777778-56.888889a28.444444 28.444444 0 0 0-38.684444 10.808889 28.444444 28.444444 0 0 0 10.24 38.115556z" p-id="16176"></path></svg></span><span title="'+n.i18n.t("preview")+'" class="vicon vpreview-btn"><svg  viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="17688" width="22" height="22"><path d="M502.390154 935.384615a29.538462 29.538462 0 1 1 0 59.076923H141.430154C79.911385 994.461538 29.538462 946.254769 29.538462 886.153846V137.846154C29.538462 77.745231 79.950769 29.538462 141.390769 29.538462h741.218462c61.44 0 111.852308 48.206769 111.852307 108.307692v300.268308a29.538462 29.538462 0 1 1-59.076923 0V137.846154c0-26.899692-23.355077-49.230769-52.775384-49.230769H141.390769c-29.420308 0-52.775385 22.331077-52.775384 49.230769v748.307692c0 26.899692 23.355077 49.230769 52.775384 49.230769h360.999385z" p-id="17689"></path><path d="M196.923077 216.615385m29.538461 0l374.153847 0q29.538462 0 29.538461 29.538461l0 0q0 29.538462-29.538461 29.538462l-374.153847 0q-29.538462 0-29.538461-29.538462l0 0q0-29.538462 29.538461-29.538461Z" p-id="17690"></path><path d="M649.846154 846.769231a216.615385 216.615385 0 1 0 0-433.230769 216.615385 216.615385 0 0 0 0 433.230769z m0 59.076923a275.692308 275.692308 0 1 1 0-551.384616 275.692308 275.692308 0 0 1 0 551.384616z" p-id="17691"></path><path d="M807.398383 829.479768m20.886847-20.886846l0 0q20.886846-20.886846 41.773692 0l125.321079 125.321079q20.886846 20.886846 0 41.773693l0 0q-20.886846 20.886846-41.773693 0l-125.321078-125.321079q-20.886846-20.886846 0-41.773693Z" p-id="17692"></path></svg></span></div></div></div><div class="vrow"><div class="vcol vcol-30" ><a alt="Markdown is supported" href="https://guides.github.com/features/mastering-markdown/" class="vicon" target="_blank"><svg class="markdown" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z"></path></svg></a></div><div class="vcol vcol-70 text-right"><button type="button"  title="Cmd|Ctrl+Enter" class="vsubmit vbtn">'+n.i18n.t("submit")+'</button></div></div><div class="vemojis" style="display:none;"></div><div class="vinput vpreview" style="display:none;"></div></div></div><div class="vcount" style="display:none;"><span class="vnum">0</span> '+n.i18n.t("comments")+'</div><div class="vload-top text-center" style="display:none;"><i class="vspinner" style="width:30px;height:30px;"></i></div><div class="vcards"></div><div class="vload-bottom text-center" style="display:none;"><i class="vspinner" style="width:30px;height:30px;"></i></div><div class="vempty" style="display:none;"></div><div class="vpage txt-center" style="display:none"><button type="button" class="vmore vbtn">'+n.i18n.t("more")+'</button></div><div class="vpower txt-right">Powered By <a href="https://valine.js.org" target="_blank">Valine</a><br>v'+p.VERSION+"</div>";n.$el.html(k),n.$el.find(".cancel-reply").on("click",(function(e){n.reset()}));var C=n.$el.find(".vempty");n.$nodata={show:function(e){return C.html(e||n.i18n.t("sofa")).show(),n},hide:function(){return C.hide(),n}};var j=n.$el.find(".vload-bottom"),A=n.$el.find(".vload-top");n.$loading={show:function(e){return e&&A.show()||j.show(),n.$nodata.hide(),n},hide:function(){return A.hide(),j.hide(),0===n.$el.find(".vcard").length&&n.$nodata.show(),n}}}(0,d.default)(n.cfg,(function(e){var t=(0,g.default)(".valine-comment-count"),r=0;!function e(t){var a=t[r++];if(a){var o=(0,g.default)(a).attr("data-xid");o&&n.Q(o).count().then((function(n){a.innerText=n,e(t)})).catch((function(n){a.innerText=0}))}}(t),o&&S.add(AV.Object.extend("Counter"),n.cfg.path),n.$el&&n.bind()}))}catch(e){(0,h.default)(n,e,"init")}};var k=function(n,e){var t=new n,r=new AV.ACL;r.setPublicReadAccess(!0),r.setPublicWriteAccess(!0),t.setACL(r),t.set("url",e.url),t.set("xid",e.xid),t.set("title",e.title),t.set("time",1),t.save().then((function(n){(0,g.default)(e.el).find(".leancloud-visitors-count").text(1)})).catch((function(n){}))},S={add:function(n,e){var t=this,r=(0,g.default)(".leancloud_visitors,.leancloud-visitors");if(1===r.length){var a=r[0],o=decodeURI((0,g.default)(a).attr("id")),i=(0,g.default)(a).attr("data-flag-title"),s=encodeURI(o),c={el:a,url:o,xid:s,title:i};if(decodeURI(o)===decodeURI(e)){var l=new AV.Query(n);l.equalTo("url",o),l.find().then((function(e){if(e.length>0){var t=e[0];t.increment("time"),t.save().then((function(n){(0,g.default)(a).find(".leancloud-visitors-count").text(n.get("time"))})).catch((function(n){}))}else k(n,c)})).catch((function(e){101==e.code?k(n,c):(0,h.default)(t,e)}))}else S.show(n,r)}else S.show(n,r)},show:function(n,e){var t=[];if(e.forEach((function(n){var e=(0,g.default)(n).find(".leancloud-visitors-count");e&&e.text("0"),t.push(/\%/.test((0,g.default)(n).attr("id"))?decodeURI((0,g.default)(n).attr("id")):(0,g.default)(n).attr("id"))})),t.length){var r=new AV.Query(n);r.containedIn("url",t),r.find().then((function(n){n.length>0&&e.forEach((function(e){n.forEach((function(n){var t=n.get("xid")||encodeURI(n.get("url")),r=n.get("time"),a=(0,g.default)(e),o=a.attr("id");if((/\%/.test(o)?o:encodeURI(o))==t){var i=a.find(".leancloud-visitors-count");i&&i.text(r)}}))}))})).catch((function(n){}))}}};a.prototype.Q=function(n){var e=this,t=arguments.length,r=e.cfg.clazzName;if(1==t){var a=new AV.Query(r);a.doesNotExist("rid");var o=new AV.Query(r);o.equalTo("rid","");var i=AV.Query.or(a,o);return"*"===n?i.exists("url"):i.equalTo("url",decodeURI(n)),i.addDescending("createdAt"),i.addDescending("insertedAt"),i}var s=JSON.stringify(arguments[1]).replace(/(\[|\])/g,""),c="select * from "+r+" where rid in ("+s+") order by -createdAt,-createdAt";return AV.Query.doCloudQuery(c)},a.prototype.installLocale=function(n,e){return this.i18n(n,e),this},a.prototype.setPath=function(n){return this.config.path=n,this},a.prototype.bind=function(){var n=this,e=n.$el.find(".vemojis"),t=n.$el.find(".vpreview"),r=n.$el.find(".vemoji-btn"),a=n.$el.find(".vpreview-btn"),o=n.$el.find(".veditor"),c=l.default.maps,d=!1;n.$emoji={show:function(){return!d&&function(n){var t=[];for(var r in c)c.hasOwnProperty(r)&&l.default.build(r)&&t.push('<i title="'+r+'" >'+l.default.build(r)+"</i>");e.html(t.join("")),d=!0,e.find("i").on("click",(function(n){n.preventDefault(),E(o[0]," :"+(0,g.default)(this).attr("title")+":")}))}(),n.$preview.hide(),e.show(),r.addClass("actived"),n.$emoji},hide:function(){return r.removeClass("actived"),e.hide(),n.$emoji}},n.$preview={show:function(){return y?(n.$emoji.hide(),a.addClass("actived"),t.html((0,f.default)(y)).show(),L()):n.$preview.hide(),n.$preview},hide:function(){return a.removeClass("actived"),t.hide().html(""),n.$preview}};var k=function(e){var r=e.val()||"";r||n.$preview.hide(),y!=r&&(y=r,a.hasClass("actived")>-1&&y!=t.html()&&t.html((0,f.default)(y)),L())};r.on("click",(function(e){r.hasClass("actived")?n.$emoji.hide():n.$emoji.show()})),a.on("click",(function(e){a.hasClass("actived")?n.$preview.hide():n.$preview.show()}));var S=n.cfg.meta,C={},j={veditor:"comment"};for(var A in S.forEach((function(n){j["v"+n]=n})),j)j.hasOwnProperty(A)&&function(){var e=j[A],t=n.$el.find("."+A);C[e]=t,t.on("input change blur propertychange",(function(r){n.cfg.enableQQ&&"blur"===r.type&&"nick"===e&&(t.val()&&!isNaN(t.val())?(0,m.fetchQQFn)(t.val(),(function(n){var e=n.nick||t.val(),r=n.qq+"@qq.com";(0,g.default)(".vnick").val(e),(0,g.default)(".vmail").val(r),v.nick=e,v.mail=r,v.QQAvatar=n.pic})):g.default.store.get(p.QQCacheKey)&&g.default.store.get(p.QQCacheKey).nick!=t.val()&&(g.default.store.remove(p.QQCacheKey),v.nick=t.val(),v.mail="",v.QQAvatar="")),"comment"===e?((0,s.default)(t[0]),T((function(n){k(t)}))()):v[e]=(0,b.default)(t.val().replace(/(^\s*)|(\s*$)/g,"").substring(0,35))}))}();var T=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:300,t=void 0;return function(){var r=this,a=arguments;t&&clearTimeout(t),t=setTimeout((function(){n.apply(r,a)}),e)}},E=function(n,e){if(document.selection)n.focus(),document.selection.createRange().text=e,n.focus();else if(n.selectionStart||"0"==n.selectionStart){var t=n.selectionStart,r=n.selectionEnd,a=n.scrollTop;n.value=n.value.substring(0,t)+e+n.value.substring(r,n.value.length),n.focus(),n.selectionStart=t+e.length,n.selectionEnd=t+e.length,n.scrollTop=a}else n.focus(),n.value+=e;T((function(e){k((0,g.default)(n))}))()},P={no:1,size:n.cfg.pageSize,skip:n.cfg.pageSize},D=n.$el.find(".vpage");D.on("click",(function(n){D.hide(),P.no++,z()}));var z=function(){var e=P.size,t=P.no,r=Number(n.$el.find(".vnum").text());n.$loading.show();var a=n.Q(n.cfg.path);a.limit(e),a.skip((t-1)*e),a.find().then((function(a){if(P.skip=P.size,a&&a.length){var o=[];a.forEach((function(e){o.push(e.id),I(e,n.$el.find(".vcards"),!0)})),n.Q(n.cfg.path,o).then((function(n){(n&&n.results||[]).forEach((function(n){I(n,(0,g.default)('.vquote[data-self-id="'+n.get("rid")+'"]'))}))})).catch((function(n){})),e*t<r?D.show():D.hide(),L()}else n.$nodata.show();n.$loading.hide()})).catch((function(e){n.$loading.hide(),(0,h.default)(n,e,"query")}))};n.Q(n.cfg.path).count().then((function(e){e>0?(n.$el.find(".vcount").show().find(".vnum").text(e),z()):n.$loading.hide()})).catch((function(e){(0,h.default)(n,e,"count")}));var B=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",e=/(https?|http):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/g,t=n.match(e)||[];return t.length>0?t[0]:""},I=function(e,t,r){var a=(0,g.default)('<div class="vcard" id="'+e.id+'"></div>'),o=(0,b.default)(e.get("ua")),s="";o&&!/ja/.test(n.cfg.lang)&&(s=(o=g.default.detect(o)).version?o.os?'<span class="vsys">'+o.browser+" "+o.version+'</span> <span class="vsys">'+o.os+" "+o.osVersion+"</span>":"":'<span class="vsys">'+o.browser+"</span>"),"*"===n.cfg.path&&(s='<a href="'+e.get("url")+'" class="vsys">'+e.get("url")+"</a>");var c=e.get("link")?/^https?\:\/\//.test(e.get("link"))?e.get("link"):"http://"+e.get("link"):"",l=g.default.escape((0,b.default)(e.get("nick").substring(0,30))),p=c?'<a class="vnick" rel="nofollow" href="'+B(c)+'" target="_blank" >'+l+"</a>":'<span class="vnick">'+l+"</span>",d=(w.hide?"":n.cfg.enableQQ&&e.get("QQAvatar")?(0,b.default)('<img class="vimg" src="'+B(e.get("QQAvatar"))+'" referrerPolicy="no-referrer"/>'):'<img class="vimg" src="'+(w.cdn+(0,i.default)(e.get("mail"))+w.params)+'">')+'<div class="vh"><div class="vhead">'+p+" "+s+'</div><div class="vmeta"><span class="vtime" >'+(0,u.default)(e.get("insertedAt"),n.i18n)+'</span><span class="vat" data-vm-id="'+(e.get("rid")||e.id)+'" data-self-id="'+e.id+'">'+n.i18n.t("reply")+'</span></div><div class="vcontent" data-expand="'+n.i18n.t("expand")+'">'+(0,f.default)(e.get("comment"))+'</div><div class="vreply-wrapper" data-self-id="'+e.id+'"></div><div class="vquote" data-self-id="'+e.id+'"></div></div>';a.html(d);var m=a.find(".vat");a.find("a:not(.at)").forEach((function(n){(0,g.default)(n).attr({target:"_blank",rel:"noopener"})})),r?t.append(a):t.prepend(a);var h=a.find(".vcontent");h&&F(h),m&&_(m,e)},O={},_=function(e,t){e.on("click",(function(r){var a=e.attr("data-vm-id"),o=e.attr("data-self-id"),i=n.$el.find(".vwrap"),s="@"+g.default.escape(t.get("nick"));(0,g.default)('.vreply-wrapper[data-self-id="'+o+'"]').append(i).find(".cancel-reply").show(),O={at:g.default.escape(s)+" ",rid:a,pid:o,rmail:t.get("mail")},C.comment.attr({placeholder:s})[0].focus()}))},L=function(){setTimeout((function(){try{n.cfg.mathjax&&"MathJax"in window&&"version"in window.MathJax&&(/^3.*/.test(window.MathJax.version)&&MathJax.typeset()||MathJax.Hub.Queue(["Typeset",MathJax.Hub,document.querySelector(".v")])),"renderMathInElement"in window&&renderMathInElement((0,g.default)(".v")[0],{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})}catch(n){}}),100)},F=function(n){setTimeout((function(){n[0].offsetHeight>200&&(n.addClass("expand"),n.on("click",(function(e){n.removeClass("expand")})))}))};!function(e){if(e=g.default.store.get(p.MetaCacheKey)||e)for(var t in S)if(S.hasOwnProperty(t)){var r=S[t];n.$el.find(".v"+r).val(g.default.unescape(e[r])),v[r]=e[r]}var a=g.default.store.get(p.QQCacheKey);v.QQAvatar=n.cfg.enableQQ&&!!a&&a.pic||""}(),n.reset=function(){v.comment="",C.comment.val(""),k(C.comment),C.comment.attr("placeholder",n.cfg.placeholder),O={},n.$preview.hide(),n.$el.find(".vpanel").append(n.$el.find(".vwrap")),n.$el.find(".cancel-reply").hide(),y="",s.default.update(C.comment[0])};var M=n.$el.find(".vsubmit"),R=function(e){if(n.cfg.requiredFields.indexOf("nick")>-1&&v.nick.length<3)return C.nick[0].focus(),void n.$el.find(".status-bar").text(""+n.i18n.t("nickFail")).empty(3e3);if(n.cfg.requiredFields.indexOf("mail")>-1&&!/[\w-\.]+@([\w-]+\.)+[a-z]{2,3}/.test(v.mail))return C.mail[0].focus(),void n.$el.find(".status-bar").text(""+n.i18n.t("mailFail")).empty(3e3);if(""!=y){for(var t in x)if(x.hasOwnProperty(t)){var r=x[t];y=y.replace(t,r),URL.revokeObjectURL(t)}x={},v.comment=(0,b.default)(y),v.nick=v.nick||"Anonymous";var a=g.default.store.get("vlx");a&&Date.now()/1e3-a/1e3<20?n.$el.find(".status-bar").text(n.i18n.t("busy")).empty(3e3):N()}else C.comment[0].focus()},N=function(){g.default.store.set("vlx",Date.now()),M.attr({disabled:!0}),n.$loading.show(!0);var e=new(AV.Object.extend(n.cfg.clazzName||"Comment"));if(v.url=decodeURI(n.cfg.path),v.insertedAt=new Date,O.rid){var t=O.pid||O.rid;e.set("rid",O.rid),e.set("pid",t),v.comment=y.replace("<p>",'<p><a class="at" href="#'+t+'">'+O.at+"</a> , ")}for(var r in v)if(v.hasOwnProperty(r)){var a=v[r];e.set(r,a)}e.setACL(function(){var n=new AV.ACL;return n.setPublicReadAccess(!0),n.setPublicWriteAccess(!1),n}()),e.save().then((function(e){"Anonymous"!=v.nick&&g.default.store.set(p.MetaCacheKey,{nick:v.nick,link:v.link,mail:v.mail});var t=n.$el.find(".vnum");try{O.rid?I(e,(0,g.default)('.vquote[data-self-id="'+O.rid+'"]'),!0):(Number(t.text())?t.text(Number(t.text())+1):n.$el.find(".vcount").show().find(".vnum").text(Number(t.text())+1),I(e,n.$el.find(".vcards")),P.skip++),M.removeAttr("disabled"),n.$loading.hide(),n.reset()}catch(e){(0,h.default)(n,e,"save")}})).catch((function(e){(0,h.default)(n,e,"commitEvt")}))};M.on("click",R),(0,g.default)(document).on("keydown",(function(n){var e=(n=window.event||n).keyCode||n.which||n.charCode;(n.ctrlKey||n.metaKey)&&13===e&&R(),9===e&&"veditor"==(document.activeElement.id||"")&&(n.preventDefault(),E(o[0],"    "))})).on("paste",(function(n){var e="clipboardData"in n?n.clipboardData:n.originalEvent&&n.originalEvent.clipboardData||window.clipboardData;e&&q(e.items,!0)})),o.on("dragenter dragleave dragover drop",(function(n){n.stopPropagation(),n.preventDefault(),"drop"===n.type&&q(n.dataTransfer.items)}));var q=function(n,e){for(var t=0,r=n.length;t<r;t++){var a=n[t];if("string"===a.kind&&a.type.match("^text/html"))!e&&a.getAsString((function(n){n&&E(o[0],n.replace(/<[^>]+>/g,""))}));else if(a.type.indexOf("image")>-1){U(a.getAsFile());continue}}},U=function(n){try{var e=URL.createObjectURL(n),t="![image]("+e+") ",r=new FileReader;E(o[0],t),r.onload=function(){x[e]=r.result},r.readAsDataURL(n)}catch(n){}}},n.exports=o,n.exports.default=o},function(n,e,t){"use strict";e.__esModule=!0;var r=function(n){return n&&n.__esModule?n:{default:n}}(t(3));e.default={getApi:function(n,e){r.default.ajax({url:"https://app-router.com/2/route",body:{appId:n}}).then((function(n){n.json().then((function(n){return e&&e("//"+n.api_server)}))}))}}},function(n,e,t){"use strict";e.__esModule=!0;var r=function(n){return n&&n.__esModule?n:{default:n}}(t(3)),a=!1;e.default=function(n,e){if("AV"in window){var t=window.AV.version||window.AV.VERSION;parseInt(t.split(".")[0])>2?a=!!AV.applicationId&&!!AV.applicationKey:r.default.deleteInWin("AV",0)}a?e&&e():r.default.sdkLoader("//unpkg.com/leancloud-storage@3/dist/av-min.js","AV",(function(t){var r,o="https://",i=n.app_id||n.appId,s=n.app_key||n.appKey;if(!n.serverURLs)switch(i.slice(-9)){case"-9Nh9j0Va":o+="tab.";break;case"-MdYXbMMI":o+="us."}r=n.serverURLs||o+"leancloud.cn",AV.init({appId:i,appKey:s,serverURLs:r}),a=!0,e&&e()}))}},function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var a=r(t(84)),o=r(t(100)),i=r(t(101)),s=r(t(98)),c=r(t(99)),l={zh:o.default,"zh-cn":o.default,"zh-CN":o.default,"zh-TW":i.default,en:s.default,"en-US":s.default,ja:c.default,"ja-JP":c.default};e.default=function(n,e){return!l[n]&&n&&e&&(l[n]=e),new a.default({phrases:l[n||"zh"],locale:n})}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n,e){if(n.$el&&n.$loading.hide().$nodata.hide(),"[object Error]"==={}.toString.call(e)){var t=e.code||e.message||e.error||"";if(isNaN(t))n.$el&&n.$nodata.show('<pre style="text-align:left;"> '+JSON.stringify(e)+"</pre>");else{var r=n.i18n.t("code-"+t),a=(r=="code-"+t?void 0:r)||e.message||e.error||"";101==t||-1==t?n.$nodata.show():n.$el&&n.$nodata.show('<pre style="text-align:left;">Code '+t+": "+a+"</pre>")}}else n.$el&&n.$nodata.show('<pre style="text-align:left;">'+JSON.stringify(e)+"</pre>")}},function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var a=t(83),o=r(t(79)),i=r(t(3)),s=r(t(12)),c=r(t(13)),l=new a.marked.Renderer;l.code=function(n,e){return'<pre><code class="hljs language-'+e+'">'+(e&&hljs.getLanguage(e)?hljs.highlight(e,n).value:i.default.escape(n))+"</code></pre>"},a.marked.setOptions({renderer:"hljs"in window?l:new a.marked.Renderer,highlight:function(n,e){return"hljs"in window?e&&hljs.getLanguage(e)&&hljs.highlight(e,n,!0).value||hljs.highlightAuto(n).value:(0,o.default)(n)},gfm:!0,tables:!0,breaks:!0,pedantic:!1,sanitize:!1,smartLists:!0,smartypants:!0,headerPrefix:"v-"}),e.default=function(n){return(0,c.default)((0,a.marked)(s.default.parse(n,!0)))}},function(n,e,t){"use strict";e.__esModule=!0,e.recordIPFn=e.fetchQQFn=void 0;var r=function(n){return n&&n.__esModule?n:{default:n}}(t(3)),a=t(6);e.fetchQQFn=function(n,e){var t=r.default.store.get(a.QQCacheKey);t&&t.qq==n?e&&e(t):r.default.ajax({url:"//valine.api.ioliu.cn/getqqinfo",method:"POST",body:{qq:n}}).then((function(n){n.json().then((function(n){n.errmsg||(r.default.store.set(a.QQCacheKey,n),e&&e(n))}))}))},e.recordIPFn=function(n){r.default.ajax({url:"https://forge.speedtest.cn/api/location/info",method:"get"}).then((function(n){return n.json()})).then((function(e){n&&n(e.ip)}))}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n,e){if(!n)return"Invalid Date.";try{var t=a(n).getTime();if(isNaN(t))return"Invalid Date.";var o=(new Date).getTime()-t,i=Math.floor(o/864e5);if(0===i){var s=o%864e5,c=Math.floor(s/36e5);if(0===c){var l=s%36e5,p=Math.floor(l/6e4);if(0===p){var u=l%6e4;return Math.round(u/1e3)+" "+e.t("seconds")}return p+" "+e.t("minutes")}return c+" "+e.t("hours")}return i<0?e.t("now"):i<8?i+" "+e.t("days"):r(n)}catch(n){}};var r=function(n){var e=o(n.getDate(),2),t=o(n.getMonth()+1,2);return o(n.getFullYear(),2)+"-"+t+"-"+e},a=function n(e){return e instanceof Date?e:!isNaN(e)||/^\d+$/.test(e)?new Date(parseInt(e)):/GMT/.test(e||"")?n(new Date(e).getTime()):(e=(e||"").replace(/(^\s*)|(\s*$)/g,"").replace(/\.\d+/,"").replace(/-/,"/").replace(/-/,"/").replace(/(\d)T(\d)/,"$1 $2").replace(/Z/," UTC").replace(/([+-]\d\d):?(\d\d)/," $1$2"),new Date(e))},o=function(n,e){for(var t=n.toString();t.length<e;)t="0"+t;return t}},function(n,e,t){var r;!function(a){"use strict";function o(n,e){var t=(65535&n)+(65535&e);return(n>>16)+(e>>16)+(t>>16)<<16|65535&t}function i(n,e,t,r,a,i){return o(function(n,e){return n<<e|n>>>32-e}(o(o(e,n),o(r,i)),a),t)}function s(n,e,t,r,a,o,s){return i(e&t|~e&r,n,e,a,o,s)}function c(n,e,t,r,a,o,s){return i(e&r|t&~r,n,e,a,o,s)}function l(n,e,t,r,a,o,s){return i(e^t^r,n,e,a,o,s)}function p(n,e,t,r,a,o,s){return i(t^(e|~r),n,e,a,o,s)}function u(n,e){n[e>>5]|=128<<e%32,n[14+(e+64>>>9<<4)]=e;var t,r,a,i,u,d=1732584193,m=-271733879,h=-1732584194,g=271733878;for(t=0;t<n.length;t+=16)r=d,a=m,i=h,u=g,d=s(d,m,h,g,n[t],7,-680876936),g=s(g,d,m,h,n[t+1],12,-389564586),h=s(h,g,d,m,n[t+2],17,606105819),m=s(m,h,g,d,n[t+3],22,-1044525330),d=s(d,m,h,g,n[t+4],7,-176418897),g=s(g,d,m,h,n[t+5],12,1200080426),h=s(h,g,d,m,n[t+6],17,-1473231341),m=s(m,h,g,d,n[t+7],22,-45705983),d=s(d,m,h,g,n[t+8],7,1770035416),g=s(g,d,m,h,n[t+9],12,-1958414417),h=s(h,g,d,m,n[t+10],17,-42063),m=s(m,h,g,d,n[t+11],22,-1990404162),d=s(d,m,h,g,n[t+12],7,1804603682),g=s(g,d,m,h,n[t+13],12,-40341101),h=s(h,g,d,m,n[t+14],17,-1502002290),d=c(d,m=s(m,h,g,d,n[t+15],22,1236535329),h,g,n[t+1],5,-165796510),g=c(g,d,m,h,n[t+6],9,-1069501632),h=c(h,g,d,m,n[t+11],14,643717713),m=c(m,h,g,d,n[t],20,-373897302),d=c(d,m,h,g,n[t+5],5,-701558691),g=c(g,d,m,h,n[t+10],9,38016083),h=c(h,g,d,m,n[t+15],14,-660478335),m=c(m,h,g,d,n[t+4],20,-405537848),d=c(d,m,h,g,n[t+9],5,568446438),g=c(g,d,m,h,n[t+14],9,-1019803690),h=c(h,g,d,m,n[t+3],14,-187363961),m=c(m,h,g,d,n[t+8],20,1163531501),d=c(d,m,h,g,n[t+13],5,-1444681467),g=c(g,d,m,h,n[t+2],9,-51403784),h=c(h,g,d,m,n[t+7],14,1735328473),d=l(d,m=c(m,h,g,d,n[t+12],20,-1926607734),h,g,n[t+5],4,-378558),g=l(g,d,m,h,n[t+8],11,-2022574463),h=l(h,g,d,m,n[t+11],16,1839030562),m=l(m,h,g,d,n[t+14],23,-35309556),d=l(d,m,h,g,n[t+1],4,-1530992060),g=l(g,d,m,h,n[t+4],11,1272893353),h=l(h,g,d,m,n[t+7],16,-155497632),m=l(m,h,g,d,n[t+10],23,-1094730640),d=l(d,m,h,g,n[t+13],4,681279174),g=l(g,d,m,h,n[t],11,-358537222),h=l(h,g,d,m,n[t+3],16,-722521979),m=l(m,h,g,d,n[t+6],23,76029189),d=l(d,m,h,g,n[t+9],4,-640364487),g=l(g,d,m,h,n[t+12],11,-421815835),h=l(h,g,d,m,n[t+15],16,530742520),d=p(d,m=l(m,h,g,d,n[t+2],23,-995338651),h,g,n[t],6,-198630844),g=p(g,d,m,h,n[t+7],10,1126891415),h=p(h,g,d,m,n[t+14],15,-1416354905),m=p(m,h,g,d,n[t+5],21,-57434055),d=p(d,m,h,g,n[t+12],6,1700485571),g=p(g,d,m,h,n[t+3],10,-1894986606),h=p(h,g,d,m,n[t+10],15,-1051523),m=p(m,h,g,d,n[t+1],21,-2054922799),d=p(d,m,h,g,n[t+8],6,1873313359),g=p(g,d,m,h,n[t+15],10,-30611744),h=p(h,g,d,m,n[t+6],15,-1560198380),m=p(m,h,g,d,n[t+13],21,1309151649),d=p(d,m,h,g,n[t+4],6,-145523070),g=p(g,d,m,h,n[t+11],10,-1120210379),h=p(h,g,d,m,n[t+2],15,718787259),m=p(m,h,g,d,n[t+9],21,-343485551),d=o(d,r),m=o(m,a),h=o(h,i),g=o(g,u);return[d,m,h,g]}function d(n){var e,t="",r=32*n.length;for(e=0;e<r;e+=8)t+=String.fromCharCode(n[e>>5]>>>e%32&255);return t}function m(n){var e,t=[];for(t[(n.length>>2)-1]=void 0,e=0;e<t.length;e+=1)t[e]=0;var r=8*n.length;for(e=0;e<r;e+=8)t[e>>5]|=(255&n.charCodeAt(e/8))<<e%32;return t}function h(n){var e,t,r="0123456789abcdef",a="";for(t=0;t<n.length;t+=1)e=n.charCodeAt(t),a+=r.charAt(e>>>4&15)+r.charAt(15&e);return a}function g(n){return unescape(encodeURIComponent(n))}function f(n){return function(n){return d(u(m(n),8*n.length))}(g(n))}function b(n,e){return function(n,e){var t,r,a=m(n),o=[],i=[];for(o[15]=i[15]=void 0,a.length>16&&(a=u(a,8*n.length)),t=0;t<16;t+=1)o[t]=909522486^a[t],i[t]=1549556828^a[t];return r=u(o.concat(m(e)),512+8*e.length),d(u(i.concat(r),640))}(g(n),g(e))}function v(n,e,t){return e?t?b(e,n):function(n,e){return h(b(n,e))}(e,n):t?f(n):function(n){return h(f(n))}(n)}void 0!==(r=function(){return v}.call(e,t,e,n))&&(n.exports=r)}()},function(n,e,t){"use strict";var r=t(2),a=t(4),o=t(1),i=t(5),s=t(14),c=t(15),l=c(),p=t(44),u=o("Array.prototype.slice"),d=a.apply(l),m=function(n,e){return i(n),d(n,u(arguments,1))};r(m,{getPolyfill:c,implementation:s,shim:p}),n.exports=m},function(n,e,t){"use strict";var r=t(2),a=t(15);n.exports=function(){var n=a();return r(Array.prototype,{forEach:n},{forEach:function(){return Array.prototype.forEach!==n}}),n}},function(n,e,t){"use strict";e.__esModule=!0;var r=function(n){return n&&n.__esModule?n:{default:n}}(t(47));e.default=function(n){return n=(0,r.default)({url:"",method:"get",body:{}},n),new Promise((function(e,t){if("jsonp"==n.method){var r="cb_"+(Date.now()+Math.round(1e3*Math.random())).toString(32),a=document,i=a.body,s=a.createElement("script");return s.async=!0,s.defer=!0,n.url.indexOf("?")>-1?n.url+="&"+o({callback:r,t:Date.now()}):n.url+="?"+o({callback:r,t:Date.now()}),s.src=n.url,window[r]=function(n){window[r]=null,i.removeChild(s),e(n)},void i.appendChild(s)}var c="XMLHttpRequest"in window?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP"),l=[],p=[],u={};for(var d in o(n.body)&&(n.url=n.url+"?"+("get"==n.method?o(n.body):"")),c.open(n.method||"get",n.url),"blob"==n.dataType&&(c.responseType="blob"),c.onload=function(){c.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,(function(n,e,t){l.push(e=e.toLowerCase()),p.push([e,t]),u[e]=u[e]?u[e]+","+t:t})),e(function n(){return{ok:2==(c.status/100|0),statusText:c.statusText,status:c.status,url:c.responseURL,text:function(){return Promise.resolve(c.responseText)},json:function(){return Promise.resolve(c.responseText).then(JSON.parse)},blob:function(){return Promise.resolve(new Blob([c.response]))},clone:n,headers:{keys:function(){return l},entries:function(){return p},get:function(n){return u[n.toLowerCase()]},has:function(n){return n.toLowerCase()in u}}}}())},c.onerror=t,c.withCredentials="include"==n.credentials,n.headers)c.setRequestHeader(d,n.headers[d]);c.send("post"==n.method?n.body:"get"==n.method?"":o(n.body))}))};var a=encodeURIComponent,o=function(n){var e=[];for(var t in n)n.hasOwnProperty(t)&&e.push(a(t)+"="+a(n[t]));return(e=e.join("&").replace(/%20/g,"+"))||""}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n){var e={},t={Trident:(n=n||navigator.userAgent).indexOf("Trident")>-1||n.indexOf("NET CLR")>-1,Presto:n.indexOf("Presto")>-1,WebKit:n.indexOf("AppleWebKit")>-1,Gecko:n.indexOf("Gecko/")>-1,Safari:n.indexOf("Safari")>-1,Edge:n.indexOf("Edge")>-1||n.indexOf("Edg")>-1,Chrome:n.indexOf("Chrome")>-1||n.indexOf("CriOS")>-1,IE:n.indexOf("MSIE")>-1||n.indexOf("Trident")>-1,Firefox:n.indexOf("Firefox")>-1||n.indexOf("FxiOS")>-1,"Firefox Focus":n.indexOf("Focus")>-1,Chromium:n.indexOf("Chromium")>-1,Opera:n.indexOf("Opera")>-1||n.indexOf("OPR")>-1,Vivaldi:n.indexOf("Vivaldi")>-1,Yandex:n.indexOf("YaBrowser")>-1,Kindle:n.indexOf("Kindle")>-1||n.indexOf("Silk/")>-1,360:n.indexOf("360EE")>-1||n.indexOf("360SE")>-1,UC:n.indexOf("UC")>-1||n.indexOf(" UBrowser")>-1,QQBrowser:n.indexOf("QQBrowser")>-1,QQ:n.indexOf("QQ/")>-1,Baidu:n.indexOf("Baidu")>-1||n.indexOf("BIDUBrowser")>-1,Maxthon:n.indexOf("Maxthon")>-1,Sogou:n.indexOf("MetaSr")>-1||n.indexOf("Sogou")>-1,LBBROWSER:n.indexOf("LBBROWSER")>-1,"2345Explorer":n.indexOf("2345Explorer")>-1,TheWorld:n.indexOf("TheWorld")>-1,XiaoMi:n.indexOf("MiuiBrowser")>-1,Quark:n.indexOf("Quark")>-1,Qiyu:n.indexOf("Qiyu")>-1,Wechat:n.indexOf("MicroMessenger")>-1,Taobao:n.indexOf("AliApp(TB")>-1,Alipay:n.indexOf("AliApp(AP")>-1,Weibo:n.indexOf("Weibo")>-1,Douban:n.indexOf("com.douban.frodo")>-1,Suning:n.indexOf("SNEBUY-APP")>-1,iQiYi:n.indexOf("IqiyiApp")>-1,Windows:n.indexOf("Windows")>-1,Linux:n.indexOf("Linux")>-1||n.indexOf("X11")>-1,macOS:n.indexOf("Macintosh")>-1,Android:n.indexOf("Android")>-1||n.indexOf("Adr")>-1,Ubuntu:n.indexOf("Ubuntu")>-1,FreeBSD:n.indexOf("FreeBSD")>-1,Debian:n.indexOf("Debian")>-1,"Windows Phone":n.indexOf("IEMobile")>-1||n.indexOf("Windows Phone")>-1,BlackBerry:n.indexOf("BlackBerry")>-1||n.indexOf("RIM")>-1||n.indexOf("BB10")>-1,MeeGo:n.indexOf("MeeGo")>-1,Symbian:n.indexOf("Symbian")>-1,iOS:n.indexOf("like Mac OS X")>-1,"Chrome OS":n.indexOf("CrOS")>-1,WebOS:n.indexOf("hpwOS")>-1,Mobile:n.indexOf("Mobi")>-1||n.indexOf("iPh")>-1||n.indexOf("480")>-1,Tablet:n.indexOf("Tablet")>-1||n.indexOf("Pad")>-1||n.indexOf("Nexus 7")>-1};t.Mobile&&(t.Mobile=!(n.indexOf("iPad")>-1));var r={browser:["Safari","Chrome","Edge","IE","Firefox","Firefox Focus","Chromium","Opera","Vivaldi","Yandex","Kindle","360","UC","QQBrowser","QQ","Baidu","Maxthon","Sogou","LBBROWSER","2345Explorer","TheWorld","XiaoMi","Quark","Qiyu","Wechat","Taobao","Alipay","Weibo","Douban","Suning","iQiYi"],os:["Windows","Linux","Mac OS","macOS","Android","Ubuntu","FreeBSD","Debian","iOS","Windows Phone","BlackBerry","MeeGo","Symbian","Chrome OS","WebOS"]};for(var a in r)if(r.hasOwnProperty(a))for(var o=0,i=r[a].length;o<i;o++){var s=r[a][o];t[s]&&(e[a]=s)}var c={Windows:function(){return{"10.0":"11",6.4:"10",6.3:"8.1",6.2:"8",6.1:"7","6.0":"Vista",5.2:"XP",5.1:"XP","5.0":"2000"}[n.replace(/^.*Windows NT ([\d.]+).*$/,"$1")]},Android:n.replace(/^.*Android ([\d.]+);.*$/,"$1"),iOS:n.replace(/^.*OS ([\d_]+) like.*$/,"$1").replace(/_/g,"."),Debian:n.replace(/^.*Debian\/([\d.]+).*$/,"$1"),"Windows Phone":n.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/,"$2"),macOS:n.replace(/^.*Mac OS X ([\d_]+).*$/,"$1").replace(/_/g,"."),WebOS:n.replace(/^.*hpwOS\/([\d.]+);.*$/,"$1"),BlackBerry:n.replace(/^.*BB([\d.]+);*$/,"$1")};e.osVersion="";var l=c[e.os];l&&(e.osVersion="function"==typeof l?l():l==n?"":l);var p={Safari:n.replace(/^.*Version\/([\d.]+).*$/,"$1"),Chrome:n.replace(/^.*Chrome\/([\d.]+).*$/,"$1").replace(/^.*CriOS\/([\d.]+).*$/,"$1"),IE:n.replace(/^.*MSIE ([\d.]+).*$/,"$1").replace(/^.*rv:([\d.]+).*$/,"$1"),Edge:n.replace(/^.*Edge?\/([\d.]+).*$/,"$1"),Firefox:n.replace(/^.*Firefox\/([\d.]+).*$/,"$1").replace(/^.*FxiOS\/([\d.]+).*$/,"$1"),"Firefox Focus":n.replace(/^.*Focus\/([\d.]+).*$/,"$1"),Chromium:n.replace(/^.*Chromium\/([\d.]+).*$/,"$1"),Opera:n.replace(/^.*Opera\/([\d.]+).*$/,"$1").replace(/^.*OPR\/([\d.]+).*$/,"$1"),Vivaldi:n.replace(/^.*Vivaldi\/([\d.]+).*$/,"$1"),Yandex:n.replace(/^.*YaBrowser\/([\d.]+).*$/,"$1"),Kindle:n.replace(/^.*Version\/([\d.]+).*$/,"$1"),Maxthon:n.replace(/^.*Maxthon\/([\d.]+).*$/,"$1"),QQBrowser:n.replace(/^.*QQBrowser\/([\d.]+).*$/,"$1"),QQ:n.replace(/^.*QQ\/([\d.]+).*$/,"$1"),Baidu:n.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/,"$1"),UC:n.replace(/^.*UC?Browser\/([\d.]+).*$/,"$1"),Sogou:n.replace(/^.*SE ([\d.X]+).*$/,"$1").replace(/^.*SogouMobileBrowser\/([\d.]+).*$/,"$1"),"2345Explorer":n.replace(/^.*2345Explorer\/([\d.]+).*$/,"$1"),TheWorld:n.replace(/^.*TheWorld ([\d.]+).*$/,"$1"),XiaoMi:n.replace(/^.*MiuiBrowser\/([\d.]+).*$/,"$1"),Quark:n.replace(/^.*Quark\/([\d.]+).*$/,"$1"),Qiyu:n.replace(/^.*Qiyu\/([\d.]+).*$/,"$1"),Wechat:n.replace(/^.*MicroMessenger\/([\d.]+).*$/,"$1"),Taobao:n.replace(/^.*AliApp\(TB\/([\d.]+).*$/,"$1"),Alipay:n.replace(/^.*AliApp\(AP\/([\d.]+).*$/,"$1"),Weibo:n.replace(/^.*weibo__([\d.]+).*$/,"$1"),Douban:n.replace(/^.*com.douban.frodo\/([\d.]+).*$/,"$1"),Suning:n.replace(/^.*SNEBUY-APP([\d.]+).*$/,"$1"),iQiYi:n.replace(/^.*IqiyiVersion\/([\d.]+).*$/,"$1")};e.version="";var u=p[e.browser];return u&&(e.version="function"==typeof u?u():u==n?"":u),null==e.browser&&(e.browser="Unknow App"),e}},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n){n=Object(n);for(var e=1,t=arguments.length;e<t;e++){var r=arguments[e];if(r)for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(n[a]=r[a])}return n}},function(n,e,t){"use strict";function r(n){return/^\{[\s\S]*\}$/.test(JSON.stringify(n))}function a(n){return"[object Function]"==={}.toString.call(n)}function o(n){return"[object Array]"==={}.toString.call(n)}function i(n){if("string"==typeof n)try{return JSON.parse(n)}catch(e){return n}}function s(){if(!(this instanceof s))return new s}function c(n,e){var t=arguments,i=null;if(p||(p=s()),0===t.length)return p.get();if(1===t.length){if("string"==typeof n)return p.get(n);if(r(n))return p.set(n)}if(2===t.length&&"string"==typeof n){if(!e)return p.remove(n);if(e&&"string"==typeof e)return p.set(n,e);e&&a(e)&&(i=null,i=e(n,p.get(n)),c.set(n,i))}if(2===t.length&&o(n)&&a(e))for(var l=0,u=n.length;l<u;l++)i=e(n[l],p.get(n[l])),c.set(n[l],i);return c}e.__esModule=!0;var l=window.localStorage;l=function(n){var e="_Is_Incognit";try{n.setItem(e,"yes")}catch(e){if(["QuotaExceededError","NS_ERROR_DOM_QUOTA_REACHED"].indexOf(e.name)>-1){var t=function(){};n.__proto__={setItem:t,getItem:t,removeItem:t,clear:t}}}finally{"yes"===n.getItem(e)&&n.removeItem(e)}return n}(l),s.prototype={set:function(n,e){if(n&&!r(n))l.setItem(n,function(n){return void 0===n||"function"==typeof n?n+"":JSON.stringify(n)}(e));else if(r(n))for(var t in n)this.set(t,n[t]);return this},get:function(n){if(!n){var e={};return this.each((function(n,t){return e[n]=t})),e}if("?"===n.charAt(0))return this.has(n.substr(1));var t=arguments;if(t.length>1){for(var r={},a=0,o=t.length;a<o;a++){var s=i(l.getItem(t[a]));s&&(r[t[a]]=s)}return r}return i(l.getItem(n))},clear:function(){return l.clear(),this},remove:function(n){var e=this.get(n);return l.removeItem(n),e},has:function(n){return{}.hasOwnProperty.call(this.get(),n)},keys:function(){var n=[];return this.each((function(e){n.push(e)})),n},each:function(n){for(var e=0,t=l.length;e<t;e++){var r=l.key(e);n(r,this.get(r))}return this},search:function(n){for(var e=this.keys(),t={},r=0,a=e.length;r<a;r++)e[r].indexOf(n)>-1&&(t[e[r]]=this.get(e[r]));return t}};var p=null;for(var u in s.prototype)c[u]=s.prototype[u];e.default=c},function(n,e,t){var r,a;a=function(n,e,t){function r(e,a,o){return o=Object.create(r.fn),e&&o.push.apply(o,e.addEventListener?[e]:""+e===e?/</.test(e)?((a=n.createElement(a)).innerHTML=e,a.children):a?(a=r(a)[0])?a[t](e):o:n[t](e):e),o}return r.fn=[],r.one=function(n,e){return r(n,e)[0]||null},r}(document,0,"querySelectorAll"),void 0!==(r=function(){return a}.apply(e,[]))&&(n.exports=r)},function(n,e,t){function r(n){return null==n}function a(n){(n=function(n){var e={};for(var t in n)e[t]=n[t];return e}(n||{})).whiteList=n.whiteList||o.whiteList,n.onAttr=n.onAttr||o.onAttr,n.onIgnoreAttr=n.onIgnoreAttr||o.onIgnoreAttr,n.safeAttrValue=n.safeAttrValue||o.safeAttrValue,this.options=n}var o=t(16),i=t(51);t(17),a.prototype.process=function(n){if(!(n=(n=n||"").toString()))return"";var e=this.options,t=e.whiteList,a=e.onAttr,o=e.onIgnoreAttr,s=e.safeAttrValue;return i(n,(function(n,e,i,c,l){var p=t[i],u=!1;if(!0===p?u=p:"function"==typeof p?u=p(c):p instanceof RegExp&&(u=p.test(c)),!0!==u&&(u=!1),c=s(i,c)){var d,m={position:e,sourcePosition:n,source:l,isWhite:u};return u?r(d=a(i,c,m))?i+":"+c:d:r(d=o(i,c,m))?void 0:d}}))},n.exports=a},function(n,e,t){var r=t(17);n.exports=function(n,e){function t(){if(!o){var t=r.trim(n.slice(i,s)),a=t.indexOf(":");if(-1!==a){var l=r.trim(t.slice(0,a)),p=r.trim(t.slice(a+1));if(l){var u=e(i,c.length,l,p,t);u&&(c+=u+"; ")}}}i=s+1}";"!==(n=r.trimRight(n))[n.length-1]&&(n+=";");for(var a=n.length,o=!1,i=0,s=0,c="";s<a;s++){var l=n[s];if("/"===l&&"*"===n[s+1]){var p=n.indexOf("*/",s+2);if(-1===p)break;i=(s=p+1)+1,o=!1}else"("===l?o=!0:")"===l?o=!1:";"===l?o||t():"\n"===l&&t()}return r.trim(c)}},function(n,e,t){"use strict";var r=t(0),a=t(1),o=r("%TypeError%"),i=t(54),s=r("%Reflect.apply%",!0)||a("%Function.prototype.apply%");n.exports=function(n,e){var t=arguments.length>2?arguments[2]:[];if(!i(t))throw new o("Assertion failed: optional `argumentsList`, if provided, must be a List");return s(n,e,t)}},function(n,e,t){"use strict";var r=t(0)("%TypeError%"),a=t(19),o=t(8);n.exports=function(n,e){if("Object"!==o(n))throw new r("Assertion failed: `O` must be an Object");if(!a(e))throw new r("Assertion failed: `P` must be a Property Key");return e in n}},function(n,e,t){"use strict";var r=t(0)("%Array%"),a=!r.isArray&&t(1)("Object.prototype.toString");n.exports=r.isArray||function(n){return"[object Array]"===a(n)}},function(n,e,t){"use strict";n.exports=t(10)},function(n,e,t){"use strict";var r=t(0)("%TypeError%"),a=t(18),o=t(58),i=t(8);n.exports=function(n){if("Object"!==i(n))throw new r("Assertion failed: `obj` must be an Object");return o(a(n,"length"))}},function(n,e,t){"use strict";var r=t(63),a=t(59);n.exports=function(n){var e=a(n);return 0!==e&&(e=r(e)),0===e?0:e}},function(n,e,t){"use strict";var r=t(72),a=t(57);n.exports=function(n){var e=a(n);return e<=0?0:e>r?r:e}},function(n,e,t){"use strict";var r=t(0),a=r("%TypeError%"),o=r("%Number%"),i=r("%RegExp%"),s=r("%parseInt%"),c=t(1),l=t(73),p=t(71),u=c("String.prototype.slice"),d=l(/^0b[01]+$/i),m=l(/^0o[0-7]+$/i),h=l(/^[-+]0x[0-9a-f]+$/i),g=l(new i("["+["","​","￾"].join("")+"]","g")),f=["\t\n\v\f\r   ᠎    ","         　\u2028","\u2029\ufeff"].join(""),b=new RegExp("(^["+f+"]+)|(["+f+"]+$)","g"),v=c("String.prototype.replace"),y=t(61);n.exports=function n(e){var t=p(e)?e:y(e,o);if("symbol"==typeof t)throw new a("Cannot convert a Symbol value to a number");if("bigint"==typeof t)throw new a("Conversion from 'BigInt' to 'number' is not allowed.");if("string"==typeof t){if(d(t))return n(s(u(t,2),2));if(m(t))return n(s(u(t,2),8));if(g(t)||h(t))return NaN;var r=function(n){return v(n,b,"")}(t);if(r!==t)return n(r)}return o(t)}},function(n,e,t){"use strict";var r=t(0)("%Object%"),a=t(5);n.exports=function(n){return a(n),r(n)}},function(n,e,t){"use strict";var r=t(76);n.exports=function(n){return arguments.length>1?r(n,arguments[1]):r(n)}},function(n,e,t){"use strict";var r=t(0)("%TypeError%");n.exports=function(n,e){if(null==n)throw new r(e||"Cannot call method on "+n);return n}},function(n,e,t){"use strict";var r=t(67),a=t(68),o=t(64),i=t(70),s=t(69),c=t(74);n.exports=function(n){var e=o(n);return i(e)?0:0!==e&&s(e)?c(e)*a(r(e)):e}},function(n,e,t){"use strict";var r=t(65);n.exports=function(n){var e=r(n,Number);if("string"!=typeof e)return+e;var t=e.replace(/^[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+|[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+$/g,"");return/^0[ob]|^[+-]0x/.test(t)?NaN:+t}},function(n,e,t){"use strict";n.exports=t(77)},function(n,e,t){"use strict";n.exports=function(n){return null===n?"Null":void 0===n?"Undefined":"function"==typeof n||"object"==typeof n?"Object":"number"==typeof n?"Number":"boolean"==typeof n?"Boolean":"string"==typeof n?"String":void 0}},function(n,e,t){"use strict";var r=t(0)("%Math.abs%");n.exports=function(n){return r(n)}},function(n,e,t){"use strict";var r=Math.floor;n.exports=function(n){return r(n)}},function(n,e,t){"use strict";var r=Number.isNaN||function(n){return n!=n};n.exports=Number.isFinite||function(n){return"number"==typeof n&&!r(n)&&n!==1/0&&n!==-1/0}},function(n,e,t){"use strict";n.exports=Number.isNaN||function(n){return n!=n}},function(n,e,t){"use strict";n.exports=function(n){return null===n||"function"!=typeof n&&"object"!=typeof n}},function(n,e,t){"use strict";var r=t(0),a=r("%Math%"),o=r("%Number%");n.exports=o.MAX_SAFE_INTEGER||a.pow(2,53)-1},function(n,e,t){"use strict";var r=t(0)("RegExp.prototype.test"),a=t(4);n.exports=function(n){return a(r,n)}},function(n,e,t){"use strict";n.exports=function(n){return n>=0?1:-1}},function(n,e){n.exports=function(n){var e=!0,t=!0,r=!1;if("function"==typeof n){try{n.call("f",(function(n,t,r){"object"!=typeof r&&(e=!1)})),n.call([null],(function(){"use strict";t="string"==typeof this}),"x")}catch(n){r=!0}return!r&&e&&t}return!1}},function(n,e,t){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator,a=t(21),o=t(10),i=t(80),s=t(82),c=function(n,e){if(null==n)throw new TypeError("Cannot call method on "+n);if("string"!=typeof e||"number"!==e&&"string"!==e)throw new TypeError('hint must be "string" or "number"');var t,r,i,s="string"===e?["toString","valueOf"]:["valueOf","toString"];for(i=0;i<s.length;++i)if(t=n[s[i]],o(t)&&(r=t.call(n),a(r)))return r;throw new TypeError("No default value")},l=function(n,e){var t=n[e];if(null!=t){if(!o(t))throw new TypeError(t+" returned for property "+e+" of object "+n+" is not a function");return t}};n.exports=function(n){if(a(n))return n;var e,t="default";if(arguments.length>1&&(arguments[1]===String?t="string":arguments[1]===Number&&(t="number")),r&&(Symbol.toPrimitive?e=l(n,Symbol.toPrimitive):s(n)&&(e=Symbol.prototype.valueOf)),void 0!==e){var o=e.call(n,t);if(a(o))return o;throw new TypeError("unable to convert exotic object to primitive")}return"default"===t&&(i(n)||s(n))&&(t="string"),c(n,"default"===t?"number":t)}},function(n,e,t){"use strict";var r=Object.prototype.toString,a=t(21),o=t(10),i=function(n){var e;if((e=arguments.length>1?arguments[1]:"[object Date]"===r.call(n)?String:Number)===String||e===Number){var t,i,s=e===String?["toString","valueOf"]:["valueOf","toString"];for(i=0;i<s.length;++i)if(o(n[s[i]])&&(t=n[s[i]](),a(t)))return t;throw new TypeError("No default value")}throw new TypeError("invalid [[DefaultValue]] hint supplied")};n.exports=function(n){return a(n)?n:arguments.length>1?i(n,arguments[1]):i(n)}},function(n,e,t){"use strict";var r=Array.prototype.slice,a=Object.prototype.toString;n.exports=function(n){var e=this;if("function"!=typeof e||"[object Function]"!==a.call(e))throw new TypeError("Function.prototype.bind called on incompatible "+e);for(var t,o=r.call(arguments,1),i=function(){if(this instanceof t){var a=e.apply(this,o.concat(r.call(arguments)));return Object(a)===a?a:this}return e.apply(n,o.concat(r.call(arguments)))},s=Math.max(0,e.length-o.length),c=[],l=0;l<s;l++)c.push("$"+l);if(t=Function("binder","return function ("+c.join(",")+"){ return binder.apply(this,arguments); }")(i),e.prototype){var p=function(){};p.prototype=e.prototype,t.prototype=new p,p.prototype=null}return t}},function(n,e,t){n.exports=function(){"use strict";var n=function(n,e){return function(n){var e=n.exports=function(){return new RegExp("(?:"+e.line().source+")|(?:"+e.block().source+")","gm")};e.line=function(){return/(?:^|\s)\/\/(.+?)$/gm},e.block=function(){return/\/\*([\S\s]*?)\*\//gm}}(e={exports:{}}),e.exports}(),e=["23AC69","91C132","F19726","E8552D","1AAB8E","E1147F","2980C1","1BA1E6","9FA0A0","F19726","E30B20","E30B20","A3338B"];return function(t,r){void 0===r&&(r={});var a=r.colors;void 0===a&&(a=e);var o=0,i={},s=new RegExp("("+/[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/.source+"|"+/</.source+")|("+n().source+")","gmi");return t.replace(s,(function(n,e,t){if(t)return function(n){return'<span style="color: slategray">'+n+"</span>"}(t);if("<"===e)return"&lt;";var r;i[e]?r=i[e]:(r=a[o],i[e]=r);var s='<span style="color: #'+r+'">'+e+"</span>";return o=++o%a.length,s}))}}()},function(n,e,t){"use strict";var r=Date.prototype.getDay,a=Object.prototype.toString,o=t(24)();n.exports=function(n){return"object"==typeof n&&null!==n&&(o?function(n){try{return r.call(n),!0}catch(n){return!1}}(n):"[object Date]"===a.call(n))}},function(n,e,t){"use strict";var r=String.prototype.valueOf,a=Object.prototype.toString,o=t(24)();n.exports=function(n){return"string"==typeof n||"object"==typeof n&&(o?function(n){try{return r.call(n),!0}catch(n){return!1}}(n):"[object String]"===a.call(n))}},function(n,e,t){"use strict";var r=Object.prototype.toString;if(t(22)()){var a=Symbol.prototype.toString,o=/^Symbol\(.*\)$/;n.exports=function(n){if("symbol"==typeof n)return!0;if("[object Symbol]"!==r.call(n))return!1;try{return function(n){return"symbol"==typeof n.valueOf()&&o.test(a.call(n))}(n)}catch(n){return!1}}}else n.exports=function(n){return!1}},function(n,e,t){!function(n){"use strict";function e(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function t(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),Object.defineProperty(n,"prototype",{writable:!1}),n}function r(n,e){if(n){if("string"==typeof n)return a(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?a(n,e):void 0}}function a(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}function o(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(t)return(t=t.call(n)).next.bind(t);if(Array.isArray(n)||(t=r(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var a=0;return function(){return a>=n.length?{done:!0}:{done:!1,value:n[a++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function i(){return{baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}function s(e){n.defaults=e}function c(n,e){if(e){if(w.test(n))return n.replace(k,A)}else if(S.test(n))return n.replace(C,A);return n}function l(n){return n.replace(T,(function(n,e){return"colon"===(e=e.toLowerCase())?":":"#"===e.charAt(0)?"x"===e.charAt(1)?String.fromCharCode(parseInt(e.substring(2),16)):String.fromCharCode(+e.substring(1)):""}))}function p(n,e){n=n.source||n,e=e||"";var t={replace:function(e,r){return r=(r=r.source||r).replace(E,"$1"),n=n.replace(e,r),t},getRegex:function(){return new RegExp(n,e)}};return t}function u(n,e,t){if(n){var r;try{r=decodeURIComponent(l(t)).replace(P,"").toLowerCase()}catch(n){return null}if(0===r.indexOf("javascript:")||0===r.indexOf("vbscript:")||0===r.indexOf("data:"))return null}e&&!D.test(t)&&(t=function(n,e){z[" "+n]||(B.test(n)?z[" "+n]=n+"/":z[" "+n]=h(n,"/",!0));var t=-1===(n=z[" "+n]).indexOf(":");return"//"===e.substring(0,2)?t?e:n.replace(I,"$1")+e:"/"===e.charAt(0)?t?e:n.replace(O,"$1")+e:n+e}(e,t));try{t=encodeURI(t).replace(/%25/g,"%")}catch(n){return null}return t}function d(n){for(var e,t,r=1;r<arguments.length;r++)for(t in e=arguments[r])Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}function m(n,e){var t=n.replace(/\|/g,(function(n,e,t){for(var r=!1,a=e;--a>=0&&"\\"===t[a];)r=!r;return r?"|":" |"})).split(/ \|/),r=0;if(t[0].trim()||t.shift(),t.length>0&&!t[t.length-1].trim()&&t.pop(),t.length>e)t.splice(e);else for(;t.length<e;)t.push("");for(;r<t.length;r++)t[r]=t[r].trim().replace(/\\\|/g,"|");return t}function h(n,e,t){var r=n.length;if(0===r)return"";for(var a=0;a<r;){var o=n.charAt(r-a-1);if(o!==e||t){if(o===e||!t)break;a++}else a++}return n.substr(0,r-a)}function g(n){n&&n.sanitize&&n.silent}function f(n,e){if(e<1)return"";for(var t="";e>1;)1&e&&(t+=n),e>>=1,n+=n;return t+n}function b(n,e,t,r){var a=e.href,o=e.title?c(e.title):null,i=n[1].replace(/\\([\[\]])/g,"$1");if("!"!==n[0].charAt(0)){r.state.inLink=!0;var s={type:"link",raw:t,href:a,title:o,text:i,tokens:r.inlineTokens(i,[])};return r.state.inLink=!1,s}return{type:"image",raw:t,href:a,title:o,text:c(i)}}function v(n){return n.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…")}function y(n){var e,t,r="",a=n.length;for(e=0;e<a;e++)t=n.charCodeAt(e),Math.random()>.5&&(t="x"+t.toString(16)),r+="&#"+t+";";return r}function x(n,e,t){if(null==n)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof n)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected");if("function"==typeof e&&(t=e,e=null),g(e=d({},x.defaults,e||{})),t){var r,a=e.highlight;try{r=R.lex(n,e)}catch(n){return t(n)}var o=function(n){var o;if(!n)try{e.walkTokens&&x.walkTokens(r,e.walkTokens),o=H.parse(r,e)}catch(e){n=e}return e.highlight=a,n?t(n):t(null,o)};if(!a||a.length<3)return o();if(delete e.highlight,!r.length)return o();var i=0;return x.walkTokens(r,(function(n){"code"===n.type&&(i++,setTimeout((function(){a(n.text,n.lang,(function(e,t){if(e)return o(e);null!=t&&t!==n.text&&(n.text=t,n.escaped=!0),0==--i&&o()}))}),0))})),void(0===i&&o())}try{var s=R.lex(n,e);return e.walkTokens&&x.walkTokens(s,e.walkTokens),H.parse(s,e)}catch(n){if(n.message+="\nPlease report this to https://github.com/markedjs/marked.",e.silent)return"<p>An error occurred:</p><pre>"+c(n.message+"",!0)+"</pre>";throw n}}n.defaults={baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1};var w=/[&<>"']/,k=/[&<>"']/g,S=/[<>"']|&(?!#?\w+;)/,C=/[<>"']|&(?!#?\w+;)/g,j={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},A=function(n){return j[n]},T=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,E=/(^|[^\[])\^/g,P=/[^\w:]/g,D=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i,z={},B=/^[^:]+:\/*[^/]*$/,I=/^([^:]+:)[\s\S]*$/,O=/^([^:]+:\/*[^/]*)[\s\S]*$/,_={exec:function(){}},L=function(){function e(e){this.options=e||n.defaults}var t=e.prototype;return t.space=function(n){var e=this.rules.block.newline.exec(n);if(e&&e[0].length>0)return{type:"space",raw:e[0]}},t.code=function(n){var e=this.rules.block.code.exec(n);if(e){var t=e[0].replace(/^ {1,4}/gm,"");return{type:"code",raw:e[0],codeBlockStyle:"indented",text:this.options.pedantic?t:h(t,"\n")}}},t.fences=function(n){var e=this.rules.block.fences.exec(n);if(e){var t=e[0],r=function(n,e){var t=n.match(/^(\s+)(?:```)/);if(null===t)return e;var r=t[1];return e.split("\n").map((function(n){var e=n.match(/^\s+/);return null===e?n:e[0].length>=r.length?n.slice(r.length):n})).join("\n")}(t,e[3]||"");return{type:"code",raw:t,lang:e[2]?e[2].trim():e[2],text:r}}},t.heading=function(n){var e=this.rules.block.heading.exec(n);if(e){var t=e[2].trim();if(/#$/.test(t)){var r=h(t,"#");this.options.pedantic?t=r.trim():r&&!/ $/.test(r)||(t=r.trim())}var a={type:"heading",raw:e[0],depth:e[1].length,text:t,tokens:[]};return this.lexer.inline(a.text,a.tokens),a}},t.hr=function(n){var e=this.rules.block.hr.exec(n);if(e)return{type:"hr",raw:e[0]}},t.blockquote=function(n){var e=this.rules.block.blockquote.exec(n);if(e){var t=e[0].replace(/^ *> ?/gm,"");return{type:"blockquote",raw:e[0],tokens:this.lexer.blockTokens(t,[]),text:t}}},t.list=function(n){var e=this.rules.block.list.exec(n);if(e){var t,r,a,i,s,c,l,p,u,d,m,h,g=e[1].trim(),f=g.length>1,b={type:"list",raw:"",ordered:f,start:f?+g.slice(0,-1):"",loose:!1,items:[]};g=f?"\\d{1,9}\\"+g.slice(-1):"\\"+g,this.options.pedantic&&(g=f?g:"[*+-]");for(var v=new RegExp("^( {0,3}"+g+")((?: [^\\n]*)?(?:\\n|$))");n&&(h=!1,e=v.exec(n))&&!this.rules.block.hr.test(n);){if(t=e[0],n=n.substring(t.length),p=e[2].split("\n",1)[0],u=n.split("\n",1)[0],this.options.pedantic?(i=2,m=p.trimLeft()):(i=(i=e[2].search(/[^ ]/))>4?1:i,m=p.slice(i),i+=e[1].length),c=!1,!p&&/^ *$/.test(u)&&(t+=u+"\n",n=n.substring(u.length+1),h=!0),!h)for(var y=new RegExp("^ {0,"+Math.min(3,i-1)+"}(?:[*+-]|\\d{1,9}[.)])");n&&(p=d=n.split("\n",1)[0],this.options.pedantic&&(p=p.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!y.test(p));){if(p.search(/[^ ]/)>=i||!p.trim())m+="\n"+p.slice(i);else{if(c)break;m+="\n"+p}c||p.trim()||(c=!0),t+=d+"\n",n=n.substring(d.length+1)}b.loose||(l?b.loose=!0:/\n *\n *$/.test(t)&&(l=!0)),this.options.gfm&&(r=/^\[[ xX]\] /.exec(m))&&(a="[ ] "!==r[0],m=m.replace(/^\[[ xX]\] +/,"")),b.items.push({type:"list_item",raw:t,task:!!r,checked:a,loose:!1,text:m}),b.raw+=t}b.items[b.items.length-1].raw=t.trimRight(),b.items[b.items.length-1].text=m.trimRight(),b.raw=b.raw.trimRight();var x=b.items.length;for(s=0;s<x;s++){this.lexer.state.top=!1,b.items[s].tokens=this.lexer.blockTokens(b.items[s].text,[]);var w=b.items[s].tokens.filter((function(n){return"space"===n.type})),k=w.every((function(n){for(var e,t=0,r=o(n.raw.split(""));!(e=r()).done;)if("\n"===e.value&&(t+=1),t>1)return!0;return!1}));!b.loose&&w.length&&k&&(b.loose=!0,b.items[s].loose=!0)}return b}},t.html=function(n){var e=this.rules.block.html.exec(n);if(e){var t={type:"html",raw:e[0],pre:!this.options.sanitizer&&("pre"===e[1]||"script"===e[1]||"style"===e[1]),text:e[0]};return this.options.sanitize&&(t.type="paragraph",t.text=this.options.sanitizer?this.options.sanitizer(e[0]):c(e[0]),t.tokens=[],this.lexer.inline(t.text,t.tokens)),t}},t.def=function(n){var e=this.rules.block.def.exec(n);if(e)return e[3]&&(e[3]=e[3].substring(1,e[3].length-1)),{type:"def",tag:e[1].toLowerCase().replace(/\s+/g," "),raw:e[0],href:e[2],title:e[3]}},t.table=function(n){var e=this.rules.block.table.exec(n);if(e){var t={type:"table",header:m(e[1]).map((function(n){return{text:n}})),align:e[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:e[3]&&e[3].trim()?e[3].replace(/\n[ \t]*$/,"").split("\n"):[]};if(t.header.length===t.align.length){t.raw=e[0];var r,a,o,i,s=t.align.length;for(r=0;r<s;r++)/^ *-+: *$/.test(t.align[r])?t.align[r]="right":/^ *:-+: *$/.test(t.align[r])?t.align[r]="center":/^ *:-+ *$/.test(t.align[r])?t.align[r]="left":t.align[r]=null;for(s=t.rows.length,r=0;r<s;r++)t.rows[r]=m(t.rows[r],t.header.length).map((function(n){return{text:n}}));for(s=t.header.length,a=0;a<s;a++)t.header[a].tokens=[],this.lexer.inlineTokens(t.header[a].text,t.header[a].tokens);for(s=t.rows.length,a=0;a<s;a++)for(i=t.rows[a],o=0;o<i.length;o++)i[o].tokens=[],this.lexer.inlineTokens(i[o].text,i[o].tokens);return t}}},t.lheading=function(n){var e=this.rules.block.lheading.exec(n);if(e){var t={type:"heading",raw:e[0],depth:"="===e[2].charAt(0)?1:2,text:e[1],tokens:[]};return this.lexer.inline(t.text,t.tokens),t}},t.paragraph=function(n){var e=this.rules.block.paragraph.exec(n);if(e){var t={type:"paragraph",raw:e[0],text:"\n"===e[1].charAt(e[1].length-1)?e[1].slice(0,-1):e[1],tokens:[]};return this.lexer.inline(t.text,t.tokens),t}},t.text=function(n){var e=this.rules.block.text.exec(n);if(e){var t={type:"text",raw:e[0],text:e[0],tokens:[]};return this.lexer.inline(t.text,t.tokens),t}},t.escape=function(n){var e=this.rules.inline.escape.exec(n);if(e)return{type:"escape",raw:e[0],text:c(e[1])}},t.tag=function(n){var e=this.rules.inline.tag.exec(n);if(e)return!this.lexer.state.inLink&&/^<a /i.test(e[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(e[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(e[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:e[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):c(e[0]):e[0]}},t.link=function(n){var e=this.rules.inline.link.exec(n);if(e){var t=e[2].trim();if(!this.options.pedantic&&/^</.test(t)){if(!/>$/.test(t))return;var r=h(t.slice(0,-1),"\\");if((t.length-r.length)%2==0)return}else{var a=function(n,e){if(-1===n.indexOf(e[1]))return-1;for(var t=n.length,r=0,a=0;a<t;a++)if("\\"===n[a])a++;else if(n[a]===e[0])r++;else if(n[a]===e[1]&&--r<0)return a;return-1}(e[2],"()");if(a>-1){var o=(0===e[0].indexOf("!")?5:4)+e[1].length+a;e[2]=e[2].substring(0,a),e[0]=e[0].substring(0,o).trim(),e[3]=""}}var i=e[2],s="";if(this.options.pedantic){var c=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(i);c&&(i=c[1],s=c[3])}else s=e[3]?e[3].slice(1,-1):"";return i=i.trim(),/^</.test(i)&&(i=this.options.pedantic&&!/>$/.test(t)?i.slice(1):i.slice(1,-1)),b(e,{href:i?i.replace(this.rules.inline._escapes,"$1"):i,title:s?s.replace(this.rules.inline._escapes,"$1"):s},e[0],this.lexer)}},t.reflink=function(n,e){var t;if((t=this.rules.inline.reflink.exec(n))||(t=this.rules.inline.nolink.exec(n))){var r=(t[2]||t[1]).replace(/\s+/g," ");if(!(r=e[r.toLowerCase()])||!r.href){var a=t[0].charAt(0);return{type:"text",raw:a,text:a}}return b(t,r,t[0],this.lexer)}},t.emStrong=function(n,e,t){void 0===t&&(t="");var r=this.rules.inline.emStrong.lDelim.exec(n);if(r&&(!r[3]||!t.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))){var a=r[1]||r[2]||"";if(!a||a&&(""===t||this.rules.inline.punctuation.exec(t))){var o,i,s=r[0].length-1,c=s,l=0,p="*"===r[0][0]?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(p.lastIndex=0,e=e.slice(-1*n.length+s);null!=(r=p.exec(e));)if(o=r[1]||r[2]||r[3]||r[4]||r[5]||r[6])if(i=o.length,r[3]||r[4])c+=i;else if(!((r[5]||r[6])&&s%3)||(s+i)%3){if(!((c-=i)>0)){if(i=Math.min(i,i+c+l),Math.min(s,i)%2){var u=n.slice(1,s+r.index+i);return{type:"em",raw:n.slice(0,s+r.index+i+1),text:u,tokens:this.lexer.inlineTokens(u,[])}}var d=n.slice(2,s+r.index+i-1);return{type:"strong",raw:n.slice(0,s+r.index+i+1),text:d,tokens:this.lexer.inlineTokens(d,[])}}}else l+=i}}},t.codespan=function(n){var e=this.rules.inline.code.exec(n);if(e){var t=e[2].replace(/\n/g," "),r=/[^ ]/.test(t),a=/^ /.test(t)&&/ $/.test(t);return r&&a&&(t=t.substring(1,t.length-1)),t=c(t,!0),{type:"codespan",raw:e[0],text:t}}},t.br=function(n){var e=this.rules.inline.br.exec(n);if(e)return{type:"br",raw:e[0]}},t.del=function(n){var e=this.rules.inline.del.exec(n);if(e)return{type:"del",raw:e[0],text:e[2],tokens:this.lexer.inlineTokens(e[2],[])}},t.autolink=function(n,e){var t,r,a=this.rules.inline.autolink.exec(n);if(a)return r="@"===a[2]?"mailto:"+(t=c(this.options.mangle?e(a[1]):a[1])):t=c(a[1]),{type:"link",raw:a[0],text:t,href:r,tokens:[{type:"text",raw:t,text:t}]}},t.url=function(n,e){var t;if(t=this.rules.inline.url.exec(n)){var r,a;if("@"===t[2])a="mailto:"+(r=c(this.options.mangle?e(t[0]):t[0]));else{var o;do{o=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])[0]}while(o!==t[0]);r=c(t[0]),a="www."===t[1]?"http://"+r:r}return{type:"link",raw:t[0],text:r,href:a,tokens:[{type:"text",raw:r,text:r}]}}},t.inlineText=function(n,e){var t,r=this.rules.inline.text.exec(n);if(r)return t=this.lexer.state.inRawBlock?this.options.sanitize?this.options.sanitizer?this.options.sanitizer(r[0]):c(r[0]):r[0]:c(this.options.smartypants?e(r[0]):r[0]),{type:"text",raw:r[0],text:t}},e}(),F={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:_,lheading:/^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\.|[^\[\]\\])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/};F.def=p(F.def).replace("label",F._label).replace("title",F._title).getRegex(),F.bullet=/(?:[*+-]|\d{1,9}[.)])/,F.listItemStart=p(/^( *)(bull) */).replace("bull",F.bullet).getRegex(),F.list=p(F.list).replace(/bull/g,F.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+F.def.source+")").getRegex(),F._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",F._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/,F.html=p(F.html,"i").replace("comment",F._comment).replace("tag",F._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),F.paragraph=p(F._paragraph).replace("hr",F.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",F._tag).getRegex(),F.blockquote=p(F.blockquote).replace("paragraph",F.paragraph).getRegex(),F.normal=d({},F),F.gfm=d({},F.normal,{table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"}),F.gfm.table=p(F.gfm.table).replace("hr",F.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",F._tag).getRegex(),F.gfm.paragraph=p(F._paragraph).replace("hr",F.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",F.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",F._tag).getRegex(),F.pedantic=d({},F.normal,{html:p("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",F._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:_,paragraph:p(F.normal._paragraph).replace("hr",F.hr).replace("heading"," *#{1,6} *[^\n]").replace("lheading",F.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()});var M={escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:_,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,rDelimUnd:/^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:_,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/,_punctuation:"!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"};M.punctuation=p(M.punctuation).replace(/punctuation/g,M._punctuation).getRegex(),M.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g,M.escapedEmSt=/\\\*|\\_/g,M._comment=p(F._comment).replace("(?:--\x3e|$)","--\x3e").getRegex(),M.emStrong.lDelim=p(M.emStrong.lDelim).replace(/punct/g,M._punctuation).getRegex(),M.emStrong.rDelimAst=p(M.emStrong.rDelimAst,"g").replace(/punct/g,M._punctuation).getRegex(),M.emStrong.rDelimUnd=p(M.emStrong.rDelimUnd,"g").replace(/punct/g,M._punctuation).getRegex(),M._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g,M._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,M._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,M.autolink=p(M.autolink).replace("scheme",M._scheme).replace("email",M._email).getRegex(),M._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,M.tag=p(M.tag).replace("comment",M._comment).replace("attribute",M._attribute).getRegex(),M._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,M._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/,M._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,M.link=p(M.link).replace("label",M._label).replace("href",M._href).replace("title",M._title).getRegex(),M.reflink=p(M.reflink).replace("label",M._label).replace("ref",F._label).getRegex(),M.nolink=p(M.nolink).replace("ref",F._label).getRegex(),M.reflinkSearch=p(M.reflinkSearch,"g").replace("reflink",M.reflink).replace("nolink",M.nolink).getRegex(),M.normal=d({},M),M.pedantic=d({},M.normal,{strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:p(/^!?\[(label)\]\((.*?)\)/).replace("label",M._label).getRegex(),reflink:p(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",M._label).getRegex()}),M.gfm=d({},M.normal,{escape:p(M.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/}),M.gfm.url=p(M.gfm.url,"i").replace("email",M.gfm._extended_email).getRegex(),M.breaks=d({},M.gfm,{br:p(M.br).replace("{2,}","*").getRegex(),text:p(M.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()});var R=function(){function e(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||n.defaults,this.options.tokenizer=this.options.tokenizer||new L,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};var t={block:F.normal,inline:M.normal};this.options.pedantic?(t.block=F.pedantic,t.inline=M.pedantic):this.options.gfm&&(t.block=F.gfm,this.options.breaks?t.inline=M.breaks:t.inline=M.gfm),this.tokenizer.rules=t}e.lex=function(n,t){return new e(t).lex(n)},e.lexInline=function(n,t){return new e(t).inlineTokens(n)};var r=e.prototype;return r.lex=function(n){n=n.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    "),this.blockTokens(n,this.tokens);for(var e;e=this.inlineQueue.shift();)this.inlineTokens(e.src,e.tokens);return this.tokens},r.blockTokens=function(n,e){var t,r,a,o,i=this;for(void 0===e&&(e=[]),this.options.pedantic&&(n=n.replace(/^ +$/gm,""));n;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some((function(r){return!!(t=r.call({lexer:i},n,e))&&(n=n.substring(t.raw.length),e.push(t),!0)}))))if(t=this.tokenizer.space(n))n=n.substring(t.raw.length),1===t.raw.length&&e.length>0?e[e.length-1].raw+="\n":e.push(t);else if(t=this.tokenizer.code(n))n=n.substring(t.raw.length),!(r=e[e.length-1])||"paragraph"!==r.type&&"text"!==r.type?e.push(t):(r.raw+="\n"+t.raw,r.text+="\n"+t.text,this.inlineQueue[this.inlineQueue.length-1].src=r.text);else if(t=this.tokenizer.fences(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.heading(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.hr(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.blockquote(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.list(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.html(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.def(n))n=n.substring(t.raw.length),!(r=e[e.length-1])||"paragraph"!==r.type&&"text"!==r.type?this.tokens.links[t.tag]||(this.tokens.links[t.tag]={href:t.href,title:t.title}):(r.raw+="\n"+t.raw,r.text+="\n"+t.raw,this.inlineQueue[this.inlineQueue.length-1].src=r.text);else if(t=this.tokenizer.table(n))n=n.substring(t.raw.length),e.push(t);else if(t=this.tokenizer.lheading(n))n=n.substring(t.raw.length),e.push(t);else if(a=n,this.options.extensions&&this.options.extensions.startBlock&&function(){var e=1/0,t=n.slice(1),r=void 0;i.options.extensions.startBlock.forEach((function(n){"number"==typeof(r=n.call({lexer:this},t))&&r>=0&&(e=Math.min(e,r))})),e<1/0&&e>=0&&(a=n.substring(0,e+1))}(),this.state.top&&(t=this.tokenizer.paragraph(a)))r=e[e.length-1],o&&"paragraph"===r.type?(r.raw+="\n"+t.raw,r.text+="\n"+t.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=r.text):e.push(t),o=a.length!==n.length,n=n.substring(t.raw.length);else if(t=this.tokenizer.text(n))n=n.substring(t.raw.length),(r=e[e.length-1])&&"text"===r.type?(r.raw+="\n"+t.raw,r.text+="\n"+t.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=r.text):e.push(t);else if(n){var s="Infinite loop on byte: "+n.charCodeAt(0);if(this.options.silent)break;throw new Error(s)}return this.state.top=!0,e},r.inline=function(n,e){this.inlineQueue.push({src:n,tokens:e})},r.inlineTokens=function(n,e){var t=this;void 0===e&&(e=[]);var r,a,o,i,s,c,l=n;if(this.tokens.links){var p=Object.keys(this.tokens.links);if(p.length>0)for(;null!=(i=this.tokenizer.rules.inline.reflinkSearch.exec(l));)p.includes(i[0].slice(i[0].lastIndexOf("[")+1,-1))&&(l=l.slice(0,i.index)+"["+f("a",i[0].length-2)+"]"+l.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;null!=(i=this.tokenizer.rules.inline.blockSkip.exec(l));)l=l.slice(0,i.index)+"["+f("a",i[0].length-2)+"]"+l.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;null!=(i=this.tokenizer.rules.inline.escapedEmSt.exec(l));)l=l.slice(0,i.index)+"++"+l.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);for(;n;)if(s||(c=""),s=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some((function(a){return!!(r=a.call({lexer:t},n,e))&&(n=n.substring(r.raw.length),e.push(r),!0)}))))if(r=this.tokenizer.escape(n))n=n.substring(r.raw.length),e.push(r);else if(r=this.tokenizer.tag(n))n=n.substring(r.raw.length),(a=e[e.length-1])&&"text"===r.type&&"text"===a.type?(a.raw+=r.raw,a.text+=r.text):e.push(r);else if(r=this.tokenizer.link(n))n=n.substring(r.raw.length),e.push(r);else if(r=this.tokenizer.reflink(n,this.tokens.links))n=n.substring(r.raw.length),(a=e[e.length-1])&&"text"===r.type&&"text"===a.type?(a.raw+=r.raw,a.text+=r.text):e.push(r);else if(r=this.tokenizer.emStrong(n,l,c))n=n.substring(r.raw.length),e.push(r);else if(r=this.tokenizer.codespan(n))n=n.substring(r.raw.length),e.push(r);else if(r=this.tokenizer.br(n))n=n.substring(r.raw.length),e.push(r);else if(r=this.tokenizer.del(n))n=n.substring(r.raw.length),e.push(r);else if(r=this.tokenizer.autolink(n,y))n=n.substring(r.raw.length),e.push(r);else if(this.state.inLink||!(r=this.tokenizer.url(n,y))){if(o=n,this.options.extensions&&this.options.extensions.startInline&&function(){var e=1/0,r=n.slice(1),a=void 0;t.options.extensions.startInline.forEach((function(n){"number"==typeof(a=n.call({lexer:this},r))&&a>=0&&(e=Math.min(e,a))})),e<1/0&&e>=0&&(o=n.substring(0,e+1))}(),r=this.tokenizer.inlineText(o,v))n=n.substring(r.raw.length),"_"!==r.raw.slice(-1)&&(c=r.raw.slice(-1)),s=!0,(a=e[e.length-1])&&"text"===a.type?(a.raw+=r.raw,a.text+=r.text):e.push(r);else if(n){var u="Infinite loop on byte: "+n.charCodeAt(0);if(this.options.silent)break;throw new Error(u)}}else n=n.substring(r.raw.length),e.push(r);return e},t(e,null,[{key:"rules",get:function(){return{block:F,inline:M}}}]),e}(),N=function(){function e(e){this.options=e||n.defaults}var t=e.prototype;return t.code=function(n,e,t){var r=(e||"").match(/\S*/)[0];if(this.options.highlight){var a=this.options.highlight(n,r);null!=a&&a!==n&&(t=!0,n=a)}return n=n.replace(/\n$/,"")+"\n",r?'<pre><code class="'+this.options.langPrefix+c(r,!0)+'">'+(t?n:c(n,!0))+"</code></pre>\n":"<pre><code>"+(t?n:c(n,!0))+"</code></pre>\n"},t.blockquote=function(n){return"<blockquote>\n"+n+"</blockquote>\n"},t.html=function(n){return n},t.heading=function(n,e,t,r){return this.options.headerIds?"<h"+e+' id="'+this.options.headerPrefix+r.slug(t)+'">'+n+"</h"+e+">\n":"<h"+e+">"+n+"</h"+e+">\n"},t.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},t.list=function(n,e,t){var r=e?"ol":"ul";return"<"+r+(e&&1!==t?' start="'+t+'"':"")+">\n"+n+"</"+r+">\n"},t.listitem=function(n){return"<li>"+n+"</li>\n"},t.checkbox=function(n){return"<input "+(n?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},t.paragraph=function(n){return"<p>"+n+"</p>\n"},t.table=function(n,e){return e&&(e="<tbody>"+e+"</tbody>"),"<table>\n<thead>\n"+n+"</thead>\n"+e+"</table>\n"},t.tablerow=function(n){return"<tr>\n"+n+"</tr>\n"},t.tablecell=function(n,e){var t=e.header?"th":"td";return(e.align?"<"+t+' align="'+e.align+'">':"<"+t+">")+n+"</"+t+">\n"},t.strong=function(n){return"<strong>"+n+"</strong>"},t.em=function(n){return"<em>"+n+"</em>"},t.codespan=function(n){return"<code>"+n+"</code>"},t.br=function(){return this.options.xhtml?"<br/>":"<br>"},t.del=function(n){return"<del>"+n+"</del>"},t.link=function(n,e,t){if(null===(n=u(this.options.sanitize,this.options.baseUrl,n)))return t;var r='<a href="'+c(n)+'"';return e&&(r+=' title="'+e+'"'),r+">"+t+"</a>"},t.image=function(n,e,t){if(null===(n=u(this.options.sanitize,this.options.baseUrl,n)))return t;var r='<img src="'+n+'" alt="'+t+'"';return e&&(r+=' title="'+e+'"'),r+(this.options.xhtml?"/>":">")},t.text=function(n){return n},e}(),q=function(){function n(){}var e=n.prototype;return e.strong=function(n){return n},e.em=function(n){return n},e.codespan=function(n){return n},e.del=function(n){return n},e.html=function(n){return n},e.text=function(n){return n},e.link=function(n,e,t){return""+t},e.image=function(n,e,t){return""+t},e.br=function(){return""},n}(),U=function(){function n(){this.seen={}}var e=n.prototype;return e.serialize=function(n){return n.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")},e.getNextSafeSlug=function(n,e){var t=n,r=0;if(this.seen.hasOwnProperty(t)){r=this.seen[n];do{t=n+"-"+ ++r}while(this.seen.hasOwnProperty(t))}return e||(this.seen[n]=r,this.seen[t]=0),t},e.slug=function(n,e){void 0===e&&(e={});var t=this.serialize(n);return this.getNextSafeSlug(t,e.dryrun)},n}(),H=function(){function e(e){this.options=e||n.defaults,this.options.renderer=this.options.renderer||new N,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new q,this.slugger=new U}e.parse=function(n,t){return new e(t).parse(n)},e.parseInline=function(n,t){return new e(t).parseInline(n)};var t=e.prototype;return t.parse=function(n,e){void 0===e&&(e=!0);var t,r,a,o,i,s,c,p,u,d,m,h,g,f,b,v,y,x,w,k="",S=n.length;for(t=0;t<S;t++)if(d=n[t],!(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[d.type])||!1===(w=this.options.extensions.renderers[d.type].call({parser:this},d))&&["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(d.type))switch(d.type){case"space":continue;case"hr":k+=this.renderer.hr();continue;case"heading":k+=this.renderer.heading(this.parseInline(d.tokens),d.depth,l(this.parseInline(d.tokens,this.textRenderer)),this.slugger);continue;case"code":k+=this.renderer.code(d.text,d.lang,d.escaped);continue;case"table":for(p="",c="",o=d.header.length,r=0;r<o;r++)c+=this.renderer.tablecell(this.parseInline(d.header[r].tokens),{header:!0,align:d.align[r]});for(p+=this.renderer.tablerow(c),u="",o=d.rows.length,r=0;r<o;r++){for(c="",i=(s=d.rows[r]).length,a=0;a<i;a++)c+=this.renderer.tablecell(this.parseInline(s[a].tokens),{header:!1,align:d.align[a]});u+=this.renderer.tablerow(c)}k+=this.renderer.table(p,u);continue;case"blockquote":u=this.parse(d.tokens),k+=this.renderer.blockquote(u);continue;case"list":for(m=d.ordered,h=d.start,g=d.loose,o=d.items.length,u="",r=0;r<o;r++)v=(b=d.items[r]).checked,y=b.task,f="",b.task&&(x=this.renderer.checkbox(v),g?b.tokens.length>0&&"paragraph"===b.tokens[0].type?(b.tokens[0].text=x+" "+b.tokens[0].text,b.tokens[0].tokens&&b.tokens[0].tokens.length>0&&"text"===b.tokens[0].tokens[0].type&&(b.tokens[0].tokens[0].text=x+" "+b.tokens[0].tokens[0].text)):b.tokens.unshift({type:"text",text:x}):f+=x),f+=this.parse(b.tokens,g),u+=this.renderer.listitem(f,y,v);k+=this.renderer.list(u,m,h);continue;case"html":k+=this.renderer.html(d.text);continue;case"paragraph":k+=this.renderer.paragraph(this.parseInline(d.tokens));continue;case"text":for(u=d.tokens?this.parseInline(d.tokens):d.text;t+1<S&&"text"===n[t+1].type;)u+="\n"+((d=n[++t]).tokens?this.parseInline(d.tokens):d.text);k+=e?this.renderer.paragraph(u):u;continue;default:var C='Token with "'+d.type+'" type was not found.';if(this.options.silent)return;throw new Error(C)}else k+=w||"";return k},t.parseInline=function(n,e){e=e||this.renderer;var t,r,a,o="",i=n.length;for(t=0;t<i;t++)if(r=n[t],!(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[r.type])||!1===(a=this.options.extensions.renderers[r.type].call({parser:this},r))&&["escape","html","link","image","strong","em","codespan","br","del","text"].includes(r.type))switch(r.type){case"escape":o+=e.text(r.text);break;case"html":o+=e.html(r.text);break;case"link":o+=e.link(r.href,r.title,this.parseInline(r.tokens,e));break;case"image":o+=e.image(r.href,r.title,r.text);break;case"strong":o+=e.strong(this.parseInline(r.tokens,e));break;case"em":o+=e.em(this.parseInline(r.tokens,e));break;case"codespan":o+=e.codespan(r.text);break;case"br":o+=e.br();break;case"del":o+=e.del(this.parseInline(r.tokens,e));break;case"text":o+=e.text(r.text);break;default:var s='Token with "'+r.type+'" type was not found.';if(this.options.silent)return;throw new Error(s)}else o+=a||"";return o},e}();x.options=x.setOptions=function(n){return d(x.defaults,n),s(x.defaults),x},x.getDefaults=i,x.defaults=n.defaults,x.use=function(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];var r,a=d.apply(void 0,[{}].concat(e)),o=x.defaults.extensions||{renderers:{},childTokens:{}};e.forEach((function(n){if(n.extensions&&(r=!0,n.extensions.forEach((function(n){if(!n.name)throw new Error("extension name required");if(n.renderer){var e=o.renderers?o.renderers[n.name]:null;o.renderers[n.name]=e?function(){for(var t=arguments.length,r=new Array(t),a=0;a<t;a++)r[a]=arguments[a];var o=n.renderer.apply(this,r);return!1===o&&(o=e.apply(this,r)),o}:n.renderer}if(n.tokenizer){if(!n.level||"block"!==n.level&&"inline"!==n.level)throw new Error("extension level must be 'block' or 'inline'");o[n.level]?o[n.level].unshift(n.tokenizer):o[n.level]=[n.tokenizer],n.start&&("block"===n.level?o.startBlock?o.startBlock.push(n.start):o.startBlock=[n.start]:"inline"===n.level&&(o.startInline?o.startInline.push(n.start):o.startInline=[n.start]))}n.childTokens&&(o.childTokens[n.name]=n.childTokens)}))),n.renderer&&function(){var e=x.defaults.renderer||new N;for(var t in n.renderer)!function(t){var r=e[t];e[t]=function(){for(var a=arguments.length,o=new Array(a),i=0;i<a;i++)o[i]=arguments[i];var s=n.renderer[t].apply(e,o);return!1===s&&(s=r.apply(e,o)),s}}(t);a.renderer=e}(),n.tokenizer&&function(){var e=x.defaults.tokenizer||new L;for(var t in n.tokenizer)!function(t){var r=e[t];e[t]=function(){for(var a=arguments.length,o=new Array(a),i=0;i<a;i++)o[i]=arguments[i];var s=n.tokenizer[t].apply(e,o);return!1===s&&(s=r.apply(e,o)),s}}(t);a.tokenizer=e}(),n.walkTokens){var e=x.defaults.walkTokens;a.walkTokens=function(t){n.walkTokens.call(this,t),e&&e.call(this,t)}}r&&(a.extensions=o),x.setOptions(a)}))},x.walkTokens=function(n,e){for(var t,r=o(n);!(t=r()).done;)!function(){var n=t.value;switch(e.call(x,n),n.type){case"table":for(var r,a=o(n.header);!(r=a()).done;){var i=r.value;x.walkTokens(i.tokens,e)}for(var s,c=o(n.rows);!(s=c()).done;)for(var l,p=o(s.value);!(l=p()).done;){var u=l.value;x.walkTokens(u.tokens,e)}break;case"list":x.walkTokens(n.items,e);break;default:x.defaults.extensions&&x.defaults.extensions.childTokens&&x.defaults.extensions.childTokens[n.type]?x.defaults.extensions.childTokens[n.type].forEach((function(t){x.walkTokens(n[t],e)})):n.tokens&&x.walkTokens(n.tokens,e)}}()},x.parseInline=function(n,e){if(null==n)throw new Error("marked.parseInline(): input parameter is undefined or null");if("string"!=typeof n)throw new Error("marked.parseInline(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected");g(e=d({},x.defaults,e||{}));try{var t=R.lexInline(n,e);return e.walkTokens&&x.walkTokens(t,e.walkTokens),H.parseInline(t,e)}catch(n){if(n.message+="\nPlease report this to https://github.com/markedjs/marked.",e.silent)return"<p>An error occurred:</p><pre>"+c(n.message+"",!0)+"</pre>";throw n}},x.Parser=H,x.parser=H.parse,x.Renderer=N,x.TextRenderer=q,x.Lexer=R,x.lexer=R.lex,x.Tokenizer=L,x.Slugger=U,x.parse=x;var $=x.options,J=x.setOptions,V=x.use,W=x.walkTokens,Q=x.parseInline,K=x,G=H.parse,X=R.lex;n.Lexer=R,n.Parser=H,n.Renderer=N,n.Slugger=U,n.TextRenderer=q,n.Tokenizer=L,n.getDefaults=i,n.lexer=X,n.marked=x,n.options=$,n.parse=K,n.parseInline=Q,n.parser=G,n.setOptions=J,n.use=V,n.walkTokens=W,Object.defineProperty(n,"__esModule",{value:!0})}(e)},function(n,e,t){"use strict";function r(n,e){var t=function(n){var e={};return s(c(n),(function(n){var t=n[0],r=n[1];s(r,(function(n){e[n]=t}))})),e}(n.pluralTypeToLanguages);return t[e]||t[h.call(e,/-/,1)[0]]||t.en}function a(n){return n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function o(n,e,t,r,a){if("string"!=typeof n)throw new TypeError("Polyglot.transformPhrase expects argument #1 to be string");if(null==e)return n;var o=n,i=r||y,s="number"==typeof e?{smart_count:e}:e;if(null!=s.smart_count&&n){var c=a||b,l=h.call(n,g),d=function(n,e,t){return n.pluralTypes[e](t)}(c,v(c,t||"en"),s.smart_count);o=u(l[d]||l[0])}return m.call(o,i,(function(n,e){return p(s,e)&&null!=s[e]?s[e]:n}))}function i(n){var e=n||{};this.phrases={},this.extend(e.phrases||{}),this.currentLocale=e.locale||"en";var t=e.allowMissing?o:null;this.onMissingKey="function"==typeof e.onMissingKey?e.onMissingKey:t,this.warn=e.warn||d,this.tokenRegex=function(n){var e=n&&n.prefix||"%{",t=n&&n.suffix||"}";if(e===g||t===g)throw new RangeError('"'+g+'" token is reserved for pluralization');return new RegExp(a(e)+"(.*?)"+a(t),"g")}(e.interpolation),this.pluralRules=e.pluralRules||b}var s=t(43),c=t(89),l=t(94),p=t(25),u=t(92),d=function(n){l(!1,n)},m=String.prototype.replace,h=String.prototype.split,g="||||",f=function(n){var e=n%100,t=e%10;return 11!==e&&1===t?0:2<=t&&t<=4&&!(e>=12&&e<=14)?1:2},b={pluralTypes:{arabic:function(n){if(n<3)return n;var e=n%100;return e>=3&&e<=10?3:e>=11?4:5},bosnian_serbian:f,chinese:function(){return 0},croatian:f,french:function(n){return n>=2?1:0},german:function(n){return 1!==n?1:0},russian:f,lithuanian:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=9&&(n%100<11||n%100>19)?1:2},czech:function(n){return 1===n?0:n>=2&&n<=4?1:2},polish:function(n){if(1===n)return 0;var e=n%10;return 2<=e&&e<=4&&(n%100<10||n%100>=20)?1:2},icelandic:function(n){return n%10!=1||n%100==11?1:0},slovenian:function(n){var e=n%100;return 1===e?0:2===e?1:3===e||4===e?2:3}},pluralTypeToLanguages:{arabic:["ar"],bosnian_serbian:["bs-Latn-BA","bs-Cyrl-BA","srl-RS","sr-RS"],chinese:["id","id-ID","ja","ko","ko-KR","lo","ms","th","th-TH","zh"],croatian:["hr","hr-HR"],german:["fa","da","de","en","es","fi","el","he","hi-IN","hu","hu-HU","it","nl","no","pt","sv","tr"],french:["fr","tl","pt-br"],russian:["ru","ru-RU"],lithuanian:["lt"],czech:["cs","cs-CZ","sk"],polish:["pl"],icelandic:["is"],slovenian:["sl-SL"]}},v=function(){var n={};return function(e,t){var a=n[t];return a&&!e.pluralTypes[a]&&(a=null,n[t]=a),a||(a=r(e,t))&&(n[t]=a),a}}(),y=/%\{(.*?)\}/g;i.prototype.locale=function(n){return n&&(this.currentLocale=n),this.currentLocale},i.prototype.extend=function(n,e){s(c(n||{}),(function(n){var t=n[0],r=n[1],a=e?e+"."+t:t;"object"==typeof r?this.extend(r,a):this.phrases[a]=r}),this)},i.prototype.unset=function(n,e){"string"==typeof n?delete this.phrases[n]:s(c(n||{}),(function(n){var t=n[0],r=n[1],a=e?e+"."+t:t;"object"==typeof r?this.unset(r,a):delete this.phrases[a]}),this)},i.prototype.clear=function(){this.phrases={}},i.prototype.replace=function(n){this.clear(),this.extend(n)},i.prototype.t=function(n,e){var t,r,a=null==e?{}:e;return"string"==typeof this.phrases[n]?t=this.phrases[n]:"string"==typeof a._?t=a._:this.onMissingKey?r=(0,this.onMissingKey)(n,a,this.currentLocale,this.tokenRegex,this.pluralRules):(this.warn('Missing translation for key: "'+n+'"'),r=n),"string"==typeof t&&(r=o(t,a,this.currentLocale,this.tokenRegex,this.pluralRules)),r},i.prototype.has=function(n){return p(this.phrases,n)},i.transformPhrase=function(n,e,t){return o(n,e,t)},n.exports=i},function(n,e,t){"use strict";function r(n){if(null==n)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(n)}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var a=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;n.exports=function(){try{if(!Object.assign)return!1;var n=new String("abc");if(n[5]="de","5"===Object.getOwnPropertyNames(n)[0])return!1;for(var e={},t=0;t<10;t++)e["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(e).map((function(n){return e[n]})).join(""))return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach((function(n){r[n]=n})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(n){return!1}}()?Object.assign:function(n,e){for(var t,s,c=r(n),l=1;l<arguments.length;l++){for(var p in t=Object(arguments[l]))o.call(t,p)&&(c[p]=t[p]);if(a){s=a(t);for(var u=0;u<s.length;u++)i.call(t,s[u])&&(c[s[u]]=t[s[u]])}}return c}},function(n,e,t){function r(n,e){if(n===1/0||n===-1/0||n!=n||n&&n>-1e3&&n<1e3||q.call(/e/,e))return e;var t=/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;if("number"==typeof n){var r=n<0?-J(-n):J(n);if(r!==n){var a=String(r),o=F.call(e,a.length+1);return M.call(a,t,"$&_")+"."+M.call(M.call(o,/([0-9]{3})/g,"$&_"),/_$/,"")}}return M.call(e,t,"$&_")}function a(n,e,t){var r="double"===(t.quoteStyle||e)?'"':"'";return r+n+r}function o(n){return M.call(String(n),/"/g,"&quot;")}function i(n){return!("[object Array]"!==l(n)||G&&"object"==typeof n&&G in n)}function s(n){if(K)return n&&"object"==typeof n&&n instanceof Symbol;if("symbol"==typeof n)return!0;if(!n||"object"!=typeof n||!Q)return!1;try{return Q.call(n),!0}catch(n){}return!1}function c(n,e){return en.call(n,e)}function l(n){return O.call(n)}function p(n){if(n.name)return n.name;var e=L.call(_.call(n),/^function\s*([\w$]+)/);return e?e[1]:null}function u(n,e){if(n.indexOf)return n.indexOf(e);for(var t=0,r=n.length;t<r;t++)if(n[t]===e)return t;return-1}function d(n){if(!D||!n||"object"!=typeof n)return!1;try{D.call(n,D);try{z.call(n,z)}catch(n){return!0}return n instanceof WeakMap}catch(n){}return!1}function m(n){if(!B||!n||"object"!=typeof n)return!1;try{return B.call(n),!0}catch(n){}return!1}function h(n){if(!z||!n||"object"!=typeof n)return!1;try{z.call(n,z);try{D.call(n,D)}catch(n){return!0}return n instanceof WeakSet}catch(n){}return!1}function g(n,e){if(n.length>e.maxStringLength){var t=n.length-e.maxStringLength,r="... "+t+" more character"+(t>1?"s":"");return g(F.call(n,0,e.maxStringLength),e)+r}return a(M.call(M.call(n,/(['\\])/g,"\\$1"),/[\x00-\x1f]/g,f),"single",e)}function f(n){var e=n.charCodeAt(0),t={8:"b",9:"t",10:"n",12:"f",13:"r"}[e];return t?"\\"+t:"\\x"+(e<16?"0":"")+R.call(e.toString(16))}function b(n){return"Object("+n+")"}function v(n){return n+" { ? }"}function y(n,e,t,r){return n+" ("+e+") {"+(r?x(t,r):H.call(t,", "))+"}"}function x(n,e){if(0===n.length)return"";var t="\n"+e.prev+e.base;return t+H.call(n,","+t)+"\n"+e.prev}function w(n,e){var t=i(n),r=[];if(t){r.length=n.length;for(var a=0;a<n.length;a++)r[a]=c(n,a)?e(n[a],n):""}var o,s="function"==typeof W?W(n):[];if(K){o={};for(var l=0;l<s.length;l++)o["$"+s[l]]=s[l]}for(var p in n)c(n,p)&&(t&&String(Number(p))===p&&p<n.length||K&&o["$"+p]instanceof Symbol||(q.call(/[^\w$]/,p)?r.push(e(p,n)+": "+e(n[p],n)):r.push(p+": "+e(n[p],n))));if("function"==typeof W)for(var u=0;u<s.length;u++)X.call(n,s[u])&&r.push("["+e(s[u])+"]: "+e(n[s[u]],n));return r}var k="function"==typeof Map&&Map.prototype,S=Object.getOwnPropertyDescriptor&&k?Object.getOwnPropertyDescriptor(Map.prototype,"size"):null,C=k&&S&&"function"==typeof S.get?S.get:null,j=k&&Map.prototype.forEach,A="function"==typeof Set&&Set.prototype,T=Object.getOwnPropertyDescriptor&&A?Object.getOwnPropertyDescriptor(Set.prototype,"size"):null,E=A&&T&&"function"==typeof T.get?T.get:null,P=A&&Set.prototype.forEach,D="function"==typeof WeakMap&&WeakMap.prototype?WeakMap.prototype.has:null,z="function"==typeof WeakSet&&WeakSet.prototype?WeakSet.prototype.has:null,B="function"==typeof WeakRef&&WeakRef.prototype?WeakRef.prototype.deref:null,I=Boolean.prototype.valueOf,O=Object.prototype.toString,_=Function.prototype.toString,L=String.prototype.match,F=String.prototype.slice,M=String.prototype.replace,R=String.prototype.toUpperCase,N=String.prototype.toLowerCase,q=RegExp.prototype.test,U=Array.prototype.concat,H=Array.prototype.join,$=Array.prototype.slice,J=Math.floor,V="function"==typeof BigInt?BigInt.prototype.valueOf:null,W=Object.getOwnPropertySymbols,Q="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol.prototype.toString:null,K="function"==typeof Symbol&&"object"==typeof Symbol.iterator,G="function"==typeof Symbol&&Symbol.toStringTag&&(Symbol.toStringTag,1)?Symbol.toStringTag:null,X=Object.prototype.propertyIsEnumerable,Z=("function"==typeof Reflect?Reflect.getPrototypeOf:Object.getPrototypeOf)||([].__proto__===Array.prototype?function(n){return n.__proto__}:null),Y=t(102).custom,nn=Y&&s(Y)?Y:null;n.exports=function n(e,t,f,k){function S(e,t,r){if(t&&(k=$.call(k)).push(t),r){var a={depth:A.depth};return c(A,"quoteStyle")&&(a.quoteStyle=A.quoteStyle),n(e,a,f+1,k)}return n(e,A,f+1,k)}var A=t||{};if(c(A,"quoteStyle")&&"single"!==A.quoteStyle&&"double"!==A.quoteStyle)throw new TypeError('option "quoteStyle" must be "single" or "double"');if(c(A,"maxStringLength")&&("number"==typeof A.maxStringLength?A.maxStringLength<0&&A.maxStringLength!==1/0:null!==A.maxStringLength))throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');var T=!c(A,"customInspect")||A.customInspect;if("boolean"!=typeof T&&"symbol"!==T)throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");if(c(A,"indent")&&null!==A.indent&&"\t"!==A.indent&&!(parseInt(A.indent,10)===A.indent&&A.indent>0))throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');if(c(A,"numericSeparator")&&"boolean"!=typeof A.numericSeparator)throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');var D=A.numericSeparator;if(void 0===e)return"undefined";if(null===e)return"null";if("boolean"==typeof e)return e?"true":"false";if("string"==typeof e)return g(e,A);if("number"==typeof e){if(0===e)return 1/0/e>0?"0":"-0";var z=String(e);return D?r(e,z):z}if("bigint"==typeof e){var B=String(e)+"n";return D?r(e,B):B}var O=void 0===A.depth?5:A.depth;if(void 0===f&&(f=0),f>=O&&O>0&&"object"==typeof e)return i(e)?"[Array]":"[Object]";var _=function(n,e){var t;if("\t"===n.indent)t="\t";else{if(!("number"==typeof n.indent&&n.indent>0))return null;t=H.call(Array(n.indent+1)," ")}return{base:t,prev:H.call(Array(e+1),t)}}(A,f);if(void 0===k)k=[];else if(u(k,e)>=0)return"[Circular]";if("function"==typeof e){var L=p(e),R=w(e,S);return"[Function"+(L?": "+L:" (anonymous)")+"]"+(R.length>0?" { "+H.call(R,", ")+" }":"")}if(s(e)){var q=K?M.call(String(e),/^(Symbol\(.*\))_[^)]*$/,"$1"):Q.call(e);return"object"!=typeof e||K?q:b(q)}if(function(n){return!(!n||"object"!=typeof n)&&("undefined"!=typeof HTMLElement&&n instanceof HTMLElement||"string"==typeof n.nodeName&&"function"==typeof n.getAttribute)}(e)){for(var J="<"+N.call(String(e.nodeName)),W=e.attributes||[],Y=0;Y<W.length;Y++)J+=" "+W[Y].name+"="+a(o(W[Y].value),"double",A);return J+=">",e.childNodes&&e.childNodes.length&&(J+="..."),J+"</"+N.call(String(e.nodeName))+">"}if(i(e)){if(0===e.length)return"[]";var en=w(e,S);return _&&!function(n){for(var e=0;e<n.length;e++)if(u(n[e],"\n")>=0)return!1;return!0}(en)?"["+x(en,_)+"]":"[ "+H.call(en,", ")+" ]"}if(function(n){return!("[object Error]"!==l(n)||G&&"object"==typeof n&&G in n)}(e)){var tn=w(e,S);return"cause"in e&&!X.call(e,"cause")?"{ ["+String(e)+"] "+H.call(U.call("[cause]: "+S(e.cause),tn),", ")+" }":0===tn.length?"["+String(e)+"]":"{ ["+String(e)+"] "+H.call(tn,", ")+" }"}if("object"==typeof e&&T){if(nn&&"function"==typeof e[nn])return e[nn]();if("symbol"!==T&&"function"==typeof e.inspect)return e.inspect()}if(function(n){if(!C||!n||"object"!=typeof n)return!1;try{C.call(n);try{E.call(n)}catch(n){return!0}return n instanceof Map}catch(n){}return!1}(e)){var rn=[];return j.call(e,(function(n,t){rn.push(S(t,e,!0)+" => "+S(n,e))})),y("Map",C.call(e),rn,_)}if(function(n){if(!E||!n||"object"!=typeof n)return!1;try{E.call(n);try{C.call(n)}catch(n){return!0}return n instanceof Set}catch(n){}return!1}(e)){var an=[];return P.call(e,(function(n){an.push(S(n,e))})),y("Set",E.call(e),an,_)}if(d(e))return v("WeakMap");if(h(e))return v("WeakSet");if(m(e))return v("WeakRef");if(function(n){return!("[object Number]"!==l(n)||G&&"object"==typeof n&&G in n)}(e))return b(S(Number(e)));if(function(n){if(!n||"object"!=typeof n||!V)return!1;try{return V.call(n),!0}catch(n){}return!1}(e))return b(S(V.call(e)));if(function(n){return!("[object Boolean]"!==l(n)||G&&"object"==typeof n&&G in n)}(e))return b(I.call(e));if(function(n){return!("[object String]"!==l(n)||G&&"object"==typeof n&&G in n)}(e))return b(S(String(e)));if(!function(n){return!("[object Date]"!==l(n)||G&&"object"==typeof n&&G in n)}(e)&&!function(n){return!("[object RegExp]"!==l(n)||G&&"object"==typeof n&&G in n)}(e)){var on=w(e,S),sn=Z?Z(e)===Object.prototype:e instanceof Object||e.constructor===Object,cn=e instanceof Object?"":"null prototype",ln=!sn&&G&&Object(e)===e&&G in e?F.call(l(e),8,-1):cn?"Object":"",pn=(sn||"function"!=typeof e.constructor?"":e.constructor.name?e.constructor.name+" ":"")+(ln||cn?"["+H.call(U.call([],ln||[],cn||[]),": ")+"] ":"");return 0===on.length?pn+"{}":_?pn+"{"+x(on,_)+"}":pn+"{ "+H.call(on,", ")+" }"}return String(e)};var en=Object.prototype.hasOwnProperty||function(n){return n in this}},function(n,e,t){"use strict";var r;if(!Object.keys){var a=Object.prototype.hasOwnProperty,o=Object.prototype.toString,i=t(26),s=Object.prototype.propertyIsEnumerable,c=!s.call({toString:null},"toString"),l=s.call((function(){}),"prototype"),p=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],u=function(n){var e=n.constructor;return e&&e.prototype===n},d={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},m=function(){if("undefined"==typeof window)return!1;for(var n in window)try{if(!d["$"+n]&&a.call(window,n)&&null!==window[n]&&"object"==typeof window[n])try{u(window[n])}catch(n){return!0}}catch(n){return!0}return!1}(),h=function(n){if("undefined"==typeof window||!m)return u(n);try{return u(n)}catch(n){return!1}};r=function(n){var e=null!==n&&"object"==typeof n,t="[object Function]"===o.call(n),r=i(n),s=e&&"[object String]"===o.call(n),u=[];if(!e&&!t&&!r)throw new TypeError("Object.keys called on a non-object");var d=l&&t;if(s&&n.length>0&&!a.call(n,0))for(var m=0;m<n.length;++m)u.push(String(m));if(r&&n.length>0)for(var g=0;g<n.length;++g)u.push(String(g));else for(var f in n)d&&"prototype"===f||!a.call(n,f)||u.push(String(f));if(c)for(var b=h(n),v=0;v<p.length;++v)b&&"constructor"===p[v]||!a.call(n,p[v])||u.push(p[v]);return u}}n.exports=r},function(n,e,t){"use strict";var r=Array.prototype.slice,a=t(26),o=Object.keys,i=o?function(n){return o(n)}:t(87),s=Object.keys;i.shim=function(){return Object.keys?function(){var n=Object.keys(arguments);return n&&n.length===arguments.length}(1,2)||(Object.keys=function(n){return s(a(n)?r.call(n):n)}):Object.keys=i,Object.keys||i},n.exports=i},function(n,e,t){"use strict";var r=t(2),a=t(4),o=t(27),i=t(28),s=t(90),c=a(i(),Object);r(c,{getPolyfill:i,implementation:o,shim:s}),n.exports=c},function(n,e,t){"use strict";var r=t(28),a=t(2);n.exports=function(){var n=r();return a(Object,{entries:n},{entries:function(){return Object.entries!==n}}),n}},function(n,e){function t(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function a(n){if(l===setTimeout)return setTimeout(n,0);if((l===t||!l)&&setTimeout)return l=setTimeout,setTimeout(n,0);try{return l(n,0)}catch(e){try{return l.call(null,n,0)}catch(e){return l.call(this,n,0)}}}function o(){h&&d&&(h=!1,d.length?m=d.concat(m):g=-1,m.length&&i())}function i(){if(!h){var n=a(o);h=!0;for(var e=m.length;e;){for(d=m,m=[];++g<e;)d&&d[g].run();g=-1,e=m.length}d=null,h=!1,function(n){if(p===clearTimeout)return clearTimeout(n);if((p===r||!p)&&clearTimeout)return p=clearTimeout,clearTimeout(n);try{p(n)}catch(e){try{return p.call(null,n)}catch(e){return p.call(this,n)}}}(n)}}function s(n,e){this.fun=n,this.array=e}function c(){}var l,p,u=n.exports={};!function(){try{l="function"==typeof setTimeout?setTimeout:t}catch(n){l=t}try{p="function"==typeof clearTimeout?clearTimeout:r}catch(n){p=r}}();var d,m=[],h=!1,g=-1;u.nextTick=function(n){var e=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)e[t-1]=arguments[t];m.push(new s(n,e)),1!==m.length||h||a(i)},s.prototype.run=function(){this.fun.apply(null,this.array)},u.title="browser",u.browser=!0,u.env={},u.argv=[],u.version="",u.versions={},u.on=c,u.addListener=c,u.once=c,u.off=c,u.removeListener=c,u.removeAllListeners=c,u.emit=c,u.prependListener=c,u.prependOnceListener=c,u.listeners=function(n){return[]},u.binding=function(n){throw new Error("process.binding is not supported")},u.cwd=function(){return"/"},u.chdir=function(n){throw new Error("process.chdir is not supported")},u.umask=function(){return 0}},function(n,e,t){"use strict";var r=t(4),a=t(2),o=t(29),i=t(30),s=t(93),c=r(i());a(c,{getPolyfill:i,implementation:o,shim:s}),n.exports=c},function(n,e,t){"use strict";var r=t(2),a=t(30);n.exports=function(){var n=a();return r(String.prototype,{trim:n},{trim:function(){return String.prototype.trim!==n}}),n}},function(n,e,t){"use strict";(function(e){var t=function(){};if("production"!==e.env.NODE_ENV){var r=function(n,e){var t=arguments.length;e=new Array(t>1?t-1:0);for(var r=1;r<t;r++)e[r-1]=arguments[r];var a=0,o="Warning: "+n.replace(/%s/g,(function(){return e[a++]}));try{throw new Error(o)}catch(n){}};t=function(n,e,t){var a=arguments.length;t=new Array(a>2?a-2:0);for(var o=2;o<a;o++)t[o-2]=arguments[o];if(void 0===e)throw new Error("`warning(condition, format, ...args)` requires a warning message argument");n||r.apply(null,[e].concat(t))}}n.exports=t}).call(e,t(91))},function(n,e,t){function r(n,e){return new i(e).process(n)}var a=t(31),o=t(32),i=t(96);for(var s in(e=n.exports=r).filterXSS=r,e.FilterXSS=i,a)e[s]=a[s];for(var s in o)e[s]=o[s];"undefined"!=typeof window&&(window.filterXSS=n.exports),"undefined"!=typeof self&&"undefined"!=typeof DedicatedWorkerGlobalScope&&self instanceof DedicatedWorkerGlobalScope&&(self.filterXSS=n.exports)},function(n,e,t){function r(n){return null==n}function a(n){(n=function(n){var e={};for(var t in n)e[t]=n[t];return e}(n||{})).stripIgnoreTag&&(n.onIgnoreTag,n.onIgnoreTag=i.onIgnoreTagStripAll),n.whiteList=n.whiteList||n.allowList||i.whiteList,n.onTag=n.onTag||i.onTag,n.onTagAttr=n.onTagAttr||i.onTagAttr,n.onIgnoreTag=n.onIgnoreTag||i.onIgnoreTag,n.onIgnoreTagAttr=n.onIgnoreTagAttr||i.onIgnoreTagAttr,n.safeAttrValue=n.safeAttrValue||i.safeAttrValue,n.escapeHtml=n.escapeHtml||i.escapeHtml,this.options=n,!1===n.css?this.cssFilter=!1:(n.css=n.css||{},this.cssFilter=new o(n.css))}var o=t(7).FilterCSS,i=t(31),s=t(32),c=s.parseTag,l=s.parseAttr,p=t(11);a.prototype.process=function(n){if(!(n=(n=n||"").toString()))return"";var e=this.options,t=e.whiteList,a=e.onTag,o=e.onIgnoreTag,s=e.onTagAttr,u=e.onIgnoreTagAttr,d=e.safeAttrValue,m=e.escapeHtml,h=this.cssFilter;e.stripBlankChar&&(n=i.stripBlankChar(n)),e.allowCommentTag||(n=i.stripCommentTag(n));var g=!1;e.stripIgnoreTagBody&&(g=i.StripTagBody(e.stripIgnoreTagBody,o),o=g.onIgnoreTag);var f=c(n,(function(n,e,i,c,g){var f,b={sourcePosition:n,position:e,isClosing:g,isWhite:t.hasOwnProperty(i)};if(!r(f=a(i,c,b)))return f;if(b.isWhite){if(b.isClosing)return"</"+i+">";var v=function(n){var e=p.spaceIndex(n);if(-1===e)return{html:"",closing:"/"===n[n.length-2]};var t="/"===(n=p.trim(n.slice(e+1,-1)))[n.length-1];return t&&(n=p.trim(n.slice(0,-1))),{html:n,closing:t}}(c),y=t[i],x=l(v.html,(function(n,e){var t,a=-1!==p.indexOf(y,n);return r(t=s(i,n,e,a))?a?(e=d(i,n,e,h))?n+'="'+e+'"':n:r(t=u(i,n,e,a))?void 0:t:t}));return c="<"+i,x&&(c+=" "+x),v.closing&&(c+=" /"),c+">"}return r(f=o(i,c,b))?m(c):f}),m);return g&&(f=g.remove(f)),f},n.exports=a},function(n,e){n.exports={smile:"e3/2018new_weixioa02_org.png",lovely:"09/2018new_keai_org.png",happy:"1e/2018new_taikaixin_org.png",clap:"6e/2018new_guzhang_thumb.png",whee:"33/2018new_xixi_thumb.png",haha:"8f/2018new_haha_thumb.png","laugh and cry":"4a/2018new_xiaoku_thumb.png",wink:"43/2018new_jiyan_org.png",greddy:"fa/2018new_chanzui_org.png",awkward:"a3/2018new_heixian_thumb.png",sweat:"28/2018new_han_org.png","pick nose":"9a/2018new_wabi_thumb.png",hum:"7c/2018new_heng_thumb.png",angry:"f6/2018new_nu_thumb.png",grievance:"a5/2018new_weiqu_thumb.png",poor:"96/2018new_kelian_org.png",disappoint:"aa/2018new_shiwang_thumb.png",sad:"ee/2018new_beishang_org.png",tear:"6e/2018new_leimu_org.png","no way":"83/2018new_kuxiao_org.png",shy:"c1/2018new_haixiu_org.png",dirt:"10/2018new_wu_thumb.png","love you":"f6/2018new_aini_org.png",kiss:"2c/2018new_qinqin_thumb.png",amorousness:"9d/2018new_huaxin_org.png",longing:"c9/2018new_chongjing_org.png",desire:"3e/2018new_tianping_thumb.png","bad laugh":"4d/2018new_huaixiao_org.png",blackness:"9e/2018new_yinxian_org.png","laugh without word":"2d/2018new_xiaoerbuyu_org.png",titter:"71/2018new_touxiao_org.png",cool:"c4/2018new_ku_org.png","not easy":"aa/2018new_bingbujiandan_thumb.png",think:"30/2018new_sikao_org.png",question:"b8/2018new_ningwen_org.png","no idea":"2a/2018new_wenhao_thumb.png",dizzy:"07/2018new_yun_thumb.png",bomb:"a2/2018new_shuai_thumb.png",bone:"a1/2018new_kulou_thumb.png","be quiet":"b0/2018new_xu_org.png","shut up":"62/2018new_bizui_org.png",stupid:"dd/2018new_shayan_org.png","surprise ":"49/2018new_chijing_org.png",vomit:"08/2018new_tu_org.png",cold:"40/2018new_kouzhao_thumb.png",sick:"3b/2018new_shengbing_thumb.png",bye:"fd/2018new_baibai_thumb.png","look down on":"da/2018new_bishi_org.png","white eye":"ef/2018new_landelini_org.png","left hum":"43/2018new_zuohengheng_thumb.png","right hum":"c1/2018new_youhengheng_thumb.png",crazy:"17/2018new_zhuakuang_org.png","scold ":"87/2018new_zhouma_thumb.png","hit on face":"cb/2018new_dalian_org.png",wow:"ae/2018new_ding_org.png",fan:"86/2018new_hufen02_org.png",money:"a2/2018new_qian_thumb.png",yawn:"55/2018new_dahaqian_org.png",sleepy:"3c/2018new_kun_thumb.png",sleep:"e2/2018new_shuijiao_thumb.png","watermelon ":"01/2018new_chigua_thumb.png",doge:"a1/2018new_doge02_org.png",dog:"22/2018new_erha_org.png",cat:"7b/2018new_miaomiao_thumb.png",thumb:"e6/2018new_zan_org.png",good:"8a/2018new_good_org.png",ok:"45/2018new_ok_org.png",yeah:"29/2018new_ye_thumb.png","shack hand":"e9/2018new_woshou_thumb.png",bow:"e7/2018new_zuoyi_org.png",come:"42/2018new_guolai_thumb.png",punch:"86/2018new_quantou_thumb.png"}},function(n,e){n.exports={nick:"NickName",mail:"E-Mail",link:"Website(http://)",nickFail:"NickName cannot be less than 3 bytes.",mailFail:"Please confirm your email address.",sofa:"No comment yet.",submit:"Submit",reply:"Reply",cancelReply:"Cancel reply",comments:"Comments",cancel:"Cancel",confirm:"Confirm",continue:"Continue",more:"Load More...",preview:"Preview",emoji:"Emoji",expand:"See more....",seconds:"seconds ago",minutes:"minutes ago",hours:"hours ago",days:"days ago",now:"just now",uploading:"Uploading ...",uploadDone:"Upload completed!",busy:"Submit is busy, please wait...","code-98":"Valine initialization failed, please check your version of av-min.js.","code-99":"Valine initialization failed, Please check the `el` element in the init method.","code-100":"Valine initialization failed, Please check your appId and appKey.","code-140":"The total number of API calls today has exceeded the development version limit.","code-401":"Unauthorized operation, Please check your appId and appKey.","code-403":"Access denied by API domain white list, Please check your security domain."}},function(n,e){n.exports={nick:"ニックネーム",mail:"メールアドレス",link:"サイト(http://)",nickFail:"3バイト以上のニックネームをご入力ください.",mailFail:"メールアドレスをご確認ください.",sofa:"コメントしましょう~",submit:"提出する",reply:"返信する",cancelReply:"キャンセル",comments:"コメント",cancel:"キャンセル",confirm:"確認する",continue:"继续",more:"さらに読み込む...",preview:"プレビュー",emoji:"絵文字",expand:"もっと見る",seconds:"秒前",minutes:"分前",hours:"時間前",days:"日前",now:"たっだ今",uploading:"アップロード中...",uploadDone:"アップロードが完了しました!",busy:"20 秒間隔で提出してください    ...","code-98":"ロードエラーです。av-min.js のバージョンを確認してください.","code-99":"ロードエラーです。initにある`el`エレメントを確認ください.","code-100":"ロードエラーです。AppIdとAppKeyを確認ください.","code-140":"今日のAPIコールの総数が開発バージョンの上限を超えた.","code-401":"権限が制限されています。AppIdとAppKeyを確認ください.","code-403":"アクセスがAPIなどに制限されました、ドメイン名のセキュリティ設定を確認ください"}},function(n,e){n.exports={nick:"昵称",mail:"邮箱",link:"网址(http://)",nickFail:"昵称不能少于3个字符",mailFail:"请填写正确的邮件地址",sofa:"来发评论吧~",submit:"提交",reply:"回复",cancelReply:"取消回复",comments:"评论",cancel:"取消",confirm:"确认",continue:"继续",more:"加载更多...",preview:"预览",emoji:"表情",expand:"查看更多...",seconds:"秒前",minutes:"分钟前",hours:"小时前",days:"天前",now:"刚刚",uploading:"正在传输...",uploadDone:"传输完成!",busy:"操作频繁，请稍候再试...","code-98":"Valine 初始化失败，请检查 av-min.js 版本","code-99":"Valine 初始化失败，请检查init中的`el`元素.","code-100":"Valine 初始化失败，请检查你的AppId和AppKey.","code-140":"今日 API 调用总次数已超过开发版限制.","code-401":"未经授权的操作，请检查你的AppId和AppKey.","code-403":"访问被API域名白名单拒绝，请检查你的安全域名设置."}},function(n,e){n.exports={nick:"暱稱",mail:"郵箱",link:"網址(http://)",nickFail:"昵稱不能少於3個字符",mailFail:"請填寫正確的郵件地址",sofa:"來發評論吧~",submit:"提交",reply:"回覆",cancelReply:"取消回覆",comments:"評論",cancel:"取消",confirm:"確認",continue:"繼續",more:"加載更多...",preview:"預覽",emoji:"表情",expand:"查看更多...",seconds:"秒前",minutes:"分鐘前",hours:"小時前",days:"天前",now:"剛剛",uploading:"正在上傳...",uploadDone:"上傳完成!",busy:"操作頻繁，請稍候再試...","code-98":"Valine 初始化失敗，請檢查 av-min.js 版本","code-99":"Valine 初始化失敗，請檢查init中的`el`元素.","code-100":"Valine 初始化失敗，請檢查你的AppId和AppKey.","code-140":"今日 API 調用總次數已超過開發版限制.","code-401":"未經授權的操作，請檢查你的AppId和AppKey.","code-403":"訪問被API域名白名單拒絕，請檢查你的安全域名設置."}},function(n,e){},function(n,e,t){var r=t(104);"string"==typeof r&&(r=[[n.i,r,""]]);var a={transform:void 0};t(106)(r,a),r.locals&&(n.exports=r.locals)},function(n,e,t){(e=t(105)(!1)).push([n.i,'.v[data-class=v]{font-size:16px;text-align:left}.v[data-class=v] *{-webkit-box-sizing:border-box;box-sizing:border-box;line-height:1.75}.v[data-class=v] .vinput,.v[data-class=v] .veditor,.v[data-class=v] p,.v[data-class=v] pre code,.v[data-class=v] .status-bar{color:#555}.v[data-class=v] .vtime,.v[data-class=v] .vsys{color:#b3b3b3}.v[data-class=v] .text-right{text-align:right}.v[data-class=v] .text-center{text-align:center}.v[data-class=v] img{max-width:100%;border:none}.v[data-class=v] hr{margin:.825em 0;border-color:#f6f6f6;border-style:dashed}.v[data-class=v].hide-avatar .vimg{display:none}.v[data-class=v] a{position:relative;cursor:pointer;color:#1abc9c;text-decoration:none;display:inline-block}.v[data-class=v] a:hover{color:#d7191a}.v[data-class=v] pre,.v[data-class=v] code{background-color:#f8f8f8;padding:.2em .4em;border-radius:3px;font-size:85%;margin:0}.v[data-class=v] pre{padding:10px;overflow:auto;line-height:1.45}.v[data-class=v] pre code{padding:0;background:transparent;white-space:pre-wrap;word-break:keep-all}.v[data-class=v] blockquote{color:#666;margin:.5em 0;padding:0 0 0 1em;border-left:8px solid rgba(238,238,238,.5)}.v[data-class=v] .vinput{border:none;resize:none;outline:none;padding:10px 5px;max-width:100%;font-size:.775em;-webkit-box-sizing:border-box;box-sizing:border-box}.v[data-class=v] input[type=checkbox],.v[data-class=v] input[type=radio]{display:inline-block;vertical-align:middle;margin-top:-2px}.v[data-class=v] .vicon{cursor:pointer;display:inline-block;overflow:hidden;fill:#555;vertical-align:middle}.v[data-class=v] .vicon+.vicon{margin-left:10px}.v[data-class=v] .vicon.actived{fill:#66b1ff}.v[data-class=v] .vrow{font-size:0;padding:10px 0}.v[data-class=v] .vrow .vcol{display:inline-block;vertical-align:middle;font-size:14px}.v[data-class=v] .vrow .vcol.vcol-20{width:20%}.v[data-class=v] .vrow .vcol.vcol-30{width:30%}.v[data-class=v] .vrow .vcol.vcol-40{width:40%}.v[data-class=v] .vrow .vcol.vcol-50{width:50%}.v[data-class=v] .vrow .vcol.vcol-60{width:60%}.v[data-class=v] .vrow .vcol.vcol-70{width:70%}.v[data-class=v] .vrow .vcol.vcol-80{width:80%}.v[data-class=v] .vrow .vcol.vctrl{font-size:12px}.v[data-class=v] .vemoji,.v[data-class=v] .emoji{width:26px;height:26px;overflow:hidden;vertical-align:middle;margin:0 1px;display:inline-block}.v[data-class=v] .vwrap{border:1px solid #f0f0f0;border-radius:4px;margin-bottom:10px;overflow:hidden;position:relative;padding:10px}.v[data-class=v] .vwrap input{background:transparent}.v[data-class=v] .vwrap .vedit{position:relative;padding-top:10px}.v[data-class=v] .vwrap .cancel-reply-btn{position:absolute;right:5px;top:5px;cursor:pointer}.v[data-class=v] .vwrap .vemojis{display:none;font-size:18px;max-height:145px;overflow:auto;padding-bottom:10px;-webkit-box-shadow:0px 0 1px #f0f0f0;box-shadow:0px 0 1px #f0f0f0}.v[data-class=v] .vwrap .vemojis i{font-style:normal;padding-top:7px;width:36px;cursor:pointer;text-align:center;display:inline-block;vertical-align:middle}.v[data-class=v] .vwrap .vpreview{padding:7px;-webkit-box-shadow:0px 0 1px #f0f0f0;box-shadow:0px 0 1px #f0f0f0}.v[data-class=v] .vwrap .vheader .vinput{width:33.33%;border-bottom:1px #dedede dashed}.v[data-class=v] .vwrap .vheader.item2 .vinput{width:50%}.v[data-class=v] .vwrap .vheader.item1 .vinput{width:100%}.v[data-class=v] .vwrap .vheader .vinput:focus{border-bottom-color:#eb5055}@media screen and (max-width: 520px){.v[data-class=v] .vwrap .vheader .vinput{width:100%}.v[data-class=v] .vwrap .vheader.item2 .vinput{width:100%}}.v[data-class=v] .vpower{color:#999;font-size:.75em;padding:.5em 0}.v[data-class=v] .vpower a{font-size:.75em}.v[data-class=v] .vcount{padding:5px;font-weight:600;font-size:1.25em}.v[data-class=v] ul,.v[data-class=v] ol{padding:0;margin-left:1.25em}.v[data-class=v] .txt-center{text-align:center}.v[data-class=v] .txt-right{text-align:right}.v[data-class=v] .veditor{width:100%;min-height:8.75em;font-size:.875em;background:transparent;resize:vertical;-webkit-transition:all .25s ease;transition:all .25s ease}.v[data-class=v] .vbtn{-webkit-transition-duration:.4s;transition-duration:.4s;text-align:center;color:#555;border:1px solid #ededed;border-radius:.3em;display:inline-block;background:transparent;margin-bottom:0;font-weight:400;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;white-space:nowrap;padding:.5em 1.25em;font-size:.875em;line-height:1.42857143;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:none}.v[data-class=v] .vbtn+.vbtn{margin-left:1.25em}.v[data-class=v] .vbtn:active,.v[data-class=v] .vbtn:hover{color:#3090e4;border-color:#3090e4}.v[data-class=v] .vbtn:disabled{border-color:#e1e1e1;color:#e1e1e1;background-color:#fdfafa;cursor:not-allowed}.v[data-class=v] .vempty{padding:1.25em;text-align:center;color:#555;overflow:auto}.v[data-class=v] .vsys{display:inline-block;padding:.2em .5em;font-size:.75em;border-radius:.2em;margin-right:.3em}@media screen and (max-width: 520px){.v[data-class=v] .vsys{display:none}}.v[data-class=v] .vcards{width:100%}.v[data-class=v] .vcards .vcard{padding-top:1.25em;position:relative;display:block}.v[data-class=v] .vcards .vcard:after{content:"";clear:both;display:block}.v[data-class=v] .vcards .vcard .vimg{width:3.125em;height:3.125em;float:left;border-radius:50%;margin-right:.7525em;border:1px solid #f5f5f5;padding:.125em}@media screen and (max-width: 720px){.v[data-class=v] .vcards .vcard .vimg{width:2.5em;height:2.5em}}.v[data-class=v] .vcards .vcard .vhead{line-height:1.5;margin-top:0}.v[data-class=v] .vcards .vcard .vhead .vnick{position:relative;font-size:.875em;font-weight:500;margin-right:.875em;cursor:pointer;text-decoration:none;display:inline-block}.v[data-class=v] .vcards .vcard .vhead .vnick:hover{color:#d7191a}.v[data-class=v] .vcards .vcard .vh{overflow:hidden;padding-bottom:.5em;border-bottom:1px dashed #f5f5f5}.v[data-class=v] .vcards .vcard .vh .vtime{font-size:.75em;margin-right:.875em}.v[data-class=v] .vcards .vcard .vh .vmeta{line-height:1;position:relative}.v[data-class=v] .vcards .vcard .vh .vmeta .vat{font-size:.8125em;color:#ef2f11;cursor:pointer;float:right}.v[data-class=v] .vcards .vcard:last-child .vh{border-bottom:none}.v[data-class=v] .vcards .vcard .vcontent{word-wrap:break-word;word-break:break-all;font-size:.875em;line-height:2;position:relative;margin-bottom:.75em;padding-top:.625em}.v[data-class=v] .vcards .vcard .vcontent.expand{cursor:pointer;max-height:8em;overflow:hidden}.v[data-class=v] .vcards .vcard .vcontent.expand::before{display:block;content:"";position:absolute;width:100%;left:0;top:0;bottom:3.15em;background:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(rgba(255, 255, 255, 0.9)));background:linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.9));z-index:999}.v[data-class=v] .vcards .vcard .vcontent.expand::after{display:block;content:attr(data-expand);text-align:center;color:#828586;position:absolute;width:100%;height:3.15em;line-height:3.15em;left:0;bottom:0;z-index:999;background:rgba(255,255,255,.9)}.v[data-class=v] .vcards .vcard .vquote{padding-left:1em;border-left:1px dashed rgba(238,238,238,.5)}.v[data-class=v] .vcards .vcard .vquote .vimg{width:2.225em;height:2.225em}.v[data-class=v] .vpage .vmore{margin:1em 0}.v[data-class=v] .clear{content:"";display:block;clear:both}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes pulse{50%{background:#dcdcdc}}@keyframes pulse{50%{background:#dcdcdc}}.v[data-class=v] .vspinner{width:22px;height:22px;display:inline-block;border:6px double #a0a0a0;border-top-color:transparent;border-bottom-color:transparent;border-radius:50%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear;position:relative;vertical-align:middle;margin:0 5px}[data-theme=dark] .v[data-class=v] .vinput,[data-theme=dark] .v[data-class=v] .veditor,[data-theme=dark] .v[data-class=v] p,[data-theme=dark] .v[data-class=v] pre code,[data-theme=dark] .v[data-class=v] .status-bar,.dark .v[data-class=v] .vinput,.dark .v[data-class=v] .veditor,.dark .v[data-class=v] p,.dark .v[data-class=v] pre code,.dark .v[data-class=v] .status-bar,.theme__dark .v[data-class=v] .vinput,.theme__dark .v[data-class=v] .veditor,.theme__dark .v[data-class=v] p,.theme__dark .v[data-class=v] pre code,.theme__dark .v[data-class=v] .status-bar,.night .v[data-class=v] .vinput,.night .v[data-class=v] .veditor,.night .v[data-class=v] p,.night .v[data-class=v] pre code,.night .v[data-class=v] .status-bar{color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vtime,[data-theme=dark] .v[data-class=v] .vsys,.dark .v[data-class=v] .vtime,.dark .v[data-class=v] .vsys,.theme__dark .v[data-class=v] .vtime,.theme__dark .v[data-class=v] .vsys,.night .v[data-class=v] .vtime,.night .v[data-class=v] .vsys{color:#929298}[data-theme=dark] .v[data-class=v] pre,[data-theme=dark] .v[data-class=v] code,[data-theme=dark] .v[data-class=v] pre code,.dark .v[data-class=v] pre,.dark .v[data-class=v] code,.dark .v[data-class=v] pre code,.theme__dark .v[data-class=v] pre,.theme__dark .v[data-class=v] code,.theme__dark .v[data-class=v] pre code,.night .v[data-class=v] pre,.night .v[data-class=v] code,.night .v[data-class=v] pre code{color:#929298;background-color:#151414}[data-theme=dark] .v[data-class=v] .vwrap,.dark .v[data-class=v] .vwrap,.theme__dark .v[data-class=v] .vwrap,.night .v[data-class=v] .vwrap{border-color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vicon,.dark .v[data-class=v] .vicon,.theme__dark .v[data-class=v] .vicon,.night .v[data-class=v] .vicon{fill:#b2b2b5}[data-theme=dark] .v[data-class=v] .vicon.actived,.dark .v[data-class=v] .vicon.actived,.theme__dark .v[data-class=v] .vicon.actived,.night .v[data-class=v] .vicon.actived{fill:#66b1ff}[data-theme=dark] .v[data-class=v] .vbtn,.dark .v[data-class=v] .vbtn,.theme__dark .v[data-class=v] .vbtn,.night .v[data-class=v] .vbtn{color:#b2b2b5;border-color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vbtn:hover,.dark .v[data-class=v] .vbtn:hover,.theme__dark .v[data-class=v] .vbtn:hover,.night .v[data-class=v] .vbtn:hover{color:#66b1ff;border-color:#66b1ff}[data-theme=dark] .v[data-class=v] a:hover,.dark .v[data-class=v] a:hover,.theme__dark .v[data-class=v] a:hover,.night .v[data-class=v] a:hover{color:#d7191a}[data-theme=dark] .v[data-class=v] .vcards .vcard .vcontent.expand::before,.dark .v[data-class=v] .vcards .vcard .vcontent.expand::before,.theme__dark .v[data-class=v] .vcards .vcard .vcontent.expand::before,.night .v[data-class=v] .vcards .vcard .vcontent.expand::before{background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.3)), to(rgba(0, 0, 0, 0.7)));background:linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.7))}[data-theme=dark] .v[data-class=v] .vcards .vcard .vcontent.expand::after,.dark .v[data-class=v] .vcards .vcard .vcontent.expand::after,.theme__dark .v[data-class=v] .vcards .vcard .vcontent.expand::after,.night .v[data-class=v] .vcards .vcard .vcontent.expand::after{background:rgba(0,0,0,.7)}@media(prefers-color-scheme: dark){.v[data-class=v] .vinput,.v[data-class=v] .veditor,.v[data-class=v] p,.v[data-class=v] pre code,.v[data-class=v] .status-bar{color:#b2b2b5}.v[data-class=v] .vtime,.v[data-class=v] .vsys{color:#929298}.v[data-class=v] pre,.v[data-class=v] code,.v[data-class=v] pre code{color:#929298;background-color:#151414}.v[data-class=v] .vwrap{border-color:#b2b2b5}.v[data-class=v] .vicon{fill:#b2b2b5}.v[data-class=v] .vicon.actived{fill:#66b1ff}.v[data-class=v] .vbtn{color:#b2b2b5;border-color:#b2b2b5}.v[data-class=v] .vbtn:hover{color:#66b1ff;border-color:#66b1ff}.v[data-class=v] a:hover{color:#d7191a}.v[data-class=v] .vcards .vcard .vcontent.expand::before{background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.3)), to(rgba(0, 0, 0, 0.7)));background:linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.7))}.v[data-class=v] .vcards .vcard .vcontent.expand::after{background:rgba(0,0,0,.7)}}',""]),n.exports=e},function(n,e,t){"use strict";function r(n,e){var t=n[1]||"",r=n[3];if(!r)return t;if(e&&"function"==typeof btoa){var a=function(n){return"/*# ".concat("sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(n)))))," */")}(r);return[t].concat(r.sources.map((function(n){return"/*# sourceURL=".concat(r.sourceRoot||"").concat(n," */")}))).concat([a]).join("\n")}return[t].join("\n")}n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t=r(e,n);return e[2]?"@media ".concat(e[2]," {").concat(t,"}"):t})).join("")},e.i=function(n,t,r){"string"==typeof n&&(n=[[null,n,""]]);var a={};if(r)for(var o=0;o<this.length;o++){var i=this[o][0];null!=i&&(a[i]=!0)}for(var s=0;s<n.length;s++){var c=[].concat(n[s]);r&&a[c[0]]||(t&&(c[2]?c[2]="".concat(t," and ").concat(c[2]):c[2]=t),e.push(c))}},e}},function(n,e,t){function r(n,e){for(var t=0;t<n.length;t++){var r=n[t],a=h[r.id];if(a){a.refs++;for(var o=0;o<a.parts.length;o++)a.parts[o](r.parts[o]);for(;o<r.parts.length;o++)a.parts.push(p(r.parts[o],e))}else{var i=[];for(o=0;o<r.parts.length;o++)i.push(p(r.parts[o],e));h[r.id]={id:r.id,refs:1,parts:i}}}}function a(n,e){for(var t=[],r={},a=0;a<n.length;a++){var o=n[a],i=e.base?o[0]+e.base:o[0],s={css:o[1],media:o[2],sourceMap:o[3]};r[i]?r[i].parts.push(s):t.push(r[i]={id:i,parts:[s]})}return t}function o(n,e){var t=f(n.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var r=y[y.length-1];if("top"===n.insertAt)r?r.nextSibling?t.insertBefore(e,r.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),y.push(e);else{if("bottom"!==n.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");t.appendChild(e)}}function i(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n);var e=y.indexOf(n);e>=0&&y.splice(e,1)}function s(n){var e=document.createElement("style");return n.attrs.type="text/css",l(e,n.attrs),o(n,e),e}function c(n){var e=document.createElement("link");return n.attrs.type="text/css",n.attrs.rel="stylesheet",l(e,n.attrs),o(n,e),e}function l(n,e){Object.keys(e).forEach((function(t){n.setAttribute(t,e[t])}))}function p(n,e){var t,r,a,o;if(e.transform&&n.css){if(!(o=e.transform(n.css)))return function(){};n.css=o}if(e.singleton){var l=v++;t=b||(b=s(e)),r=u.bind(null,t,l,!1),a=u.bind(null,t,l,!0)}else n.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=c(e),r=m.bind(null,t,e),a=function(){i(t),t.href&&URL.revokeObjectURL(t.href)}):(t=s(e),r=d.bind(null,t),a=function(){i(t)});return r(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;r(n=e)}else a()}}function u(n,e,t,r){var a=t?"":r.css;if(n.styleSheet)n.styleSheet.cssText=w(e,a);else{var o=document.createTextNode(a),i=n.childNodes;i[e]&&n.removeChild(i[e]),i.length?n.insertBefore(o,i[e]):n.appendChild(o)}}function d(n,e){var t=e.css,r=e.media;if(r&&n.setAttribute("media",r),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}function m(n,e,t){var r=t.css,a=t.sourceMap,o=void 0===e.convertToAbsoluteUrls&&a;(e.convertToAbsoluteUrls||o)&&(r=x(r)),a&&(r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */");var i=new Blob([r],{type:"text/css"}),s=n.href;n.href=URL.createObjectURL(i),s&&URL.revokeObjectURL(s)}var h={},g=function(n){var e;return function(){return void 0===e&&(e=n.apply(this,arguments)),e}}((function(){return window&&document&&document.all&&!window.atob})),f=function(n){var e={};return function(t){return void 0===e[t]&&(e[t]=n.call(this,t)),e[t]}}((function(n){return document.querySelector(n)})),b=null,v=0,y=[],x=t(107);n.exports=function(n,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(e=e||{}).attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||(e.singleton=g()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var t=a(n,e);return r(t,e),function(n){for(var o=[],i=0;i<t.length;i++){var s=t[i];(c=h[s.id]).refs--,o.push(c)}for(n&&r(a(n,e),e),i=0;i<o.length;i++){var c;if(0===(c=o[i]).refs){for(var l=0;l<c.parts.length;l++)c.parts[l]();delete h[c.id]}}}};var w=function(){var n=[];return function(e,t){return n[e]=t,n.filter(Boolean).join("\n")}}()},function(n,e){n.exports=function(n){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!n||"string"!=typeof n)return n;var t=e.protocol+"//"+e.host,r=t+e.pathname.replace(/\/[^\/]*$/,"/");return n.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,(function(n,e){var a,o=e.trim().replace(/^"(.*)"$/,(function(n,e){return e})).replace(/^'(.*)'$/,(function(n,e){return e}));return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(o)?n:(a=0===o.indexOf("//")?o:0===o.indexOf("/")?t+o:r+o.replace(/^\.\//,""),"url("+JSON.stringify(a)+")")}))}},function(n,e,t){t(103),n.exports=t(34)}])},function(n,e,t){"use strict";t(111)},function(n,e,t){"use strict";var r=t(112),a=t(113),o={brackets:function(n){return n+"[]"},indices:function(n,e){return n+"["+e+"]"},repeat:function(n){return n}},i=Array.isArray,s=Array.prototype.push,c=function(n,e){s.apply(n,i(e)?e:[e])},l=Date.prototype.toISOString,p={delimiter:"&",encode:!0,encoder:r.encode,encodeValuesOnly:!1,serializeDate:function(n){return l.call(n)},skipNulls:!1,strictNullHandling:!1},u=function n(e,t,a,o,s,l,u,d,m,h,g,f){var b=e;if("function"==typeof u?b=u(t,b):b instanceof Date&&(b=h(b)),null===b){if(o)return l&&!f?l(t,p.encoder):t;b=""}if("string"==typeof b||"number"==typeof b||"boolean"==typeof b||r.isBuffer(b))return l?[g(f?t:l(t,p.encoder))+"="+g(l(b,p.encoder))]:[g(t)+"="+g(String(b))];var v,y=[];if(void 0===b)return y;if(i(u))v=u;else{var x=Object.keys(b);v=d?x.sort(d):x}for(var w=0;w<v.length;++w){var k=v[w];s&&null===b[k]||(i(b)?c(y,n(b[k],a(t,k),a,o,s,l,u,d,m,h,g,f)):c(y,n(b[k],t+(m?"."+k:"["+k+"]"),a,o,s,l,u,d,m,h,g,f)))}return y};n.exports=function(n,e){var t=n,s=e?r.assign({},e):{};if(null!==s.encoder&&void 0!==s.encoder&&"function"!=typeof s.encoder)throw new TypeError("Encoder has to be a function.");var l=void 0===s.delimiter?p.delimiter:s.delimiter,d="boolean"==typeof s.strictNullHandling?s.strictNullHandling:p.strictNullHandling,m="boolean"==typeof s.skipNulls?s.skipNulls:p.skipNulls,h="boolean"==typeof s.encode?s.encode:p.encode,g="function"==typeof s.encoder?s.encoder:p.encoder,f="function"==typeof s.sort?s.sort:null,b=void 0!==s.allowDots&&s.allowDots,v="function"==typeof s.serializeDate?s.serializeDate:p.serializeDate,y="boolean"==typeof s.encodeValuesOnly?s.encodeValuesOnly:p.encodeValuesOnly;if(void 0===s.format)s.format=a.default;else if(!Object.prototype.hasOwnProperty.call(a.formatters,s.format))throw new TypeError("Unknown format option provided.");var x,w,k=a.formatters[s.format];"function"==typeof s.filter?t=(w=s.filter)("",t):i(s.filter)&&(x=w=s.filter);var S,C=[];if("object"!=typeof t||null===t)return"";S=s.arrayFormat in o?s.arrayFormat:"indices"in s?s.indices?"indices":"repeat":"indices";var j=o[S];x||(x=Object.keys(t)),f&&x.sort(f);for(var A=0;A<x.length;++A){var T=x[A];m&&null===t[T]||c(C,u(t[T],T,j,d,m,h?g:null,w,f,b,v,k,y))}var E=C.join(l),P=!0===s.addQueryPrefix?"?":"";return E.length>0?P+E:""}},function(n,e,t){"use strict";var r=t(112),a=Object.prototype.hasOwnProperty,o={allowDots:!1,allowPrototypes:!1,arrayLimit:20,decoder:r.decode,delimiter:"&",depth:5,parameterLimit:1e3,plainObjects:!1,strictNullHandling:!1},i=function(n,e,t){if(n){var r=t.allowDots?n.replace(/\.([^.[]+)/g,"[$1]"):n,o=/(\[[^[\]]*])/g,i=/(\[[^[\]]*])/.exec(r),s=i?r.slice(0,i.index):r,c=[];if(s){if(!t.plainObjects&&a.call(Object.prototype,s)&&!t.allowPrototypes)return;c.push(s)}for(var l=0;null!==(i=o.exec(r))&&l<t.depth;){if(l+=1,!t.plainObjects&&a.call(Object.prototype,i[1].slice(1,-1))&&!t.allowPrototypes)return;c.push(i[1])}return i&&c.push("["+r.slice(i.index)+"]"),function(n,e,t){for(var r=e,a=n.length-1;a>=0;--a){var o,i=n[a];if("[]"===i&&t.parseArrays)o=[].concat(r);else{o=t.plainObjects?Object.create(null):{};var s="["===i.charAt(0)&&"]"===i.charAt(i.length-1)?i.slice(1,-1):i,c=parseInt(s,10);t.parseArrays||""!==s?!isNaN(c)&&i!==s&&String(c)===s&&c>=0&&t.parseArrays&&c<=t.arrayLimit?(o=[])[c]=r:"__proto__"!==s&&(o[s]=r):o={0:r}}r=o}return r}(c,e,t)}};n.exports=function(n,e){var t=e?r.assign({},e):{};if(null!==t.decoder&&void 0!==t.decoder&&"function"!=typeof t.decoder)throw new TypeError("Decoder has to be a function.");if(t.ignoreQueryPrefix=!0===t.ignoreQueryPrefix,t.delimiter="string"==typeof t.delimiter||r.isRegExp(t.delimiter)?t.delimiter:o.delimiter,t.depth="number"==typeof t.depth?t.depth:o.depth,t.arrayLimit="number"==typeof t.arrayLimit?t.arrayLimit:o.arrayLimit,t.parseArrays=!1!==t.parseArrays,t.decoder="function"==typeof t.decoder?t.decoder:o.decoder,t.allowDots="boolean"==typeof t.allowDots?t.allowDots:o.allowDots,t.plainObjects="boolean"==typeof t.plainObjects?t.plainObjects:o.plainObjects,t.allowPrototypes="boolean"==typeof t.allowPrototypes?t.allowPrototypes:o.allowPrototypes,t.parameterLimit="number"==typeof t.parameterLimit?t.parameterLimit:o.parameterLimit,t.strictNullHandling="boolean"==typeof t.strictNullHandling?t.strictNullHandling:o.strictNullHandling,""===n||null==n)return t.plainObjects?Object.create(null):{};for(var s="string"==typeof n?function(n,e){for(var t={},r=e.ignoreQueryPrefix?n.replace(/^\?/,""):n,i=e.parameterLimit===1/0?void 0:e.parameterLimit,s=r.split(e.delimiter,i),c=0;c<s.length;++c){var l,p,u=s[c],d=u.indexOf("]="),m=-1===d?u.indexOf("="):d+1;-1===m?(l=e.decoder(u,o.decoder),p=e.strictNullHandling?null:""):(l=e.decoder(u.slice(0,m),o.decoder),p=e.decoder(u.slice(m+1),o.decoder)),a.call(t,l)?t[l]=[].concat(t[l]).concat(p):t[l]=p}return t}(n,t):n,c=t.plainObjects?Object.create(null):{},l=Object.keys(s),p=0;p<l.length;++p){var u=l[p],d=i(u,s[u],t);c=r.merge(c,d,t)}return r.compact(c)}},function(n,e,t){var r=t(17),a=t(304),o=t(305);n.exports=function(n){var e=r(n);return o(e,a(e))+1}},function(n,e){n.exports=function(n){var e=new Date(n.getTime()),t=e.getTimezoneOffset();return e.setSeconds(0,0),6e4*t+e.getTime()%6e4}},function(n,e,t){var r=t(17);n.exports=function(n){var e=r(n),t=new Date(0);return t.setFullYear(e.getFullYear(),0,1),t.setHours(0,0,0,0),t}},function(n,e,t){var r=t(306);n.exports=function(n,e){var t=r(n),a=r(e),o=t.getTime()-6e4*t.getTimezoneOffset(),i=a.getTime()-6e4*a.getTimezoneOffset();return Math.round((o-i)/864e5)}},function(n,e,t){var r=t(17);n.exports=function(n){var e=r(n);return e.setHours(0,0,0,0),e}},function(n,e,t){var r=t(17),a=t(62),o=t(309);n.exports=function(n){var e=r(n),t=a(e).getTime()-o(e).getTime();return Math.round(t/6048e5)+1}},function(n,e,t){var r=t(17);n.exports=function(n,e){var t=e&&Number(e.weekStartsOn)||0,a=r(n),o=a.getDay(),i=(o<t?7:0)+o-t;return a.setDate(a.getDate()-i),a.setHours(0,0,0,0),a}},function(n,e,t){var r=t(115),a=t(62);n.exports=function(n){var e=r(n),t=new Date(0);return t.setFullYear(e,0,4),t.setHours(0,0,0,0),a(t)}},function(n,e,t){var r=t(114);n.exports=function(n){if(r(n))return!isNaN(n);throw new TypeError(toString.call(n)+" is not an instance of Date")}},function(n,e,t){var r=t(312),a=t(313);n.exports={distanceInWords:r(),format:a()}},function(n,e){n.exports=function(){var n={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}};return{localize:function(e,t,r){var a;return r=r||{},a="string"==typeof n[e]?n[e]:1===t?n[e].one:n[e].other.replace("{{count}}",t),r.addSuffix?r.comparison>0?"in "+a:a+" ago":a}}}},function(n,e,t){var r=t(314);n.exports=function(){var n=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],e=["January","February","March","April","May","June","July","August","September","October","November","December"],t=["Su","Mo","Tu","We","Th","Fr","Sa"],a=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],o=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],i=["AM","PM"],s=["am","pm"],c=["a.m.","p.m."],l={MMM:function(e){return n[e.getMonth()]},MMMM:function(n){return e[n.getMonth()]},dd:function(n){return t[n.getDay()]},ddd:function(n){return a[n.getDay()]},dddd:function(n){return o[n.getDay()]},A:function(n){return n.getHours()/12>=1?i[1]:i[0]},a:function(n){return n.getHours()/12>=1?s[1]:s[0]},aa:function(n){return n.getHours()/12>=1?c[1]:c[0]}};return["M","D","DDD","d","Q","W"].forEach((function(n){l[n+"o"]=function(e,t){return function(n){var e=n%100;if(e>20||e<10)switch(e%10){case 1:return n+"st";case 2:return n+"nd";case 3:return n+"rd"}return n+"th"}(t[n](e))}})),{formatters:l,formattingTokensRegExp:r(l)}}},function(n,e){var t=["M","MM","Q","D","DD","DDD","DDDD","d","E","W","WW","YY","YYYY","GG","GGGG","H","HH","h","hh","m","mm","s","ss","S","SS","SSS","Z","ZZ","X","x"];n.exports=function(n){var e=[];for(var r in n)n.hasOwnProperty(r)&&e.push(r);var a=t.concat(e).sort().reverse();return new RegExp("(\\[[^\\[]*\\])|(\\\\)?("+a.join("|")+"|.)","g")}},function(n,e,t){"use strict";var r=t(5),a=t(116),o=t(316),i=t(123);var s=function n(e){var t=new o(e),s=a(o.prototype.request,t);return r.extend(s,o.prototype,t),r.extend(s,t),s.create=function(t){return n(i(e,t))},s}(t(63));s.Axios=o,s.Cancel=t(41),s.CancelToken=t(329),s.isCancel=t(122),s.VERSION=t(124).version,s.all=function(n){return Promise.all(n)},s.spread=t(330),s.isAxiosError=t(331),n.exports=s,n.exports.default=s},function(n,e,t){"use strict";var r=t(5),a=t(117),o=t(317),i=t(318),s=t(123),c=t(328),l=c.validators;function p(n){this.defaults=n,this.interceptors={request:new o,response:new o}}p.prototype.request=function(n,e){"string"==typeof n?(e=e||{}).url=n:e=n||{},(e=s(this.defaults,e)).method?e.method=e.method.toLowerCase():this.defaults.method?e.method=this.defaults.method.toLowerCase():e.method="get";var t=e.transitional;void 0!==t&&c.assertOptions(t,{silentJSONParsing:l.transitional(l.boolean),forcedJSONParsing:l.transitional(l.boolean),clarifyTimeoutError:l.transitional(l.boolean)},!1);var r=[],a=!0;this.interceptors.request.forEach((function(n){"function"==typeof n.runWhen&&!1===n.runWhen(e)||(a=a&&n.synchronous,r.unshift(n.fulfilled,n.rejected))}));var o,p=[];if(this.interceptors.response.forEach((function(n){p.push(n.fulfilled,n.rejected)})),!a){var u=[i,void 0];for(Array.prototype.unshift.apply(u,r),u=u.concat(p),o=Promise.resolve(e);u.length;)o=o.then(u.shift(),u.shift());return o}for(var d=e;r.length;){var m=r.shift(),h=r.shift();try{d=m(d)}catch(n){h(n);break}}try{o=i(d)}catch(n){return Promise.reject(n)}for(;p.length;)o=o.then(p.shift(),p.shift());return o},p.prototype.getUri=function(n){return n=s(this.defaults,n),a(n.url,n.params,n.paramsSerializer).replace(/^\?/,"")},r.forEach(["delete","get","head","options"],(function(n){p.prototype[n]=function(e,t){return this.request(s(t||{},{method:n,url:e,data:(t||{}).data}))}})),r.forEach(["post","put","patch"],(function(n){p.prototype[n]=function(e,t,r){return this.request(s(r||{},{method:n,url:e,data:t}))}})),n.exports=p},function(n,e,t){"use strict";var r=t(5);function a(){this.handlers=[]}a.prototype.use=function(n,e,t){return this.handlers.push({fulfilled:n,rejected:e,synchronous:!!t&&t.synchronous,runWhen:t?t.runWhen:null}),this.handlers.length-1},a.prototype.eject=function(n){this.handlers[n]&&(this.handlers[n]=null)},a.prototype.forEach=function(n){r.forEach(this.handlers,(function(e){null!==e&&n(e)}))},n.exports=a},function(n,e,t){"use strict";var r=t(5),a=t(319),o=t(122),i=t(63),s=t(41);function c(n){if(n.cancelToken&&n.cancelToken.throwIfRequested(),n.signal&&n.signal.aborted)throw new s("canceled")}n.exports=function(n){return c(n),n.headers=n.headers||{},n.data=a.call(n,n.data,n.headers,n.transformRequest),n.headers=r.merge(n.headers.common||{},n.headers[n.method]||{},n.headers),r.forEach(["delete","get","head","post","put","patch","common"],(function(e){delete n.headers[e]})),(n.adapter||i.adapter)(n).then((function(e){return c(n),e.data=a.call(n,e.data,e.headers,n.transformResponse),e}),(function(e){return o(e)||(c(n),e&&e.response&&(e.response.data=a.call(n,e.response.data,e.response.headers,n.transformResponse))),Promise.reject(e)}))}},function(n,e,t){"use strict";var r=t(5),a=t(63);n.exports=function(n,e,t){var o=this||a;return r.forEach(t,(function(t){n=t.call(o,n,e)})),n}},function(n,e,t){"use strict";var r=t(5);n.exports=function(n,e){r.forEach(n,(function(t,r){r!==e&&r.toUpperCase()===e.toUpperCase()&&(n[e]=t,delete n[r])}))}},function(n,e,t){"use strict";var r=t(121);n.exports=function(n,e,t){var a=t.config.validateStatus;t.status&&a&&!a(t.status)?e(r("Request failed with status code "+t.status,t.config,null,t.request,t)):n(t)}},function(n,e,t){"use strict";var r=t(5);n.exports=r.isStandardBrowserEnv()?{write:function(n,e,t,a,o,i){var s=[];s.push(n+"="+encodeURIComponent(e)),r.isNumber(t)&&s.push("expires="+new Date(t).toGMTString()),r.isString(a)&&s.push("path="+a),r.isString(o)&&s.push("domain="+o),!0===i&&s.push("secure"),document.cookie=s.join("; ")},read:function(n){var e=document.cookie.match(new RegExp("(^|;\\s*)("+n+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove:function(n){this.write(n,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},function(n,e,t){"use strict";var r=t(324),a=t(325);n.exports=function(n,e){return n&&!r(e)?a(n,e):e}},function(n,e,t){"use strict";n.exports=function(n){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(n)}},function(n,e,t){"use strict";n.exports=function(n,e){return e?n.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):n}},function(n,e,t){"use strict";var r=t(5),a=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];n.exports=function(n){var e,t,o,i={};return n?(r.forEach(n.split("\n"),(function(n){if(o=n.indexOf(":"),e=r.trim(n.substr(0,o)).toLowerCase(),t=r.trim(n.substr(o+1)),e){if(i[e]&&a.indexOf(e)>=0)return;i[e]="set-cookie"===e?(i[e]?i[e]:[]).concat([t]):i[e]?i[e]+", "+t:t}})),i):i}},function(n,e,t){"use strict";var r=t(5);n.exports=r.isStandardBrowserEnv()?function(){var n,e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");function a(n){var r=n;return e&&(t.setAttribute("href",r),r=t.href),t.setAttribute("href",r),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:"/"===t.pathname.charAt(0)?t.pathname:"/"+t.pathname}}return n=a(window.location.href),function(e){var t=r.isString(e)?a(e):e;return t.protocol===n.protocol&&t.host===n.host}}():function(){return!0}},function(n,e,t){"use strict";var r=t(124).version,a={};["object","boolean","number","function","string","symbol"].forEach((function(n,e){a[n]=function(t){return typeof t===n||"a"+(e<1?"n ":" ")+n}}));var o={};a.transitional=function(n,e,t){function a(n,e){return"[Axios v"+r+"] Transitional option '"+n+"'"+e+(t?". "+t:"")}return function(t,r,i){if(!1===n)throw new Error(a(r," has been removed"+(e?" in "+e:"")));return e&&!o[r]&&(o[r]=!0,console.warn(a(r," has been deprecated since v"+e+" and will be removed in the near future"))),!n||n(t,r,i)}},n.exports={assertOptions:function(n,e,t){if("object"!=typeof n)throw new TypeError("options must be an object");for(var r=Object.keys(n),a=r.length;a-- >0;){var o=r[a],i=e[o];if(i){var s=n[o],c=void 0===s||i(s,o,n);if(!0!==c)throw new TypeError("option "+o+" must be "+c)}else if(!0!==t)throw Error("Unknown option "+o)}},validators:a}},function(n,e,t){"use strict";var r=t(41);function a(n){if("function"!=typeof n)throw new TypeError("executor must be a function.");var e;this.promise=new Promise((function(n){e=n}));var t=this;this.promise.then((function(n){if(t._listeners){var e,r=t._listeners.length;for(e=0;e<r;e++)t._listeners[e](n);t._listeners=null}})),this.promise.then=function(n){var e,r=new Promise((function(n){t.subscribe(n),e=n})).then(n);return r.cancel=function(){t.unsubscribe(e)},r},n((function(n){t.reason||(t.reason=new r(n),e(t.reason))}))}a.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},a.prototype.subscribe=function(n){this.reason?n(this.reason):this._listeners?this._listeners.push(n):this._listeners=[n]},a.prototype.unsubscribe=function(n){if(this._listeners){var e=this._listeners.indexOf(n);-1!==e&&this._listeners.splice(e,1)}},a.source=function(){var n;return{token:new a((function(e){n=e})),cancel:n}},n.exports=a},function(n,e,t){"use strict";n.exports=function(n){return function(e){return n.apply(null,e)}}},function(n,e,t){"use strict";var r=t(5);n.exports=function(n){return r.isObject(n)&&!0===n.isAxiosError}},function(n,e,t){},function(n,e,t){"use strict";t(125)},function(n,e,t){},function(n,e,t){var r;function a(n){function t(){if(t.enabled){var n=t,a=+new Date,o=a-(r||a);n.diff=o,n.prev=r,n.curr=a,r=a;for(var i=new Array(arguments.length),s=0;s<i.length;s++)i[s]=arguments[s];i[0]=e.coerce(i[0]),"string"!=typeof i[0]&&i.unshift("%O");var c=0;i[0]=i[0].replace(/%([a-zA-Z%])/g,(function(t,r){if("%%"===t)return t;c++;var a=e.formatters[r];if("function"==typeof a){var o=i[c];t=a.call(n,o),i.splice(c,1),c--}return t})),e.formatArgs.call(n,i);var l=t.log||e.log||console.log.bind(console);l.apply(n,i)}}return t.namespace=n,t.enabled=e.enabled(n),t.useColors=e.useColors(),t.color=function(n){var t,r=0;for(t in n)r=(r<<5)-r+n.charCodeAt(t),r|=0;return e.colors[Math.abs(r)%e.colors.length]}(n),"function"==typeof e.init&&e.init(t),t}(e=n.exports=a.debug=a.default=a).coerce=function(n){return n instanceof Error?n.stack||n.message:n},e.disable=function(){e.enable("")},e.enable=function(n){e.save(n),e.names=[],e.skips=[];for(var t=("string"==typeof n?n:"").split(/[\s,]+/),r=t.length,a=0;a<r;a++)t[a]&&("-"===(n=t[a].replace(/\*/g,".*?"))[0]?e.skips.push(new RegExp("^"+n.substr(1)+"$")):e.names.push(new RegExp("^"+n+"$")))},e.enabled=function(n){var t,r;for(t=0,r=e.skips.length;t<r;t++)if(e.skips[t].test(n))return!1;for(t=0,r=e.names.length;t<r;t++)if(e.names[t].test(n))return!0;return!1},e.humanize=t(336),e.names=[],e.skips=[],e.formatters={}},function(n,e){var t=1e3,r=6e4,a=60*r,o=24*a;function i(n,e,t){if(!(n<e))return n<1.5*e?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}n.exports=function(n,e){e=e||{};var s,c=typeof n;if("string"===c&&n.length>0)return function(n){if((n=String(n)).length>100)return;var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(!e)return;var i=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*i;case"days":case"day":case"d":return i*o;case"hours":case"hour":case"hrs":case"hr":case"h":return i*a;case"minutes":case"minute":case"mins":case"min":case"m":return i*r;case"seconds":case"second":case"secs":case"sec":case"s":return i*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return i;default:return}}(n);if("number"===c&&!1===isNaN(n))return e.long?i(s=n,o,"day")||i(s,a,"hour")||i(s,r,"minute")||i(s,t,"second")||s+" ms":function(n){if(n>=o)return Math.round(n/o)+"d";if(n>=a)return Math.round(n/a)+"h";if(n>=r)return Math.round(n/r)+"m";if(n>=t)return Math.round(n/t)+"s";return n+"ms"}(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))}},function(n,e,t){"use strict";t(127)},function(n,e,t){"use strict";t(128)},function(n,e,t){"use strict";t(129)},function(n,e,t){"use strict";t(130)},function(n,e,t){"use strict";t(131)},function(n,e,t){"use strict";t.r(e);var r=t(1);
/*!
  * vue-router v3.6.5
  * (c) 2022 Evan You
  * @license MIT
  */function a(n,e){for(var t in e)n[t]=e[t];return n}var o=/[!'()*]/g,i=function(n){return"%"+n.charCodeAt(0).toString(16)},s=/%2C/g,c=function(n){return encodeURIComponent(n).replace(o,i).replace(s,",")};function l(n){try{return decodeURIComponent(n)}catch(n){0}return n}var p=function(n){return null==n||"object"==typeof n?n:String(n)};function u(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=l(t.shift()),a=t.length>0?l(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function d(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return c(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(c(e)):r.push(c(e)+"="+c(n)))})),r.join("&")}return c(e)+"="+c(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var m=/\/?$/;function h(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=g(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:v(e,a),matched:n?b(n):[]};return t&&(i.redirectedFrom=v(t,a)),Object.freeze(i)}function g(n){if(Array.isArray(n))return n.map(g);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=g(n[t]);return e}return n}var f=h(null,{path:"/"});function b(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function v(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||d)(r)+a}function y(n,e,t){return e===f?n===e:!!e&&(n.path&&e.path?n.path.replace(m,"")===e.path.replace(m,"")&&(t||n.hash===e.hash&&x(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&x(n.query,e.query)&&x(n.params,e.params))))}function x(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?x(o,i):String(o)===String(i)}))}function w(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var k={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,i=e.data;i.routerView=!0;for(var s=o.$createElement,c=t.name,l=o.$route,p=o._routerViewCache||(o._routerViewCache={}),u=0,d=!1;o&&o._routerRoot!==o;){var m=o.$vnode?o.$vnode.data:{};m.routerView&&u++,m.keepAlive&&o._directInactive&&o._inactive&&(d=!0),o=o.$parent}if(i.routerViewDepth=u,d){var h=p[c],g=h&&h.component;return g?(h.configProps&&S(g,i,h.route,h.configProps),s(g,i,r)):s()}var f=l.matched[u],b=f&&f.components[c];if(!f||!b)return p[c]=null,s();p[c]={component:b},i.registerRouteInstance=function(n,e){var t=f.instances[c];(e&&t!==n||!e&&t===n)&&(f.instances[c]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){f.instances[c]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[c]&&(f.instances[c]=n.componentInstance),w(l)};var v=f.props&&f.props[c];return v&&(a(p[c],{route:l,configProps:v}),S(b,i,l,v)),s(b,i,r)}};function S(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=a({},o);var i=e.attrs=e.attrs||{};for(var s in o)n.props&&s in n.props||(i[s]=o[s],delete o[s])}}function C(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function j(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var A=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},T=q,E=I,P=function(n,e){return _(I(n,e),e)},D=_,z=N,B=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function I(n,e){for(var t,r=[],a=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=B.exec(n));){var c=t[0],l=t[1],p=t.index;if(i+=n.slice(o,p),o=p+c.length,l)i+=l[1];else{var u=n[o],d=t[2],m=t[3],h=t[4],g=t[5],f=t[6],b=t[7];i&&(r.push(i),i="");var v=null!=d&&null!=u&&u!==d,y="+"===f||"*"===f,x="?"===f||"*"===f,w=t[2]||s,k=h||g;r.push({name:m||a++,prefix:d||"",delimiter:w,optional:x,repeat:y,partial:v,asterisk:!!b,pattern:k?F(k):b?".*":"[^"+L(w)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function O(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function _(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",R(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?O:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,p=o[c.name];if(null==p){if(c.optional){c.partial&&(a+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(A(p)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var u=0;u<p.length;u++){if(l=i(p[u]),!t[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");a+=(0===u?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(p),!t[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');a+=c.prefix+l}}else a+=c}return a}}function L(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function F(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function M(n,e){return n.keys=e,n}function R(n){return n&&n.sensitive?"":"i"}function N(n,e,t){A(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=L(s);else{var c=L(s.prefix),l="(?:"+s.pattern+")";e.push(s),s.repeat&&(l+="(?:"+c+l+")*"),o+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var p=L(t.delimiter||"/"),u=o.slice(-p.length)===p;return r||(o=(u?o.slice(0,-p.length):o)+"(?:"+p+"(?=$))?"),o+=a?"$":r&&u?"":"(?="+p+"|$)",M(new RegExp("^"+o,R(t)),e)}function q(n,e,t){return A(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return M(n,e)}(n,e):A(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(q(n[a],e,t).source);return M(new RegExp("(?:"+r.join("|")+")",R(t)),e)}(n,e,t):function(n,e,t){return N(I(n,t),e,t)}(n,e,t)}T.parse=E,T.compile=P,T.tokensToFunction=D,T.tokensToRegExp=z;var U=Object.create(null);function H(n,e,t){e=e||{};try{var r=U[n]||(U[n]=T.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function $(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var i=(o=a({},n)).params;return i&&"object"==typeof i&&(o.params=a({},i)),o}if(!o.path&&o.params&&e){(o=a({},o))._normalized=!0;var s=a(a({},e.params),o.params);if(e.name)o.name=e.name,o.params=s;else if(e.matched.length){var c=e.matched[e.matched.length-1].path;o.path=H(c,s,e.path)}else 0;return o}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(o.path||""),d=e&&e.path||"/",m=l.path?C(l.path,d,t||o.append):d,h=function(n,e,t){void 0===e&&(e={});var r,a=t||u;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(p):p(i)}return r}(l.query,o.query,r&&r.options.parseQuery),g=o.hash||l.hash;return g&&"#"!==g.charAt(0)&&(g="#"+g),{_normalized:!0,path:m,query:h,hash:g}}var J,V=function(){},W={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),i=o.location,s=o.route,c=o.href,l={},p=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==p?"router-link-active":p,g=null==u?"router-link-exact-active":u,f=null==this.activeClass?d:this.activeClass,b=null==this.exactActiveClass?g:this.exactActiveClass,v=s.redirectedFrom?h(null,$(s.redirectedFrom),null,t):s;l[b]=y(r,v,this.exactPath),l[f]=this.exact||this.exactPath?l[b]:function(n,e){return 0===n.path.replace(m,"/").indexOf(e.path.replace(m,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,v);var x=l[b]?this.ariaCurrentValue:null,w=function(n){Q(n)&&(e.replace?t.replace(i,V):t.push(i,V))},k={click:Q};Array.isArray(this.event)?this.event.forEach((function(n){k[n]=w})):k[this.event]=w;var S={class:l},C=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:c,route:s,navigate:w,isActive:l[f],isExactActive:l[b]});if(C){if(1===C.length)return C[0];if(C.length>1||!C.length)return 0===C.length?n():n("span",{},C)}if("a"===this.tag)S.on=k,S.attrs={href:c,"aria-current":x};else{var j=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(j){j.isStatic=!1;var A=j.data=a({},j.data);for(var T in A.on=A.on||{},A.on){var E=A.on[T];T in k&&(A.on[T]=Array.isArray(E)?E:[E])}for(var P in k)P in A.on?A.on[P].push(k[P]):A.on[P]=w;var D=j.data.attrs=a({},j.data.attrs);D.href=c,D["aria-current"]=x}else S.on=k}return n(this.tag,S,this.$slots.default)}};function Q(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var K="undefined"!=typeof window;function G(n,e,t,r,a){var o=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var s=a.path,c=a.name;0;var l=a.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return j(e.path+"/"+n)}(s,o,l.strict);"boolean"==typeof a.caseSensitive&&(l.sensitive=a.caseSensitive);var u={path:p,regex:X(p,l),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:c,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?j(i+"/"+a.path):void 0;n(e,t,r,a,u,o)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==a.alias)for(var d=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<d.length;++m){0;var h={path:d[m],children:a.children};n(e,t,r,h,o,u.path||"/")}c&&(r[c]||(r[c]=u))}(o,i,s,n,a)}));for(var c=0,l=o.length;c<l;c++)"*"===o[c]&&(o.push(o.splice(c,1)[0]),l--,c--);return{pathList:o,pathMap:i,nameMap:s}}function X(n,e){return T(n,[],e)}function Z(n,e){var t=G(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function i(n,t,i){var s=$(n,t,!1,e),l=s.name;if(l){var p=o[l];if(!p)return c(null,s);var u=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&u.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=H(p.path,s.params),c(p,s,i)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var h=r[m],g=a[h];if(Y(g.regex,s.path,s.params))return c(g,s,i)}}return c(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(h(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return c(null,t);var s=a,l=s.name,p=s.path,u=t.query,d=t.hash,m=t.params;if(u=s.hasOwnProperty("query")?s.query:u,d=s.hasOwnProperty("hash")?s.hash:d,m=s.hasOwnProperty("params")?s.params:m,l){o[l];return i({_normalized:!0,name:l,query:u,hash:d,params:m},void 0,t)}if(p){var g=function(n,e){return C(n,e.parent?e.parent.path:"/",!0)}(p,n);return i({_normalized:!0,path:H(g,m),query:u,hash:d},void 0,t)}return c(null,t)}function c(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:H(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,c(o,e)}return c(null,e)}(0,t,n.matchAs):h(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;G([e||n],r,a,o,t),t&&t.alias.length&&G(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,o,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){G(n,r,a,o)}}}function Y(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?l(r[a]):r[a])}return!0}var nn=K&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function rn(){return tn}function an(n){return tn=n}var on=Object.create(null);function sn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=a({},window.history.state);return t.key=rn(),window.history.replaceState(t,"",e),window.addEventListener("popstate",pn),function(){window.removeEventListener("popstate",pn)}}function cn(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=rn();if(n)return on[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){gn(n,o)})).catch((function(n){0})):gn(i,o))}))}}function ln(){var n=rn();n&&(on[n]={x:window.pageXOffset,y:window.pageYOffset})}function pn(n){ln(),n.state&&n.state.key&&an(n.state.key)}function un(n){return mn(n.x)||mn(n.y)}function dn(n){return{x:mn(n.x)?n.x:window.pageXOffset,y:mn(n.y)?n.y:window.pageYOffset}}function mn(n){return"number"==typeof n}var hn=/^#\d/;function gn(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=hn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:mn((t=o).x)?t.x:0,y:mn(t.y)?t.y:0})}else un(n)&&(e=dn(n))}else r&&un(n)&&(e=dn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var fn,bn=K&&((-1===(fn=window.navigator.userAgent).indexOf("Android 2.")&&-1===fn.indexOf("Android 4.0")||-1===fn.indexOf("Mobile Safari")||-1!==fn.indexOf("Chrome")||-1!==fn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function vn(n,e){ln();var t=window.history;try{if(e){var r=a({},t.state);r.key=rn(),t.replaceState(r,"",n)}else t.pushState({key:an(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function yn(n){vn(n,!0)}var xn={redirected:2,aborted:4,cancelled:8,duplicated:16};function wn(n,e){return Sn(n,e,xn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Cn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function kn(n,e){return Sn(n,e,xn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Sn(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var Cn=["params","query","hash"];function jn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function An(n,e){return jn(n)&&n._isRouter&&(null==e||n.type===e)}function Tn(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}function En(n){return function(e,t,r){var a=!1,o=0,i=null;Pn(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var c,l=Bn((function(e){var a;((a=e).__esModule||zn&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:J.extend(e),t.components[s]=e,--o<=0&&r()})),p=Bn((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=jn(n)?n:new Error(e),r(i))}));try{c=n(l,p)}catch(n){p(n)}if(c)if("function"==typeof c.then)c.then(l,p);else{var u=c.component;u&&"function"==typeof u.then&&u.then(l,p)}}})),a||r()}}function Pn(n,e){return Dn(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Dn(n){return Array.prototype.concat.apply([],n)}var zn="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Bn(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var In=function(n,e){this.router=n,this.base=function(n){if(!n)if(K){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=f,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function On(n,e,t,r){var a=Pn(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=J.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return Dn(r?a.reverse():a)}function _n(n,e){if(e)return function(){return n.apply(e,arguments)}}In.prototype.listen=function(n){this.cb=n},In.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},In.prototype.onError=function(n){this.errorCbs.push(n)},In.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(An(n,xn.redirected)&&o===f||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},In.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o=function(n){!An(n)&&jn(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},i=n.matched.length-1,s=a.matched.length-1;if(y(n,a)&&i===s&&n.matched[i]===a.matched[s])return this.ensureURL(),n.hash&&cn(this.router,a,n,!1),o(function(n,e){var t=Sn(n,e,xn.duplicated,'Avoided redundant navigation to current location: "'+n.fullPath+'".');return t.name="NavigationDuplicated",t}(a,n));var c=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),l=c.updated,p=c.deactivated,u=c.activated,d=[].concat(function(n){return On(n,"beforeRouteLeave",_n,!0)}(p),this.router.beforeHooks,function(n){return On(n,"beforeRouteUpdate",_n)}(l),u.map((function(n){return n.beforeEnter})),En(u)),m=function(e,t){if(r.pending!==n)return o(kn(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),o(function(n,e){return Sn(n,e,xn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):jn(e)?(r.ensureURL(!0),o(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(o(wn(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){o(n)}};Tn(d,m,(function(){Tn(function(n){return On(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(u).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return o(kn(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){w(n)}))}))}))},In.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},In.prototype.setupListeners=function(){},In.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=f,this.pending=null};var Ln=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Fn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=bn&&t;r&&this.listeners.push(sn());var a=function(){var t=n.current,a=Fn(n.base);n.current===f&&a===n._startLocation||n.transitionTo(a,(function(n){r&&cn(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){vn(j(r.base+n.fullPath)),cn(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){yn(j(r.base+n.fullPath)),cn(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Fn(this.base)!==this.current.fullPath){var e=j(this.base+this.current.fullPath);n?vn(e):yn(e)}},e.prototype.getCurrentLocation=function(){return Fn(this.base)},e}(In);function Fn(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(j(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Mn=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Fn(n);if(!/^\/#/.test(e))return window.location.replace(j(n+"/#"+e)),!0}(this.base)||Rn()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=bn&&e;t&&this.listeners.push(sn());var r=function(){var e=n.current;Rn()&&n.transitionTo(Nn(),(function(r){t&&cn(n.router,r,e,!0),bn||Hn(r.fullPath)}))},a=bn?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Un(n.fullPath),cn(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Hn(n.fullPath),cn(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Nn()!==e&&(n?Un(e):Hn(e))},e.prototype.getCurrentLocation=function(){return Nn()},e}(In);function Rn(){var n=Nn();return"/"===n.charAt(0)||(Hn("/"+n),!1)}function Nn(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function qn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Un(n){bn?vn(qn(n)):window.location.hash=n}function Hn(n){bn?yn(qn(n)):window.location.replace(qn(n))}var $n=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){An(n,xn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(In),Jn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Z(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!bn&&!1!==n.fallback,this.fallback&&(e="hash"),K||(e="abstract"),this.mode=e,e){case"history":this.history=new Ln(this,n.base);break;case"hash":this.history=new Mn(this,n.base,this.fallback);break;case"abstract":this.history=new $n(this,n.base);break;default:0}},Vn={currentRoute:{configurable:!0}};Jn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Vn.currentRoute.get=function(){return this.history&&this.history.current},Jn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ln||t instanceof Mn){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;bn&&a&&"fullPath"in n&&cn(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Jn.prototype.beforeEach=function(n){return Qn(this.beforeHooks,n)},Jn.prototype.beforeResolve=function(n){return Qn(this.resolveHooks,n)},Jn.prototype.afterEach=function(n){return Qn(this.afterHooks,n)},Jn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Jn.prototype.onError=function(n){this.history.onError(n)},Jn.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Jn.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Jn.prototype.go=function(n){this.history.go(n)},Jn.prototype.back=function(){this.go(-1)},Jn.prototype.forward=function(){this.go(1)},Jn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Jn.prototype.resolve=function(n,e,t){var r=$(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?j(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},Jn.prototype.getRoutes=function(){return this.matcher.getRoutes()},Jn.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==f&&this.history.transitionTo(this.history.getCurrentLocation())},Jn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==f&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Jn.prototype,Vn);var Wn=Jn;function Qn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Jn.install=function n(e){if(!n.installed||J!==e){n.installed=!0,J=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",k),e.component("RouterLink",W);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Jn.version="3.6.5",Jn.isNavigationFailure=An,Jn.NavigationFailureType=xn,Jn.START_LOCATION=f,K&&window.Vue&&window.Vue.use(Jn);t(45);var Kn=t(0),Gn=t(132),Xn=t.n(Gn),Zn=t(133),Yn=t.n(Zn),ne={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${Yn()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=te(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=re(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Xn()([{name:"description",content:this.$description}],n,this.siteMeta,ae)},updateCanonicalLink(){ee(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",te(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){re(null,this.currentMetaTags),ee()}};function ee(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function te(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function re(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ae(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var oe=t(134),ie={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(oe)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],i=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(s&&c!==decodeURIComponent(o.hash)){const t=o;if(a===r)for(let t=n+1;t<e.length;t++)if(c===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},se=(t(284),Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n}),ce=function(n){return"IMG"===n.tagName},le=function(n){return n&&1===n.nodeType},pe=function(n){return".svg"===(n.currentSrc||n.src).substr(-4).toLowerCase()},ue=function(n){try{return Array.isArray(n)?n.filter(ce):function(n){return NodeList.prototype.isPrototypeOf(n)}(n)?[].slice.call(n).filter(ce):le(n)?[n].filter(ce):"string"==typeof n?[].slice.call(document.querySelectorAll(n)).filter(ce):[]}catch(n){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},de=function(n){var e=document.createElement("div");return e.classList.add("medium-zoom-overlay"),e.style.background=n,e},me=function(n){var e=n.getBoundingClientRect(),t=e.top,r=e.left,a=e.width,o=e.height,i=n.cloneNode(),s=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,c=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return i.removeAttribute("id"),i.style.position="absolute",i.style.top=t+s+"px",i.style.left=r+c+"px",i.style.width=a+"px",i.style.height=o+"px",i.style.transform="",i},he=function(n,e){var t=se({bubbles:!1,cancelable:!1,detail:void 0},e);if("function"==typeof window.CustomEvent)return new CustomEvent(n,t);var r=document.createEvent("CustomEvent");return r.initCustomEvent(n,t.bubbles,t.cancelable,t.detail),r};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var ge=function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=window.Promise||function(n){function e(){}n(e,e)},a=function(n){var e=n.target;e!==j?-1!==y.indexOf(e)&&g({target:e}):h()},o=function(){if(!w&&C.original){var n=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(k-n)>S.scrollOffset&&setTimeout(h,150)}},i=function(n){var e=n.key||n.keyCode;"Escape"!==e&&"Esc"!==e&&27!==e||h()},s=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n;if(n.background&&(j.style.background=n.background),n.container&&n.container instanceof Object&&(e.container=se({},S.container,n.container)),n.template){var t=le(n.template)?n.template:document.querySelector(n.template);e.template=t}return S=se({},S,e),y.forEach((function(n){n.dispatchEvent(he("medium-zoom:update",{detail:{zoom:A}}))})),A},c=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(se({},S,e))},l=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];var r=e.reduce((function(n,e){return[].concat(n,ue(e))}),[]);return r.filter((function(n){return-1===y.indexOf(n)})).forEach((function(n){y.push(n),n.classList.add("medium-zoom-image")})),x.forEach((function(n){var e=n.type,t=n.listener,a=n.options;r.forEach((function(n){n.addEventListener(e,t,a)}))})),A},p=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];C.zoomed&&h();var r=e.length>0?e.reduce((function(n,e){return[].concat(n,ue(e))}),[]):y;return r.forEach((function(n){n.classList.remove("medium-zoom-image"),n.dispatchEvent(he("medium-zoom:detach",{detail:{zoom:A}}))})),y=y.filter((function(n){return-1===r.indexOf(n)})),A},u=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return y.forEach((function(r){r.addEventListener("medium-zoom:"+n,e,t)})),x.push({type:"medium-zoom:"+n,listener:e,options:t}),A},d=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return y.forEach((function(r){r.removeEventListener("medium-zoom:"+n,e,t)})),x=x.filter((function(t){return!(t.type==="medium-zoom:"+n&&t.listener.toString()===e.toString())})),A},m=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target,t=function(){var n={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},e=void 0,t=void 0;if(S.container)if(S.container instanceof Object)e=(n=se({},n,S.container)).width-n.left-n.right-2*S.margin,t=n.height-n.top-n.bottom-2*S.margin;else{var r=(le(S.container)?S.container:document.querySelector(S.container)).getBoundingClientRect(),a=r.width,o=r.height,i=r.left,s=r.top;n=se({},n,{width:a,height:o,left:i,top:s})}e=e||n.width-2*S.margin,t=t||n.height-2*S.margin;var c=C.zoomedHd||C.original,l=pe(c)?e:c.naturalWidth||e,p=pe(c)?t:c.naturalHeight||t,u=c.getBoundingClientRect(),d=u.top,m=u.left,h=u.width,g=u.height,f=Math.min(Math.max(h,l),e)/h,b=Math.min(Math.max(g,p),t)/g,v=Math.min(f,b),y="scale("+v+") translate3d("+((e-h)/2-m+S.margin+n.left)/v+"px, "+((t-g)/2-d+S.margin+n.top)/v+"px, 0)";C.zoomed.style.transform=y,C.zoomedHd&&(C.zoomedHd.style.transform=y)};return new r((function(n){if(e&&-1===y.indexOf(e))n(A);else{if(C.zoomed)n(A);else{if(e)C.original=e;else{if(!(y.length>0))return void n(A);var r=y;C.original=r[0]}if(C.original.dispatchEvent(he("medium-zoom:open",{detail:{zoom:A}})),k=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,w=!0,C.zoomed=me(C.original),document.body.appendChild(j),S.template){var a=le(S.template)?S.template:document.querySelector(S.template);C.template=document.createElement("div"),C.template.appendChild(a.content.cloneNode(!0)),document.body.appendChild(C.template)}if(C.original.parentElement&&"PICTURE"===C.original.parentElement.tagName&&C.original.currentSrc&&(C.zoomed.src=C.original.currentSrc),document.body.appendChild(C.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),C.original.classList.add("medium-zoom-image--hidden"),C.zoomed.classList.add("medium-zoom-image--opened"),C.zoomed.addEventListener("click",h),C.zoomed.addEventListener("transitionend",(function e(){w=!1,C.zoomed.removeEventListener("transitionend",e),C.original.dispatchEvent(he("medium-zoom:opened",{detail:{zoom:A}})),n(A)})),C.original.getAttribute("data-zoom-src")){C.zoomedHd=C.zoomed.cloneNode(),C.zoomedHd.removeAttribute("srcset"),C.zoomedHd.removeAttribute("sizes"),C.zoomedHd.removeAttribute("loading"),C.zoomedHd.src=C.zoomed.getAttribute("data-zoom-src"),C.zoomedHd.onerror=function(){clearInterval(o),console.warn("Unable to reach the zoom image target "+C.zoomedHd.src),C.zoomedHd=null,t()};var o=setInterval((function(){C.zoomedHd.complete&&(clearInterval(o),C.zoomedHd.classList.add("medium-zoom-image--opened"),C.zoomedHd.addEventListener("click",h),document.body.appendChild(C.zoomedHd),t())}),10)}else if(C.original.hasAttribute("srcset")){C.zoomedHd=C.zoomed.cloneNode(),C.zoomedHd.removeAttribute("sizes"),C.zoomedHd.removeAttribute("loading");var i=C.zoomedHd.addEventListener("load",(function(){C.zoomedHd.removeEventListener("load",i),C.zoomedHd.classList.add("medium-zoom-image--opened"),C.zoomedHd.addEventListener("click",h),document.body.appendChild(C.zoomedHd),t()}))}else t()}}}))},h=function(){return new r((function(n){if(!w&&C.original){w=!0,document.body.classList.remove("medium-zoom--opened"),C.zoomed.style.transform="",C.zoomedHd&&(C.zoomedHd.style.transform=""),C.template&&(C.template.style.transition="opacity 150ms",C.template.style.opacity=0),C.original.dispatchEvent(he("medium-zoom:close",{detail:{zoom:A}})),C.zoomed.addEventListener("transitionend",(function e(){C.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(C.zoomed),C.zoomedHd&&document.body.removeChild(C.zoomedHd),document.body.removeChild(j),C.zoomed.classList.remove("medium-zoom-image--opened"),C.template&&document.body.removeChild(C.template),w=!1,C.zoomed.removeEventListener("transitionend",e),C.original.dispatchEvent(he("medium-zoom:closed",{detail:{zoom:A}})),C.original=null,C.zoomed=null,C.zoomedHd=null,C.template=null,n(A)}))}else n(A)}))},g=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target;return C.original?h():m({target:e})},f=function(){return S},b=function(){return y},v=function(){return C.original},y=[],x=[],w=!1,k=0,S=t,C={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?S=e:(e||"string"==typeof e)&&l(e),S=se({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},S);var j=de(S.background);document.addEventListener("click",a),document.addEventListener("keyup",i),document.addEventListener("scroll",o),window.addEventListener("resize",h);var A={open:m,close:h,toggle:g,update:s,clone:c,attach:l,detach:p,on:u,off:d,getOptions:f,getImages:b,getZoomedImage:v};return A},fe={data:()=>({zoom:null}),mounted(){this.updateZoom()},updated(){this.updateZoom()},methods:{updateZoom(){setTimeout(()=>{this.zoom&&this.zoom.detach(),this.zoom=ge(".theme-reco-content :not(a) > img",{})},1e3)}}},be=t(42),ve=t.n(be),ye={mounted(){ve.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||r.a.component(n.name)||ve.a.start(),t()}),this.$router.afterEach(()=>{ve.a.done(),this.isSidebarOpen=!1})}},xe=t(135),we=t.n(xe),ke=(t(285),{mounted(){we.a.polyfill()}}),Se={props:{parent:Object,code:String,options:{align:String,color:String,backgroundTransition:Boolean,backgroundColor:String,successText:String,staticIcon:Boolean}},data:()=>({success:!1,originalBackground:null,originalTransition:null}),computed:{alignStyle(){let n={};return n[this.options.align]="7.5px",n},iconClass(){return this.options.staticIcon?"":"hover"}},mounted(){this.originalTransition=this.parent.style.transition,this.originalBackground=this.parent.style.background},beforeDestroy(){this.parent.style.transition=this.originalTransition,this.parent.style.background=this.originalBackground},methods:{hexToRgb(n){let e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n);return e?{r:parseInt(e[1],16),g:parseInt(e[2],16),b:parseInt(e[3],16)}:null},copyToClipboard(n){if(navigator.clipboard)navigator.clipboard.writeText(this.code).then(()=>{this.setSuccessTransitions()},()=>{});else{let n=document.createElement("textarea");document.body.appendChild(n),n.value=this.code,n.select(),document.execCommand("Copy"),n.remove(),this.setSuccessTransitions()}},setSuccessTransitions(){if(clearTimeout(this.successTimeout),this.options.backgroundTransition){this.parent.style.transition="background 350ms";let n=this.hexToRgb(this.options.backgroundColor);this.parent.style.background=`rgba(${n.r}, ${n.g}, ${n.b}, 0.1)`}this.success=!0,this.successTimeout=setTimeout(()=>{this.options.backgroundTransition&&(this.parent.style.background=this.originalBackground,this.parent.style.transition=this.originalTransition),this.success=!1},500)}}},Ce=(t(286),t(2)),je=Object(Ce.a)(Se,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"code-copy"},[e("svg",{class:n.iconClass,style:n.alignStyle,attrs:{xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",viewBox:"0 0 24 24"},on:{click:n.copyToClipboard}},[e("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),n._v(" "),e("path",{attrs:{fill:n.options.color,d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"}})]),n._v(" "),e("span",{class:n.success?"success":"",style:n.alignStyle},[n._v("\n        "+n._s(n.options.successText)+"\n    ")])])}),[],!1,null,"49140617",null).exports,Ae=(t(287),{updated(){this.update()},methods:{update(){setTimeout(()=>{document.querySelectorAll('div[class*="language-"] pre').forEach(n=>{if(n.classList.contains("code-copy-added"))return;let e=new(r.a.extend(je));e.options={align:"bottom",color:"#27b1ff",backgroundTransition:!0,backgroundColor:"#0075b8",successText:"Copied!",staticIcon:!1},e.code=n.innerText,e.parent=n,e.$mount(),n.classList.add("code-copy-added"),n.appendChild(e.$el)})},100)}}}),Te=t(146),Ee={noCopy:!1,noSelect:!1,disabled:!1,minLength:100,authorName:""},Pe=[ne,ie,fe,ye,ke,Ae,{data:()=>({isElement:!1}),created(){this.onCopy=n=>{const e=getSelection().getRangeAt(0);if(String(e).length<this.minLength)return;if(n.preventDefault(),this.noCopy)return;const t=document.createElement("div");t.appendChild(getSelection().getRangeAt(0).cloneContents());const a=this.$lang,o=new r.a({render:n=>n(Te.default,{props:{html:t.innerHTML,lang:a}})}).$mount(),{innerHTML:i,innerText:s}=o.$el;n.clipboardData?(n.clipboardData.setData("text/html",i),n.clipboardData.setData("text/plain",s)):window.clipboardData&&window.clipboardData.setData("text",s)}},watch:{isElement(n){if(!n)return;let{copyright:e=!Ee.disabled}=this.$frontmatter;if(!e)return;"object"!=typeof e&&(e={});const t=e.noSelect||Ee.noSelect;this.minLength=e.minLength||Ee.minLength,this.noCopy=e.noCopy||Ee.noCopy,t?this.$el.style.userSelect="none":this.$el.addEventListener("copy",this.onCopy)}},updated(){this.isElement="#comment"!==this.$el.nodeName},beforeDestory(){this.$el.removeEventListener("copy",this.onCopy)}}],De={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return Object(Kn.i)("layout",n),r.a.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ze=Object(Ce.a)(De,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;Object(Kn.g)(ze,"mixins",Pe);const Be=[{name:"v-6885a764",path:"/other/project.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Projects","v-6885a764").then(t)}},{name:"v-27bdaeaa",path:"/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-27bdaeaa").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-2e6c285b",path:"/about/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-2e6c285b").then(t)}},{path:"/about/index.html",redirect:"/about/"},{name:"v-7e3794d9",path:"/views/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-7e3794d9").then(t)}},{path:"/views/index.html",redirect:"/views/"},{name:"v-59e792f7",path:"/views/backend/ArrayList.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-59e792f7").then(t)}},{name:"v-a03de038",path:"/other/friends.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-a03de038").then(t)}},{name:"v-59596aa5",path:"/views/backend/CountDownLatch.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-59596aa5").then(t)}},{name:"v-0a438352",path:"/views/backend/HashMap.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-0a438352").then(t)}},{name:"v-8b8c23d2",path:"/views/backend/JUC.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-8b8c23d2").then(t)}},{name:"v-229bb1b7",path:"/views/backend/EasyExcel.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-229bb1b7").then(t)}},{name:"v-b07ca2b2",path:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-b07ca2b2").then(t)}},{path:"/views/backend/OOM分类及排查.html",redirect:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html"},{path:"/views/backend/OOM分类及排查.html",redirect:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html"},{name:"v-93974ed2",path:"/views/backend/ReentrantLock.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-93974ed2").then(t)}},{name:"v-6ebf631e",path:"/views/backend/SPI_JdkDubboSpring.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-6ebf631e").then(t)}},{name:"v-0b69064b",path:"/views/backend/SchedulingConfigurer.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-0b69064b").then(t)}},{name:"v-9ebad7d2",path:"/views/backend/SSH.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-9ebad7d2").then(t)}},{name:"v-74fedb77",path:"/views/backend/ThreadLocal.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-74fedb77").then(t)}},{name:"v-3c7afeb6",path:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-3c7afeb6").then(t)}},{path:"/views/backend/Spring的IOC源码以及流程分析.html",redirect:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html"},{path:"/views/backend/Spring的IOC源码以及流程分析.html",redirect:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html"},{name:"v-1c8f87f8",path:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-1c8f87f8").then(t)}},{path:"/views/backend/API网关概述.html",redirect:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html"},{path:"/views/backend/API网关概述.html",redirect:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html"},{name:"v-a3d48a82",path:"/views/backend/ThreadPool.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-a3d48a82").then(t)}},{name:"v-6dc818d2",path:"/views/backend/ThreadPool2.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-6dc818d2").then(t)}},{name:"v-cdecc45e",path:"/views/backend/ThreadTopCPU.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-cdecc45e").then(t)}},{name:"v-8cb01f92",path:"/views/backend/annotationLog.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-8cb01f92").then(t)}},{name:"v-196b8f52",path:"/views/backend/itext.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-196b8f52").then(t)}},{name:"v-989d2c6a",path:"/views/backend/docker.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-989d2c6a").then(t)}},{name:"v-04d0dd31",path:"/views/backend/javaLock.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-04d0dd31").then(t)}},{name:"v-1ba7191d",path:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-1ba7191d").then(t)}},{path:"/views/backend/java_io模型.html",redirect:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html"},{path:"/views/backend/java_io模型.html",redirect:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html"},{name:"v-6bf3fa77",path:"/views/backend/jvm.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-6bf3fa77").then(t)}},{name:"v-2ed49eb7",path:"/views/backend/jwt.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-2ed49eb7").then(t)}},{name:"v-90af05e8",path:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-90af05e8").then(t)}},{path:"/views/backend/mybatis一二级缓存.html",redirect:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html"},{path:"/views/backend/mybatis一二级缓存.html",redirect:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html"},{name:"v-73fde4d7",path:"/views/backend/mysql_explain.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-73fde4d7").then(t)}},{name:"v-3e9083fd",path:"/views/backend/mini-ioc.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-3e9083fd").then(t)}},{name:"v-42002a52",path:"/views/backend/poi.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-42002a52").then(t)}},{name:"v-f59ecb92",path:"/views/backend/rabbitmq001.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-f59ecb92").then(t)}},{name:"v-77367395",path:"/views/backend/quartz.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-77367395").then(t)}},{name:"v-24839ad2",path:"/views/backend/rabbitmq002.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-24839ad2").then(t)}},{name:"v-6dd97e97",path:"/views/backend/redis01.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-6dd97e97").then(t)}},{name:"v-f711c112",path:"/views/backend/redis02.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-f711c112").then(t)}},{name:"v-1e51bcb2",path:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-1e51bcb2").then(t)}},{path:"/views/backend/redis使用场景.html",redirect:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"},{path:"/views/backend/redis使用场景.html",redirect:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html"},{name:"v-2b4237af",path:"/views/backend/spring-security-01.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-2b4237af").then(t)}},{name:"v-345c456d",path:"/views/backend/spring-security-02.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-345c456d").then(t)}},{name:"v-55af23a5",path:"/views/backend/spring-source-01.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-55af23a5").then(t)}},{name:"v-a2fc25ba",path:"/views/backend/spring-source-02.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-a2fc25ba").then(t)}},{name:"v-0754b6a1",path:"/views/backend/spring-source-03.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-0754b6a1").then(t)}},{name:"v-8e0b6cc6",path:"/views/backend/spring-source-05.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-8e0b6cc6").then(t)}},{name:"v-6027801f",path:"/views/backend/spring-source-04.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-6027801f").then(t)}},{name:"v-11cd131b",path:"/views/backend/spring-source-06.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-11cd131b").then(t)}},{name:"v-65a6b7f7",path:"/views/backend/spring_application_json.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-65a6b7f7").then(t)}},{name:"v-24ae108a",path:"/views/backend/swagger2.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-24ae108a").then(t)}},{name:"v-3456e51e",path:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-3456e51e").then(t)}},{path:"/views/backend/springboot配置文件加载顺序.html",redirect:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html"},{path:"/views/backend/springboot配置文件加载顺序.html",redirect:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html"},{name:"v-d12af5d4",path:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-d12af5d4").then(t)}},{path:"/views/backend/zk选举和一致性.html",redirect:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html"},{path:"/views/backend/zk选举和一致性.html",redirect:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html"},{name:"v-3c54cc77",path:"/views/backend/thread.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-3c54cc77").then(t)}},{name:"v-5cb8f20a",path:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-5cb8f20a").then(t)}},{path:"/views/backend/分布式系统概述.html",redirect:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html"},{path:"/views/backend/分布式系统概述.html",redirect:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html"},{name:"v-1bebd69a",path:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-1bebd69a").then(t)}},{path:"/views/backend/动态代理和静态代理区别.html",redirect:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html"},{path:"/views/backend/动态代理和静态代理区别.html",redirect:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html"},{name:"v-0eb0312f",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-0eb0312f").then(t)}},{path:"/views/backend/单元测试1.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html"},{path:"/views/backend/单元测试1.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html"},{name:"v-1e6887d2",path:"/views/backend/zookeeper.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-1e6887d2").then(t)}},{name:"v-6a4aab62",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-6a4aab62").then(t)}},{path:"/views/backend/单元测试2.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html"},{path:"/views/backend/单元测试2.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html"},{name:"v-65899d47",path:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-65899d47").then(t)}},{path:"/views/backend/超时取消分析.html",redirect:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html"},{path:"/views/backend/超时取消分析.html",redirect:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html"},{name:"v-f1f5b922",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-f1f5b922").then(t)}},{path:"/views/backend/单元测试3.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html"},{path:"/views/backend/单元测试3.html",redirect:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html"},{name:"v-5d97d573",path:"/views/essay/20190928.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-5d97d573").then(t)}},{name:"v-5dec17bf",path:"/views/essay/20191109.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-5dec17bf").then(t)}},{name:"v-bed2e2f2",path:"/views/essay/20191116.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-bed2e2f2").then(t)}},{name:"v-25eb7c17",path:"/views/essay/20191130.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-25eb7c17").then(t)}},{name:"v-09c6eb57",path:"/views/essay/20200227.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-09c6eb57").then(t)}},{name:"v-57f1379d",path:"/views/essay/20200301.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-57f1379d").then(t)}},{name:"v-1cf9f311",path:"/views/essay/20200703.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-1cf9f311").then(t)}},{name:"v-6b8bff0f",path:"/views/essay/20200715.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-6b8bff0f").then(t)}},{name:"v-56da6351",path:"/views/essay/20200813.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-56da6351").then(t)}},{name:"v-33ecb7b6",path:"/views/essay/20201012.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-33ecb7b6").then(t)}},{name:"v-3274a2d6",path:"/views/essay/20201119.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-3274a2d6").then(t)}},{name:"v-b517ba06",path:"/views/frontend/TCP&UDP.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-b517ba06").then(t)}},{name:"v-3419df1d",path:"/views/frontend/js-json.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-3419df1d").then(t)}},{name:"v-28ad82bd",path:"/views/frontend/reco-info.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-28ad82bd").then(t)}},{name:"v-fd18a65e",path:"/views/frontend/viaStart.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-fd18a65e").then(t)}},{name:"v-209f2ade",path:"/views/frontend/vue-demo.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-209f2ade").then(t)}},{name:"v-193cdd9e",path:"/views/frontend/vuepress-plugin-boxx.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-193cdd9e").then(t)}},{name:"v-21bc8b46",path:"/views/qaq/sum_db_001.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-21bc8b46").then(t)}},{name:"v-7ad83f1b",path:"/views/qaq/sum_fe_001.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-7ad83f1b").then(t)}},{name:"v-59d18056",path:"/views/qaq/sum_java_001.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-59d18056").then(t)}},{name:"v-5cfc5853",path:"/views/qaq/sum_java_002.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-5cfc5853").then(t)}},{name:"v-10c74a0d",path:"/views/qaq/sum_ms_001.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-10c74a0d").then(t)}},{name:"v-3b409fbd",path:"/views/qaq/sum_spring_002.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-3b409fbd").then(t)}},{name:"v-0727fa02",path:"/views/qaq/sum_spring_001.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-0727fa02").then(t)}},{name:"v-7a153c7b",path:"/views/qaq/sum_spring_003.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-7a153c7b").then(t)}},{name:"v-b3ebfa12",path:"/views/specification/ali.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-b3ebfa12").then(t)}},{name:"v-b9441912",path:"/views/specification/git.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-b9441912").then(t)}},{name:"v-309fb177",path:"/views/specification/guide.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-309fb177").then(t)}},{name:"v-2830159a",path:"/views/specification/javaNamingConvention.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-2830159a").then(t)}},{name:"v-5d6482c8",path:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-5d6482c8").then(t)}},{path:"/views/specification/k8s基本命令与pod管理.html",redirect:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html"},{path:"/views/specification/k8s基本命令与pod管理.html",redirect:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html"},{name:"v-516caef5",path:"/views/specification/wildcard.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-516caef5").then(t)}},{name:"v-90c76f52",path:"/views/specification/linux01.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-90c76f52").then(t)}},{name:"v-660e1712",path:"/views/specification/linux02.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-660e1712").then(t)}},{name:"v-1f63dd63",path:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-1f63dd63").then(t)}},{path:"/views/specification/提交规范.html",redirect:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html"},{path:"/views/specification/提交规范.html",redirect:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html"},{name:"v-0008eb77",path:"/views/specification/objectModel.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-0008eb77").then(t)}},{name:"v-4789f531",path:"/views/frontend/EChartsStudy.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-4789f531").then(t)}},{name:"v-7d39c359",path:"/views/qaq/sum_fe_002.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-7d39c359").then(t)}},{name:"v-011bc3d7",path:"/views/essay/20211216.html",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-011bc3d7").then(t)}},{name:"v-b1564aac",path:"/tag/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tags","v-b1564aac").then(t)},meta:{pid:"tags",id:"tags"}},{path:"/tag/index.html",redirect:"/tag/"},{name:"v-ef9325c4",path:"/categories/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("FrontmatterKey","v-ef9325c4").then(t)},meta:{pid:"categories",id:"categories"}},{path:"/categories/index.html",redirect:"/categories/"},{name:"v-6319eb4e",path:"/timeline/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("TimeLines","v-6319eb4e").then(t)},meta:{pid:"timeline",id:"timeline"}},{path:"/timeline/index.html",redirect:"/timeline/"},{name:"v-70487ef8",path:"/tag/源码分析/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-70487ef8").then(t)},meta:{pid:"tags",id:"源码分析"}},{path:"/tag/源码分析/index.html",redirect:"/tag/源码分析/"},{name:"v-18082c7a",path:"/tag/Java/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-18082c7a").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/index.html",redirect:"/tag/Java/"},{name:"v-75682621",path:"/tag/多线程/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-75682621").then(t)},meta:{pid:"tags",id:"多线程"}},{path:"/tag/多线程/index.html",redirect:"/tag/多线程/"},{name:"v-322fe662",path:"/tag/poi/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-322fe662").then(t)},meta:{pid:"tags",id:"poi"}},{path:"/tag/poi/index.html",redirect:"/tag/poi/"},{name:"v-08174efe",path:"/tag/分布式/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-08174efe").then(t)},meta:{pid:"tags",id:"分布式"}},{path:"/tag/分布式/index.html",redirect:"/tag/分布式/"},{name:"v-324b3466",path:"/tag/SPI/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-324b3466").then(t)},meta:{pid:"tags",id:"SPI"}},{path:"/tag/SPI/index.html",redirect:"/tag/SPI/"},{name:"v-63814eec",path:"/tag/定时任务/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-63814eec").then(t)},meta:{pid:"tags",id:"定时任务"}},{path:"/tag/定时任务/index.html",redirect:"/tag/定时任务/"},{name:"v-3cf63429",path:"/tag/网关/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-3cf63429").then(t)},meta:{pid:"tags",id:"网关"}},{path:"/tag/网关/index.html",redirect:"/tag/网关/"},{name:"v-231b917c",path:"/tag/日志/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-231b917c").then(t)},meta:{pid:"tags",id:"日志"}},{path:"/tag/日志/index.html",redirect:"/tag/日志/"},{name:"v-323039b2",path:"/tag/pdf/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-323039b2").then(t)},meta:{pid:"tags",id:"pdf"}},{path:"/tag/pdf/index.html",redirect:"/tag/pdf/"},{name:"v-83bebff6",path:"/tag/Docker/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-83bebff6").then(t)},meta:{pid:"tags",id:"Docker"}},{path:"/tag/Docker/index.html",redirect:"/tag/Docker/"},{name:"v-f11be80a",path:"/tag/IO模型/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-f11be80a").then(t)},meta:{pid:"tags",id:"IO模型"}},{path:"/tag/IO模型/index.html",redirect:"/tag/IO模型/"},{name:"v-32352550",path:"/tag/jvm/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-32352550").then(t)},meta:{pid:"tags",id:"jvm"}},{path:"/tag/jvm/index.html",redirect:"/tag/jvm/"},{name:"v-32351c1c",path:"/tag/jwt/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-32351c1c").then(t)},meta:{pid:"tags",id:"jwt"}},{path:"/tag/jwt/index.html",redirect:"/tag/jwt/"},{name:"v-f5f3b4b4",path:"/tag/MyBatis/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-f5f3b4b4").then(t)},meta:{pid:"tags",id:"MyBatis"}},{path:"/tag/MyBatis/index.html",redirect:"/tag/MyBatis/"},{name:"v-71925cf6",path:"/tag/sql优化/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-71925cf6").then(t)},meta:{pid:"tags",id:"sql优化"}},{path:"/tag/sql优化/index.html",redirect:"/tag/sql优化/"},{name:"v-3c438db2",path:"/tag/RabbitMQ/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-3c438db2").then(t)},meta:{pid:"tags",id:"RabbitMQ"}},{path:"/tag/RabbitMQ/index.html",redirect:"/tag/RabbitMQ/"},{name:"v-cd4f2d44",path:"/tag/Redis/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-cd4f2d44").then(t)},meta:{pid:"tags",id:"Redis"}},{path:"/tag/Redis/index.html",redirect:"/tag/Redis/"},{name:"v-4c97ede3",path:"/tag/Spring Security/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-4c97ede3").then(t)},meta:{pid:"tags",id:"Spring Security"}},{path:"/tag/Spring Security/index.html",redirect:"/tag/Spring Security/"},{name:"v-36fc09bd",path:"/tag/Swagger2/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-36fc09bd").then(t)},meta:{pid:"tags",id:"Swagger2"}},{path:"/tag/Swagger2/index.html",redirect:"/tag/Swagger2/"},{name:"v-29013a71",path:"/tag/Spring Boot/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-29013a71").then(t)},meta:{pid:"tags",id:"Spring Boot"}},{path:"/tag/Spring Boot/index.html",redirect:"/tag/Spring Boot/"},{name:"v-d3c816e6",path:"/tag/ZooKeeper/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-d3c816e6").then(t)},meta:{pid:"tags",id:"ZooKeeper"}},{path:"/tag/ZooKeeper/index.html",redirect:"/tag/ZooKeeper/"},{name:"v-46031d55",path:"/tag/单元测试/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-46031d55").then(t)},meta:{pid:"tags",id:"单元测试"}},{path:"/tag/单元测试/index.html",redirect:"/tag/单元测试/"},{name:"v-1eedfa34",path:"/tag/随笔/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-1eedfa34").then(t)},meta:{pid:"tags",id:"随笔"}},{path:"/tag/随笔/index.html",redirect:"/tag/随笔/"},{name:"v-3c2760d0",path:"/tag/网络协议/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-3c2760d0").then(t)},meta:{pid:"tags",id:"网络协议"}},{path:"/tag/网络协议/index.html",redirect:"/tag/网络协议/"},{name:"v-7a5f6990",path:"/tag/JavaScript/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-7a5f6990").then(t)},meta:{pid:"tags",id:"JavaScript"}},{path:"/tag/JavaScript/index.html",redirect:"/tag/JavaScript/"},{name:"v-14722046",path:"/tag/json/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-14722046").then(t)},meta:{pid:"tags",id:"json"}},{path:"/tag/json/index.html",redirect:"/tag/json/"},{name:"v-dfb71430",path:"/tag/vuepress/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-dfb71430").then(t)},meta:{pid:"tags",id:"vuepress"}},{path:"/tag/vuepress/index.html",redirect:"/tag/vuepress/"},{name:"v-3247b8aa",path:"/tag/Via/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-3247b8aa").then(t)},meta:{pid:"tags",id:"Via"}},{path:"/tag/Via/index.html",redirect:"/tag/Via/"},{name:"v-32475d9a",path:"/tag/Vue/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-32475d9a").then(t)},meta:{pid:"tags",id:"Vue"}},{path:"/tag/Vue/index.html",redirect:"/tag/Vue/"},{name:"v-5acc93b2",path:"/tag/复习/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-5acc93b2").then(t)},meta:{pid:"tags",id:"复习"}},{path:"/tag/复习/index.html",redirect:"/tag/复习/"},{name:"v-4a5e8070",path:"/tag/开发规范/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-4a5e8070").then(t)},meta:{pid:"tags",id:"开发规范"}},{path:"/tag/开发规范/index.html",redirect:"/tag/开发规范/"},{name:"v-32383f72",path:"/tag/git/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-32383f72").then(t)},meta:{pid:"tags",id:"git"}},{path:"/tag/git/index.html",redirect:"/tag/git/"},{name:"v-32360c9a",path:"/tag/k8s/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-32360c9a").then(t)},meta:{pid:"tags",id:"k8s"}},{path:"/tag/k8s/index.html",redirect:"/tag/k8s/"},{name:"v-7418fe36",path:"/tag/linux/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-7418fe36").then(t)},meta:{pid:"tags",id:"linux"}},{path:"/tag/linux/index.html",redirect:"/tag/linux/"},{name:"v-5e43a71f",path:"/tag/ECharts/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Tag","v-5e43a71f").then(t)},meta:{pid:"tags",id:"ECharts"}},{path:"/tag/ECharts/index.html",redirect:"/tag/ECharts/"},{name:"v-c2a8e576",path:"/categories/后端 Back-end/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Category","v-c2a8e576").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/index.html",redirect:"/categories/后端 Back-end/"},{name:"v-ab316f34",path:"/categories/随笔 Essay/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Category","v-ab316f34").then(t)},meta:{pid:"categories",id:"随笔 Essay"}},{path:"/categories/随笔 Essay/index.html",redirect:"/categories/随笔 Essay/"},{name:"v-60e851e2",path:"/categories/前端 Front-end/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Category","v-60e851e2").then(t)},meta:{pid:"categories",id:"前端 Front-end"}},{path:"/categories/前端 Front-end/index.html",redirect:"/categories/前端 Front-end/"},{name:"v-e09e3912",path:"/categories/规范 Standard/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Category","v-e09e3912").then(t)},meta:{pid:"categories",id:"规范 Standard"}},{path:"/categories/规范 Standard/index.html",redirect:"/categories/规范 Standard/"},{name:"v-eaa23b1a",path:"/categories/知识晶体 Q&A/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Category","v-eaa23b1a").then(t)},meta:{pid:"categories",id:"知识晶体 Q&A"}},{path:"/categories/知识晶体 Q&A/index.html",redirect:"/categories/知识晶体 Q&A/"},{name:"v-04bd0e8e",path:"/tag/源码分析/page/2/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-04bd0e8e").then(t)},meta:{pid:"tags",id:"源码分析"}},{path:"/tag/源码分析/page/2/index.html",redirect:"/tag/源码分析/page/2/"},{name:"v-e3c98acc",path:"/tag/Java/page/2/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-e3c98acc").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/page/2/index.html",redirect:"/tag/Java/page/2/"},{name:"v-e3c98a8e",path:"/tag/Java/page/3/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-e3c98a8e").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/page/3/index.html",redirect:"/tag/Java/page/3/"},{name:"v-e3c98a50",path:"/tag/Java/page/4/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-e3c98a50").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tag/Java/page/4/index.html",redirect:"/tag/Java/page/4/"},{name:"v-7c1bf909",path:"/tag/随笔/page/2/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-7c1bf909").then(t)},meta:{pid:"tags",id:"随笔"}},{path:"/tag/随笔/page/2/index.html",redirect:"/tag/随笔/page/2/"},{name:"v-707700d8",path:"/categories/后端 Back-end/page/2/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-707700d8").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/2/index.html",redirect:"/categories/后端 Back-end/page/2/"},{name:"v-707700f7",path:"/categories/后端 Back-end/page/3/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-707700f7").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/3/index.html",redirect:"/categories/后端 Back-end/page/3/"},{name:"v-70770116",path:"/categories/后端 Back-end/page/4/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-70770116").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/4/index.html",redirect:"/categories/后端 Back-end/page/4/"},{name:"v-70770135",path:"/categories/后端 Back-end/page/5/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-70770135").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/5/index.html",redirect:"/categories/后端 Back-end/page/5/"},{name:"v-70770154",path:"/categories/后端 Back-end/page/6/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-70770154").then(t)},meta:{pid:"categories",id:"后端 Back-end"}},{path:"/categories/后端 Back-end/page/6/index.html",redirect:"/categories/后端 Back-end/page/6/"},{name:"v-a7aca2d2",path:"/categories/随笔 Essay/page/2/",component:ze,beforeEnter:(n,e,t)=>{Object(Kn.a)("Layout","v-a7aca2d2").then(t)},meta:{pid:"categories",id:"随笔 Essay"}},{path:"/categories/随笔 Essay/page/2/index.html",redirect:"/categories/随笔 Essay/page/2/"},{path:"*",component:ze}],Ie={title:"znote",description:"荷尽已无擎雨盖，菊残犹有傲霜枝。",base:"/znote/",headTags:[["meta",{name:"viewport",content:"width=device-width,initial-scale=1,user-scalable=no"}],["meta",{name:"renderer",content:"webkit"}],["meta",{name:"referrer",content:"never"}],["meta",{"data-draft-node":"block","data-draft-type":"table","data-size":"normal","data-row-style":"normal"}],["link",{rel:"icon",href:"/znote/logo.png"}],["link",{rel:"icon",type:"image/png",sizes:"16x16",href:"/znote/vuepress/favicon-16x16.png"}],["link",{rel:"icon",type:"image/png",sizes:"32x32",href:"/znote/vuepress/favicon-32x32.png"}],["link",{rel:"mask-icon",href:"/znote/vuepress/safari-pinned-tab.svg"}],["link",{rel:"manifest",href:"/znote/manifest.json"}],["link",{rel:"apple-touch-icon",sizes:"57x57",href:"/znote/vuepress/apple-touch-icon-57x57.png"}],["link",{rel:"apple-touch-icon",sizes:"60x60",href:"/znote/vuepress/apple-touch-icon-60x60.png"}],["link",{rel:"apple-touch-icon",sizes:"72x72",href:"/znote/vuepress/apple-touch-icon-72x72.png"}],["link",{rel:"apple-touch-icon",sizes:"76x76",href:"/znote/vuepress/apple-touch-icon-76x76.png"}],["link",{rel:"apple-touch-icon",sizes:"120x120",href:"/znote/vuepress/apple-touch-icon-120x120.png"}],["link",{rel:"apple-touch-icon",sizes:"144x144",href:"/znote/vuepress/apple-touch-icon-144x144.png"}],["link",{rel:"apple-touch-icon",sizes:"152x152",href:"/znote/vuepress/apple-touch-icon-152x152.png"}],["link",{rel:"apple-touch-icon",sizes:"180x180",href:"/znote/vuepress/apple-touch-icon-180x180.png"}],["meta",{name:"apple-mobile-web-app-capable",content:"yes"}],["meta",{name:"apple-mobile-web-app-status-bar-style",content:"black"}],["meta",{name:"msapplication-TileImage",content:"/vuepress/msapplication-icon-144x144.png"}],["meta",{name:"msapplication-TileColor",content:"#000000"}],["script",{language:"javascript",type:"text/javascript",src:"https://cdn.bootcss.com/jquery/3.6.0/jquery.min.js"}],["script",{language:"javascript",type:"text/javascript",src:"/znote/js/MouseClickEffect.js"}]],pages:[{frontmatter:{sidebar:!1,isComment:!1,isShowReward:!1,layout:"Projects"},regularPath:"/other/project.html",relativePath:"other/project.md",key:"v-6885a764",path:"/other/project.html",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Home",frontmatter:{home:!0,heroImage:"/vuepress/topic.png",faceImage:"/vuepress/head.png",heroImageStyle:{maxWidth:"680px",width:"100%",display:"block",margin:"14% auto -16% auto","//border":"1px dashed #000","box-shadow":"8px 8px 20px #022",borderRadius:"10px"},isShowTitleInHome:!0,actionText:"开启进阶之路",actionLink:"/views/",features:[{title:null,details:"把所有的不快给昨天"},{title:null,details:"把所有的努力给今天"},{title:null,details:"把所有的希望给明天"}],footer:"MIT Licensed | Copyright © 2018-present Evan You"},regularPath:"/",relativePath:"README.md",key:"v-27bdaeaa",path:"/",headersStr:null,content:"人的一生能有几天\n\n问一问，人的一生能有几天\n算一算，人的一生不过三天\n\n\n跑过去的是昨天\n奔过来的是明天\n正在走的是今天\n\n\n不要忘记昨天\n认真计划明天\n好好把握今天\n\n\n但愿到了明天\n今天已成昨天\n而你依然在我身边\n\n\n啊。\n春梦无痕，秋夜缠绵\n如歌岁月，似水流年\n\n\n但愿到了明天\n今天已成昨天\n而我依然在你心间",normalizedContent:"人的一生能有几天\n\n问一问，人的一生能有几天\n算一算，人的一生不过三天\n\n\n跑过去的是昨天\n奔过来的是明天\n正在走的是今天\n\n\n不要忘记昨天\n认真计划明天\n好好把握今天\n\n\n但愿到了明天\n今天已成昨天\n而你依然在我身边\n\n\n啊。\n春梦无痕，秋夜缠绵\n如歌岁月，似水流年\n\n\n但愿到了明天\n今天已成昨天\n而我依然在你心间",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"关于我",frontmatter:{title:"关于我",isTimeLine:!1,sidebar:!1,isShowComments:!0},regularPath:"/about/",relativePath:"about/README.md",key:"v-2e6c285b",path:"/about/",headers:[{level:2,title:"一句话",slug:"一句话",normalizedTitle:"一句话",charIndex:72},{level:2,title:"关于我",slug:"关于我",normalizedTitle:"关于我",charIndex:116},{level:2,title:"兴趣方向",slug:"兴趣方向",normalizedTitle:"兴趣方向",charIndex:191},{level:2,title:"成熟标志",slug:"成熟标志",normalizedTitle:"成熟标志",charIndex:222},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:372},{level:2,title:"部落",slug:"部落",normalizedTitle:"部落",charIndex:457},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:890},{level:2,title:"联系",slug:"联系",normalizedTitle:"联系",charIndex:951},{level:2,title:"赞赏",slug:"赞赏",normalizedTitle:"赞赏",charIndex:978}],headersStr:"一句话 关于我 兴趣方向 成熟标志 社区 部落 其他 联系 赞赏",content:"YOU AND ME\n\n世界上最远的距离，是我在 if 里你在 else 里，虽然经常一起出现，但却永不结伴执行。\n\n来自 ZNOTE\n\n\n# 一句话\n\n * Just do IT ! （翻译：我只是个搞 IT的！哭笑脸）\n\n\n# 关于我\n\n * 一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的，偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！\n\n\n# 兴趣方向\n\n * 在互联网信息高速公路上 流浪。 。\n\n\n# 成熟标志\n\n * 爱您：80231\n * 会扔、敢买、能赚、懂爱！\n * 自信乐观，勇于担当，明白责任的意义！\n * 意识到自己时间有限，具备区分什么是值得花时间的、什么是不值得花时间的的能力！\n * 成年人的发泄方式，不再是改头像、换签名、发朋友圈，而是吹吹风，静一静，习惯性的等待自愈！\n\n\n# 社区\n\n * 博客：https://zpj80231.github.io/znote\n * Github：https://github.com/zpj80231\n\n\n# 部落\n\n * Email：zpj80231@163.com\n * 微信：见下方或 [ 点我直达 ]，记得一定要先看一眼 [ Guide ]\n * 友链：欢迎入队组队🏆 --\x3e 《 Let's go! 》\n\nFor you\n\n你若盛开，清风自来。\n\nTo me\n\n心若浮沉，浅笑安然。\n\n- img: /znote/img/other/766d39ee-fbf0-329e-8973-45e90625b579.jpg\n  link: /znote/other/friends.html\n  name: For you\n  desc: 你若盛开，清风自来。\n- img: /znote/img/other/c33a5027-85d3-3eb4-a785-dd404f674baa.jpg\n  link: /znote/other/friends.html\n  name: To me\n  desc: 心若浮沉，浅笑安然。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 其他\n\n * 本仓库代码使用 MIT 协议进行开源，但是全部文档内容使用 CC 4.0 BY-SA 协议进行发布\n\n\n# 联系\n\n\n\n     \n个人   公众号\n\n\n\n\n# 赞赏\n\nThanks for you!",normalizedContent:"you and me\n\n世界上最远的距离，是我在 if 里你在 else 里，虽然经常一起出现，但却永不结伴执行。\n\n来自 znote\n\n\n# 一句话\n\n * just do it ! （翻译：我只是个搞 it的！哭笑脸）\n\n\n# 关于我\n\n * 一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的，偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！\n\n\n# 兴趣方向\n\n * 在互联网信息高速公路上 流浪。 。\n\n\n# 成熟标志\n\n * 爱您：80231\n * 会扔、敢买、能赚、懂爱！\n * 自信乐观，勇于担当，明白责任的意义！\n * 意识到自己时间有限，具备区分什么是值得花时间的、什么是不值得花时间的的能力！\n * 成年人的发泄方式，不再是改头像、换签名、发朋友圈，而是吹吹风，静一静，习惯性的等待自愈！\n\n\n# 社区\n\n * 博客：https://zpj80231.github.io/znote\n * github：https://github.com/zpj80231\n\n\n# 部落\n\n * email：zpj80231@163.com\n * 微信：见下方或 [ 点我直达 ]，记得一定要先看一眼 [ guide ]\n * 友链：欢迎入队组队🏆 --\x3e 《 let's go! 》\n\nfor you\n\n你若盛开，清风自来。\n\nto me\n\n心若浮沉，浅笑安然。\n\n- img: /znote/img/other/766d39ee-fbf0-329e-8973-45e90625b579.jpg\n  link: /znote/other/friends.html\n  name: for you\n  desc: 你若盛开，清风自来。\n- img: /znote/img/other/c33a5027-85d3-3eb4-a785-dd404f674baa.jpg\n  link: /znote/other/friends.html\n  name: to me\n  desc: 心若浮沉，浅笑安然。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 其他\n\n * 本仓库代码使用 mit 协议进行开源，但是全部文档内容使用 cc 4.0 by-sa 协议进行发布\n\n\n# 联系\n\n\n\n     \n个人   公众号\n\n\n\n\n# 赞赏\n\nthanks for you!",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"概览",frontmatter:{title:"概览",sidebar:!0,date:"2019-08-21T00:00:00.000Z",sidebarDepth:0,isShowComments:!0},regularPath:"/views/",relativePath:"views/README.md",key:"v-7e3794d9",path:"/views/",headersStr:null,content:" \n \n \n远航\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n风吹雨打不退让\n \n无论我去到哪方\n心里梦想不变样\n是新生 是醒觉\n梦想永远在世上\n \n前路哪怕远 只要自强\n我继续独自寻路向\n常为以往梦想发狂\n耐心摸索路途上\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n途人路上回望我\n只因我的怪模样\n途人谁能明白我\n今天眼睛多雪亮\n \n人是各有各理想\n奔向目标不退让\n用歌声 用欢笑\n来博知音的赞赏\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n依照心中那 正确方向\n \n怀着爱与恕的心\n充满梦想的笑着\n用歌声 用欢笑\n来博知音的赞赏\n \n\n【分类】\n\n【标签】\n\n【前端】 | 【后端】\n\n【规范】 | 【随笔】",normalizedContent:" \n \n \n远航\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n风吹雨打不退让\n \n无论我去到哪方\n心里梦想不变样\n是新生 是醒觉\n梦想永远在世上\n \n前路哪怕远 只要自强\n我继续独自寻路向\n常为以往梦想发狂\n耐心摸索路途上\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n途人路上回望我\n只因我的怪模样\n途人谁能明白我\n今天眼睛多雪亮\n \n人是各有各理想\n奔向目标不退让\n用歌声 用欢笑\n来博知音的赞赏\n \n怀自信 我永不怕夜航\n到困倦我自弹自唱\n掌声我向梦想里寻\n尽管一切是狂想\n \n昂然踏着前路去\n追赶理想旅途上\n前行步步怀自信\n依照心中那 正确方向\n \n怀着爱与恕的心\n充满梦想的笑着\n用歌声 用欢笑\n来博知音的赞赏\n \n\n【分类】\n\n【标签】\n\n【前端】 | 【后端】\n\n【规范】 | 【随笔】",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"ArrayList底层实现和原理",frontmatter:{title:"ArrayList底层实现和原理",date:"2017-06-13T20:53:26.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/ArrayList.html",relativePath:"views/backend/ArrayList.md",key:"v-59e792f7",path:"/views/backend/ArrayList.html",headers:[{level:2,title:"ArrayList底层简介",slug:"arraylist底层简介",normalizedTitle:"arraylist底层简介",charIndex:100},{level:2,title:"手写一个简单的MyArrayList",slug:"手写一个简单的myarraylist",normalizedTitle:"手写一个简单的myarraylist",charIndex:117},{level:2,title:"ArrayList的线程安全性",slug:"arraylist的线程安全性",normalizedTitle:"arraylist的线程安全性",charIndex:139},{level:2,title:"ArrayList和LinkedList、Vector的优缺点？",slug:"arraylist和linkedlist、vector的优缺点",normalizedTitle:"arraylist和linkedlist、vector的优缺点？",charIndex:158}],excerpt:"<Boxx/>\n<p>ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。</p>\n",headersStr:"ArrayList底层简介 手写一个简单的MyArrayList ArrayList的线程安全性 ArrayList和LinkedList、Vector的优缺点？",content:'ArrayList可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。\n\n\n\n * ArrayList底层简介\n * 手写一个简单的MyArrayList\n * ArrayList的线程安全性\n * ArrayList和LinkedList、Vector的优缺点？\n\n\n\n\n# ArrayList底层简介\n\n * ArrayList是List接口的一个可变大小的数组的实现\n * ArrayList的内部是使用一个Object对象数组来存储元素的\n * 初始化ArrayList的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10\n * 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍（1.7以后）\n * 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移\n * 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移\n\n\n# 手写一个简单的MyArrayList\n\npackage com.zpj.electric.SourceCodeAnalysis;\n\n/**\n * Created by admin on 2017/6/10.\n */\npublic class MyArrayList {\n\n    //ArrayList有一个专门用来装元素的容器，为了保证集合什么类型的数据都可存储，所以定义的Object[]\n    public Object[] data;\n    //ArrayList里还有一个属性，用来记录集合元素的个数\n    public int size;\n\n    /**\n     * 有参构造方法\n     *\n     * @param x 指定数组大小\n     */\n    public MyArrayList(int x) {\n        if (x > 0) {\n            data = new Object[x];\n        } else {\n            System.out.println("参数异常");\n        }\n    }\n\n    /**\n     * 如果指定数组大小，默认10个\n     */\n    public MyArrayList() {\n        this(10);\n    }\n\n    /**\n     * 得到集合的大小  如：int x = list.size();\n     *\n     * @return\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 往集合中添加元素 如：list.add(Object obj);\n     *\n     * @param obj\n     */\n    public void add(Object obj) {\n        //当我们往集合中添加元素的时候，obj最终都会添加进Object[]数组中去\n        //所以每次添加数据的时候都需要判断Object[],即data数组有没有填满\n        if (data.length == size) {\n            //如果填满了，那么需要扩容:\n            // jdk1.7之前：size*3/2+1\n            // jdk1.7及之后：size+(size>>1)\n            Object[] temp = new Object[size + (size >> 1)];\n            //扩容后将老数组复制到新数组里\n            System.arraycopy(data, 0, temp, 0, size);\n            //改变引用指向 gc回收老数组对象\n            data = temp;\n        }\n        \n        data[size] = obj;\n        size++;\n    }\n\n    /**\n     * 按指定下标删除集合中的元素\n     *\n     * @param index\n     */\n    public void remove(int index) {\n        //System.arraycopy(要被复制的老数组，从下标index开始复制，要复制到的新数组，从新数组的下标index插入,从老数组下标开始要被复制的个数);\n        System.arraycopy(data, index + 1, data, index, size - (index + 1));\n        size--;\n    }\n\n    /**\n     * 指定元素删除集合中的元素\n     *\n     * @param obj\n     */\n    public void remove(Object obj) {\n        //每当指定元素删除的时候，底层会拿着obj和每个元素做equals比较\n        for (int x = 0; x < size; x++) {\n            if (obj.equals(data[x])) {\n                remove(x);//按下标删除元素\n                break;//一个remove方法只能删除一个对象\n            }\n        }\n    }\n\n    /**\n     * 根据指定下标获得元素\n     *\n     * @param x\n     * @return\n     */\n    public Object get(int x) {\n        return x >= 0 && x < size ? data[x] : "参数越界异常";\n    }\n\n}\n\nclass TestMyArrayList {\n    public static void main(String[] args) {\n        MyArrayList myArrayList = new MyArrayList();\n        myArrayList.add(234);\n        myArrayList.add("john");\n        myArrayList.add("demon");\n        myArrayList.add("alex");\n        System.out.println(myArrayList.size());\n        System.out.println(myArrayList.get(2));\n\n        myArrayList.remove(1);\n        System.out.println(myArrayList.size());\n\n        MyArrayList myArrayList1 = new MyArrayList(20);\n        System.out.println(myArrayList1.data.length);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n> ArrayList其他方法如add(int index, E element)，contains(E)可以去看：https://blog.csdn.net/aizhuyanwei/article/details/78493495\n\n\n# ArrayList的线程安全性\n\n对ArrayList进行添加元素的操作的时候是分两个步骤进行的，即第一步先在object[size]的位置上存放需要添加的元素；第二步将size的值增加1。由于这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。\n\n具体举例说明：在单线程运行的情况下，如果Size = 0，添加一个元素后，此元素在位置 0，而且Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增 加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而Size却等于 2。这就是“线程不安全”了。\n\n如果非要在多线程的环境下使用ArrayList，就需要保证它的线程安全性，通常有两种解决办法：第一，使用synchronized关键字；第二，可以用Collections类中的静态方法synchronizedList();对ArrayList进行调用即可。\n\n\n# ArrayList和LinkedList、Vector的优缺点？\n\n * ArrayList底层是数组结构，查询快，增删慢，线程不安全，效率高\n\n * LinkedList底层是链表数据结构，查询慢，增删快，线程不安全，效率高\n\n * Vector底层是数组结构，查询快，增删慢，线程安全，效率低',normalizedContent:'arraylist可以简单的看作是动态数组，相对于普通的数组它可以动态的增加容量或者减少容量。要注意的是arraylist并不是线程安全的，因此一般建议在单线程中使用arraylist。\n\n\n\n * arraylist底层简介\n * 手写一个简单的myarraylist\n * arraylist的线程安全性\n * arraylist和linkedlist、vector的优缺点？\n\n\n\n\n# arraylist底层简介\n\n * arraylist是list接口的一个可变大小的数组的实现\n * arraylist的内部是使用一个object对象数组来存储元素的\n * 初始化arraylist的时候，可以指定初始化容量的大小，如果不指定，就会使用默认大小，为10\n * 当添加一个新元素的时候，首先会检查容量是否足够添加这个元素，如果够就直接添加，如果不够就进行扩容，扩容为原数组容量的1.5倍（1.7以后）\n * 当在index处放置一个元素的时候，会将数组index处右边的元素全部右移\n * 当在index处删除一个元素的时候，会将数组index处右边的元素全部左移\n\n\n# 手写一个简单的myarraylist\n\npackage com.zpj.electric.sourcecodeanalysis;\n\n/**\n * created by admin on 2017/6/10.\n */\npublic class myarraylist {\n\n    //arraylist有一个专门用来装元素的容器，为了保证集合什么类型的数据都可存储，所以定义的object[]\n    public object[] data;\n    //arraylist里还有一个属性，用来记录集合元素的个数\n    public int size;\n\n    /**\n     * 有参构造方法\n     *\n     * @param x 指定数组大小\n     */\n    public myarraylist(int x) {\n        if (x > 0) {\n            data = new object[x];\n        } else {\n            system.out.println("参数异常");\n        }\n    }\n\n    /**\n     * 如果指定数组大小，默认10个\n     */\n    public myarraylist() {\n        this(10);\n    }\n\n    /**\n     * 得到集合的大小  如：int x = list.size();\n     *\n     * @return\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * 往集合中添加元素 如：list.add(object obj);\n     *\n     * @param obj\n     */\n    public void add(object obj) {\n        //当我们往集合中添加元素的时候，obj最终都会添加进object[]数组中去\n        //所以每次添加数据的时候都需要判断object[],即data数组有没有填满\n        if (data.length == size) {\n            //如果填满了，那么需要扩容:\n            // jdk1.7之前：size*3/2+1\n            // jdk1.7及之后：size+(size>>1)\n            object[] temp = new object[size + (size >> 1)];\n            //扩容后将老数组复制到新数组里\n            system.arraycopy(data, 0, temp, 0, size);\n            //改变引用指向 gc回收老数组对象\n            data = temp;\n        }\n        \n        data[size] = obj;\n        size++;\n    }\n\n    /**\n     * 按指定下标删除集合中的元素\n     *\n     * @param index\n     */\n    public void remove(int index) {\n        //system.arraycopy(要被复制的老数组，从下标index开始复制，要复制到的新数组，从新数组的下标index插入,从老数组下标开始要被复制的个数);\n        system.arraycopy(data, index + 1, data, index, size - (index + 1));\n        size--;\n    }\n\n    /**\n     * 指定元素删除集合中的元素\n     *\n     * @param obj\n     */\n    public void remove(object obj) {\n        //每当指定元素删除的时候，底层会拿着obj和每个元素做equals比较\n        for (int x = 0; x < size; x++) {\n            if (obj.equals(data[x])) {\n                remove(x);//按下标删除元素\n                break;//一个remove方法只能删除一个对象\n            }\n        }\n    }\n\n    /**\n     * 根据指定下标获得元素\n     *\n     * @param x\n     * @return\n     */\n    public object get(int x) {\n        return x >= 0 && x < size ? data[x] : "参数越界异常";\n    }\n\n}\n\nclass testmyarraylist {\n    public static void main(string[] args) {\n        myarraylist myarraylist = new myarraylist();\n        myarraylist.add(234);\n        myarraylist.add("john");\n        myarraylist.add("demon");\n        myarraylist.add("alex");\n        system.out.println(myarraylist.size());\n        system.out.println(myarraylist.get(2));\n\n        myarraylist.remove(1);\n        system.out.println(myarraylist.size());\n\n        myarraylist myarraylist1 = new myarraylist(20);\n        system.out.println(myarraylist1.data.length);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n> arraylist其他方法如add(int index, e element)，contains(e)可以去看：https://blog.csdn.net/aizhuyanwei/article/details/78493495\n\n\n# arraylist的线程安全性\n\n对arraylist进行添加元素的操作的时候是分两个步骤进行的，即第一步先在object[size]的位置上存放需要添加的元素；第二步将size的值增加1。由于这个过程在多线程的环境下是不能保证具有原子性的，因此arraylist在多线程的环境下是线程不安全的。\n\n具体举例说明：在单线程运行的情况下，如果size = 0，添加一个元素后，此元素在位置 0，而且size=1；而如果是在多线程情况下，比如有两个线程，线程 a 先将元素存放在位置0。但是此时 cpu 调度线程a暂停，线程 b 得到运行的机会。线程b也向此arraylist 添加元素，因为此时 size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程a仅仅完成了步骤1），所以线程b也将元素存放在位置0。然后线程a和线程b都继续运行，都增 加 size 的值。 那好，现在我们来看看 arraylist 的情况，元素实际上只有一个，存放在位置 0，而size却等于 2。这就是“线程不安全”了。\n\n如果非要在多线程的环境下使用arraylist，就需要保证它的线程安全性，通常有两种解决办法：第一，使用synchronized关键字；第二，可以用collections类中的静态方法synchronizedlist();对arraylist进行调用即可。\n\n\n# arraylist和linkedlist、vector的优缺点？\n\n * arraylist底层是数组结构，查询快，增删慢，线程不安全，效率高\n\n * linkedlist底层是链表数据结构，查询慢，增删快，线程不安全，效率高\n\n * vector底层是数组结构，查询快，增删慢，线程安全，效率低',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"友人帐",frontmatter:{title:"友人帐",sidebar:!0,isShowComments:!0,reward:!0},regularPath:"/other/friends.html",relativePath:"other/friends.md",key:"v-a03de038",path:"/other/friends.html",headers:[{level:3,title:"高质量友人帐",slug:"高质量友人帐",normalizedTitle:"高质量友人帐",charIndex:2},{level:3,title:"友链互换",slug:"友链互换",normalizedTitle:"友链互换",charIndex:2547}],headersStr:"高质量友人帐 友链互换",content:"# 高质量友人帐\n\n * 朋友丰富人生 —— 林肯\n * 展示所有友情站点，排名不分先后！\n * 稍息，立正。欢迎入队！👍\n\n午后南杂\n\nEnjoy when you can, and endure when you must.\n\nznote\n\n荷尽已无擎雨盖，菊残犹有傲霜枝。\n\nEvan's blog\n\n积跬步以至千里，致敬每个爱学习的你。\n\n友人c\n\n只要心还眺。\n\n田小波\n\n欢迎访问田小波的技术博客。\n\n易良同学的博客\n\n正在努力！\n\n会飞的小弋\n\n喜欢大数据，嵌入式和机器视觉\n\n站位等待中...\n\n稍息，立正。欢迎入队！👍\n\n- name: 午后南杂\n  avatar: https://www.recoluan.com/head.png\n  desc: Enjoy when you can, and endure when you must.\n  link: https://www.recoluan.com\n  bgColor: 'rgb(165 216 243)'\n  textColor: '#6854A1'\n#- name: 青灯有味\n#  desc: 闹里有钱，静外安身。\n#  avatar: https://zscnb.gitee.io/logo.png\n#  link: https://zscnb.gitee.io/\n#  bgColor: '#FCE5BF'\n#  textColor: '#7B2532'\n- name: znote\n  desc: 荷尽已无擎雨盖，菊残犹有傲霜枝。\n  avatar: https://zpj80231.gitee.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.gitee.io/znote/\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n#- name: 有梦想的咸鱼\n#  desc: 我不能克制我记几。\n#  avatar: https://blog.liudongyang.top/head-logo.gif\n#  link: https://blog.liudongyang.top\n#  bgColor: '#1abc9c'\n#  textColor: '#c0392b'\n- name: Evan's blog\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n  desc: 积跬步以至千里，致敬每个爱学习的你。\n  link: https://xugaoyi.com/\n  bgColor: '#2980b9'\n  textColor: '#ecf0f1'\n- name: 友人c\n  avatar: https://www.ihewro.com/usr/uploads/2020/02/863730882.jpg\n  desc: 只要心还眺。\n  link: https://www.ihewro.com/\n  bgColor: 'rgb(136,181,214)'\n  textColor: 'rgb(249,249,249)'\n- name: 田小波\n  avatar: https://www.tianxiaobo.com/images/tx.png\n  desc: 欢迎访问田小波的技术博客。\n  link: https://www.tianxiaobo.com/\n  bgColor: '#B39CD0'\n  textColor: '#FBEAFF'\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpeg\n  link: https://yiliang.site\n  bgColor: 'rgb(220 218 218)'\n  textColor: '#2c3e50' \n- name: 会飞的小弋\n  link: https://lovelijunyi.gitee.io/\n  avatar: https://gitee.com/lovelijunyi/images/raw/master/20200404135847.jpg\n  desc: 喜欢大数据，嵌入式和机器视觉\n  bgColor: 'rgb(243 126 126)'\n  textColor: 'rgb(102 48 72)'\n- name: 站位等待中...\n  link: \n  avatar: \n  desc: 稍息，立正。欢迎入队！👍\n  bgColor: 'rgb(157 156 186)'\n  textColor: 'rgb(252 249 247)'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\nFor you\n\n你若盛开，清风自来。\n\nTo me\n\n心若浮沉，浅笑安然。\n\n- img: /znote/img/other/5666c8e4-867a-3356-9708-6ba918e87853.jpg\n  link: /znote/other/friends.html\n  name: For you\n  desc: 你若盛开，清风自来。\n- img: /znote/img/other/4ec4e5f0-947b-3abe-9e8b-47bad5b8cf1c.jpg\n  link: /znote/about/index.html\n  name: To me\n  desc: 心若浮沉，浅笑安然。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 友链互换\n\n如需友链，请 联系我 或 留言👇 告知，格式如下：\n\n- name: znote\n  desc: 荷尽已无擎雨盖，菊残犹有傲霜枝\n  avatar: https://zpj80231.github.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.github.io/znote/\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n\n\n1\n2\n3\n4\n5\n6\n\n * 颜色仅供参考。\n * 站点要求：内容合法、非营利性。\n * 申请前请记得先添加本站哦～",normalizedContent:"# 高质量友人帐\n\n * 朋友丰富人生 —— 林肯\n * 展示所有友情站点，排名不分先后！\n * 稍息，立正。欢迎入队！👍\n\n午后南杂\n\nenjoy when you can, and endure when you must.\n\nznote\n\n荷尽已无擎雨盖，菊残犹有傲霜枝。\n\nevan's blog\n\n积跬步以至千里，致敬每个爱学习的你。\n\n友人c\n\n只要心还眺。\n\n田小波\n\n欢迎访问田小波的技术博客。\n\n易良同学的博客\n\n正在努力！\n\n会飞的小弋\n\n喜欢大数据，嵌入式和机器视觉\n\n站位等待中...\n\n稍息，立正。欢迎入队！👍\n\n- name: 午后南杂\n  avatar: https://www.recoluan.com/head.png\n  desc: enjoy when you can, and endure when you must.\n  link: https://www.recoluan.com\n  bgcolor: 'rgb(165 216 243)'\n  textcolor: '#6854a1'\n#- name: 青灯有味\n#  desc: 闹里有钱，静外安身。\n#  avatar: https://zscnb.gitee.io/logo.png\n#  link: https://zscnb.gitee.io/\n#  bgcolor: '#fce5bf'\n#  textcolor: '#7b2532'\n- name: znote\n  desc: 荷尽已无擎雨盖，菊残犹有傲霜枝。\n  avatar: https://zpj80231.gitee.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.gitee.io/znote/\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n#- name: 有梦想的咸鱼\n#  desc: 我不能克制我记几。\n#  avatar: https://blog.liudongyang.top/head-logo.gif\n#  link: https://blog.liudongyang.top\n#  bgcolor: '#1abc9c'\n#  textcolor: '#c0392b'\n- name: evan's blog\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n  desc: 积跬步以至千里，致敬每个爱学习的你。\n  link: https://xugaoyi.com/\n  bgcolor: '#2980b9'\n  textcolor: '#ecf0f1'\n- name: 友人c\n  avatar: https://www.ihewro.com/usr/uploads/2020/02/863730882.jpg\n  desc: 只要心还眺。\n  link: https://www.ihewro.com/\n  bgcolor: 'rgb(136,181,214)'\n  textcolor: 'rgb(249,249,249)'\n- name: 田小波\n  avatar: https://www.tianxiaobo.com/images/tx.png\n  desc: 欢迎访问田小波的技术博客。\n  link: https://www.tianxiaobo.com/\n  bgcolor: '#b39cd0'\n  textcolor: '#fbeaff'\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpeg\n  link: https://yiliang.site\n  bgcolor: 'rgb(220 218 218)'\n  textcolor: '#2c3e50' \n- name: 会飞的小弋\n  link: https://lovelijunyi.gitee.io/\n  avatar: https://gitee.com/lovelijunyi/images/raw/master/20200404135847.jpg\n  desc: 喜欢大数据，嵌入式和机器视觉\n  bgcolor: 'rgb(243 126 126)'\n  textcolor: 'rgb(102 48 72)'\n- name: 站位等待中...\n  link: \n  avatar: \n  desc: 稍息，立正。欢迎入队！👍\n  bgcolor: 'rgb(157 156 186)'\n  textcolor: 'rgb(252 249 247)'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\nfor you\n\n你若盛开，清风自来。\n\nto me\n\n心若浮沉，浅笑安然。\n\n- img: /znote/img/other/5666c8e4-867a-3356-9708-6ba918e87853.jpg\n  link: /znote/other/friends.html\n  name: for you\n  desc: 你若盛开，清风自来。\n- img: /znote/img/other/4ec4e5f0-947b-3abe-9e8b-47bad5b8cf1c.jpg\n  link: /znote/about/index.html\n  name: to me\n  desc: 心若浮沉，浅笑安然。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 友链互换\n\n如需友链，请 联系我 或 留言👇 告知，格式如下：\n\n- name: znote\n  desc: 荷尽已无擎雨盖，菊残犹有傲霜枝\n  avatar: https://zpj80231.github.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.github.io/znote/\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n\n\n1\n2\n3\n4\n5\n6\n\n * 颜色仅供参考。\n * 站点要求：内容合法、非营利性。\n * 申请前请记得先添加本站哦～",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"CountDownLatch 详解",frontmatter:{title:"CountDownLatch 详解",date:"2020-06-22T00:00:00.000Z",tags:["源码分析","多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/CountDownLatch.html",relativePath:"views/backend/CountDownLatch.md",key:"v-59596aa5",path:"/views/backend/CountDownLatch.html",headers:[{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:38},{level:2,title:"CountDownLatch解析",slug:"countdownlatch解析",normalizedTitle:"countdownlatch解析",charIndex:46},{level:3,title:"await () 方法",slug:"await-方法",normalizedTitle:"await () 方法",charIndex:68},{level:3,title:"countDown () 方法",slug:"countdown-方法",normalizedTitle:"countdown () 方法",charIndex:85},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:104}],excerpt:"<Boxx/>\n<p>依靠 AQS类中锁标记 state 实现的，任务的分割与合并。</p>\n",headersStr:"适用场景 CountDownLatch解析 await () 方法 countDown () 方法 参考",content:'依靠 AQS类中锁标记 state 实现的，任务的分割与合并。\n\n\n\n * 适用场景\n * CountDownLatch解析\n   * await () 方法\n   * countDown () 方法\n * 参考\n\n\n\n\n# 适用场景\n\n * 常和线程池共同出现，用做任务的分割合并，如：\n   \n   我们有90万数据，需要多线程多 Sheet 页导出 Excel，这时候就需要用到 CountDownLatch 来将这一任务具体细分。\n   \n   1. 将导出 Excel 看作一项大任务。\n   \n   2. 用线程池操作，导出的每个 Sheet 页为其中一项小任务。\n      \n      2.1 告诉 CountDownLatch 总任务数\n      \n      CountDownLatch countDownLatch = new CountDownLatch(任务总数);\n      \n      2.2 每完成一个任务就调用countDownLatch.countDown();（任务数-1）表示此项小任务已完成\n   \n   3. 在主线程调用countDownLatch.await();（即直到任务数为0时）等待所有小任务完成后，再执行其他操作。\n      \n      当然，为防止一直等待，可以加个超时时间countDownLatch.await(10L,TimeUnit.SECONDS);，超出时间后不再等待，直接唤醒 await 线程进行下一步操作。\n\n * 以上思路实例代码可见另一篇poi多线程多sheet导出Excel,csv\n\n\n# CountDownLatch解析\n\nCountDownLatch 类图如下:\n\n\n\n从图中可以看出，CountDownLatch 内部依赖 Sync 实现，而 Sync 继承自 AQS。CountDownLatch 仅提供了一个构造方法：\n\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException("count < 0");\n\n    this.sync = new Sync(count);\n}\n\n\n1\n2\n3\n4\n5\n\n\nSync 是 CountDownLatch 的静态内部类，其定义也比较简单，如下所示：\n\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n\n    private static final long serialVersionUID = 4982264981922014374L;\n\n    // 设置同步状态值（锁标记）\n    Sync(int count) {\n        setState(count);\n    }\n\n    // 获取同步状态值\n    int getCount() {\n        return getState();\n    }\n    \n    // 共享式获取同步状态\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\n    // 共享式释放同步状态\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            // 获取当前state属性的值\n            int c = getState();\n            // 如果state为0，则说明当前计数器已经计数完成，直接返回\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            // 使用CAS算法对state进行设置\n            if (compareAndSetState(c, nextc))\n                // 设置成功后返回当前是否为最后一个设置state的线程\n                return nextc == 0;\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# await () 方法\n\nCountDownLatch 提供了 await () 方法来使当前线程一直等待，直到计数器的值减为 0，或者线程被中断，该方法定义如下：\n\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n\n1\n2\n3\n\n\nawait () 方法调用了 AQS 的共享式相应中断获取同步状态的方法，acquireSharedInterruptibly (int)，如下所示：\n\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n\n    if (Thread.interrupted())\n        throw new InterruptedException();\n\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nSync 类重写了 tryAcquireShared (int) 方法：\n\nprotected int tryAcquireShared(int acquires) {\n    return (getState() == 0) ? 1 : -1;\n}\n\n\n1\n2\n3\n\n\n可以看到，只有当计数器（即同步状态）值为 0 时，才返回 1，即当前线程获取到了同步状态，在这里表示等待线程可以继续执行，若计数器值不是 0，则当前线程会调用 doAcquireSharedInterruptibly (int) 方法，一直自旋去尝试获取同步状态：\n\nprivate void doAcquireSharedInterruptibly(int arg) throws InterruptedException {\n  final Node node = addWaiter(Node.SHARED); // 使用当前线程创建一个共享模式的节点\n  boolean failed = true;\n  try {\n    for (;;) {\n      final Node p = node.predecessor();    // 获取当前节点的前一个节点\n      if (p == head) {  // 判断前一个节点是否为头结点\n        int r = tryAcquireShared(arg);  // 查看当前线程是否获取到了执行权限\n        if (r >= 0) {   // 大于0表示获取了执行权限\n          \n          /* 发现 r 大于 0（因为 state 已经被置为 0 了），\n           * 该线程就会调用 setHeadAndPropagate (Node, int) 方法，\n           * 并且退出当前循环，\n           * 也就开始执行我们调用 await() 方法之后的代码\n           */\n          setHeadAndPropagate(node, r); // 将当前节点设置为头结点，并且唤醒后面处于等待状态的节点\n          p.next = null; // help GC\n          failed = false;\n          return;\n        }\n      }\n      \n      // 走到这一步说明没有获取到执行权限，就使当前线程进入“搁置”状态\n      if (shouldParkAfterFailedAcquire(p, node) &&\n          parkAndCheckInterrupt())\n        throw new InterruptedException();\n    }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这里我们看看 setHeadAndPropagate (Node, int) 方法的具体实现：\n\nprivate void setHeadAndPropagate(Node node, int propagate) {\n  Node h = head;\n  setHead(node);    // 将当前节点设置为头节点\n  // 检查唤醒过程是否需要往下传递，并且检查头结点的等待状态\n  if (propagate > 0 || h == null || h.waitStatus < 0 ||\n      (h = head) == null || h.waitStatus < 0) {\n    Node s = node.next;\n    if (s == null || s.isShared())  // 如果下一个节点是尝试以共享状态获取获取执行权限的节点，则将其唤醒\n      doReleaseShared();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nsetHeadAndPropagate (Node, int) 方法主要作用是设置当前节点为头结点，并且将唤醒工作往下传递，在传递的过程中，其会判断被传递的节点是否是以共享模式尝试获取执行权限的，如果不是，则传递到该节点处为止（一般情况下，等待队列中都只会都是处于共享模式或者处于独占模式的节点）。也就是说，头结点会依次唤醒后续处于共享状态的节点，这也就是共享锁与独占锁的实现方式。这里 doReleaseShared () 方法也就是我们前面讲到的会将离头结点最近的一个处于等待状态的节点唤醒的方法。\n\n\n# countDown () 方法\n\nCountDownLatch 提供了 countDown () 方法递减计数器的值，如果计数到达 0，则释放所有等待的线程，该方法定义如下：\n\npublic void countDown() {\n    sync.releaseShared(1);\n}\n\n\n1\n2\n3\n\n\ncountDown () 方法调用了 AQS 的 releaseShared (int) 方法来释放共享锁同步状态：\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        //doReleaseShared()主要作用是唤醒调用了await()方法的线程\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nSync 类重写了 releaseShared (int) 方法：\n\n可以看到，在执行 sync.releaseShared (1) 方法时，其在调用 tryReleaseShared (int) 方法时会在无限 for 循环中设置 state 属性的值，设置成功之后其会根据设置的返回值（此时 state 已经自减了一），即当前线程是否为将 state 属性设置为 0 的线程，来判断是否执行 if 块中的代码（即doReleaseShared()）。\n\nprotected boolean tryReleaseShared(int releases) {\n    // Decrement count; signal when transition to zero\n    for (;;) {\n        // 获取同步状态\n        int c = getState();\n        // 同步状态为0，则直接返回\n        if (c == 0)\n            return false;\n        // 计算并更新同步状态\n        int nextc = c-1;\n        if (compareAndSetState(c, nextc))\n            return nextc == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndoReleaseShared () 方法主要作用是唤醒调用了 await () 方法的线程。需要注意的是，如果有多个线程调用了 await () 方法，这些线程都是以共享的方式等待在 await () 方法处的，试想，如果以独占的方式等待，那么当计数器减少至零时，就只有一个线程会被唤醒执行 await () 之后的代码，这显然不符合逻辑。如下是 doReleaseShared () 方法的实现代码：\n\nprivate void doReleaseShared() {\n  for (;;) {\n    Node h = head;  // 记录等待队列中的头结点的线程\n    if (h != null && h != tail) {   // 头结点不为空，且头结点不等于尾节点\n      int ws = h.waitStatus;\n      if (ws == Node.SIGNAL) {  // SIGNAL状态表示当前节点正在等待被唤醒\n        if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))    // 清除当前节点的等待状态\n          continue;\n        unparkSuccessor(h); // 唤醒当前节点的下一个节点\n      } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n        continue;\n    }\n    // 如果h还是指向头结点，说明前面这段代码执行过程中没有其他线程对头结点进行过处理\n    if (h == head)  \n      break;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考\n\nJava 并发编程之 CountDownLatch 详解\n\nCountDownLatch 详解',normalizedContent:'依靠 aqs类中锁标记 state 实现的，任务的分割与合并。\n\n\n\n * 适用场景\n * countdownlatch解析\n   * await () 方法\n   * countdown () 方法\n * 参考\n\n\n\n\n# 适用场景\n\n * 常和线程池共同出现，用做任务的分割合并，如：\n   \n   我们有90万数据，需要多线程多 sheet 页导出 excel，这时候就需要用到 countdownlatch 来将这一任务具体细分。\n   \n   1. 将导出 excel 看作一项大任务。\n   \n   2. 用线程池操作，导出的每个 sheet 页为其中一项小任务。\n      \n      2.1 告诉 countdownlatch 总任务数\n      \n      countdownlatch countdownlatch = new countdownlatch(任务总数);\n      \n      2.2 每完成一个任务就调用countdownlatch.countdown();（任务数-1）表示此项小任务已完成\n   \n   3. 在主线程调用countdownlatch.await();（即直到任务数为0时）等待所有小任务完成后，再执行其他操作。\n      \n      当然，为防止一直等待，可以加个超时时间countdownlatch.await(10l,timeunit.seconds);，超出时间后不再等待，直接唤醒 await 线程进行下一步操作。\n\n * 以上思路实例代码可见另一篇poi多线程多sheet导出excel,csv\n\n\n# countdownlatch解析\n\ncountdownlatch 类图如下:\n\n\n\n从图中可以看出，countdownlatch 内部依赖 sync 实现，而 sync 继承自 aqs。countdownlatch 仅提供了一个构造方法：\n\npublic countdownlatch(int count) {\n    if (count < 0) throw new illegalargumentexception("count < 0");\n\n    this.sync = new sync(count);\n}\n\n\n1\n2\n3\n4\n5\n\n\nsync 是 countdownlatch 的静态内部类，其定义也比较简单，如下所示：\n\nprivate static final class sync extends abstractqueuedsynchronizer {\n\n    private static final long serialversionuid = 4982264981922014374l;\n\n    // 设置同步状态值（锁标记）\n    sync(int count) {\n        setstate(count);\n    }\n\n    // 获取同步状态值\n    int getcount() {\n        return getstate();\n    }\n    \n    // 共享式获取同步状态\n    protected int tryacquireshared(int acquires) {\n        return (getstate() == 0) ? 1 : -1;\n    }\n\n    // 共享式释放同步状态\n    protected boolean tryreleaseshared(int releases) {\n        // decrement count; signal when transition to zero\n        for (;;) {\n            // 获取当前state属性的值\n            int c = getstate();\n            // 如果state为0，则说明当前计数器已经计数完成，直接返回\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            // 使用cas算法对state进行设置\n            if (compareandsetstate(c, nextc))\n                // 设置成功后返回当前是否为最后一个设置state的线程\n                return nextc == 0;\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# await () 方法\n\ncountdownlatch 提供了 await () 方法来使当前线程一直等待，直到计数器的值减为 0，或者线程被中断，该方法定义如下：\n\npublic void await() throws interruptedexception {\n    sync.acquiresharedinterruptibly(1);\n}\n\n\n1\n2\n3\n\n\nawait () 方法调用了 aqs 的共享式相应中断获取同步状态的方法，acquiresharedinterruptibly (int)，如下所示：\n\npublic final void acquiresharedinterruptibly(int arg)\n        throws interruptedexception {\n\n    if (thread.interrupted())\n        throw new interruptedexception();\n\n    if (tryacquireshared(arg) < 0)\n        doacquiresharedinterruptibly(arg);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nsync 类重写了 tryacquireshared (int) 方法：\n\nprotected int tryacquireshared(int acquires) {\n    return (getstate() == 0) ? 1 : -1;\n}\n\n\n1\n2\n3\n\n\n可以看到，只有当计数器（即同步状态）值为 0 时，才返回 1，即当前线程获取到了同步状态，在这里表示等待线程可以继续执行，若计数器值不是 0，则当前线程会调用 doacquiresharedinterruptibly (int) 方法，一直自旋去尝试获取同步状态：\n\nprivate void doacquiresharedinterruptibly(int arg) throws interruptedexception {\n  final node node = addwaiter(node.shared); // 使用当前线程创建一个共享模式的节点\n  boolean failed = true;\n  try {\n    for (;;) {\n      final node p = node.predecessor();    // 获取当前节点的前一个节点\n      if (p == head) {  // 判断前一个节点是否为头结点\n        int r = tryacquireshared(arg);  // 查看当前线程是否获取到了执行权限\n        if (r >= 0) {   // 大于0表示获取了执行权限\n          \n          /* 发现 r 大于 0（因为 state 已经被置为 0 了），\n           * 该线程就会调用 setheadandpropagate (node, int) 方法，\n           * 并且退出当前循环，\n           * 也就开始执行我们调用 await() 方法之后的代码\n           */\n          setheadandpropagate(node, r); // 将当前节点设置为头结点，并且唤醒后面处于等待状态的节点\n          p.next = null; // help gc\n          failed = false;\n          return;\n        }\n      }\n      \n      // 走到这一步说明没有获取到执行权限，就使当前线程进入“搁置”状态\n      if (shouldparkafterfailedacquire(p, node) &&\n          parkandcheckinterrupt())\n        throw new interruptedexception();\n    }\n  } finally {\n    if (failed)\n      cancelacquire(node);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这里我们看看 setheadandpropagate (node, int) 方法的具体实现：\n\nprivate void setheadandpropagate(node node, int propagate) {\n  node h = head;\n  sethead(node);    // 将当前节点设置为头节点\n  // 检查唤醒过程是否需要往下传递，并且检查头结点的等待状态\n  if (propagate > 0 || h == null || h.waitstatus < 0 ||\n      (h = head) == null || h.waitstatus < 0) {\n    node s = node.next;\n    if (s == null || s.isshared())  // 如果下一个节点是尝试以共享状态获取获取执行权限的节点，则将其唤醒\n      doreleaseshared();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nsetheadandpropagate (node, int) 方法主要作用是设置当前节点为头结点，并且将唤醒工作往下传递，在传递的过程中，其会判断被传递的节点是否是以共享模式尝试获取执行权限的，如果不是，则传递到该节点处为止（一般情况下，等待队列中都只会都是处于共享模式或者处于独占模式的节点）。也就是说，头结点会依次唤醒后续处于共享状态的节点，这也就是共享锁与独占锁的实现方式。这里 doreleaseshared () 方法也就是我们前面讲到的会将离头结点最近的一个处于等待状态的节点唤醒的方法。\n\n\n# countdown () 方法\n\ncountdownlatch 提供了 countdown () 方法递减计数器的值，如果计数到达 0，则释放所有等待的线程，该方法定义如下：\n\npublic void countdown() {\n    sync.releaseshared(1);\n}\n\n\n1\n2\n3\n\n\ncountdown () 方法调用了 aqs 的 releaseshared (int) 方法来释放共享锁同步状态：\n\npublic final boolean releaseshared(int arg) {\n    if (tryreleaseshared(arg)) {\n        //doreleaseshared()主要作用是唤醒调用了await()方法的线程\n        doreleaseshared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nsync 类重写了 releaseshared (int) 方法：\n\n可以看到，在执行 sync.releaseshared (1) 方法时，其在调用 tryreleaseshared (int) 方法时会在无限 for 循环中设置 state 属性的值，设置成功之后其会根据设置的返回值（此时 state 已经自减了一），即当前线程是否为将 state 属性设置为 0 的线程，来判断是否执行 if 块中的代码（即doreleaseshared()）。\n\nprotected boolean tryreleaseshared(int releases) {\n    // decrement count; signal when transition to zero\n    for (;;) {\n        // 获取同步状态\n        int c = getstate();\n        // 同步状态为0，则直接返回\n        if (c == 0)\n            return false;\n        // 计算并更新同步状态\n        int nextc = c-1;\n        if (compareandsetstate(c, nextc))\n            return nextc == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ndoreleaseshared () 方法主要作用是唤醒调用了 await () 方法的线程。需要注意的是，如果有多个线程调用了 await () 方法，这些线程都是以共享的方式等待在 await () 方法处的，试想，如果以独占的方式等待，那么当计数器减少至零时，就只有一个线程会被唤醒执行 await () 之后的代码，这显然不符合逻辑。如下是 doreleaseshared () 方法的实现代码：\n\nprivate void doreleaseshared() {\n  for (;;) {\n    node h = head;  // 记录等待队列中的头结点的线程\n    if (h != null && h != tail) {   // 头结点不为空，且头结点不等于尾节点\n      int ws = h.waitstatus;\n      if (ws == node.signal) {  // signal状态表示当前节点正在等待被唤醒\n        if (!compareandsetwaitstatus(h, node.signal, 0))    // 清除当前节点的等待状态\n          continue;\n        unparksuccessor(h); // 唤醒当前节点的下一个节点\n      } else if (ws == 0 && !compareandsetwaitstatus(h, 0, node.propagate))\n        continue;\n    }\n    // 如果h还是指向头结点，说明前面这段代码执行过程中没有其他线程对头结点进行过处理\n    if (h == head)  \n      break;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 参考\n\njava 并发编程之 countdownlatch 详解\n\ncountdownlatch 详解',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"HashMap底层实现和原理",frontmatter:{title:"HashMap底层实现和原理",date:"2019-06-13T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/HashMap.html",relativePath:"views/backend/HashMap.md",key:"v-0a438352",path:"/views/backend/HashMap.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"继承关系",slug:"继承关系",normalizedTitle:"继承关系",charIndex:9},{level:2,title:"实现原理",slug:"实现原理",normalizedTitle:"实现原理",charIndex:17},{level:2,title:"手写一个简单的HashMap",slug:"手写一个简单的hashmap",normalizedTitle:"手写一个简单的hashmap",charIndex:25},{level:2,title:"HashMap的扩容机制 resize()",slug:"hashmap的扩容机制-resize",normalizedTitle:"hashmap的扩容机制 resize()",charIndex:43},{level:3,title:"HashMap的负载因子",slug:"hashmap的负载因子",normalizedTitle:"hashmap的负载因子",charIndex:70},{level:3,title:"先说HashMap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)",slug:"先说hashmap底层数组长度扩容为什么是2的幂次方数-其实就是为了使hash均匀分组",normalizedTitle:"先说hashmap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)",charIndex:88},{level:3,title:"再来说HashMap的resize()",slug:"再来说hashmap的resize",normalizedTitle:"再来说hashmap的resize()",charIndex:138},{level:2,title:"HashMap面试题",slug:"hashmap面试题",normalizedTitle:"hashmap面试题",charIndex:161}],headersStr:"简介 继承关系 实现原理 手写一个简单的HashMap HashMap的扩容机制 resize() HashMap的负载因子 先说HashMap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组) 再来说HashMap的resize() HashMap面试题",content:' * 简介\n * 继承关系\n * 实现原理\n * 手写一个简单的HashMap\n * HashMap的扩容机制 resize()\n   * HashMap的负载因子\n   * 先说HashMap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)\n   * 再来说HashMap的resize()\n * HashMap面试题\n\n\n\n\n# 简介\n\n * HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射\n * HashMap采用了数组和链表的数据结构，方便继承了数组的线性查找和链表的寻址修改\n * HashMap是非synchronized（但是在rehash和扩容的时候可能出现并发问题），所以HashMap很快\n * HashMap可以接受null键和值，而Hashtable则不能（原因就是equlas()方法需要对象）\n\n\n# 继承关系\n\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable {\n\n\n1\n2\n\n\n\n# 实现原理\n\n * HashMap由数组+链表(+红黑树 1.8)来实现对数据的存储\n * 详细可以看：HashMap原理深入理解\n\n\n\n\n# 手写一个简单的HashMap\n\n * 很简单，就是看一下HashMap源码中定义了什么属性、方法，然后我们写一个简单的类继承HashMap，挑其中几个重要的方法做出实现就好了\n\npackage com.eee;\n\nimport java.util.HashMap;\n\n/**\n * @className: MyHashMap\n * @descripe: 模拟HashMap底层实现\n * @author: zpj\n * @date: 2019/6/7\n * @version: 1.0\n */\npublic class MyHashMap<key,value> extends HashMap<key,value>{\n\n    //定义一个数组\n    private Node<key,value>[] table; \n    //初始化数组容量大小为 16\n    private static Integer CSHSZRL = 16;\n    //定义一个size，用来统计HashMap内个数\n    private int size = 0;\n\n    public MyHashMap() {\n        //创建对象的时候就初始化数组\n        table = new Node[CSHSZRL];\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    @Override\n    public value get(Object key) {\n        //算出这个节点是在哪个hash组\n        int hash = key.hashCode();\n        int index = hash % table.length;\n\n        //遍历\n        for(Node<key,value> node = table[index];table[index]!=null;node.getNext()){\n            //新元素和老元素一样的话\n            if(node.getK().equals(key)){\n                return node.getV();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return super.containsKey(key);\n    }\n\n    /**\n     * HashMap的 put()方法\n     * @param key\n     * @param value\n     * @return 当put元素出现重复的时候，新元素覆盖老元素，返回老元素的value\n     */\n    @Override\n    public value put(key key, value value) {\n        //算出这个节点是在哪个hash组\n        int hash = key.hashCode();\n        int index = hash % table.length;\n\n        //新增元素时，遍历老元素，和新元素比较\n        for(Node<key,value> node = table[index];table[index]!=null;node.getNext()){\n            //新元素和老元素一样的话\n            if(node.k.equals(key)){\n                value oldValue = node.v;\n                node.v=value;\n                return oldValue;\n            }\n        }\n        \n        //当put第N个元素\n        addNode(key, value, index);\n\n        return null;\n    }\n\n    private void addNode(key key, value value, int index) {\n        //Node<key, value> node = new Node<>(key, value, null);//这个hash组是空的，put第一个元素\n        //table[index] = node;\n\n        //老节点对象\n        Node node = table[index];\n        //再把新的节点对象追加到原先节点头部,形成链表\n        table[index] = new Node(key,value,node);\n        //每增加一个元素，HashMap内 个数加1\n        size++;\n    }\n\n    @Override\n    public value remove(Object key) {\n        return super.remove(key);\n    }\n\n    /**\n     * 源码中定义了一个节点类对象，用来存放每个数据\n     * @param <K>\n     * @param <V>\n     */\n    static class Node<K,V> {\n\n        private K k;\n        private V v;\n        //用来充当链表\n        private Node<K,V> next;\n\n        //可以传入新元素，然后构成链表\n        public Node(K k, V v, Node<K, V> next) {\n            this.k = k;\n            this.v = v;\n            this.next = next;\n        }\n\n        public K getK() {\n            return k;\n        }\n\n        public V getV() {\n            return v;\n        }\n\n        public Node<K, V> getNext() {\n            return next;\n        }\n    }\n\n    public static void main(String[] args){\n        MyHashMap<String,String> myHashMap = new MyHashMap<>();\n        for (int x=0;x<10;x++){\n            myHashMap.put(x+"貂蝉",x+"貂蝉配吕布");\n        }\n        myHashMap.put("8貂蝉","8貂蝉戏吕布");\n        System.out.println(myHashMap.get("8貂蝉"));\n        System.out.println(myHashMap.size());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n\n\n\n# HashMap的扩容机制 resize()\n\n * 这一节是整个文章的重点，也是我学习的重点笔记，从这我也理解了为什么阿里规范手册中初始化HashMap的时候要指定大小。\n\n\n# HashMap的负载因子\n\n 1. 负载因子loadFactor保持在0.75f是在时间跟空间上达到一个平衡，实际上也就是说0.75f是效率相对比较高的\n\n\n# 先说HashMap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)\n\n 1. 只有当数组长度为2的幂次方时，hash&(length-1)才等价于h%length，即实现了key的hash定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率；\n\n 2. 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，再于 hash 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，再于 hash 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了（这几个数最后一位都是1，化为10进制为1，3，5，9，11，7，13），空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。\n\n\n# 再来说HashMap的resize()\n\n 1. 当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize()。\n\n 2. 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过扩容是2的幂次方数，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 < 1000, 也就是说为了让0.75 * size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。\n    \n    > 具体resize()的实现可以看：https://blog.csdn.net/u010890358/article/details/80496144\n\n\n# HashMap面试题\n\n 1.  hashmap的主要参数都有哪些？\n\n 2.  hashmap的数据结构是什么样子的？自己如何实现一个hashmap？\n\n 3.  hash计算规则是什么？\n\n 4.  说说hashmap的存取过程？\n\n 5.  说说hashmap如何处理碰撞的，或者说说它的扩容？\n     \n     == 答案 ==\n\n 6.  针对 HashMap 中某个 Entry 链太长，查找的时间复杂度可能达到 O(n)，怎么优化？\n\n 7.  如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？\n\n 8.  为什么String, Interger这样的类适合作为键？\n\n 9.  HashMap与HashTable区别，能否让HashMap同步？\n     \n     == 答案 ==\n\n 10. HashMap 的 table 的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？\n\n 11. HashMap 的遍历方式及其性能对比\n\n 12. HashMap，LinkedHashMap，TreeMap 有什么区别？\n\n 13. HashMap & TreeMap & LinkedHashMap 使用场景？\n\n 14. 为什么 ConcurrentHashMap 比 HashTable 效率要高，及ConcurrentHashMap？\n     \n     == 答案 ==\n\n 15. hashMap put()',normalizedContent:' * 简介\n * 继承关系\n * 实现原理\n * 手写一个简单的hashmap\n * hashmap的扩容机制 resize()\n   * hashmap的负载因子\n   * 先说hashmap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)\n   * 再来说hashmap的resize()\n * hashmap面试题\n\n\n\n\n# 简介\n\n * hashmap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射\n * hashmap采用了数组和链表的数据结构，方便继承了数组的线性查找和链表的寻址修改\n * hashmap是非synchronized（但是在rehash和扩容的时候可能出现并发问题），所以hashmap很快\n * hashmap可以接受null键和值，而hashtable则不能（原因就是equlas()方法需要对象）\n\n\n# 继承关系\n\npublic class hashmap<k,v> extends abstractmap<k,v>\n    implements map<k,v>, cloneable, serializable {\n\n\n1\n2\n\n\n\n# 实现原理\n\n * hashmap由数组+链表(+红黑树 1.8)来实现对数据的存储\n * 详细可以看：hashmap原理深入理解\n\n\n\n\n# 手写一个简单的hashmap\n\n * 很简单，就是看一下hashmap源码中定义了什么属性、方法，然后我们写一个简单的类继承hashmap，挑其中几个重要的方法做出实现就好了\n\npackage com.eee;\n\nimport java.util.hashmap;\n\n/**\n * @classname: myhashmap\n * @descripe: 模拟hashmap底层实现\n * @author: zpj\n * @date: 2019/6/7\n * @version: 1.0\n */\npublic class myhashmap<key,value> extends hashmap<key,value>{\n\n    //定义一个数组\n    private node<key,value>[] table; \n    //初始化数组容量大小为 16\n    private static integer cshszrl = 16;\n    //定义一个size，用来统计hashmap内个数\n    private int size = 0;\n\n    public myhashmap() {\n        //创建对象的时候就初始化数组\n        table = new node[cshszrl];\n    }\n\n    @override\n    public int size() {\n        return size;\n    }\n\n    @override\n    public value get(object key) {\n        //算出这个节点是在哪个hash组\n        int hash = key.hashcode();\n        int index = hash % table.length;\n\n        //遍历\n        for(node<key,value> node = table[index];table[index]!=null;node.getnext()){\n            //新元素和老元素一样的话\n            if(node.getk().equals(key)){\n                return node.getv();\n            }\n        }\n        return null;\n    }\n\n    @override\n    public boolean containskey(object key) {\n        return super.containskey(key);\n    }\n\n    /**\n     * hashmap的 put()方法\n     * @param key\n     * @param value\n     * @return 当put元素出现重复的时候，新元素覆盖老元素，返回老元素的value\n     */\n    @override\n    public value put(key key, value value) {\n        //算出这个节点是在哪个hash组\n        int hash = key.hashcode();\n        int index = hash % table.length;\n\n        //新增元素时，遍历老元素，和新元素比较\n        for(node<key,value> node = table[index];table[index]!=null;node.getnext()){\n            //新元素和老元素一样的话\n            if(node.k.equals(key)){\n                value oldvalue = node.v;\n                node.v=value;\n                return oldvalue;\n            }\n        }\n        \n        //当put第n个元素\n        addnode(key, value, index);\n\n        return null;\n    }\n\n    private void addnode(key key, value value, int index) {\n        //node<key, value> node = new node<>(key, value, null);//这个hash组是空的，put第一个元素\n        //table[index] = node;\n\n        //老节点对象\n        node node = table[index];\n        //再把新的节点对象追加到原先节点头部,形成链表\n        table[index] = new node(key,value,node);\n        //每增加一个元素，hashmap内 个数加1\n        size++;\n    }\n\n    @override\n    public value remove(object key) {\n        return super.remove(key);\n    }\n\n    /**\n     * 源码中定义了一个节点类对象，用来存放每个数据\n     * @param <k>\n     * @param <v>\n     */\n    static class node<k,v> {\n\n        private k k;\n        private v v;\n        //用来充当链表\n        private node<k,v> next;\n\n        //可以传入新元素，然后构成链表\n        public node(k k, v v, node<k, v> next) {\n            this.k = k;\n            this.v = v;\n            this.next = next;\n        }\n\n        public k getk() {\n            return k;\n        }\n\n        public v getv() {\n            return v;\n        }\n\n        public node<k, v> getnext() {\n            return next;\n        }\n    }\n\n    public static void main(string[] args){\n        myhashmap<string,string> myhashmap = new myhashmap<>();\n        for (int x=0;x<10;x++){\n            myhashmap.put(x+"貂蝉",x+"貂蝉配吕布");\n        }\n        myhashmap.put("8貂蝉","8貂蝉戏吕布");\n        system.out.println(myhashmap.get("8貂蝉"));\n        system.out.println(myhashmap.size());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n\n\n\n# hashmap的扩容机制 resize()\n\n * 这一节是整个文章的重点，也是我学习的重点笔记，从这我也理解了为什么阿里规范手册中初始化hashmap的时候要指定大小。\n\n\n# hashmap的负载因子\n\n 1. 负载因子loadfactor保持在0.75f是在时间跟空间上达到一个平衡，实际上也就是说0.75f是效率相对比较高的\n\n\n# 先说hashmap底层数组长度扩容为什么是2的幂次方数(其实就是为了使hash均匀分组)\n\n 1. 只有当数组长度为2的幂次方时，hash&(length-1)才等价于h%length，即实现了key的hash定位，2的幂次方也可以减少冲突次数，提高hashmap的查询效率；\n\n 2. 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，再于 hash 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，再于 hash 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了（这几个数最后一位都是1，化为10进制为1，3，5，9，11，7，13），空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。\n\n\n# 再来说hashmap的resize()\n\n 1. 当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在arraylist中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize()。\n\n 2. 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadfactor时，就会进行数组扩容，loadfactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new hashmap(1000), 但是理论上来讲new hashmap(1024)更合适，不过扩容是2的幂次方数，即使是1000，hashmap也自动会将其设置为1024。 但是new hashmap(1024)还不是更合适的，因为0.75*1000 < 1000, 也就是说为了让0.75 * size > 1000, 我们必须这样new hashmap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。\n    \n    > 具体resize()的实现可以看：https://blog.csdn.net/u010890358/article/details/80496144\n\n\n# hashmap面试题\n\n 1.  hashmap的主要参数都有哪些？\n\n 2.  hashmap的数据结构是什么样子的？自己如何实现一个hashmap？\n\n 3.  hash计算规则是什么？\n\n 4.  说说hashmap的存取过程？\n\n 5.  说说hashmap如何处理碰撞的，或者说说它的扩容？\n     \n     == 答案 ==\n\n 6.  针对 hashmap 中某个 entry 链太长，查找的时间复杂度可能达到 o(n)，怎么优化？\n\n 7.  如果hashmap的大小超过了负载因子(load factor)定义的容量，怎么办？\n\n 8.  为什么string, interger这样的类适合作为键？\n\n 9.  hashmap与hashtable区别，能否让hashmap同步？\n     \n     == 答案 ==\n\n 10. hashmap 的 table 的容量如何确定？loadfactor 是什么？ 该容量如何变化？这种变化会带来什么问题？\n\n 11. hashmap 的遍历方式及其性能对比\n\n 12. hashmap，linkedhashmap，treemap 有什么区别？\n\n 13. hashmap & treemap & linkedhashmap 使用场景？\n\n 14. 为什么 concurrenthashmap 比 hashtable 效率要高，及concurrenthashmap？\n     \n     == 答案 ==\n\n 15. hashmap put()',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"JUC小结",frontmatter:{title:"JUC小结",date:"2020-03-11T00:00:00.000Z",tags:["Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/JUC.html",relativePath:"views/backend/JUC.md",key:"v-8b8c23d2",path:"/views/backend/JUC.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"volatile关键字",slug:"volatile关键字",normalizedTitle:"volatile关键字",charIndex:9},{level:2,title:"CAS原子类",slug:"cas原子类",normalizedTitle:"cas原子类",charIndex:24},{level:3,title:"ABA问题的解决",slug:"aba问题的解决",normalizedTitle:"aba问题的解决",charIndex:36},{level:2,title:"JUC下的常见类",slug:"juc下的常见类",normalizedTitle:"juc下的常见类",charIndex:48},{level:3,title:"JUC下的一些并发容器类：",slug:"juc下的一些并发容器类",normalizedTitle:"juc下的一些并发容器类：",charIndex:62},{level:3,title:"未完待续",slug:"未完待续",normalizedTitle:"未完待续",charIndex:81}],headersStr:"简介 volatile关键字 CAS原子类 ABA问题的解决 JUC下的常见类 JUC下的一些并发容器类： 未完待续",content:' * 简介\n * volatile关键字\n * CAS原子类\n   * ABA问题的解决\n * JUC下的常见类\n   * JUC下的一些并发容器类：\n   * 未完待续\n\n\n\n\n# 简介\n\n * 自JDK1.5出现的，JUC（Java并发包）就是java.util .concurrent工具包的简称。\n * 所属位置：jre1.8.0/lib/rj.jar，在jvm中rj.jar由👉bootsrap.classloader加载器通过双亲委派机制加载到内存。\n\n\n# volatile关键字\n\n * Java中各线程变量都是私有的，为 保证多线程共享数据，常用volatile 关键字修饰数据以保证共享数据在内存中的可见性。\n\n * 各线程数据都是从主内存中copy过来的，某一线程修改完数据之后再回写到主内存中去，加volatile就相当于一旦有一个线程修改完数据的同时主内存数据也修改同时通知其它线程这个数据已被修改其它线程停止对这个数据的所有操作（加volatile可以理解为直接操作主内存）\n   \n   public class TestVolatile {\n       public static void main(String[] args){ //这个线程是用来读取flag的值的\n           ThreadDemo threadDemo = new ThreadDemo();\n           Thread thread = new Thread(threadDemo);\n           thread.start();\n           while (true){\n               if (threadDemo.isFlag()){\n                   System.out.println("主线程读取到的flag = " + threadDemo.isFlag());\n                   break;\n               }\n           }\n       }\n   }\n   \n   @Data\n   class ThreadDemo implements Runnable{ //这个线程是用来修改flag的值的\n       public  boolean flag = false;\n       \n       //加volatile保证flag在主线程的可见性\n       //public  volatile boolean flag = false;\n       \n       @Override\n       public void run() {\n           try {\n               Thread.sleep(200);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n           flag = true;\n           System.out.println("ThreadDemo线程修改后的flag = " + isFlag());\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n * volatile和synchronized的区别：\n   \n   volatile禁止指令重排序。 volatile不具备互斥性(当一个线程持有锁时，其他线程进不来，这就是互斥性)。 volatile保证可见性但是不具备原子性(保证原子性：1.加锁、2.使用volatile保证可见，使用CAS原子类保证原子性)。\n\n\n# CAS原子类\n\n * CAS：CompareAndSet，CAS涉及3个元素:内存地址、期盼值和目标值，只有内存地址对应的值和期望的值相同时，才把内存地址对应的值修改为目标值。\n\n * CAS的缺点：\n   \n   * 效率低：底层采用遍历比较的方式，如果期望值和当前值比较不成功则会一直循环，时间一长导致CPU开销过大\n   \n   * 可能导致ABA问题：假设2个线程读取了主内存中的共享变量。如果一个线程对主内存中的值进行了修改后，又把新值改回了原来的值，而此时另一个线程进行CAS操作，发现原值和期盼的值是一样的，就顺利的进行了CAS操作。这就是CAS引发的ABA问题\n\n\n# ABA问题的解决\n\n * juc的atomic包下提供了AtomicStampedReference类，它相较于普通的Atomic原子类多增加了一个版本号的字段（相当于svn，git的版本号机制）\n * ABA问题的演示与解决\n\npackage com.zpj80321.znote.juc.volatiles;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\n/**\n * @Description : TODO 测试ABA问题的产生与解决\n */\npublic class ABA {\n\n    public static void main(String[] args) throws Exception\n    {\n        System.out.println("ABA问题的演示---------------------------------");\n        AtomicReference<Integer> atomicReference = new AtomicReference<>(10);\n\n        new Thread(()->{\n            //先将数据修改成其他值,再修改回原值\n            System.out.println(atomicReference.compareAndSet(10 , 11));\n            //修改回原值 :10\n            System.out.println(atomicReference.compareAndSet(11, 10));\n        },"A").start();\n\n        new Thread(()->{\n            try\n            {\n                //让当前线程停止3秒中,让 A 线程先完成ABA问题的修改,然后此线程再执行\n                TimeUnit.SECONDS.sleep(3);\n\n                System.out.println("经过ABA操作后,数据修改: "+\n                        atomicReference.compareAndSet(10,11)+" 为: " + atomicReference.get());\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            }\n        },"B").start();\n\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println("\\n\\nABA问题的解决办法---------------------------------------------------");\n\n        AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(10,1);\n\n        new Thread(()->{\n\t\t\t//当前值，期望值，当前版本号，期望版本号\n            atomicStampedReference.compareAndSet(10,11,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);\n                //更改值的时候也更改版本号\n                System.out.println("C线程第一次修改后的版号为 ：　" +atomicStampedReference.getStamp());\n                //改回原值也要更新版本号\n                atomicStampedReference.compareAndSet(11,10,\n                        atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);\n                System.out.println("C线程第二次修改后的版号为 ：　" +atomicStampedReference.getStamp());\n        },"C").start();\n\n        new Thread(()->{\n            try\n            {\n                TimeUnit.SECONDS.sleep(3);\n                System.out.println(\n                        "D线程修改: "\n                                +\n                         atomicStampedReference.compareAndSet(10,11,1,atomicStampedReference.getStamp()+1)\n                );\n\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            }\n        },"D").start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# JUC下的常见类\n\n * JUC的atomic包下运用了CAS的AtomicBoolean、AtomicInteger、AtomicReference等原子变量类\n\n * JUC的locks包下的AbstractQueuedSynchronizer（AQS）以及使用AQS的ReentantLock（显式锁）、ReentrantReadWriteLock\n   \n   附：运用了AQS的类还有：Semaphore、CountDownLatch、ReentantLock（显式锁）、ReentrantReadWriteLock\n\n * JUC下的一些同步工具类：CountDownLatch（闭锁）、Semaphore（信号量）、CyclicBarrier（栅栏）、FutureTask\n\n\n# JUC下的一些并发容器类：\n\n 1. 使用写时复制类 CopyOnWriteArrayList，此类适合读多写少的场合,它的性能比Vector好的多。\n    \n    * 它的读取方法没有使用加锁操作，而是在使用add，set等修改操作的时候将原内容和要修改的内容复制到新的副本中，写完后，再将副本赋予原数据。\n    \n    /**\n      * Appends the specified element to the end of this list.\n      *\n      * @param e element to be appended to this list\n      * @return {@code true} (as specified by {@link Collection#add})\n      */\n    public boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    /**\n      * 实现CopyOnWriteArraySet需要用到的方法\n      */\n    public boolean addIfAbsent(E e) {\n        Object[] snapshot = getArray();\n        return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n        addIfAbsent(e, snapshot);\n    }\n    private static int indexOf(Object o, Object[] elements,\n                                   int index, int fence) {\n        if (o == null) {\n            for (int i = index; i < fence; i++)\n                if (elements[i] == null)\n                    return i;\n        } else {\n            for (int i = index; i < fence; i++)\n                if (o.equals(elements[i]))\n                    return i;\n        }\n        return -1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    \n\n 2. CopyOnWriteArraySet： 值得一提的是：CopyOnWriteArraySet使用CopyOnWriteArrayList实现。\n    \n    private final CopyOnWriteArrayList<E> al;\n    \n    public boolean add(E e) {\n        //还是遍历list，看是否有这个元素\n        return al.addIfAbsent(e);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 3. ConcurrentHashMap: 并发map，很好的支持高性能和高并发（分段锁）。\n    \n    * jdk1.7之前使用分段数组+链表实现。jdk1.8后使用 数组+链表/红黑树 实现\n    \n    * jdk1.7之前给每段数据加锁，当一个线程访问其中一段数据时，其他数据也能被其他线程访问，也是非常的高效\n    \n    * jdk1.8后使用数组+链表/红黑树实现，其扩容等机制与HashMap一样，但是控制并发的方法改为了CAS+synchronized\n      \n      synchronized锁的只是链表的首节点或红黑树的首节点，这样一来，只要节点不冲突(hash不冲突)，synchronized也不会触发，更加高效\n\n\n# 未完待续',normalizedContent:' * 简介\n * volatile关键字\n * cas原子类\n   * aba问题的解决\n * juc下的常见类\n   * juc下的一些并发容器类：\n   * 未完待续\n\n\n\n\n# 简介\n\n * 自jdk1.5出现的，juc（java并发包）就是java.util .concurrent工具包的简称。\n * 所属位置：jre1.8.0/lib/rj.jar，在jvm中rj.jar由👉bootsrap.classloader加载器通过双亲委派机制加载到内存。\n\n\n# volatile关键字\n\n * java中各线程变量都是私有的，为 保证多线程共享数据，常用volatile 关键字修饰数据以保证共享数据在内存中的可见性。\n\n * 各线程数据都是从主内存中copy过来的，某一线程修改完数据之后再回写到主内存中去，加volatile就相当于一旦有一个线程修改完数据的同时主内存数据也修改同时通知其它线程这个数据已被修改其它线程停止对这个数据的所有操作（加volatile可以理解为直接操作主内存）\n   \n   public class testvolatile {\n       public static void main(string[] args){ //这个线程是用来读取flag的值的\n           threaddemo threaddemo = new threaddemo();\n           thread thread = new thread(threaddemo);\n           thread.start();\n           while (true){\n               if (threaddemo.isflag()){\n                   system.out.println("主线程读取到的flag = " + threaddemo.isflag());\n                   break;\n               }\n           }\n       }\n   }\n   \n   @data\n   class threaddemo implements runnable{ //这个线程是用来修改flag的值的\n       public  boolean flag = false;\n       \n       //加volatile保证flag在主线程的可见性\n       //public  volatile boolean flag = false;\n       \n       @override\n       public void run() {\n           try {\n               thread.sleep(200);\n           } catch (interruptedexception e) {\n               e.printstacktrace();\n           }\n           flag = true;\n           system.out.println("threaddemo线程修改后的flag = " + isflag());\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n * volatile和synchronized的区别：\n   \n   volatile禁止指令重排序。 volatile不具备互斥性(当一个线程持有锁时，其他线程进不来，这就是互斥性)。 volatile保证可见性但是不具备原子性(保证原子性：1.加锁、2.使用volatile保证可见，使用cas原子类保证原子性)。\n\n\n# cas原子类\n\n * cas：compareandset，cas涉及3个元素:内存地址、期盼值和目标值，只有内存地址对应的值和期望的值相同时，才把内存地址对应的值修改为目标值。\n\n * cas的缺点：\n   \n   * 效率低：底层采用遍历比较的方式，如果期望值和当前值比较不成功则会一直循环，时间一长导致cpu开销过大\n   \n   * 可能导致aba问题：假设2个线程读取了主内存中的共享变量。如果一个线程对主内存中的值进行了修改后，又把新值改回了原来的值，而此时另一个线程进行cas操作，发现原值和期盼的值是一样的，就顺利的进行了cas操作。这就是cas引发的aba问题\n\n\n# aba问题的解决\n\n * juc的atomic包下提供了atomicstampedreference类，它相较于普通的atomic原子类多增加了一个版本号的字段（相当于svn，git的版本号机制）\n * aba问题的演示与解决\n\npackage com.zpj80321.znote.juc.volatiles;\n\nimport java.util.concurrent.timeunit;\nimport java.util.concurrent.atomic.atomicreference;\nimport java.util.concurrent.atomic.atomicstampedreference;\n\n/**\n * @description : todo 测试aba问题的产生与解决\n */\npublic class aba {\n\n    public static void main(string[] args) throws exception\n    {\n        system.out.println("aba问题的演示---------------------------------");\n        atomicreference<integer> atomicreference = new atomicreference<>(10);\n\n        new thread(()->{\n            //先将数据修改成其他值,再修改回原值\n            system.out.println(atomicreference.compareandset(10 , 11));\n            //修改回原值 :10\n            system.out.println(atomicreference.compareandset(11, 10));\n        },"a").start();\n\n        new thread(()->{\n            try\n            {\n                //让当前线程停止3秒中,让 a 线程先完成aba问题的修改,然后此线程再执行\n                timeunit.seconds.sleep(3);\n\n                system.out.println("经过aba操作后,数据修改: "+\n                        atomicreference.compareandset(10,11)+" 为: " + atomicreference.get());\n            }\n            catch(exception e)\n            {\n                e.printstacktrace();\n            }\n        },"b").start();\n\n        timeunit.seconds.sleep(4);\n        system.out.println("\\n\\naba问题的解决办法---------------------------------------------------");\n\n        atomicstampedreference<integer> atomicstampedreference = new atomicstampedreference<>(10,1);\n\n        new thread(()->{\n\t\t\t//当前值，期望值，当前版本号，期望版本号\n            atomicstampedreference.compareandset(10,11,atomicstampedreference.getstamp(),atomicstampedreference.getstamp()+1);\n                //更改值的时候也更改版本号\n                system.out.println("c线程第一次修改后的版号为 ：　" +atomicstampedreference.getstamp());\n                //改回原值也要更新版本号\n                atomicstampedreference.compareandset(11,10,\n                        atomicstampedreference.getstamp(),atomicstampedreference.getstamp()+1);\n                system.out.println("c线程第二次修改后的版号为 ：　" +atomicstampedreference.getstamp());\n        },"c").start();\n\n        new thread(()->{\n            try\n            {\n                timeunit.seconds.sleep(3);\n                system.out.println(\n                        "d线程修改: "\n                                +\n                         atomicstampedreference.compareandset(10,11,1,atomicstampedreference.getstamp()+1)\n                );\n\n            }\n            catch(exception e)\n            {\n                e.printstacktrace();\n            }\n        },"d").start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# juc下的常见类\n\n * juc的atomic包下运用了cas的atomicboolean、atomicinteger、atomicreference等原子变量类\n\n * juc的locks包下的abstractqueuedsynchronizer（aqs）以及使用aqs的reentantlock（显式锁）、reentrantreadwritelock\n   \n   附：运用了aqs的类还有：semaphore、countdownlatch、reentantlock（显式锁）、reentrantreadwritelock\n\n * juc下的一些同步工具类：countdownlatch（闭锁）、semaphore（信号量）、cyclicbarrier（栅栏）、futuretask\n\n\n# juc下的一些并发容器类：\n\n 1. 使用写时复制类 copyonwritearraylist，此类适合读多写少的场合,它的性能比vector好的多。\n    \n    * 它的读取方法没有使用加锁操作，而是在使用add，set等修改操作的时候将原内容和要修改的内容复制到新的副本中，写完后，再将副本赋予原数据。\n    \n    /**\n      * appends the specified element to the end of this list.\n      *\n      * @param e element to be appended to this list\n      * @return {@code true} (as specified by {@link collection#add})\n      */\n    public boolean add(e e) {\n        final reentrantlock lock = this.lock;\n        lock.lock();\n        try {\n            object[] elements = getarray();\n            int len = elements.length;\n            object[] newelements = arrays.copyof(elements, len + 1);\n            newelements[len] = e;\n            setarray(newelements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    /**\n      * 实现copyonwritearrayset需要用到的方法\n      */\n    public boolean addifabsent(e e) {\n        object[] snapshot = getarray();\n        return indexof(e, snapshot, 0, snapshot.length) >= 0 ? false :\n        addifabsent(e, snapshot);\n    }\n    private static int indexof(object o, object[] elements,\n                                   int index, int fence) {\n        if (o == null) {\n            for (int i = index; i < fence; i++)\n                if (elements[i] == null)\n                    return i;\n        } else {\n            for (int i = index; i < fence; i++)\n                if (o.equals(elements[i]))\n                    return i;\n        }\n        return -1;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    \n\n 2. copyonwritearrayset： 值得一提的是：copyonwritearrayset使用copyonwritearraylist实现。\n    \n    private final copyonwritearraylist<e> al;\n    \n    public boolean add(e e) {\n        //还是遍历list，看是否有这个元素\n        return al.addifabsent(e);\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 3. concurrenthashmap: 并发map，很好的支持高性能和高并发（分段锁）。\n    \n    * jdk1.7之前使用分段数组+链表实现。jdk1.8后使用 数组+链表/红黑树 实现\n    \n    * jdk1.7之前给每段数据加锁，当一个线程访问其中一段数据时，其他数据也能被其他线程访问，也是非常的高效\n    \n    * jdk1.8后使用数组+链表/红黑树实现，其扩容等机制与hashmap一样，但是控制并发的方法改为了cas+synchronized\n      \n      synchronized锁的只是链表的首节点或红黑树的首节点，这样一来，只要节点不冲突(hash不冲突)，synchronized也不会触发，更加高效\n\n\n# 未完待续',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"EasyExcel",frontmatter:{title:"EasyExcel",date:"2022-01-10T00:00:00.000Z",tags:["poi","分布式"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/EasyExcel.html",relativePath:"views/backend/EasyExcel.md",key:"v-229bb1b7",path:"/views/backend/EasyExcel.html",headers:[{level:2,title:"EasyExcel简介",slug:"easyexcel简介",normalizedTitle:"easyexcel简介",charIndex:132},{level:2,title:"集成",slug:"集成",normalizedTitle:"集成",charIndex:147},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:153},{level:3,title:"简单导出",slug:"简单导出",normalizedTitle:"简单导出",charIndex:161},{level:3,title:"简单导入",slug:"简单导入",normalizedTitle:"简单导入",charIndex:171},{level:3,title:"复杂导出",slug:"复杂导出",normalizedTitle:"复杂导出",charIndex:181},{level:4,title:"使用EasyPoi实现",slug:"使用easypoi实现",normalizedTitle:"使用easypoi实现",charIndex:5881},{level:4,title:"寻找方案",slug:"寻找方案",normalizedTitle:"寻找方案",charIndex:5987},{level:4,title:"解决思路",slug:"解决思路",normalizedTitle:"解决思路",charIndex:6200},{level:4,title:"实现过程",slug:"实现过程",normalizedTitle:"实现过程",charIndex:6330},{level:3,title:"其他使用",slug:"其他使用",normalizedTitle:"其他使用",charIndex:191},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:199},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:205},{level:2,title:"项目源码地址",slug:"项目源码地址",normalizedTitle:"项目源码地址",charIndex:213}],excerpt:'<Boxx/>\n<p>操作Excel实现导入导出是个非常常见的需求，之前介绍了一款非常好用的工具<a href="https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&amp;mid=2247494886&amp;idx=1&amp;sn=7b9a4ff5aacc7d5f109ea8ee2babd06a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">EasyPoi<OutboundLink/></a> 。有读者提出在数据量大的情况下，EasyPoi占用内存大，性能不够好。今天给大家推荐一款性能更好的Excel导入导出工具<code>EasyExcel</code>，希望对大家有所帮助！</p>\n',headersStr:"EasyExcel简介 集成 使用 简单导出 简单导入 复杂导出 使用EasyPoi实现 寻找方案 解决思路 实现过程 其他使用 总结 参考资料 项目源码地址",content:'操作Excel实现导入导出是个非常常见的需求，之前介绍了一款非常好用的工具EasyPoi 。有读者提出在数据量大的情况下，EasyPoi占用内存大，性能不够好。今天给大家推荐一款性能更好的Excel导入导出工具EasyExcel，希望对大家有所帮助！\n\n\n\n * EasyExcel简介\n * 集成\n * 使用\n   * 简单导出\n   * 简单导入\n   * 复杂导出\n   * 其他使用\n * 总结\n * 参考资料\n * 项目源码地址\n\n\n\n\n# EasyExcel简介\n\n官方文档：传送门\n\nEasyExcel是一款阿里开源的Excel导入导出工具，具有处理快速、占用内存小、使用方便的特点，在Github上已有22k+Star，可见其非常流行。\n\nEasyExcel读取75M(46W行25列)的Excel，仅需使用64M内存，耗时20s，极速模式还可以更快！\n\n\n\n\n# 集成\n\n> 在SpringBoot中集成EasyExcel非常简单，仅需一个依赖即可。\n\n\x3c!--EasyExcel相关依赖--\x3e\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>easyexcel</artifactId>\n    <version>3.0.5</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 使用\n\n> EasyExcel和EasyPoi的使用非常类似，都是通过注解来控制导入导出。接下来我们以会员信息和订单信息的导入导出为例，分别实现下简单的单表导出和具有一对多关系的复杂导出。\n\n\n# 简单导出\n\n> 我们以会员信息的导出为例，来体验下EasyExcel的导出功能。\n\n * 首先创建一个会员对象Member，封装会员信息，这里使用了EasyExcel的注解；\n\n/**\n * 购物会员\n * Created by macro on 2021/10/12.\n */\n@Data\n@EqualsAndHashCode(callSuper = false)\npublic class Member {\n    @ExcelProperty("ID")\n    @ColumnWidth(10)\n    private Long id;\n    @ExcelProperty("用户名")\n    @ColumnWidth(20)\n    private String username;\n    @ExcelIgnore\n    private String password;\n    @ExcelProperty("昵称")\n    @ColumnWidth(20)\n    private String nickname;\n    @ExcelProperty("出生日期")\n    @ColumnWidth(20)\n    @DateTimeFormat("yyyy-MM-dd")\n    private Date birthday;\n    @ExcelProperty("手机号")\n    @ColumnWidth(20)\n    private String phone;\n    @ExcelIgnore\n    private String icon;\n    @ExcelProperty(value = "性别", converter = GenderConverter.class)\n    @ColumnWidth(10)\n    private Integer gender;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n * 上面代码使用到了EasyExcel的核心注解，我们分别来了解下：\n\n * * @ExcelProperty：核心注解，value属性可用来设置表头名称，converter属性可以用来设置类型转换器；\n   * @ColumnWidth：用于设置表格列的宽度；\n   * @DateTimeFormat：用于设置日期转换格式。\n\n * 在EasyExcel中，如果你想实现枚举类型到字符串的转换（比如gender属性中，0->男，1->女），需要自定义转换器，下面为自定义的GenderConverter代码实现；\n\n/**\n * excel性别转换器\n * Created by macro on 2021/12/29.\n */\npublic class GenderConverter implements Converter<Integer> {\n    @Override\n    public Class<?> supportJavaTypeKey() {\n        //对象属性类型\n        return Integer.class;\n    }\n\n    @Override\n    public CellDataTypeEnum supportExcelTypeKey() {\n        //CellData属性类型\n        return CellDataTypeEnum.STRING;\n    }\n\n    @Override\n    public Integer convertToJavaData(ReadConverterContext<?> context) throws Exception {\n        //CellData转对象属性\n        String cellStr = context.getReadCellData().getStringValue();\n        if (StrUtil.isEmpty(cellStr)) return null;\n        if ("男".equals(cellStr)) {\n            return 0;\n        } else if ("女".equals(cellStr)) {\n            return 1;\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public WriteCellData<?> convertToExcelData(WriteConverterContext<Integer> context) throws Exception {\n        //对象属性转CellData\n        Integer cellValue = context.getValue();\n        if (cellValue == null) {\n            return new WriteCellData<>("");\n        }\n        if (cellValue == 0) {\n            return new WriteCellData<>("男");\n        } else if (cellValue == 1) {\n            return new WriteCellData<>("女");\n        } else {\n            return new WriteCellData<>("");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * 接下来我们在Controller中添加一个接口，用于导出会员列表到Excel，还需给响应头设置下载excel的属性，具体代码如下；\n\n/**\n * EasyExcel导入导出测试Controller\n * Created by macro on 2021/10/12.\n */\n@Controller\n@Api(tags = "EasyExcelController", description = "EasyExcel导入导出测试")\n@RequestMapping("/easyExcel")\npublic class EasyExcelController {\n\n    @SneakyThrows(IOException.class)\n    @ApiOperation(value = "导出会员列表Excel")\n    @RequestMapping(value = "/exportMemberList", method = RequestMethod.GET)\n    public void exportMemberList(HttpServletResponse response) {\n        setExcelRespProp(response, "会员列表");\n        List<Member> memberList = LocalJsonUtil.getListFromJson("json/members.json", Member.class);\n        EasyExcel.write(response.getOutputStream())\n                .head(Member.class)\n                .excelType(ExcelTypeEnum.XLSX)\n                .sheet("会员列表")\n                .doWrite(memberList);\n    }\n    \n  /**\n   * 设置excel下载响应头属性\n   */\n  private void setExcelRespProp(HttpServletResponse response, String rawFileName) throws UnsupportedEncodingException {\n    response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");\n    response.setCharacterEncoding("utf-8");\n    String fileName = URLEncoder.encode(rawFileName, "UTF-8").replaceAll("\\\\+", "%20");\n    response.setHeader("Content-disposition", "attachment;filename*=utf-8\'\'" + fileName + ".xlsx");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 运行项目，通过Swagger测试接口，注意在Swagger中访问接口无法直接下载，需要点击返回结果中的下载按钮才行，访问地址：http://localhost:8088/swagger-ui/\n\n\n\n * 下载完成后，查看下文件，一个标准的Excel文件已经被导出了。\n\n\n\n\n# 简单导入\n\n> 接下来我们以会员信息的导入为例，来体验下EasyExcel的导入功能。\n\n * 在Controller中添加会员信息导入的接口，这里需要注意的是使用@RequestPart注解修饰文件上传参数，否则在Swagger中就没法显示上传按钮了；\n\n/**\n * EasyExcel导入导出测试Controller\n * Created by macro on 2021/10/12.\n */\n@Controller\n@Api(tags = "EasyExcelController", description = "EasyExcel导入导出测试")\n@RequestMapping("/easyExcel")\npublic class EasyExcelController {\n    \n    @SneakyThrows\n    @ApiOperation("从Excel导入会员列表")\n    @RequestMapping(value = "/importMemberList", method = RequestMethod.POST)\n    @ResponseBody\n    public CommonResult importMemberList(@RequestPart("file") MultipartFile file) {\n        List<Member> memberList = EasyExcel.read(file.getInputStream())\n                .head(Member.class)\n                .sheet()\n                .doReadSync();\n        return CommonResult.success(memberList);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 然后在Swagger中测试接口，选择之前导出的Excel文件即可，导入成功后会返回解析到的数据。\n\n\n\n\n# 复杂导出\n\n> 当然EasyExcel也可以实现更加复杂的导出，比如导出一个嵌套了商品信息的订单列表，下面我们来实现下！\n\n# 使用EasyPoi实现\n\n之前我们使用过EasyPoi实现该功能，由于EasyPoi本来就支持嵌套对象的导出，直接使用内置的@ExcelCollection注解即可实现，非常方便也符合面向对象的思想。\n\n\n\n# 寻找方案\n\n> 由于EasyExcel本身并不支持这种一对多的信息导出，所以我们得自行实现下，这里分享一个我平时常用的快速查找解决方案的办法。\n\n我们可以直接从开源项目的issues里面去搜索，比如搜索下一对多，会直接找到有无一对多导出比较优雅的方案这个issue。\n\n\n\n从此issue的回复我们可以发现，项目维护者建议创建自定义合并策略来实现，有位回复的老哥已经给出了实现代码，接下来我们就用这个方案来实现下。\n\n\n\n# 解决思路\n\n为什么自定义单元格合并策略能实现一对多的列表信息的导出呢？首先我们来看下将嵌套数据平铺，不进行合并导出的Excel。\n\n\n\n看完之后我们很容易理解解决思路，只要把订单ID相同的列中需要合并的列给合并了，就可以实现这种一对多嵌套信息的导出了。\n\n# 实现过程\n\n * 首先我们得把原来嵌套的订单商品信息给平铺了，创建一个专门的导出对象OrderData，包含订单和商品信息，二级表头可以通过设置@ExcelProperty的value为数组来实现；\n\n/**\n * 订单导出\n * Created by macro on 2021/12/30.\n */\n@Data\n@EqualsAndHashCode(callSuper = false)\npublic class OrderData {\n    @ExcelProperty(value = "订单ID")\n    @ColumnWidth(10)\n    @CustomMerge(needMerge = true, isPk = true)\n    private String id;\n    @ExcelProperty(value = "订单编码")\n    @ColumnWidth(20)\n    @CustomMerge(needMerge = true)\n    private String orderSn;\n    @ExcelProperty(value = "创建时间")\n    @ColumnWidth(20)\n    @DateTimeFormat("yyyy-MM-dd")\n    @CustomMerge(needMerge = true)\n    private Date createTime;\n    @ExcelProperty(value = "收货地址")\n    @CustomMerge(needMerge = true)\n    @ColumnWidth(20)\n    private String receiverAddress;\n    @ExcelProperty(value = {"商品信息", "商品编码"})\n    @ColumnWidth(20)\n    private String productSn;\n    @ExcelProperty(value = {"商品信息", "商品名称"})\n    @ColumnWidth(20)\n    private String name;\n    @ExcelProperty(value = {"商品信息", "商品标题"})\n    @ColumnWidth(30)\n    private String subTitle;\n    @ExcelProperty(value = {"商品信息", "品牌名称"})\n    @ColumnWidth(20)\n    private String brandName;\n    @ExcelProperty(value = {"商品信息", "商品价格"})\n    @ColumnWidth(20)\n    private BigDecimal price;\n    @ExcelProperty(value = {"商品信息", "商品数量"})\n    @ColumnWidth(20)\n    private Integer count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n * 然后将原来嵌套的Order对象列表转换为OrderData对象列表；\n\n/**\n * EasyExcel导入导出测试Controller\n * Created by macro on 2021/10/12.\n */\n@Controller\n@Api(tags = "EasyExcelController", description = "EasyExcel导入导出测试")\n@RequestMapping("/easyExcel")\npublic class EasyExcelController {\n    private List<OrderData> convert(List<Order> orderList) {\n        List<OrderData> result = new ArrayList<>();\n        for (Order order : orderList) {\n            List<Product> productList = order.getProductList();\n            for (Product product : productList) {\n                OrderData orderData = new OrderData();\n                BeanUtil.copyProperties(product,orderData);\n                BeanUtil.copyProperties(order,orderData);\n                result.add(orderData);\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 再创建一个自定义注解CustomMerge，用于标记哪些属性需要合并，哪个是主键；\n\n/**\n * 自定义注解，用于判断是否需要合并以及合并的主键\n */\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\npublic @interface CustomMerge {\n\n    /**\n     * 是否需要合并单元格\n     */\n    boolean needMerge() default false;\n\n    /**\n     * 是否是主键,即该字段相同的行合并\n     */\n    boolean isPk() default false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 再创建自定义单元格合并策略类CustomMergeStrategy，当Excel中两列主键相同时，合并被标记需要合并的列；\n\n/**\n * 自定义单元格合并策略\n */\npublic class CustomMergeStrategy implements RowWriteHandler {\n    /**\n     * 主键下标\n     */\n    private Integer pkIndex;\n\n    /**\n     * 需要合并的列的下标集合\n     */\n    private List<Integer> needMergeColumnIndex = new ArrayList<>();\n\n    /**\n     * DTO数据类型\n     */\n    private Class<?> elementType;\n\n    public CustomMergeStrategy(Class<?> elementType) {\n        this.elementType = elementType;\n    }\n\n    @Override\n    public void afterRowDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row, Integer relativeRowIndex, Boolean isHead) {\n        // 如果是标题,则直接返回\n        if (isHead) {\n            return;\n        }\n\n        // 获取当前sheet\n        Sheet sheet = writeSheetHolder.getSheet();\n\n        // 获取标题行\n        Row titleRow = sheet.getRow(0);\n\n        if (null == pkIndex) {\n            this.lazyInit(writeSheetHolder);\n        }\n\n        // 判断是否需要和上一行进行合并\n        // 不能和标题合并，只能数据行之间合并\n        if (row.getRowNum() <= 1) {\n            return;\n        }\n        // 获取上一行数据\n        Row lastRow = sheet.getRow(row.getRowNum() - 1);\n        // 将本行和上一行是同一类型的数据(通过主键字段进行判断)，则需要合并\n        if (lastRow.getCell(pkIndex).getStringCellValue().equalsIgnoreCase(row.getCell(pkIndex).getStringCellValue())) {\n            for (Integer needMerIndex : needMergeColumnIndex) {\n                CellRangeAddress cellRangeAddress = new CellRangeAddress(row.getRowNum() - 1, row.getRowNum(),\n                        needMerIndex, needMerIndex);\n                sheet.addMergedRegionUnsafe(cellRangeAddress);\n            }\n        }\n    }\n\n    /**\n     * 初始化主键下标和需要合并字段的下标\n     */\n    private void lazyInit(WriteSheetHolder writeSheetHolder) {\n\n        // 获取当前sheet\n        Sheet sheet = writeSheetHolder.getSheet();\n\n        // 获取标题行\n        Row titleRow = sheet.getRow(0);\n        // 获取DTO的类型\n        Class<?> eleType = this.elementType;\n\n        // 获取DTO所有的属性\n        Field[] fields = eleType.getDeclaredFields();\n\n        // 遍历所有的字段，因为是基于DTO的字段来构建excel，所以字段数 >= excel的列数\n        for (Field theField : fields) {\n            // 获取@ExcelProperty注解，用于获取该字段对应在excel中的列的下标\n            ExcelProperty easyExcelAnno = theField.getAnnotation(ExcelProperty.class);\n            // 为空,则表示该字段不需要导入到excel,直接处理下一个字段\n            if (null == easyExcelAnno) {\n                continue;\n            }\n            // 获取自定义的注解，用于合并单元格\n            CustomMerge customMerge = theField.getAnnotation(CustomMerge.class);\n\n            // 没有@CustomMerge注解的默认不合并\n            if (null == customMerge) {\n                continue;\n            }\n\n            for (int index = 0; index < fields.length; index++) {\n                Cell theCell = titleRow.getCell(index);\n                // 当配置为不需要导出时，返回的为null，这里作一下判断，防止NPE\n                if (null == theCell) {\n                    continue;\n                }\n                // 将字段和excel的表头匹配上\n                if (easyExcelAnno.value()[0].equalsIgnoreCase(theCell.getStringCellValue())) {\n                    if (customMerge.isPk()) {\n                        pkIndex = index;\n                    }\n\n                    if (customMerge.needMerge()) {\n                        needMergeColumnIndex.add(index);\n                    }\n                }\n            }\n        }\n\n        // 没有指定主键，则异常\n        if (null == this.pkIndex) {\n            throw new IllegalStateException("使用@CustomMerge注解必须指定主键");\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n * 接下来在Controller中添加导出订单列表的接口，将我们自定义的合并策略CustomMergeStrategy给注册上去；\n\n/**\n * EasyExcel导入导出测试Controller\n * Created by macro on 2021/10/12.\n */\n@Controller\n@Api(tags = "EasyExcelController", description = "EasyExcel导入导出测试")\n@RequestMapping("/easyExcel")\npublic class EasyExcelController {\n    \n    @SneakyThrows\n    @ApiOperation(value = "导出订单列表Excel")\n    @RequestMapping(value = "/exportOrderList", method = RequestMethod.GET)\n    public void exportOrderList(HttpServletResponse response) {\n        List<Order> orderList = getOrderList();\n        List<OrderData> orderDataList = convert(orderList);\n        setExcelRespProp(response, "订单列表");\n        EasyExcel.write(response.getOutputStream())\n                .head(OrderData.class)\n                .registerWriteHandler(new CustomMergeStrategy(OrderData.class))\n                .excelType(ExcelTypeEnum.XLSX)\n                .sheet("订单列表")\n                .doWrite(orderDataList);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 在Swagger中访问接口测试，导出订单列表对应Excel；\n\n\n\n * 下载完成后，查看下文件，由于EasyExcel需要自己来实现，对比之前使用EasyPoi来实现麻烦了不少。\n\n\n\n\n# 其他使用\n\n由于EasyExcel的官方文档介绍的比较简单，如果你想要更深入地进行使用的话，建议大家看下官方Demo。\n\n\n\n\n# 总结\n\n体验了一把EasyExcel，使用还是挺方便的，性能也很优秀。但是比较常见的一对多导出实现比较复杂，而且功能也不如EasyPoi 强大。如果你的Excel导出数据量不大的话，可以使用EasyPoi，如果数据量大，比较在意性能的话，还是使用EasyExcel吧。\n\n来源于 https://mp.weixin.qq.com/s/1c9ojd9GaUO70IhJu3jO8A\n\n\n# 参考资料\n\n * 项目地址：https://github.com/alibaba/easyexcel\n * 官方文档：https://www.yuque.com/easyexcel/doc/easyexcel\n\n\n# 项目源码地址\n\nhttps://github.com/macrozheng/mall-learning/tree/master/mall-tiny-easyexcel',normalizedContent:'操作excel实现导入导出是个非常常见的需求，之前介绍了一款非常好用的工具easypoi 。有读者提出在数据量大的情况下，easypoi占用内存大，性能不够好。今天给大家推荐一款性能更好的excel导入导出工具easyexcel，希望对大家有所帮助！\n\n\n\n * easyexcel简介\n * 集成\n * 使用\n   * 简单导出\n   * 简单导入\n   * 复杂导出\n   * 其他使用\n * 总结\n * 参考资料\n * 项目源码地址\n\n\n\n\n# easyexcel简介\n\n官方文档：传送门\n\neasyexcel是一款阿里开源的excel导入导出工具，具有处理快速、占用内存小、使用方便的特点，在github上已有22k+star，可见其非常流行。\n\neasyexcel读取75m(46w行25列)的excel，仅需使用64m内存，耗时20s，极速模式还可以更快！\n\n\n\n\n# 集成\n\n> 在springboot中集成easyexcel非常简单，仅需一个依赖即可。\n\n\x3c!--easyexcel相关依赖--\x3e\n<dependency>\n    <groupid>com.alibaba</groupid>\n    <artifactid>easyexcel</artifactid>\n    <version>3.0.5</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 使用\n\n> easyexcel和easypoi的使用非常类似，都是通过注解来控制导入导出。接下来我们以会员信息和订单信息的导入导出为例，分别实现下简单的单表导出和具有一对多关系的复杂导出。\n\n\n# 简单导出\n\n> 我们以会员信息的导出为例，来体验下easyexcel的导出功能。\n\n * 首先创建一个会员对象member，封装会员信息，这里使用了easyexcel的注解；\n\n/**\n * 购物会员\n * created by macro on 2021/10/12.\n */\n@data\n@equalsandhashcode(callsuper = false)\npublic class member {\n    @excelproperty("id")\n    @columnwidth(10)\n    private long id;\n    @excelproperty("用户名")\n    @columnwidth(20)\n    private string username;\n    @excelignore\n    private string password;\n    @excelproperty("昵称")\n    @columnwidth(20)\n    private string nickname;\n    @excelproperty("出生日期")\n    @columnwidth(20)\n    @datetimeformat("yyyy-mm-dd")\n    private date birthday;\n    @excelproperty("手机号")\n    @columnwidth(20)\n    private string phone;\n    @excelignore\n    private string icon;\n    @excelproperty(value = "性别", converter = genderconverter.class)\n    @columnwidth(10)\n    private integer gender;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n * 上面代码使用到了easyexcel的核心注解，我们分别来了解下：\n\n * * @excelproperty：核心注解，value属性可用来设置表头名称，converter属性可以用来设置类型转换器；\n   * @columnwidth：用于设置表格列的宽度；\n   * @datetimeformat：用于设置日期转换格式。\n\n * 在easyexcel中，如果你想实现枚举类型到字符串的转换（比如gender属性中，0->男，1->女），需要自定义转换器，下面为自定义的genderconverter代码实现；\n\n/**\n * excel性别转换器\n * created by macro on 2021/12/29.\n */\npublic class genderconverter implements converter<integer> {\n    @override\n    public class<?> supportjavatypekey() {\n        //对象属性类型\n        return integer.class;\n    }\n\n    @override\n    public celldatatypeenum supportexceltypekey() {\n        //celldata属性类型\n        return celldatatypeenum.string;\n    }\n\n    @override\n    public integer converttojavadata(readconvertercontext<?> context) throws exception {\n        //celldata转对象属性\n        string cellstr = context.getreadcelldata().getstringvalue();\n        if (strutil.isempty(cellstr)) return null;\n        if ("男".equals(cellstr)) {\n            return 0;\n        } else if ("女".equals(cellstr)) {\n            return 1;\n        } else {\n            return null;\n        }\n    }\n\n    @override\n    public writecelldata<?> converttoexceldata(writeconvertercontext<integer> context) throws exception {\n        //对象属性转celldata\n        integer cellvalue = context.getvalue();\n        if (cellvalue == null) {\n            return new writecelldata<>("");\n        }\n        if (cellvalue == 0) {\n            return new writecelldata<>("男");\n        } else if (cellvalue == 1) {\n            return new writecelldata<>("女");\n        } else {\n            return new writecelldata<>("");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * 接下来我们在controller中添加一个接口，用于导出会员列表到excel，还需给响应头设置下载excel的属性，具体代码如下；\n\n/**\n * easyexcel导入导出测试controller\n * created by macro on 2021/10/12.\n */\n@controller\n@api(tags = "easyexcelcontroller", description = "easyexcel导入导出测试")\n@requestmapping("/easyexcel")\npublic class easyexcelcontroller {\n\n    @sneakythrows(ioexception.class)\n    @apioperation(value = "导出会员列表excel")\n    @requestmapping(value = "/exportmemberlist", method = requestmethod.get)\n    public void exportmemberlist(httpservletresponse response) {\n        setexcelrespprop(response, "会员列表");\n        list<member> memberlist = localjsonutil.getlistfromjson("json/members.json", member.class);\n        easyexcel.write(response.getoutputstream())\n                .head(member.class)\n                .exceltype(exceltypeenum.xlsx)\n                .sheet("会员列表")\n                .dowrite(memberlist);\n    }\n    \n  /**\n   * 设置excel下载响应头属性\n   */\n  private void setexcelrespprop(httpservletresponse response, string rawfilename) throws unsupportedencodingexception {\n    response.setcontenttype("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");\n    response.setcharacterencoding("utf-8");\n    string filename = urlencoder.encode(rawfilename, "utf-8").replaceall("\\\\+", "%20");\n    response.setheader("content-disposition", "attachment;filename*=utf-8\'\'" + filename + ".xlsx");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 运行项目，通过swagger测试接口，注意在swagger中访问接口无法直接下载，需要点击返回结果中的下载按钮才行，访问地址：http://localhost:8088/swagger-ui/\n\n\n\n * 下载完成后，查看下文件，一个标准的excel文件已经被导出了。\n\n\n\n\n# 简单导入\n\n> 接下来我们以会员信息的导入为例，来体验下easyexcel的导入功能。\n\n * 在controller中添加会员信息导入的接口，这里需要注意的是使用@requestpart注解修饰文件上传参数，否则在swagger中就没法显示上传按钮了；\n\n/**\n * easyexcel导入导出测试controller\n * created by macro on 2021/10/12.\n */\n@controller\n@api(tags = "easyexcelcontroller", description = "easyexcel导入导出测试")\n@requestmapping("/easyexcel")\npublic class easyexcelcontroller {\n    \n    @sneakythrows\n    @apioperation("从excel导入会员列表")\n    @requestmapping(value = "/importmemberlist", method = requestmethod.post)\n    @responsebody\n    public commonresult importmemberlist(@requestpart("file") multipartfile file) {\n        list<member> memberlist = easyexcel.read(file.getinputstream())\n                .head(member.class)\n                .sheet()\n                .doreadsync();\n        return commonresult.success(memberlist);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 然后在swagger中测试接口，选择之前导出的excel文件即可，导入成功后会返回解析到的数据。\n\n\n\n\n# 复杂导出\n\n> 当然easyexcel也可以实现更加复杂的导出，比如导出一个嵌套了商品信息的订单列表，下面我们来实现下！\n\n# 使用easypoi实现\n\n之前我们使用过easypoi实现该功能，由于easypoi本来就支持嵌套对象的导出，直接使用内置的@excelcollection注解即可实现，非常方便也符合面向对象的思想。\n\n\n\n# 寻找方案\n\n> 由于easyexcel本身并不支持这种一对多的信息导出，所以我们得自行实现下，这里分享一个我平时常用的快速查找解决方案的办法。\n\n我们可以直接从开源项目的issues里面去搜索，比如搜索下一对多，会直接找到有无一对多导出比较优雅的方案这个issue。\n\n\n\n从此issue的回复我们可以发现，项目维护者建议创建自定义合并策略来实现，有位回复的老哥已经给出了实现代码，接下来我们就用这个方案来实现下。\n\n\n\n# 解决思路\n\n为什么自定义单元格合并策略能实现一对多的列表信息的导出呢？首先我们来看下将嵌套数据平铺，不进行合并导出的excel。\n\n\n\n看完之后我们很容易理解解决思路，只要把订单id相同的列中需要合并的列给合并了，就可以实现这种一对多嵌套信息的导出了。\n\n# 实现过程\n\n * 首先我们得把原来嵌套的订单商品信息给平铺了，创建一个专门的导出对象orderdata，包含订单和商品信息，二级表头可以通过设置@excelproperty的value为数组来实现；\n\n/**\n * 订单导出\n * created by macro on 2021/12/30.\n */\n@data\n@equalsandhashcode(callsuper = false)\npublic class orderdata {\n    @excelproperty(value = "订单id")\n    @columnwidth(10)\n    @custommerge(needmerge = true, ispk = true)\n    private string id;\n    @excelproperty(value = "订单编码")\n    @columnwidth(20)\n    @custommerge(needmerge = true)\n    private string ordersn;\n    @excelproperty(value = "创建时间")\n    @columnwidth(20)\n    @datetimeformat("yyyy-mm-dd")\n    @custommerge(needmerge = true)\n    private date createtime;\n    @excelproperty(value = "收货地址")\n    @custommerge(needmerge = true)\n    @columnwidth(20)\n    private string receiveraddress;\n    @excelproperty(value = {"商品信息", "商品编码"})\n    @columnwidth(20)\n    private string productsn;\n    @excelproperty(value = {"商品信息", "商品名称"})\n    @columnwidth(20)\n    private string name;\n    @excelproperty(value = {"商品信息", "商品标题"})\n    @columnwidth(30)\n    private string subtitle;\n    @excelproperty(value = {"商品信息", "品牌名称"})\n    @columnwidth(20)\n    private string brandname;\n    @excelproperty(value = {"商品信息", "商品价格"})\n    @columnwidth(20)\n    private bigdecimal price;\n    @excelproperty(value = {"商品信息", "商品数量"})\n    @columnwidth(20)\n    private integer count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n * 然后将原来嵌套的order对象列表转换为orderdata对象列表；\n\n/**\n * easyexcel导入导出测试controller\n * created by macro on 2021/10/12.\n */\n@controller\n@api(tags = "easyexcelcontroller", description = "easyexcel导入导出测试")\n@requestmapping("/easyexcel")\npublic class easyexcelcontroller {\n    private list<orderdata> convert(list<order> orderlist) {\n        list<orderdata> result = new arraylist<>();\n        for (order order : orderlist) {\n            list<product> productlist = order.getproductlist();\n            for (product product : productlist) {\n                orderdata orderdata = new orderdata();\n                beanutil.copyproperties(product,orderdata);\n                beanutil.copyproperties(order,orderdata);\n                result.add(orderdata);\n            }\n        }\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 再创建一个自定义注解custommerge，用于标记哪些属性需要合并，哪个是主键；\n\n/**\n * 自定义注解，用于判断是否需要合并以及合并的主键\n */\n@target({elementtype.field})\n@retention(retentionpolicy.runtime)\n@inherited\npublic @interface custommerge {\n\n    /**\n     * 是否需要合并单元格\n     */\n    boolean needmerge() default false;\n\n    /**\n     * 是否是主键,即该字段相同的行合并\n     */\n    boolean ispk() default false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 再创建自定义单元格合并策略类custommergestrategy，当excel中两列主键相同时，合并被标记需要合并的列；\n\n/**\n * 自定义单元格合并策略\n */\npublic class custommergestrategy implements rowwritehandler {\n    /**\n     * 主键下标\n     */\n    private integer pkindex;\n\n    /**\n     * 需要合并的列的下标集合\n     */\n    private list<integer> needmergecolumnindex = new arraylist<>();\n\n    /**\n     * dto数据类型\n     */\n    private class<?> elementtype;\n\n    public custommergestrategy(class<?> elementtype) {\n        this.elementtype = elementtype;\n    }\n\n    @override\n    public void afterrowdispose(writesheetholder writesheetholder, writetableholder writetableholder, row row, integer relativerowindex, boolean ishead) {\n        // 如果是标题,则直接返回\n        if (ishead) {\n            return;\n        }\n\n        // 获取当前sheet\n        sheet sheet = writesheetholder.getsheet();\n\n        // 获取标题行\n        row titlerow = sheet.getrow(0);\n\n        if (null == pkindex) {\n            this.lazyinit(writesheetholder);\n        }\n\n        // 判断是否需要和上一行进行合并\n        // 不能和标题合并，只能数据行之间合并\n        if (row.getrownum() <= 1) {\n            return;\n        }\n        // 获取上一行数据\n        row lastrow = sheet.getrow(row.getrownum() - 1);\n        // 将本行和上一行是同一类型的数据(通过主键字段进行判断)，则需要合并\n        if (lastrow.getcell(pkindex).getstringcellvalue().equalsignorecase(row.getcell(pkindex).getstringcellvalue())) {\n            for (integer needmerindex : needmergecolumnindex) {\n                cellrangeaddress cellrangeaddress = new cellrangeaddress(row.getrownum() - 1, row.getrownum(),\n                        needmerindex, needmerindex);\n                sheet.addmergedregionunsafe(cellrangeaddress);\n            }\n        }\n    }\n\n    /**\n     * 初始化主键下标和需要合并字段的下标\n     */\n    private void lazyinit(writesheetholder writesheetholder) {\n\n        // 获取当前sheet\n        sheet sheet = writesheetholder.getsheet();\n\n        // 获取标题行\n        row titlerow = sheet.getrow(0);\n        // 获取dto的类型\n        class<?> eletype = this.elementtype;\n\n        // 获取dto所有的属性\n        field[] fields = eletype.getdeclaredfields();\n\n        // 遍历所有的字段，因为是基于dto的字段来构建excel，所以字段数 >= excel的列数\n        for (field thefield : fields) {\n            // 获取@excelproperty注解，用于获取该字段对应在excel中的列的下标\n            excelproperty easyexcelanno = thefield.getannotation(excelproperty.class);\n            // 为空,则表示该字段不需要导入到excel,直接处理下一个字段\n            if (null == easyexcelanno) {\n                continue;\n            }\n            // 获取自定义的注解，用于合并单元格\n            custommerge custommerge = thefield.getannotation(custommerge.class);\n\n            // 没有@custommerge注解的默认不合并\n            if (null == custommerge) {\n                continue;\n            }\n\n            for (int index = 0; index < fields.length; index++) {\n                cell thecell = titlerow.getcell(index);\n                // 当配置为不需要导出时，返回的为null，这里作一下判断，防止npe\n                if (null == thecell) {\n                    continue;\n                }\n                // 将字段和excel的表头匹配上\n                if (easyexcelanno.value()[0].equalsignorecase(thecell.getstringcellvalue())) {\n                    if (custommerge.ispk()) {\n                        pkindex = index;\n                    }\n\n                    if (custommerge.needmerge()) {\n                        needmergecolumnindex.add(index);\n                    }\n                }\n            }\n        }\n\n        // 没有指定主键，则异常\n        if (null == this.pkindex) {\n            throw new illegalstateexception("使用@custommerge注解必须指定主键");\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n * 接下来在controller中添加导出订单列表的接口，将我们自定义的合并策略custommergestrategy给注册上去；\n\n/**\n * easyexcel导入导出测试controller\n * created by macro on 2021/10/12.\n */\n@controller\n@api(tags = "easyexcelcontroller", description = "easyexcel导入导出测试")\n@requestmapping("/easyexcel")\npublic class easyexcelcontroller {\n    \n    @sneakythrows\n    @apioperation(value = "导出订单列表excel")\n    @requestmapping(value = "/exportorderlist", method = requestmethod.get)\n    public void exportorderlist(httpservletresponse response) {\n        list<order> orderlist = getorderlist();\n        list<orderdata> orderdatalist = convert(orderlist);\n        setexcelrespprop(response, "订单列表");\n        easyexcel.write(response.getoutputstream())\n                .head(orderdata.class)\n                .registerwritehandler(new custommergestrategy(orderdata.class))\n                .exceltype(exceltypeenum.xlsx)\n                .sheet("订单列表")\n                .dowrite(orderdatalist);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 在swagger中访问接口测试，导出订单列表对应excel；\n\n\n\n * 下载完成后，查看下文件，由于easyexcel需要自己来实现，对比之前使用easypoi来实现麻烦了不少。\n\n\n\n\n# 其他使用\n\n由于easyexcel的官方文档介绍的比较简单，如果你想要更深入地进行使用的话，建议大家看下官方demo。\n\n\n\n\n# 总结\n\n体验了一把easyexcel，使用还是挺方便的，性能也很优秀。但是比较常见的一对多导出实现比较复杂，而且功能也不如easypoi 强大。如果你的excel导出数据量不大的话，可以使用easypoi，如果数据量大，比较在意性能的话，还是使用easyexcel吧。\n\n来源于 https://mp.weixin.qq.com/s/1c9ojd9gauo70ihju3jo8a\n\n\n# 参考资料\n\n * 项目地址：https://github.com/alibaba/easyexcel\n * 官方文档：https://www.yuque.com/easyexcel/doc/easyexcel\n\n\n# 项目源码地址\n\nhttps://github.com/macrozheng/mall-learning/tree/master/mall-tiny-easyexcel',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"OOM分类及排查",frontmatter:{title:"OOM分类及排查",date:"2022-04-10T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html",relativePath:"views/backend/OOM分类及排查.md",key:"v-b07ca2b2",path:"/views/backend/OOM%E5%88%86%E7%B1%BB%E5%8F%8A%E6%8E%92%E6%9F%A5.html",headers:[{level:2,title:"OOM分类",slug:"oom分类",normalizedTitle:"oom分类",charIndex:3},{level:2,title:"CPU过高排查流程",slug:"cpu过高排查流程",normalizedTitle:"cpu过高排查流程",charIndex:12},{level:2,title:"内存占用过高排查流程",slug:"内存占用过高排查流程",normalizedTitle:"内存占用过高排查流程",charIndex:25},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:39},{level:3,title:"使用 ps 命令查看进程",slug:"使用-ps-命令查看进程",normalizedTitle:"使用 ps 命令查看进程",charIndex:47},{level:3,title:"使用 top 命令",slug:"使用-top-命令",normalizedTitle:"使用 top 命令",charIndex:65},{level:3,title:"使用 jmap 命令查看",slug:"使用-jmap-命令查看",normalizedTitle:"使用 jmap 命令查看",charIndex:80}],excerpt:"<Boxx/>\n",headersStr:"OOM分类 CPU过高排查流程 内存占用过高排查流程 示例 使用 ps 命令查看进程 使用 top 命令 使用 jmap 命令查看",content:" * OOM分类\n * CPU过高排查流程\n * 内存占用过高排查流程\n * 示例\n   * 使用 ps 命令查看进程\n   * 使用 top 命令\n   * 使用 jmap 命令查看\n\n\n\n\n# OOM分类\n\n * java.lang.OutOfMemoryError: Java heap space\n   \n   Java 堆溢出原因： 无法在 Java 堆中分配对象 应用程序保存了无法被GC回收的对象。 应用程序过度使用 finalizer。\n\n * java.lang.OutOfMemoryError: unable to create new native thread\n   \n   排查代码，确定是否显示使用死循环创建线程，或者隐式调用第三方接口创建线程\n\n * java.lang.OutOfMemoryError: Metaspace\n   \n   方法区溢出：检查JVM元空间设置参数是否过小，检查对应代码,是否使用CGLib生成了大量的代理类\n\n * java.lang.OutOfMemoryError: Direct buffer memory\n   \n   本机直接内存溢出：检查JVM参数-Xmx，-XX:MaxDirectMemorySize 是否合理。\n\n * java.lang.OutOfMemoryError: GC overhead limit exceeded\n   \n   Sun 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。\n   \n   一般都是堆太小导致的：检查JVM参数-Xmx -Xms是否合理 dump内存，检查是否存在内存泄露，如果没有，加大内存。\n\n\n# CPU过高排查流程\n\n 1. 利用 top 命令可以查出占用 CPU 最高的进程pid，如果pid为 9876\n 2. 然后查看该进程下占用最高的线程id【top -Hp 9876】\n 3. 假设占用率最高的线程 ID 为6900，将其转换为 16 进制形式（因为 java native 线程以 16 进制形式输出）【printf '%x\\n' 6900】\n 4. 利用jstack打印出 java 线程调用栈信息 【jstack 9876 | grep '0x1af4' -A 50 --color】，这样就可以更好的定位问题\n\n线上解决示例参考上一篇文章：找出某个Java进程中最耗费CPU的Java线程\n\n\n# 内存占用过高排查流程\n\n 1. 查找进程id：【top -d 2 -c】\n 2. 查看 JVM 堆内存分配情况：jmap -head pid\n 3. 查看占用内存比较多的对象：jamp -histo pid | head -n 100\n 4. 查看占用内存比较多的存活对象：jmap -histo:live pid | head -n 100\n\n\n# 示例\n\n下面是对常见的 java.lang.OutOfMemoryError: Java heap space 排查：\n\n\n# 使用 ps 命令查看进程\n\nps -aux|grep java命令查看一下你的java进程，就可以找到你的java进程的进程id。\n\n\n# 使用 top 命令\n\ntop命令显示的结果列表中，会看到%MEM这一列，这里可以看到你的进程可能对内存的使用率特别高。以查看正在运行的进程和系统负载信息，包括cpu负载、内存使用、各个进程所占系统资源等。\n\n\n\n\n# 使用 jmap 命令查看\n\n * ./jmap -heap PID 打印堆总结\n\n * ./jmap -dump:file=/data/logs/jmap/auto.dump PID，dump内存分析日志\n\n[root@test bin]# ./jmap -dump:file=/data/logs/jmap/auto.dump 13\n13: Unable to open socket file: target process not responding or HotSpot VM not loaded\nThe -F option can be used when the target process is not responding\n[root@test bin]# ./jmap -F -dump:file=/data/logs/jmap/auto.dump 13\nAttaching to process ID 13, please wait...\nError attaching to process: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file\nsun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread.execute(LinuxDebuggerLocal.java:163)\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.attach(LinuxDebuggerLocal.java:278)\n        at sun.jvm.hotspot.HotSpotAgent.attachDebugger(HotSpotAgent.java:671)\n        at sun.jvm.hotspot.HotSpotAgent.setupDebuggerLinux(HotSpotAgent.java:611)\n        at sun.jvm.hotspot.HotSpotAgent.setupDebugger(HotSpotAgent.java:337)\n        at sun.jvm.hotspot.HotSpotAgent.go(HotSpotAgent.java:304)\n        at sun.jvm.hotspot.HotSpotAgent.attach(HotSpotAgent.java:140)\n        at sun.jvm.hotspot.tools.Tool.start(Tool.java:185)\n        at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118)\n        at sun.jvm.hotspot.tools.HeapDumper.main(HeapDumper.java:83)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at sun.tools.jmap.JMap.runTool(JMap.java:201)\n        at sun.tools.jmap.JMap.main(JMap.java:130)\nCaused by: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.attach0(Native Method)\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.access$100(LinuxDebuggerLocal.java:62)\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$1AttachTask.doit(LinuxDebuggerLocal.java:269)\n        at sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal$LinuxDebuggerLocalWorkerThread.run(LinuxDebuggerLocal.java:138)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:" * oom分类\n * cpu过高排查流程\n * 内存占用过高排查流程\n * 示例\n   * 使用 ps 命令查看进程\n   * 使用 top 命令\n   * 使用 jmap 命令查看\n\n\n\n\n# oom分类\n\n * java.lang.outofmemoryerror: java heap space\n   \n   java 堆溢出原因： 无法在 java 堆中分配对象 应用程序保存了无法被gc回收的对象。 应用程序过度使用 finalizer。\n\n * java.lang.outofmemoryerror: unable to create new native thread\n   \n   排查代码，确定是否显示使用死循环创建线程，或者隐式调用第三方接口创建线程\n\n * java.lang.outofmemoryerror: metaspace\n   \n   方法区溢出：检查jvm元空间设置参数是否过小，检查对应代码,是否使用cglib生成了大量的代理类\n\n * java.lang.outofmemoryerror: direct buffer memory\n   \n   本机直接内存溢出：检查jvm参数-xmx，-xx:maxdirectmemorysize 是否合理。\n\n * java.lang.outofmemoryerror: gc overhead limit exceeded\n   \n   sun 官方对此的定义：超过98%的时间用来做gc并且回收了不到2%的堆内存时会抛出此异常。\n   \n   一般都是堆太小导致的：检查jvm参数-xmx -xms是否合理 dump内存，检查是否存在内存泄露，如果没有，加大内存。\n\n\n# cpu过高排查流程\n\n 1. 利用 top 命令可以查出占用 cpu 最高的进程pid，如果pid为 9876\n 2. 然后查看该进程下占用最高的线程id【top -hp 9876】\n 3. 假设占用率最高的线程 id 为6900，将其转换为 16 进制形式（因为 java native 线程以 16 进制形式输出）【printf '%x\\n' 6900】\n 4. 利用jstack打印出 java 线程调用栈信息 【jstack 9876 | grep '0x1af4' -a 50 --color】，这样就可以更好的定位问题\n\n线上解决示例参考上一篇文章：找出某个java进程中最耗费cpu的java线程\n\n\n# 内存占用过高排查流程\n\n 1. 查找进程id：【top -d 2 -c】\n 2. 查看 jvm 堆内存分配情况：jmap -head pid\n 3. 查看占用内存比较多的对象：jamp -histo pid | head -n 100\n 4. 查看占用内存比较多的存活对象：jmap -histo:live pid | head -n 100\n\n\n# 示例\n\n下面是对常见的 java.lang.outofmemoryerror: java heap space 排查：\n\n\n# 使用 ps 命令查看进程\n\nps -aux|grep java命令查看一下你的java进程，就可以找到你的java进程的进程id。\n\n\n# 使用 top 命令\n\ntop命令显示的结果列表中，会看到%mem这一列，这里可以看到你的进程可能对内存的使用率特别高。以查看正在运行的进程和系统负载信息，包括cpu负载、内存使用、各个进程所占系统资源等。\n\n\n\n\n# 使用 jmap 命令查看\n\n * ./jmap -heap pid 打印堆总结\n\n * ./jmap -dump:file=/data/logs/jmap/auto.dump pid，dump内存分析日志\n\n[root@test bin]# ./jmap -dump:file=/data/logs/jmap/auto.dump 13\n13: unable to open socket file: target process not responding or hotspot vm not loaded\nthe -f option can be used when the target process is not responding\n[root@test bin]# ./jmap -f -dump:file=/data/logs/jmap/auto.dump 13\nattaching to process id 13, please wait...\nerror attaching to process: sun.jvm.hotspot.debugger.debuggerexception: cannot open binary file\nsun.jvm.hotspot.debugger.debuggerexception: sun.jvm.hotspot.debugger.debuggerexception: cannot open binary file\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal$linuxdebuggerlocalworkerthread.execute(linuxdebuggerlocal.java:163)\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal.attach(linuxdebuggerlocal.java:278)\n        at sun.jvm.hotspot.hotspotagent.attachdebugger(hotspotagent.java:671)\n        at sun.jvm.hotspot.hotspotagent.setupdebuggerlinux(hotspotagent.java:611)\n        at sun.jvm.hotspot.hotspotagent.setupdebugger(hotspotagent.java:337)\n        at sun.jvm.hotspot.hotspotagent.go(hotspotagent.java:304)\n        at sun.jvm.hotspot.hotspotagent.attach(hotspotagent.java:140)\n        at sun.jvm.hotspot.tools.tool.start(tool.java:185)\n        at sun.jvm.hotspot.tools.tool.execute(tool.java:118)\n        at sun.jvm.hotspot.tools.heapdumper.main(heapdumper.java:83)\n        at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n        at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n        at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n        at java.lang.reflect.method.invoke(method.java:498)\n        at sun.tools.jmap.jmap.runtool(jmap.java:201)\n        at sun.tools.jmap.jmap.main(jmap.java:130)\ncaused by: sun.jvm.hotspot.debugger.debuggerexception: cannot open binary file\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal.attach0(native method)\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal.access$100(linuxdebuggerlocal.java:62)\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal$1attachtask.doit(linuxdebuggerlocal.java:269)\n        at sun.jvm.hotspot.debugger.linux.linuxdebuggerlocal$linuxdebuggerlocalworkerthread.run(linuxdebuggerlocal.java:138)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"ReentrantLock 详解",frontmatter:{title:"ReentrantLock 详解",date:"2020-06-19T00:00:00.000Z",tags:["源码分析","多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/ReentrantLock.html",relativePath:"views/backend/ReentrantLock.md",key:"v-93974ed2",path:"/views/backend/ReentrantLock.html",headers:[{level:2,title:"主要特性：",slug:"主要特性",normalizedTitle:"主要特性：",charIndex:48},{level:2,title:"Lock",slug:"lock",normalizedTitle:"lock",charIndex:57},{level:2,title:"lock() 过程",slug:"lock-过程",normalizedTitle:"lock() 过程",charIndex:65},{level:3,title:"公平锁",slug:"公平锁",normalizedTitle:"公平锁",charIndex:80},{level:3,title:"非公平锁",slug:"非公平锁",normalizedTitle:"非公平锁",charIndex:89},{level:2,title:"unlock() 过程",slug:"unlock-过程",normalizedTitle:"unlock() 过程",charIndex:97},{level:2,title:"lockInterruptibly() 中断锁过程",slug:"lockinterruptibly-中断锁过程",normalizedTitle:"lockinterruptibly() 中断锁过程",charIndex:112},{level:2,title:"tryLock()",slug:"trylock",normalizedTitle:"trylock()",charIndex:141},{level:2,title:"tryLock(long timeout, TimeUnit unit)",slug:"trylock-long-timeout-timeunit-unit",normalizedTitle:"trylock(long timeout, timeunit unit)",charIndex:154},{level:2,title:"ReentrantLock 的等待 / 通知机制",slug:"reentrantlock-的等待-通知机制",normalizedTitle:"reentrantlock 的等待 / 通知机制",charIndex:194},{level:3,title:"newCondition()",slug:"newcondition",normalizedTitle:"newcondition()",charIndex:224},{level:2,title:"ReentrantLock 和 Synchronized 对比",slug:"reentrantlock-和-synchronized-对比",normalizedTitle:"reentrantlock 和 synchronized 对比",charIndex:242}],excerpt:"<Boxx/>\n<p>可独占，可重入，可中断，可公平可非公平。</p>\n",headersStr:"主要特性： Lock lock() 过程 公平锁 非公平锁 unlock() 过程 lockInterruptibly() 中断锁过程 tryLock() tryLock(long timeout, TimeUnit unit) ReentrantLock 的等待 / 通知机制 newCondition() ReentrantLock 和 Synchronized 对比",content:'可独占，可重入，可中断，可公平可非公平。\n\n引自掘金hahaeee和薛8糅合而来。\n\n\n\n * 主要特性：\n * Lock\n * lock() 过程\n   * 公平锁\n   * 非公平锁\n * unlock() 过程\n * lockInterruptibly() 中断锁过程\n * tryLock()\n * tryLock(long timeout, TimeUnit unit)\n * ReentrantLock 的等待 / 通知机制\n   * newCondition()\n * ReentrantLock 和 Synchronized 对比\n\n\n\n\n# 主要特性：\n\n 1. 可重入。ReentrantLock 是可重入锁，因为它会记录之前获得锁线程对象，保存在 exclusiveOwenerThread 变量中，当一个线程要获取锁时，会先判断当前线程是不是已经获取锁的线程。synchronized 也是可重入锁。\n\n 2. 可中断。ReentrantLock 是可中断锁，它提供了 lockInterruptibly 这种可中断的加锁方式，可以有效的避免线程之间因为互相持续占有资源而导致阻塞。synchronized 无法实现可中断。\n\n 3. 公平锁与非公平锁可选。ReentrantLock 默认是非公平锁，但是也可以通过构造方法选择非公平锁。公平锁是指当多个线程尝试获取同一个锁时，获取锁的顺序按照到达的时间顺序排序。\n\n\n\n\n\n斜体为抽象类,下横线为接口\n\n聚合关系总结:\n\n 1. ReentrantLock 实现了 Lock,Serializable 接口\n 2. ReentrantLock.Sync (内部类) 继承了 AQS\n 3. ReentrantLock.NonfairSync 和 ReentrantLock.FairSync 继承了 ReentrantLock.Sync\n 4. ReentrantLock 持有 ReentrantLock.Sync 对象 (实现锁功能)\n\n锁实现总结:\n\n 1. 由 Node 节点组成一条同步队列 (有 head,tail 两个指针，并且 head 初始化时指向空节点)\n 2. int state 标记锁使用数量 (独占锁时，通常为 1, 发生重入时> 1)\n 3. lock () 时加到队列尾部\n 4. unlock () 时，释放 head 节点，并指向下一个节点 head=head.next, 然后唤醒当前 head 节点\n\n性质:\n\n 1. 独占锁 (排它锁): 只能有一个线程获取锁\n 2. 重入锁：一个线程可以多次 lock ()\n 3. 公平 / 非公平锁：只针对上锁过程\n    1. 非公平锁：尝试获取锁，若成功立刻返回，失败则加入同步队列\n    2. 公平锁：直接加入同步队列\n\n\n# Lock\n\nLock 接口定义了锁的行为\n\npublic interface Lock {\n\t//上锁(不响应Thread.interrupt()直到获取锁)\n    void lock();\n\t//上锁(响应Thread.interrupt())\n    void lockInterruptibly() throws InterruptedException;\n\t//尝试获取锁(以nonFair方式获取锁)\n    boolean tryLock();\n  \t//在指定时间内尝试获取锁(响应Thread.interrupt(),支持公平/二阶段非公平)\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n\t//解锁\n    void unlock();\n\t//获取Condition\n    Condition newCondition();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# lock() 过程\n\n//锁具体实现\nprivate final Sync sync;\n//根据传入参数选择FairSync或NonfairSync实现\npublic ReentrantLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n}\npublic void lock() {\n\tsync.lock();\n}\n#java.util.concurrent.locks.ReentrantLock.Sync\nabstract void lock();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 公平锁\n\n加入同步队列 (当同步队列为空时会直接获得锁), 等待锁\n\n#java.util.concurrent.locks.ReentrantLock.FairSync\nfinal void lock() {\n\tacquire(1);\n}\n#java.util.concurrent.locks.AbstractQueuedSynchronizer\npublic final void acquire(int arg) {\n\tif (!tryAcquire(arg) &&acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n\t\tselfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nacquire () 流程:\n\n 1. tryAcquire (): 模板方法，获取锁\n    \n     #java.util.concurrent.locks.ReentrantLock.FairSync\n     protected final boolean tryAcquire(int acquires) {\n     \t//获取当前线程\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {//当前锁没被占用\n     \t   if (!hasQueuedPredecessors() &&//1.判断同步队列中是否有节点在等待\n     \t\t   compareAndSetState(0, acquires)) {//2.如果上面!1成立,修改state值(表明当前锁已被占用)\n     \t\t   setExclusiveOwnerThread(current);//3.如果2成立,修改当前占用锁的线程为当前线程\n     \t\t   return true;\n     \t   }\n        }\n        else if (current == getExclusiveOwnerThread()) {//占用锁线程==当前线程(重入)\n     \t   int nextc = c + acquires;//\n     \t   if (nextc < 0)\n     \t\t   throw new Error("Maximum lock count exceeded");\n     \t   setState(nextc);//修改status\n     \t   return true;\n        }\n        return false;//直接获取锁失败\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 2. acquireQueued (addWaiter (Node.EXCLUSIVE), arg): 加入同步队列\n    \n    #java.util.concurrent.locks.AbstractQueuedSynchronizer\n    //1\n    private Node addWaiter(Node mode) {\n     //生成node\n        Node node = new Node(Thread.currentThread(), mode);\n        Node pred = tail;\n        if (pred != null) {\n     \t//将node加到队列尾部\n     \t   node.prev = pred;\n     \t   if (compareAndSetTail(pred, node)) {\n     \t\t   pred.next = node;\n     \t\t   return node;\n     \t   }\n        }\n        //如果加入失败(多线程竞争或者tail指针为null)\n        enq(node);\n        return node;\n    }\n    //1.1  \n    private Node enq(final Node node) {\n     //死循环加入节点(cas会失败)\n        for (;;) {\n     \t   Node t = tail;\n     \t   if (t == null) { //tail为null,同步队列初始化\n     \t\t//设置head指针\n     \t\t   if (compareAndSetHead(new Node()))//注意这里是个空节点!!\n     \t\t\t   tail = head;//将tail也指向head\n     \t   } else {\n     \t\t   node.prev = t;//将当前node加到队尾\n     \t\t   if (compareAndSetTail(t, node)) {\n     \t\t\t   t.next = node;\n     \t\t\t   return t;//注意这里才返回\n     \t\t   }\n     \t   }\n        }\n    }\n    //2\n    final boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n     \t//表示是否被打断\n     \t   boolean interrupted = false;\n     \t   for (;;) {\n     \t\t//获取node.pre节点\n     \t\t   final Node p = node.predecessor();\n     \t\t   if (p == head //当前节点是否是同步队列中的第二个节点\n     \t\t   && tryAcquire(arg)) {//获取锁,head指向当前节点\n     \t\t\t   setHead(node);//head=head.next\n     \t\t\t   p.next = null;//置空 \n     \t\t\t   failed = false;\n     \t\t\t   return interrupted;\n     \t\t   }\n    \n     \t\t   if (shouldParkAfterFailedAcquire(p, node) && //是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)\n     \t\t\t   parkAndCheckInterrupt())//利用unsafe.park()进行空转(阻塞)\n     \t\t\t   interrupted = true;//如果Thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)\n     \t   }\n        } finally {\n     \t   if (failed)//tryAcquire()过程出现异常导致获取锁失败,则移除当前节点\n     \t\t   cancelAcquire(node);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    \n    \n    过程总结:\n    \n    1. 空转 (如果当前节点是同步队列中的第二个节点，则直接获得锁返回)\n    2. 获得锁\n    \n    > 注意，这里有两次tryAcquire()过程：\n    > 第一次，为了避免同步队列为空时还插入队列产生的性能耗费(cas空转)。\n    > 第二次，就是正常的流程，先插入队尾，然后等待唤醒，再获取锁。\n\n 3. selfInterrupt (): 唤醒当前线程\n    \n    static void selfInterrupt() {//在获取锁之后 响应intterpt()请求\n    \tThread.currentThread().interrupt();\n    }\n    \n    \n    1\n    2\n    3\n    \n\n\n# 非公平锁\n\n一阶段\n\n#java.util.concurrent.locks.ReentrantLock.NonfairSync\nfinal void lock() {\n\t//在acquire()之前先尝试获取锁\n\tif (compareAndSetState(0, 1))\n\t\tsetExclusiveOwnerThread(Thread.currentThread());\n\telse\n\t\tacquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n二阶段 acquire () 流程与公平锁一模一样，唯一区别在于 tryAcquire () 实现中\n\n#java.util.concurrent.locks.ReentrantLock.NonfairSync\nprotected final boolean tryAcquire(int acquires) {\n \treturn nonfairTryAcquire(acquires);\n }\n \n#java.util.concurrent.locks.ReentrantLock.Sync\n final boolean nonfairTryAcquire(int acquires) {//这个过程其实和FairSync.tryAcquire()基本一致\n\tfinal Thread current = Thread.currentThread();\n\tint c = getState();\n\tif (c == 0) {\n\t\t//唯一区别: 这里不会去判断队列中是否为空\n\t\tif (compareAndSetState(0, acquires)) {\n\t\t\tsetExclusiveOwnerThread(current);\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (current == getExclusiveOwnerThread()) {\n\t\tint nextc = c + acquires;\n\t\tif (nextc < 0) // overflow\n\t\t\tthrow new Error("Maximum lock count exceeded");\n\t\tsetState(nextc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n区别点           LOCK () 过程 (一阶段)      TRYACQUIRE () 过程 (二阶段)\nFairSync      直接 acquire ()         当前若无线程持有锁，如果同步队列为空，获取锁\nNonFairSync   先尝试获取锁，再 acquire ()   当前若无线程持有锁，获取锁\n\n\n# unlock() 过程\n\n#java.util.concurrent.locks.ReentrantLock\npublic void unlock() {\n\tsync.release(1);\n}\n#java.util.concurrent.locks.AbstractQueuedSynchronizer\npublic final boolean release(int arg) {\nif (tryRelease(arg)) {//释放锁\n\tNode h = head;\n\tif (h != null &&//head节点为空(非公平锁直接获取锁)\n\th.waitStatus != 0)\n\t\tunparkSuccessor(h);//唤醒同步队列中离head最近的一个waitStatus<=0的节点\n\treturn true;\n}\nreturn false;\n}\n#java.util.concurrent.locks.ReentrantLock\nprotected final boolean tryRelease(int releases) {\n\tint c = getState() - releases;\n\t//持有锁的线程==当前线程\n\tif (Thread.currentThread() != getExclusiveOwnerThread())\n\t\tthrow new IllegalMonitorStateException();\n\tboolean free = false;\n\tif (c == 0) {//重入锁全部释放\n\t\tfree = true;\n\t\t//置空持有锁线程\n\t\tsetExclusiveOwnerThread(null);\n\t}\n\t//state==0(此时持有锁,不用cas)\n\tsetState(c);\n\treturn free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# lockInterruptibly() 中断锁过程\n\nlockInterruptibly () 与 lock () 过程基本相同，区别在于 Thread.intterpt () 的应对措施不同。\n\nReentrantLock 中的 lockInterruptibly () 方法使得线程可以在被阻塞时响应中断，比如一个线程 t1 通过 lockInterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过 lockInterruptibly() 方法就可以立刻打断 t1 线程的执行，来获取 t1 持有的那个可重入锁。而通过 ReentrantLock 的 lock () 方法或者 Synchronized 持有锁的线程是不会响应其他线程的 interrupt () 方法的，直到该方法主动释放锁之后才会响应 interrupt () 方法。\n\n//lock()\nfinal boolean acquireQueued(final Node node, int arg) {\n\tboolean failed = true;\n\ttry {\n\t\t//表示是否被打断\n\t\tboolean interrupted = false;\n\t\tfor (;;) {\n\t\t\t//获取node.pre节点\n\t\t\tfinal Node p = node.predecessor();\n\t\t\tif (p == head //当前节点是否是同步队列中的第二个节点\n\t\t\t&& tryAcquire(arg)) {//获取锁,当前head指向当前节点\n\t\t\t\tsetHead(node);//head=head.next\n\t\t\t\tp.next = null;//置空 \n\t\t\t\tfailed = false;\n\t\t\t\treturn interrupted;\n\t\t\t}\n\n\t\t\tif (shouldParkAfterFailedAcquire(p, node) && //是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)\n\t\t\t\tparkAndCheckInterrupt())//利用unsafe.park()进行空转(阻塞)\n\t\t\t\tinterrupted = true;//如果Thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)\n\t\t}\n\t} finally {\n\t\tif (failed)//tryAcquire()过程出现异常导致获取锁失败,则移除当前节点\n\t\t\tcancelAcquire(node);\n\t}\n}\n// lockInterruptibly()\nprivate void doAcquireInterruptibly(int arg)\n\tthrows InterruptedException {\n\tfinal Node node = addWaiter(Node.EXCLUSIVE);\n\tboolean failed = true;\n\ttry {\n\t\tfor (;;) {\n\t\t\tfinal Node p = node.predecessor();\n\t\t\tif (p == head && tryAcquire(arg)) {\n\t\t\t\tsetHead(node);\n\t\t\t\tp.next = null; \n\t\t\t\tfailed = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldParkAfterFailedAcquire(p, node) &&\n\t\t\t\tparkAndCheckInterrupt())//唯一区别当Thread.intterpt()打断时,直接抛出异常\n\t\t\t\tthrow new InterruptedException();\n\t\t}\n\t} finally {\n\t\tif (failed)//然后移除当前节点\n\t\t\tcancelAcquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n * 中断锁代码测试：CSDN\n\n\n# tryLock()\n\n#java.util.concurrent.locks.ReentrantLock\npublic boolean tryLock() {\n\t//尝试获取非公平锁\n\treturn sync.nonfairTryAcquire(1);\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# tryLock(long timeout, TimeUnit unit)\n\n#java.util.concurrent.locks.ReentrantLock\npublic boolean tryLock(long timeout, TimeUnit unit)\n\t\tthrows InterruptedException {\n\treturn sync.tryAcquireNanos(1, unit.toNanos(timeout));\n}\n#java.util.concurrent.locks.AbstractQueuedSynchronizer\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n\t\tthrows InterruptedException {\n\tif (Thread.interrupted())\n\t\tthrow new InterruptedException();\n\treturn tryAcquire(arg) ||//获取锁(公平/非公平)\n\t\tdoAcquireNanos(arg, nanosTimeout);//在指定时间内等待锁(空转)\n}\n\nprivate boolean doAcquireNanos(int arg, long nanosTimeout)\n\t\tthrows InterruptedException {\n\t...\n\tfinal long deadline = System.nanoTime() + nanosTimeout;\n\t//加入队尾\n\tfinal Node node = addWaiter(Node.EXCLUSIVE);\n\tboolean failed = true;\n\ttry {\n\t\tfor (;;) {\n\t\t\tfinal Node p = node.predecessor();\n\t\t\tif (p == head && tryAcquire(arg)) {\n\t\t\t\tsetHead(node);\n\t\t\t\tp.next = null; \n\t\t\t\tfailed = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t  //上面与acquireQueued()相同,重点看这里\n\t\t  //计算剩余时间\n\t\t\tnanosTimeout = deadline - System.nanoTime();\n\t\t\tif (nanosTimeout <= 0L)\n\t\t\t\treturn false;\n\t\t\tif (shouldParkAfterFailedAcquire(p, node) &&\n\t\t\t\tnanosTimeout > spinForTimeoutThreshold)\n\t\t\t\t//利用parkNanos()指定空转时间\n\t\t\t\tLockSupport.parkNanos(this, nanosTimeout);\n\t\t\tif (Thread.interrupted())//如果被Thread.interrupt(),则抛异常\n\t\t\t\tthrow new InterruptedException();\n\t\t}\n\t} finally {\n\t\tif (failed)//移除节点\n\t\t\tcancelAcquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# ReentrantLock 的等待 / 通知机制\n\n\n# newCondition()\n\npublic Condition newCondition() {\n\treturn sync.newCondition();\n}\n#java.util.concurrent.locks.ReentrantLock.Sync\nfinal ConditionObject newCondition() {\n\treturn new ConditionObject();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 等待和唤醒\n\n我们知道关键字 Synchronized + Object 的 wait 和 notify、notifyAll 方法能实现等待 / 通知机制，那么 ReentrantLock 是否也能实现这样的等待 / 通知机制，答案是：可以。 ReentrantLock 通过 Condition 对象，也就是条件队列实现了和 wait、notify、notifyAll 相同的语义。 线程执行 condition.await() 方法，将节点 1 从同步队列转移到条件队列中。\n\n\n\n线程执行 condition.signal() 方法，将节点 1 从条件队列中转移到同步队列。\n\n\n\n因为只有在同步队列中的线程才能去获取锁，所以通过 Condition 对象的 wait 和 signal 方法能实现等待 / 通知机制。\n\n * 等待和唤醒部分\n\n如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个 Condition 对象了，因为 ReentrantLock 支持创建多个 Condition 对象，例如：\n\n//为了减少篇幅 仅给出伪代码\nReentrantLock lock = new ReentrantLock();\nCondition condition = lock.newCondition();\nCondition condition1 = lock.newCondition();\n\n//线程1 调用condition.await() 线程进入到条件队列\ncondition.await();\n\n//线程2 调用condition1.await() 线程进入到条件队列\ncondition1.await();\n\n//线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。\ncondition1.await();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这样就实现了部分唤醒的功能。\n\n\n# ReentrantLock 和 Synchronized 对比\n\n               REENTRANTLOCK   SYNCHRONIZED\n底层实现           通过 AQS 实现       通过 JVM 实现，其中 synchronized 又有多个类型的锁，除了重量级锁是通过 monitor 对象\n                               (操作系统 mutex 互斥原语) 实现外，其它类型的通过对象头实现。\n是否可重入          是               是\n公平锁            是               否\n非公平锁           是               是\n锁的类型           悲观锁、显式锁         悲观锁、隐式锁 (内置锁)\n是否支持中断         是               否\n是否支持超时等待       是               否\n是否自动获取 / 释放锁   否               是',normalizedContent:'可独占，可重入，可中断，可公平可非公平。\n\n引自掘金hahaeee和薛8糅合而来。\n\n\n\n * 主要特性：\n * lock\n * lock() 过程\n   * 公平锁\n   * 非公平锁\n * unlock() 过程\n * lockinterruptibly() 中断锁过程\n * trylock()\n * trylock(long timeout, timeunit unit)\n * reentrantlock 的等待 / 通知机制\n   * newcondition()\n * reentrantlock 和 synchronized 对比\n\n\n\n\n# 主要特性：\n\n 1. 可重入。reentrantlock 是可重入锁，因为它会记录之前获得锁线程对象，保存在 exclusiveowenerthread 变量中，当一个线程要获取锁时，会先判断当前线程是不是已经获取锁的线程。synchronized 也是可重入锁。\n\n 2. 可中断。reentrantlock 是可中断锁，它提供了 lockinterruptibly 这种可中断的加锁方式，可以有效的避免线程之间因为互相持续占有资源而导致阻塞。synchronized 无法实现可中断。\n\n 3. 公平锁与非公平锁可选。reentrantlock 默认是非公平锁，但是也可以通过构造方法选择非公平锁。公平锁是指当多个线程尝试获取同一个锁时，获取锁的顺序按照到达的时间顺序排序。\n\n\n\n\n\n斜体为抽象类,下横线为接口\n\n聚合关系总结:\n\n 1. reentrantlock 实现了 lock,serializable 接口\n 2. reentrantlock.sync (内部类) 继承了 aqs\n 3. reentrantlock.nonfairsync 和 reentrantlock.fairsync 继承了 reentrantlock.sync\n 4. reentrantlock 持有 reentrantlock.sync 对象 (实现锁功能)\n\n锁实现总结:\n\n 1. 由 node 节点组成一条同步队列 (有 head,tail 两个指针，并且 head 初始化时指向空节点)\n 2. int state 标记锁使用数量 (独占锁时，通常为 1, 发生重入时> 1)\n 3. lock () 时加到队列尾部\n 4. unlock () 时，释放 head 节点，并指向下一个节点 head=head.next, 然后唤醒当前 head 节点\n\n性质:\n\n 1. 独占锁 (排它锁): 只能有一个线程获取锁\n 2. 重入锁：一个线程可以多次 lock ()\n 3. 公平 / 非公平锁：只针对上锁过程\n    1. 非公平锁：尝试获取锁，若成功立刻返回，失败则加入同步队列\n    2. 公平锁：直接加入同步队列\n\n\n# lock\n\nlock 接口定义了锁的行为\n\npublic interface lock {\n\t//上锁(不响应thread.interrupt()直到获取锁)\n    void lock();\n\t//上锁(响应thread.interrupt())\n    void lockinterruptibly() throws interruptedexception;\n\t//尝试获取锁(以nonfair方式获取锁)\n    boolean trylock();\n  \t//在指定时间内尝试获取锁(响应thread.interrupt(),支持公平/二阶段非公平)\n    boolean trylock(long time, timeunit unit) throws interruptedexception;\n\t//解锁\n    void unlock();\n\t//获取condition\n    condition newcondition();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# lock() 过程\n\n//锁具体实现\nprivate final sync sync;\n//根据传入参数选择fairsync或nonfairsync实现\npublic reentrantlock(boolean fair) {\n        sync = fair ? new fairsync() : new nonfairsync();\n}\npublic void lock() {\n\tsync.lock();\n}\n#java.util.concurrent.locks.reentrantlock.sync\nabstract void lock();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 公平锁\n\n加入同步队列 (当同步队列为空时会直接获得锁), 等待锁\n\n#java.util.concurrent.locks.reentrantlock.fairsync\nfinal void lock() {\n\tacquire(1);\n}\n#java.util.concurrent.locks.abstractqueuedsynchronizer\npublic final void acquire(int arg) {\n\tif (!tryacquire(arg) &&acquirequeued(addwaiter(node.exclusive), arg))\n\t\tselfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nacquire () 流程:\n\n 1. tryacquire (): 模板方法，获取锁\n    \n     #java.util.concurrent.locks.reentrantlock.fairsync\n     protected final boolean tryacquire(int acquires) {\n     \t//获取当前线程\n        final thread current = thread.currentthread();\n        int c = getstate();\n        if (c == 0) {//当前锁没被占用\n     \t   if (!hasqueuedpredecessors() &&//1.判断同步队列中是否有节点在等待\n     \t\t   compareandsetstate(0, acquires)) {//2.如果上面!1成立,修改state值(表明当前锁已被占用)\n     \t\t   setexclusiveownerthread(current);//3.如果2成立,修改当前占用锁的线程为当前线程\n     \t\t   return true;\n     \t   }\n        }\n        else if (current == getexclusiveownerthread()) {//占用锁线程==当前线程(重入)\n     \t   int nextc = c + acquires;//\n     \t   if (nextc < 0)\n     \t\t   throw new error("maximum lock count exceeded");\n     \t   setstate(nextc);//修改status\n     \t   return true;\n        }\n        return false;//直接获取锁失败\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 2. acquirequeued (addwaiter (node.exclusive), arg): 加入同步队列\n    \n    #java.util.concurrent.locks.abstractqueuedsynchronizer\n    //1\n    private node addwaiter(node mode) {\n     //生成node\n        node node = new node(thread.currentthread(), mode);\n        node pred = tail;\n        if (pred != null) {\n     \t//将node加到队列尾部\n     \t   node.prev = pred;\n     \t   if (compareandsettail(pred, node)) {\n     \t\t   pred.next = node;\n     \t\t   return node;\n     \t   }\n        }\n        //如果加入失败(多线程竞争或者tail指针为null)\n        enq(node);\n        return node;\n    }\n    //1.1  \n    private node enq(final node node) {\n     //死循环加入节点(cas会失败)\n        for (;;) {\n     \t   node t = tail;\n     \t   if (t == null) { //tail为null,同步队列初始化\n     \t\t//设置head指针\n     \t\t   if (compareandsethead(new node()))//注意这里是个空节点!!\n     \t\t\t   tail = head;//将tail也指向head\n     \t   } else {\n     \t\t   node.prev = t;//将当前node加到队尾\n     \t\t   if (compareandsettail(t, node)) {\n     \t\t\t   t.next = node;\n     \t\t\t   return t;//注意这里才返回\n     \t\t   }\n     \t   }\n        }\n    }\n    //2\n    final boolean acquirequeued(final node node, int arg) {\n        boolean failed = true;\n        try {\n     \t//表示是否被打断\n     \t   boolean interrupted = false;\n     \t   for (;;) {\n     \t\t//获取node.pre节点\n     \t\t   final node p = node.predecessor();\n     \t\t   if (p == head //当前节点是否是同步队列中的第二个节点\n     \t\t   && tryacquire(arg)) {//获取锁,head指向当前节点\n     \t\t\t   sethead(node);//head=head.next\n     \t\t\t   p.next = null;//置空 \n     \t\t\t   failed = false;\n     \t\t\t   return interrupted;\n     \t\t   }\n    \n     \t\t   if (shouldparkafterfailedacquire(p, node) && //是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)\n     \t\t\t   parkandcheckinterrupt())//利用unsafe.park()进行空转(阻塞)\n     \t\t\t   interrupted = true;//如果thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)\n     \t   }\n        } finally {\n     \t   if (failed)//tryacquire()过程出现异常导致获取锁失败,则移除当前节点\n     \t\t   cancelacquire(node);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    \n    \n    过程总结:\n    \n    1. 空转 (如果当前节点是同步队列中的第二个节点，则直接获得锁返回)\n    2. 获得锁\n    \n    > 注意，这里有两次tryacquire()过程：\n    > 第一次，为了避免同步队列为空时还插入队列产生的性能耗费(cas空转)。\n    > 第二次，就是正常的流程，先插入队尾，然后等待唤醒，再获取锁。\n\n 3. selfinterrupt (): 唤醒当前线程\n    \n    static void selfinterrupt() {//在获取锁之后 响应intterpt()请求\n    \tthread.currentthread().interrupt();\n    }\n    \n    \n    1\n    2\n    3\n    \n\n\n# 非公平锁\n\n一阶段\n\n#java.util.concurrent.locks.reentrantlock.nonfairsync\nfinal void lock() {\n\t//在acquire()之前先尝试获取锁\n\tif (compareandsetstate(0, 1))\n\t\tsetexclusiveownerthread(thread.currentthread());\n\telse\n\t\tacquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n二阶段 acquire () 流程与公平锁一模一样，唯一区别在于 tryacquire () 实现中\n\n#java.util.concurrent.locks.reentrantlock.nonfairsync\nprotected final boolean tryacquire(int acquires) {\n \treturn nonfairtryacquire(acquires);\n }\n \n#java.util.concurrent.locks.reentrantlock.sync\n final boolean nonfairtryacquire(int acquires) {//这个过程其实和fairsync.tryacquire()基本一致\n\tfinal thread current = thread.currentthread();\n\tint c = getstate();\n\tif (c == 0) {\n\t\t//唯一区别: 这里不会去判断队列中是否为空\n\t\tif (compareandsetstate(0, acquires)) {\n\t\t\tsetexclusiveownerthread(current);\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (current == getexclusiveownerthread()) {\n\t\tint nextc = c + acquires;\n\t\tif (nextc < 0) // overflow\n\t\t\tthrow new error("maximum lock count exceeded");\n\t\tsetstate(nextc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n区别点           lock () 过程 (一阶段)      tryacquire () 过程 (二阶段)\nfairsync      直接 acquire ()         当前若无线程持有锁，如果同步队列为空，获取锁\nnonfairsync   先尝试获取锁，再 acquire ()   当前若无线程持有锁，获取锁\n\n\n# unlock() 过程\n\n#java.util.concurrent.locks.reentrantlock\npublic void unlock() {\n\tsync.release(1);\n}\n#java.util.concurrent.locks.abstractqueuedsynchronizer\npublic final boolean release(int arg) {\nif (tryrelease(arg)) {//释放锁\n\tnode h = head;\n\tif (h != null &&//head节点为空(非公平锁直接获取锁)\n\th.waitstatus != 0)\n\t\tunparksuccessor(h);//唤醒同步队列中离head最近的一个waitstatus<=0的节点\n\treturn true;\n}\nreturn false;\n}\n#java.util.concurrent.locks.reentrantlock\nprotected final boolean tryrelease(int releases) {\n\tint c = getstate() - releases;\n\t//持有锁的线程==当前线程\n\tif (thread.currentthread() != getexclusiveownerthread())\n\t\tthrow new illegalmonitorstateexception();\n\tboolean free = false;\n\tif (c == 0) {//重入锁全部释放\n\t\tfree = true;\n\t\t//置空持有锁线程\n\t\tsetexclusiveownerthread(null);\n\t}\n\t//state==0(此时持有锁,不用cas)\n\tsetstate(c);\n\treturn free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# lockinterruptibly() 中断锁过程\n\nlockinterruptibly () 与 lock () 过程基本相同，区别在于 thread.intterpt () 的应对措施不同。\n\nreentrantlock 中的 lockinterruptibly () 方法使得线程可以在被阻塞时响应中断，比如一个线程 t1 通过 lockinterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过 lockinterruptibly() 方法就可以立刻打断 t1 线程的执行，来获取 t1 持有的那个可重入锁。而通过 reentrantlock 的 lock () 方法或者 synchronized 持有锁的线程是不会响应其他线程的 interrupt () 方法的，直到该方法主动释放锁之后才会响应 interrupt () 方法。\n\n//lock()\nfinal boolean acquirequeued(final node node, int arg) {\n\tboolean failed = true;\n\ttry {\n\t\t//表示是否被打断\n\t\tboolean interrupted = false;\n\t\tfor (;;) {\n\t\t\t//获取node.pre节点\n\t\t\tfinal node p = node.predecessor();\n\t\t\tif (p == head //当前节点是否是同步队列中的第二个节点\n\t\t\t&& tryacquire(arg)) {//获取锁,当前head指向当前节点\n\t\t\t\tsethead(node);//head=head.next\n\t\t\t\tp.next = null;//置空 \n\t\t\t\tfailed = false;\n\t\t\t\treturn interrupted;\n\t\t\t}\n\n\t\t\tif (shouldparkafterfailedacquire(p, node) && //是否空转(因为空转唤醒是个耗时操作,进入空转前判断pre节点状态.如果pre节点即将释放锁,则不进入空转)\n\t\t\t\tparkandcheckinterrupt())//利用unsafe.park()进行空转(阻塞)\n\t\t\t\tinterrupted = true;//如果thread.interrupt()被调用,(不会真的被打断,会继续循环空转直到获取到锁)\n\t\t}\n\t} finally {\n\t\tif (failed)//tryacquire()过程出现异常导致获取锁失败,则移除当前节点\n\t\t\tcancelacquire(node);\n\t}\n}\n// lockinterruptibly()\nprivate void doacquireinterruptibly(int arg)\n\tthrows interruptedexception {\n\tfinal node node = addwaiter(node.exclusive);\n\tboolean failed = true;\n\ttry {\n\t\tfor (;;) {\n\t\t\tfinal node p = node.predecessor();\n\t\t\tif (p == head && tryacquire(arg)) {\n\t\t\t\tsethead(node);\n\t\t\t\tp.next = null; \n\t\t\t\tfailed = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldparkafterfailedacquire(p, node) &&\n\t\t\t\tparkandcheckinterrupt())//唯一区别当thread.intterpt()打断时,直接抛出异常\n\t\t\t\tthrow new interruptedexception();\n\t\t}\n\t} finally {\n\t\tif (failed)//然后移除当前节点\n\t\t\tcancelacquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n * 中断锁代码测试：csdn\n\n\n# trylock()\n\n#java.util.concurrent.locks.reentrantlock\npublic boolean trylock() {\n\t//尝试获取非公平锁\n\treturn sync.nonfairtryacquire(1);\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# trylock(long timeout, timeunit unit)\n\n#java.util.concurrent.locks.reentrantlock\npublic boolean trylock(long timeout, timeunit unit)\n\t\tthrows interruptedexception {\n\treturn sync.tryacquirenanos(1, unit.tonanos(timeout));\n}\n#java.util.concurrent.locks.abstractqueuedsynchronizer\npublic final boolean tryacquirenanos(int arg, long nanostimeout)\n\t\tthrows interruptedexception {\n\tif (thread.interrupted())\n\t\tthrow new interruptedexception();\n\treturn tryacquire(arg) ||//获取锁(公平/非公平)\n\t\tdoacquirenanos(arg, nanostimeout);//在指定时间内等待锁(空转)\n}\n\nprivate boolean doacquirenanos(int arg, long nanostimeout)\n\t\tthrows interruptedexception {\n\t...\n\tfinal long deadline = system.nanotime() + nanostimeout;\n\t//加入队尾\n\tfinal node node = addwaiter(node.exclusive);\n\tboolean failed = true;\n\ttry {\n\t\tfor (;;) {\n\t\t\tfinal node p = node.predecessor();\n\t\t\tif (p == head && tryacquire(arg)) {\n\t\t\t\tsethead(node);\n\t\t\t\tp.next = null; \n\t\t\t\tfailed = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t  //上面与acquirequeued()相同,重点看这里\n\t\t  //计算剩余时间\n\t\t\tnanostimeout = deadline - system.nanotime();\n\t\t\tif (nanostimeout <= 0l)\n\t\t\t\treturn false;\n\t\t\tif (shouldparkafterfailedacquire(p, node) &&\n\t\t\t\tnanostimeout > spinfortimeoutthreshold)\n\t\t\t\t//利用parknanos()指定空转时间\n\t\t\t\tlocksupport.parknanos(this, nanostimeout);\n\t\t\tif (thread.interrupted())//如果被thread.interrupt(),则抛异常\n\t\t\t\tthrow new interruptedexception();\n\t\t}\n\t} finally {\n\t\tif (failed)//移除节点\n\t\t\tcancelacquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# reentrantlock 的等待 / 通知机制\n\n\n# newcondition()\n\npublic condition newcondition() {\n\treturn sync.newcondition();\n}\n#java.util.concurrent.locks.reentrantlock.sync\nfinal conditionobject newcondition() {\n\treturn new conditionobject();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 等待和唤醒\n\n我们知道关键字 synchronized + object 的 wait 和 notify、notifyall 方法能实现等待 / 通知机制，那么 reentrantlock 是否也能实现这样的等待 / 通知机制，答案是：可以。 reentrantlock 通过 condition 对象，也就是条件队列实现了和 wait、notify、notifyall 相同的语义。 线程执行 condition.await() 方法，将节点 1 从同步队列转移到条件队列中。\n\n\n\n线程执行 condition.signal() 方法，将节点 1 从条件队列中转移到同步队列。\n\n\n\n因为只有在同步队列中的线程才能去获取锁，所以通过 condition 对象的 wait 和 signal 方法能实现等待 / 通知机制。\n\n * 等待和唤醒部分\n\n如果想单独唤醒部分线程应该怎么做呢？这时就有必要使用多个 condition 对象了，因为 reentrantlock 支持创建多个 condition 对象，例如：\n\n//为了减少篇幅 仅给出伪代码\nreentrantlock lock = new reentrantlock();\ncondition condition = lock.newcondition();\ncondition condition1 = lock.newcondition();\n\n//线程1 调用condition.await() 线程进入到条件队列\ncondition.await();\n\n//线程2 调用condition1.await() 线程进入到条件队列\ncondition1.await();\n\n//线程32 调用condition.signal() 仅唤醒调用condition中的线程，不会影响到调用condition1。\ncondition1.await();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这样就实现了部分唤醒的功能。\n\n\n# reentrantlock 和 synchronized 对比\n\n               reentrantlock   synchronized\n底层实现           通过 aqs 实现       通过 jvm 实现，其中 synchronized 又有多个类型的锁，除了重量级锁是通过 monitor 对象\n                               (操作系统 mutex 互斥原语) 实现外，其它类型的通过对象头实现。\n是否可重入          是               是\n公平锁            是               否\n非公平锁           是               是\n锁的类型           悲观锁、显式锁         悲观锁、隐式锁 (内置锁)\n是否支持中断         是               否\n是否支持超时等待       是               否\n是否自动获取 / 释放锁   否               是',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"JDK/Dubbo/Spring 三种SPI机制解析",frontmatter:{title:"JDK/Dubbo/Spring 三种SPI机制解析",date:"2022-02-15T00:00:00.000Z",tags:["SPI"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/SPI_JdkDubboSpring.html",relativePath:"views/backend/SPI_JdkDubboSpring.md",key:"v-6ebf631e",path:"/views/backend/SPI_JdkDubboSpring.html",headers:[{level:2,title:"SPI 有什么用？",slug:"spi-有什么用",normalizedTitle:"spi 有什么用？",charIndex:3},{level:2,title:"JDK SPI",slug:"jdk-spi",normalizedTitle:"jdk spi",charIndex:16},{level:2,title:"Dubbo SPI",slug:"dubbo-spi",normalizedTitle:"dubbo spi",charIndex:27},{level:2,title:"Spring SPI",slug:"spring-spi",normalizedTitle:"spring spi",charIndex:40},{level:2,title:"对比",slug:"对比",normalizedTitle:"对比",charIndex:54},{level:2,title:"SPI 的使用",slug:"spi-的使用",normalizedTitle:"spi 的使用",charIndex:60},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:71}],headersStr:"SPI 有什么用？ JDK SPI Dubbo SPI Spring SPI 对比 SPI 的使用 参考",content:' * SPI 有什么用？\n * JDK SPI\n * Dubbo SPI\n * Spring SPI\n * 对比\n * SPI 的使用\n * 参考\n\n\n\n> SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。\n\n本文主要是特性 & 用法介绍，不涉及源码解析（源码都很简单，相信你一定一看就懂）\n\n\n# SPI 有什么用？\n\n举个栗子，现在我们设计了一款全新的日志框架：super-logger。默认以XML文件作为我们这款日志的配置文件，并设计了一个配置文件解析的接口：\n\npackage com.github.kongwu.spisamples;\n\npublic interface SuperLoggerConfiguration {\n\tvoid configure(String configFile);\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后来一个默认的XML实现：\n\npackage com.github.kongwu.spisamples;\n\npublic class XMLConfiguration implements SuperLoggerConfiguration{\n\tpublic void configure(String configFile){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n那么我们在初始化，解析配置时，只需要调用这个XMLConfiguration来解析XML配置文件即可。\n\npackage com.github.kongwu.spisamples;\n\npublic class LoggerFactory {\n    static {\n        SuperLoggerConfiguration configuration = new XMLConfiguration();\n    \tconfiguration.configure(configFile);\n    }\n\n    public static getLogger(Class clazz){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这样就完成了一个基础的模型，看起来也没什么问题。不过扩展性不太好，因为如果想定制/扩展/重写解析功能的话，我还得重新定义入口的代码，LoggerFactory 也得重写，不够灵活，侵入性太强了。\n\n比如现在用户/使用方想增加一个 yml 文件的方式，作为日志配置文件，那么只需要新建一个YAMLConfiguration，实现 SuperLoggerConfiguration 就可以。但是……怎么注入呢，怎么让 LoggerFactory中使用新建的这个 YAMLConfiguration ？难不成连 LoggerFactory 也重写了？\n\n如果借助SPI机制的话，这个事情就很简单了，可以很方便的完成这个入口的扩展功能。\n\n下面就先来看看，利用JDK 的 SPI 机制怎么解决上面的扩展性问题。\n\n\n# JDK SPI\n\nJDK 中 提供了一个 SPI 的功能，核心类是 java.util.ServiceLoader。其作用就是，可以通过类名获取在"META-INF/services/"下的多个配置实现文件。\n\n为了解决上面的扩展问题，现在我们在META-INF/services/下创建一个com.github.kongwu.spisamples.SuperLoggerConfiguration文件（没有后缀）。文件中只有一行代码，那就是我们默认的com.github.kongwu.spisamples.XMLConfiguration（注意，一个文件里也可以写多个实现，回车分隔）\n\nMETA-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:\n\ncom.github.kongwu.spisamples.XMLConfigurationCOPY\n\n\n1\n2\n3\n\n\n然后通过 ServiceLoader 获取我们的 SPI 机制配置的实现类：\n\nServiceLoader<SuperLoggerConfiguration> serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);\nIterator<SuperLoggerConfiguration> iterator = serviceLoader.iterator();\nSuperLoggerConfiguration configuration;\n\nwhile(iterator.hasNext()) {\n    //加载并初始化实现类\n\tconfiguration = iterator.next();\n}\n\n//对最后一个configuration类调用configure方法\nconfiguration.configure(configFile);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后在调整LoggerFactory中初始化配置的方式为现在的SPI方式：\n\npackage com.github.kongwu.spisamples;\n\npublic class LoggerFactory {\n\tstatic {\n        ServiceLoader<SuperLoggerConfiguration> serviceLoader = ServiceLoader.load(SuperLoggerConfiguration.class);\n        Iterator<SuperLoggerConfiguration> iterator = serviceLoader.iterator();\n        SuperLoggerConfiguration configuration;\n\n        while(iterator.hasNext()) {\n            configuration = iterator.next();//加载并初始化实现类\n        }\n        configuration.configure(configFile);\n    }\n    \n    public static getLogger(Class clazz){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n等等，这里为什么是用 iterator ? 而不是get之类的只获取一个实例的方法？\n\n试想一下，如果是一个固定的get方法，那么get到的是一个固定的实例，SPI 还有什么意义呢？\n\nSPI 的目的，就是增强扩展性。将固定的配置提取出来，通过 SPI 机制来配置。那既然如此，一般都会有一个默认的配置，然后通过 SPI 的文件配置不同的实现，这样就会存在一个接口多个实现的问题。要是找到多个实现的话，用哪个实现作为最后的实例呢？\n\n所以这里使用iterator来获取所有的实现类配置。刚才已经在我们这个 super-logger 包里增加了默认的SuperLoggerConfiguration 实现。\n\n为了支持 YAML 配置，现在在使用方/用户的代码里，增加一个YAMLConfiguration的 SPI 配置：\n\nMETA-INF/services/com.github.kongwu.spisamples.SuperLoggerConfiguration:\n\ncom.github.kongwu.spisamples.ext.YAMLConfiguration\n\n\n1\n2\n3\n\n\n此时通过iterator方法，就会获取到默认的XMLConfiguration和我们扩展的这个YAMLConfiguration两个配置实现类了。\n\n在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们使用最后一个实现配置作为最终的实例。\n\n再等等？最后一个？怎么算最后一个？\n\n使用方/用户自定义的的这个 YAMLConfiguration 一定是最后一个吗？\n\n这个真的不一定，取决于我们运行时的 ClassPath 配置，在前面加载的jar自然在前，最后的jar里的自然当然也在后面。所以如果用户的包在ClassPath中的顺序比super-logger的包更靠后，才会处于最后一个位置；如果用户的包位置在前，那么所谓的最后一个仍然是默认的XMLConfiguration。\n\n举个栗子，如果我们程序的启动脚本为：\n\njava -cp super-logger.jar:a.jar:b.jar:main.jar example.Main\n\n\n1\n\n\n默认的XMLConfiguration SPI配置在super-logger.jar，扩展的YAMLConfiguration SPI配置文件在main.jar，那么iterator获取的最后一个元素一定为YAMLConfiguration。\n\n但这个classpath顺序如果反了呢？main.jar 在前，super-logger.jar 在后\n\njava -cp main.jar:super-logger.jar:a.jar:b.jar example.Main\n\n\n1\n\n\n这样一来，iterator 获取的最后一个元素又变成了默认的XMLConfiguration，我们使用 JDK SPI 没啥意义了，获取的又是第一个，还是默认的XMLConfiguration。\n\n由于这个加载顺序（classpath）是由用户指定的，所以无论我们加载第一个还是最后一个，都有可能会导致加载不到用户自定义的那个配置。\n\n所以这也是JDK SPI机制的一个劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠ClassPath的顺序是一个非常不严谨的方式\n\nJDK SPI机制的缺点是：会加载所有的实现类，需要知道接口的所有具体实现类，通过迭代的方式获取指定的实现类。（可能还会存在并发问题）\n\n\n# Dubbo SPI\n\n> Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。\n\nDubbo 中实现了一套新的 SPI 机制，功能更强大，也更复杂一些。相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下，配置内容如下（以下demo来自dubbo官方文档）。\n\noptimusPrime = org.apache.spi.OptimusPrime\nbumblebee = org.apache.spi.Bumblebee\n\n\n1\n2\n\n\n与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外在使用时还需要在接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：\n\n@SPI\npublic interface Robot {\n    void sayHello();\n}\n\npublic class OptimusPrime implements Robot {\n\n    @Override\n    public void sayHello() {\n        System.out.println("Hello, I am Optimus Prime.");\n    }\n}\n\npublic class Bumblebee implements Robot {\n\n    @Override\n    public void sayHello() {\n        System.out.println("Hello, I am Bumblebee.");\n    }\n}\n\npublic class DubboSPITest {\n\n    @Test\n    public void sayHello() throws Exception {\n        ExtensionLoader<Robot> extensionLoader = \n            ExtensionLoader.getExtensionLoader(Robot.class);\n        Robot optimusPrime = extensionLoader.getExtension("optimusPrime");\n        optimusPrime.sayHello();\n        Robot bumblebee = extensionLoader.getExtension("bumblebee");\n        bumblebee.sayHello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nDubbo SPI 和 JDK SPI 最大的区别就在于支持“别名”，可以通过某个扩展点的别名来获取固定的扩展点。就像上面的例子中，我可以获取 Robot 多个 SPI 实现中别名为“optimusPrime”的实现，也可以获取别名为“bumblebee”的实现，这个功能非常有用！\n\n通过 @SPI 注解的 value 属性，还可以默认一个“别名”的实现。比如在Dubbo 中，默认的是Dubbo 私有协议：dubbo protocol – dubbo:// ** 来看看Dubbo中协议的接口：\n\n@SPI("dubbo")\npublic interface Protocol {\n\t......\n}\n\n\n1\n2\n3\n4\n\n\n在 Protocol 接口上，增加了一个 @SPI 注解，而注解的 value 值为 Dubbo ，通过 SPI 获取实现时就会获取 Protocol SPI 配置中别名为dubbo的那个实现，com.alibaba.dubbo.rpc.Protocol文件如下：\n\nfilter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper\nmock=com.alibaba.dubbo.rpc.support.MockProtocol\n\ndubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol\n\ninjvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol\nrmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol\nhessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol\ncom.alibaba.dubbo.rpc.protocol.http.HttpProtocol\ncom.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol\nthrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocol\nmemcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol\nredis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol\nrest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocol\nregistry=com.alibaba.dubbo.registry.integration.RegistryProtocol\nqos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然后只需要通过getDefaultExtension，就可以获取到 @SPI 注解上value对应的那个扩展实现了\n\nProtocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getDefaultExtension();\n\n\n1\n\n\n还有一个 Adaptive 的机制，虽然非常灵活，但……用法并不是很“优雅”，这里就不介绍了\n\nDubbo 的 SPI 中还有一个“加载优先级”，优先加载内置（internal）的，然后加载外部的（external），按优先级顺序加载，如果遇到重复就跳过不会加载了。\n\n所以如果想靠classpath加载顺序去覆盖内置的扩展，也是个不太理智的做法，原因同上 – 加载顺序不严谨\n\n\n# Spring SPI\n\nSpring 的 SPI 配置文件是一个固定的文件 – META-INF/spring.factories，功能上和 JDK 的类似，每个接口可以有多个扩展实现，使用起来非常简单：\n\nList<LoggingSystemFactory> factories = \n    SpringFactoriesLoader.loadFactories(LoggingSystemFactory.class, classLoader);\n\n\n1\n2\n\n\n下面是一段 Spring Boot 中 spring.factories 的配置\n\n# Logging Systems\norg.springframework.boot.logging.LoggingSystemFactory=\\\norg.springframework.boot.logging.logback.LogbackLoggingSystem.Factory,\\\norg.springframework.boot.logging.log4j2.Log4J2LoggingSystem.Factory,\\\norg.springframework.boot.logging.java.JavaLoggingSystem.Factory\n\n# PropertySource Loaders\norg.springframework.boot.env.PropertySourceLoader=\\\norg.springframework.boot.env.PropertiesPropertySourceLoader,\\\norg.springframework.boot.env.YamlPropertySourceLoader\n\n# ConfigData Location Resolvers\norg.springframework.boot.context.config.ConfigDataLocationResolver=\\\norg.springframework.boot.context.config.ConfigTreeConfigDataLocationResolver,\\\norg.springframework.boot.context.config.StandardConfigDataLocationResolver\n\n......\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nSpring SPI 中，将所有的配置放到一个固定的文件中，省去了配置一大堆文件的麻烦。至于多个接口的扩展配置，是用一个文件好，还是每个单独一个文件好这个，这个问题就见仁见智了（个人喜欢 Spring 这种，干净利落）。\n\nSpring的SPI 虽然属于spring-framework(core)，但是目前主要用在spring boot中……\n\n和前面两种 SPI 机制一样，Spring 也是支持 ClassPath 中存在多个 spring.factories 文件的，加载时会按照 classpath 的顺序依次加载这些 spring.factories 文件，添加到一个 ArrayList 中。由于没有别名，所以也没有去重的概念，有多少就添加多少。\n\n但由于 Spring 的 SPI 主要用在 Spring Boot 中，而 Spring Boot 中的 ClassLoader 会优先加载项目中的文件，而不是依赖包中的文件。所以如果在你的项目中定义个spring.factories文件，那么你项目中的文件会被第一个加载，得到的Factories中，项目中spring.factories里配置的那个实现类也会排在第一个\n\n如果我们要扩展某个接口的话，只需要在你的项目（spring boot）里新建一个META-INF/spring.factories文件，只添加你要的那个配置，不要完整的复制一遍 Spring Boot 的 spring.factories 文件然后修改 ** 比如我只想添加一个新的 LoggingSystemFactory 实现，那么我只需要新建一个META-INF/spring.factories文件，而不是完整的复制+修改：\n\norg.springframework.boot.logging.LoggingSystemFactory=\\\ncom.example.log4j2demo.Log4J2LoggingSystem.FactoryCOPY\n\n\n1\n2\n\n\n\n# 对比\n\n            JDK SPI           DUBBO SPI                                                   SPRING SPI\n文件方式        每个扩展点单独一个文件       每个扩展点单独一个文件                                                 所有的扩展点在一个文件\n获取某个固定的实现   不支持，只能按顺序获取所有实现   有“别名”的概念，可以通过名称获取扩展点的某个固定实现，配合Dubbo SPI的注解很方便               不支持，只能按顺序获取所有实现。但由于Spring Boot\n                                                                                          ClassLoader会优先加载用户代码中的文件，所以可以保证用户自定义的spring.factoires文件在第一个，通过获取第一个factory的方式就可以固定获取自定义的扩展\n其他          无                 支持Dubbo内部的依赖注入，通过目录来区分Dubbo 内置SPI和外部SPI，优先加载内部，保证内部的优先级最高   无\n文档完整度       文章 & 三方资料足够丰富     文档 & 三方资料足够丰富                                               文档不够丰富，但由于功能少，使用非常简单\nIDE支持       无                 无                                                           IDEA 完美支持，有语法提示\n\n三种 SPI 机制对比之下，JDK 内置的机制是最弱鸡的，但是由于是 JDK 内置，所以还是有一定应用场景，毕竟不用额外的依赖；Dubbo 的功能最丰富，但机制有点复杂了，而且只能配合 Dubbo 使用，不能完全算是一个独立的模块；Spring 的功能和JDK的相差无几，最大的区别是所有扩展点写在一个 spring.factories 文件中，也算是一个改进，并且 IDEA 完美支持语法提示。\n\n\n# SPI 的使用\n\n举个简单的例子：\n\n有个maven工程，分为三个项目：\n\n * 项目1有一个接口Pay.java\n * 项目2依赖项目1，有个实现类AliPay.java，在resources下创建META-INF.services包，采用SPI的方式暴露出实现类\n * 项目3依赖项目1，有个实现类WeiXinPay.java，在resources下创建META-INF.services包，采用SPI的方式暴露出实现类\n\n新建一个项目4，测试：\n\npublic static void main(String[] args) {\n    ServiceLoader<Pay> services = ServiceLoader.load(Pay.class);\n    for (Pay pay : services) {\n        pay.pay();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 若项目4依赖项目1和项目2，此时项目4用的实现类为AliPay\n * 若项目4依赖项目1和项目3，此时项目4用的实现类为WeiXinPay\n * 若项目4依赖项目1和项目2、项目3，此时项目4用的实现类为AliPay、WeiXinPay\n\n\n# 参考\n\n * Introduction to the Service Provider Interfaces – Oracle\n * Dubbo SPI – Apache Dubbo\n * Creating Your Own Auto-configuration – Spring',normalizedContent:' * spi 有什么用？\n * jdk spi\n * dubbo spi\n * spring spi\n * 对比\n * spi 的使用\n * 参考\n\n\n\n> spi 全称为 service provider interface，是一种服务发现机制。spi 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 spi 机制为我们的程序提供拓展功能。\n\n本文主要是特性 & 用法介绍，不涉及源码解析（源码都很简单，相信你一定一看就懂）\n\n\n# spi 有什么用？\n\n举个栗子，现在我们设计了一款全新的日志框架：super-logger。默认以xml文件作为我们这款日志的配置文件，并设计了一个配置文件解析的接口：\n\npackage com.github.kongwu.spisamples;\n\npublic interface superloggerconfiguration {\n\tvoid configure(string configfile);\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后来一个默认的xml实现：\n\npackage com.github.kongwu.spisamples;\n\npublic class xmlconfiguration implements superloggerconfiguration{\n\tpublic void configure(string configfile){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n那么我们在初始化，解析配置时，只需要调用这个xmlconfiguration来解析xml配置文件即可。\n\npackage com.github.kongwu.spisamples;\n\npublic class loggerfactory {\n    static {\n        superloggerconfiguration configuration = new xmlconfiguration();\n    \tconfiguration.configure(configfile);\n    }\n\n    public static getlogger(class clazz){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这样就完成了一个基础的模型，看起来也没什么问题。不过扩展性不太好，因为如果想定制/扩展/重写解析功能的话，我还得重新定义入口的代码，loggerfactory 也得重写，不够灵活，侵入性太强了。\n\n比如现在用户/使用方想增加一个 yml 文件的方式，作为日志配置文件，那么只需要新建一个yamlconfiguration，实现 superloggerconfiguration 就可以。但是……怎么注入呢，怎么让 loggerfactory中使用新建的这个 yamlconfiguration ？难不成连 loggerfactory 也重写了？\n\n如果借助spi机制的话，这个事情就很简单了，可以很方便的完成这个入口的扩展功能。\n\n下面就先来看看，利用jdk 的 spi 机制怎么解决上面的扩展性问题。\n\n\n# jdk spi\n\njdk 中 提供了一个 spi 的功能，核心类是 java.util.serviceloader。其作用就是，可以通过类名获取在"meta-inf/services/"下的多个配置实现文件。\n\n为了解决上面的扩展问题，现在我们在meta-inf/services/下创建一个com.github.kongwu.spisamples.superloggerconfiguration文件（没有后缀）。文件中只有一行代码，那就是我们默认的com.github.kongwu.spisamples.xmlconfiguration（注意，一个文件里也可以写多个实现，回车分隔）\n\nmeta-inf/services/com.github.kongwu.spisamples.superloggerconfiguration:\n\ncom.github.kongwu.spisamples.xmlconfigurationcopy\n\n\n1\n2\n3\n\n\n然后通过 serviceloader 获取我们的 spi 机制配置的实现类：\n\nserviceloader<superloggerconfiguration> serviceloader = serviceloader.load(superloggerconfiguration.class);\niterator<superloggerconfiguration> iterator = serviceloader.iterator();\nsuperloggerconfiguration configuration;\n\nwhile(iterator.hasnext()) {\n    //加载并初始化实现类\n\tconfiguration = iterator.next();\n}\n\n//对最后一个configuration类调用configure方法\nconfiguration.configure(configfile);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n最后在调整loggerfactory中初始化配置的方式为现在的spi方式：\n\npackage com.github.kongwu.spisamples;\n\npublic class loggerfactory {\n\tstatic {\n        serviceloader<superloggerconfiguration> serviceloader = serviceloader.load(superloggerconfiguration.class);\n        iterator<superloggerconfiguration> iterator = serviceloader.iterator();\n        superloggerconfiguration configuration;\n\n        while(iterator.hasnext()) {\n            configuration = iterator.next();//加载并初始化实现类\n        }\n        configuration.configure(configfile);\n    }\n    \n    public static getlogger(class clazz){\n    \t......\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n等等，这里为什么是用 iterator ? 而不是get之类的只获取一个实例的方法？\n\n试想一下，如果是一个固定的get方法，那么get到的是一个固定的实例，spi 还有什么意义呢？\n\nspi 的目的，就是增强扩展性。将固定的配置提取出来，通过 spi 机制来配置。那既然如此，一般都会有一个默认的配置，然后通过 spi 的文件配置不同的实现，这样就会存在一个接口多个实现的问题。要是找到多个实现的话，用哪个实现作为最后的实例呢？\n\n所以这里使用iterator来获取所有的实现类配置。刚才已经在我们这个 super-logger 包里增加了默认的superloggerconfiguration 实现。\n\n为了支持 yaml 配置，现在在使用方/用户的代码里，增加一个yamlconfiguration的 spi 配置：\n\nmeta-inf/services/com.github.kongwu.spisamples.superloggerconfiguration:\n\ncom.github.kongwu.spisamples.ext.yamlconfiguration\n\n\n1\n2\n3\n\n\n此时通过iterator方法，就会获取到默认的xmlconfiguration和我们扩展的这个yamlconfiguration两个配置实现类了。\n\n在上面那段加载的代码里，我们遍历iterator，遍历到最后，我们使用最后一个实现配置作为最终的实例。\n\n再等等？最后一个？怎么算最后一个？\n\n使用方/用户自定义的的这个 yamlconfiguration 一定是最后一个吗？\n\n这个真的不一定，取决于我们运行时的 classpath 配置，在前面加载的jar自然在前，最后的jar里的自然当然也在后面。所以如果用户的包在classpath中的顺序比super-logger的包更靠后，才会处于最后一个位置；如果用户的包位置在前，那么所谓的最后一个仍然是默认的xmlconfiguration。\n\n举个栗子，如果我们程序的启动脚本为：\n\njava -cp super-logger.jar:a.jar:b.jar:main.jar example.main\n\n\n1\n\n\n默认的xmlconfiguration spi配置在super-logger.jar，扩展的yamlconfiguration spi配置文件在main.jar，那么iterator获取的最后一个元素一定为yamlconfiguration。\n\n但这个classpath顺序如果反了呢？main.jar 在前，super-logger.jar 在后\n\njava -cp main.jar:super-logger.jar:a.jar:b.jar example.main\n\n\n1\n\n\n这样一来，iterator 获取的最后一个元素又变成了默认的xmlconfiguration，我们使用 jdk spi 没啥意义了，获取的又是第一个，还是默认的xmlconfiguration。\n\n由于这个加载顺序（classpath）是由用户指定的，所以无论我们加载第一个还是最后一个，都有可能会导致加载不到用户自定义的那个配置。\n\n所以这也是jdk spi机制的一个劣势，无法确认具体加载哪一个实现，也无法加载某个指定的实现，仅靠classpath的顺序是一个非常不严谨的方式\n\njdk spi机制的缺点是：会加载所有的实现类，需要知道接口的所有具体实现类，通过迭代的方式获取指定的实现类。（可能还会存在并发问题）\n\n\n# dubbo spi\n\n> dubbo 就是通过 spi 机制加载所有的组件。不过，dubbo 并未使用 java 原生的 spi 机制，而是对其进行了增强，使其能够更好的满足需求。在 dubbo 中，spi 是一个非常重要的模块。基于 spi，我们可以很容易的对 dubbo 进行拓展。如果大家想要学习 dubbo 的源码，spi 机制务必弄懂。接下来，我们先来了解一下 java spi 与 dubbo spi 的用法，然后再来分析 dubbo spi 的源码。\n\ndubbo 中实现了一套新的 spi 机制，功能更强大，也更复杂一些。相关逻辑被封装在了 extensionloader 类中，通过 extensionloader，我们可以加载指定的实现类。dubbo spi 所需的配置文件需放置在 meta-inf/dubbo 路径下，配置内容如下（以下demo来自dubbo官方文档）。\n\noptimusprime = org.apache.spi.optimusprime\nbumblebee = org.apache.spi.bumblebee\n\n\n1\n2\n\n\n与 java spi 实现类配置不同，dubbo spi 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外在使用时还需要在接口上标注 @spi 注解。下面来演示 dubbo spi 的用法：\n\n@spi\npublic interface robot {\n    void sayhello();\n}\n\npublic class optimusprime implements robot {\n\n    @override\n    public void sayhello() {\n        system.out.println("hello, i am optimus prime.");\n    }\n}\n\npublic class bumblebee implements robot {\n\n    @override\n    public void sayhello() {\n        system.out.println("hello, i am bumblebee.");\n    }\n}\n\npublic class dubbospitest {\n\n    @test\n    public void sayhello() throws exception {\n        extensionloader<robot> extensionloader = \n            extensionloader.getextensionloader(robot.class);\n        robot optimusprime = extensionloader.getextension("optimusprime");\n        optimusprime.sayhello();\n        robot bumblebee = extensionloader.getextension("bumblebee");\n        bumblebee.sayhello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\ndubbo spi 和 jdk spi 最大的区别就在于支持“别名”，可以通过某个扩展点的别名来获取固定的扩展点。就像上面的例子中，我可以获取 robot 多个 spi 实现中别名为“optimusprime”的实现，也可以获取别名为“bumblebee”的实现，这个功能非常有用！\n\n通过 @spi 注解的 value 属性，还可以默认一个“别名”的实现。比如在dubbo 中，默认的是dubbo 私有协议：dubbo protocol – dubbo:// ** 来看看dubbo中协议的接口：\n\n@spi("dubbo")\npublic interface protocol {\n\t......\n}\n\n\n1\n2\n3\n4\n\n\n在 protocol 接口上，增加了一个 @spi 注解，而注解的 value 值为 dubbo ，通过 spi 获取实现时就会获取 protocol spi 配置中别名为dubbo的那个实现，com.alibaba.dubbo.rpc.protocol文件如下：\n\nfilter=com.alibaba.dubbo.rpc.protocol.protocolfilterwrapper\nlistener=com.alibaba.dubbo.rpc.protocol.protocollistenerwrapper\nmock=com.alibaba.dubbo.rpc.support.mockprotocol\n\ndubbo=com.alibaba.dubbo.rpc.protocol.dubbo.dubboprotocol\n\ninjvm=com.alibaba.dubbo.rpc.protocol.injvm.injvmprotocol\nrmi=com.alibaba.dubbo.rpc.protocol.rmi.rmiprotocol\nhessian=com.alibaba.dubbo.rpc.protocol.hessian.hessianprotocol\ncom.alibaba.dubbo.rpc.protocol.http.httpprotocol\ncom.alibaba.dubbo.rpc.protocol.webservice.webserviceprotocol\nthrift=com.alibaba.dubbo.rpc.protocol.thrift.thriftprotocol\nmemcached=com.alibaba.dubbo.rpc.protocol.memcached.memcachedprotocol\nredis=com.alibaba.dubbo.rpc.protocol.redis.redisprotocol\nrest=com.alibaba.dubbo.rpc.protocol.rest.restprotocol\nregistry=com.alibaba.dubbo.registry.integration.registryprotocol\nqos=com.alibaba.dubbo.qos.protocol.qosprotocolwrapper\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n然后只需要通过getdefaultextension，就可以获取到 @spi 注解上value对应的那个扩展实现了\n\nprotocol protocol = extensionloader.getextensionloader(protocol.class).getdefaultextension();\n\n\n1\n\n\n还有一个 adaptive 的机制，虽然非常灵活，但……用法并不是很“优雅”，这里就不介绍了\n\ndubbo 的 spi 中还有一个“加载优先级”，优先加载内置（internal）的，然后加载外部的（external），按优先级顺序加载，如果遇到重复就跳过不会加载了。\n\n所以如果想靠classpath加载顺序去覆盖内置的扩展，也是个不太理智的做法，原因同上 – 加载顺序不严谨\n\n\n# spring spi\n\nspring 的 spi 配置文件是一个固定的文件 – meta-inf/spring.factories，功能上和 jdk 的类似，每个接口可以有多个扩展实现，使用起来非常简单：\n\nlist<loggingsystemfactory> factories = \n    springfactoriesloader.loadfactories(loggingsystemfactory.class, classloader);\n\n\n1\n2\n\n\n下面是一段 spring boot 中 spring.factories 的配置\n\n# logging systems\norg.springframework.boot.logging.loggingsystemfactory=\\\norg.springframework.boot.logging.logback.logbackloggingsystem.factory,\\\norg.springframework.boot.logging.log4j2.log4j2loggingsystem.factory,\\\norg.springframework.boot.logging.java.javaloggingsystem.factory\n\n# propertysource loaders\norg.springframework.boot.env.propertysourceloader=\\\norg.springframework.boot.env.propertiespropertysourceloader,\\\norg.springframework.boot.env.yamlpropertysourceloader\n\n# configdata location resolvers\norg.springframework.boot.context.config.configdatalocationresolver=\\\norg.springframework.boot.context.config.configtreeconfigdatalocationresolver,\\\norg.springframework.boot.context.config.standardconfigdatalocationresolver\n\n......\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nspring spi 中，将所有的配置放到一个固定的文件中，省去了配置一大堆文件的麻烦。至于多个接口的扩展配置，是用一个文件好，还是每个单独一个文件好这个，这个问题就见仁见智了（个人喜欢 spring 这种，干净利落）。\n\nspring的spi 虽然属于spring-framework(core)，但是目前主要用在spring boot中……\n\n和前面两种 spi 机制一样，spring 也是支持 classpath 中存在多个 spring.factories 文件的，加载时会按照 classpath 的顺序依次加载这些 spring.factories 文件，添加到一个 arraylist 中。由于没有别名，所以也没有去重的概念，有多少就添加多少。\n\n但由于 spring 的 spi 主要用在 spring boot 中，而 spring boot 中的 classloader 会优先加载项目中的文件，而不是依赖包中的文件。所以如果在你的项目中定义个spring.factories文件，那么你项目中的文件会被第一个加载，得到的factories中，项目中spring.factories里配置的那个实现类也会排在第一个\n\n如果我们要扩展某个接口的话，只需要在你的项目（spring boot）里新建一个meta-inf/spring.factories文件，只添加你要的那个配置，不要完整的复制一遍 spring boot 的 spring.factories 文件然后修改 ** 比如我只想添加一个新的 loggingsystemfactory 实现，那么我只需要新建一个meta-inf/spring.factories文件，而不是完整的复制+修改：\n\norg.springframework.boot.logging.loggingsystemfactory=\\\ncom.example.log4j2demo.log4j2loggingsystem.factorycopy\n\n\n1\n2\n\n\n\n# 对比\n\n            jdk spi           dubbo spi                                                   spring spi\n文件方式        每个扩展点单独一个文件       每个扩展点单独一个文件                                                 所有的扩展点在一个文件\n获取某个固定的实现   不支持，只能按顺序获取所有实现   有“别名”的概念，可以通过名称获取扩展点的某个固定实现，配合dubbo spi的注解很方便               不支持，只能按顺序获取所有实现。但由于spring boot\n                                                                                          classloader会优先加载用户代码中的文件，所以可以保证用户自定义的spring.factoires文件在第一个，通过获取第一个factory的方式就可以固定获取自定义的扩展\n其他          无                 支持dubbo内部的依赖注入，通过目录来区分dubbo 内置spi和外部spi，优先加载内部，保证内部的优先级最高   无\n文档完整度       文章 & 三方资料足够丰富     文档 & 三方资料足够丰富                                               文档不够丰富，但由于功能少，使用非常简单\nide支持       无                 无                                                           idea 完美支持，有语法提示\n\n三种 spi 机制对比之下，jdk 内置的机制是最弱鸡的，但是由于是 jdk 内置，所以还是有一定应用场景，毕竟不用额外的依赖；dubbo 的功能最丰富，但机制有点复杂了，而且只能配合 dubbo 使用，不能完全算是一个独立的模块；spring 的功能和jdk的相差无几，最大的区别是所有扩展点写在一个 spring.factories 文件中，也算是一个改进，并且 idea 完美支持语法提示。\n\n\n# spi 的使用\n\n举个简单的例子：\n\n有个maven工程，分为三个项目：\n\n * 项目1有一个接口pay.java\n * 项目2依赖项目1，有个实现类alipay.java，在resources下创建meta-inf.services包，采用spi的方式暴露出实现类\n * 项目3依赖项目1，有个实现类weixinpay.java，在resources下创建meta-inf.services包，采用spi的方式暴露出实现类\n\n新建一个项目4，测试：\n\npublic static void main(string[] args) {\n    serviceloader<pay> services = serviceloader.load(pay.class);\n    for (pay pay : services) {\n        pay.pay();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 若项目4依赖项目1和项目2，此时项目4用的实现类为alipay\n * 若项目4依赖项目1和项目3，此时项目4用的实现类为weixinpay\n * 若项目4依赖项目1和项目2、项目3，此时项目4用的实现类为alipay、weixinpay\n\n\n# 参考\n\n * introduction to the service provider interfaces – oracle\n * dubbo spi – apache dubbo\n * creating your own auto-configuration – spring',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Spring定时任务添加开关，修改cron不用重启",frontmatter:{title:"Spring定时任务添加开关，修改cron不用重启",date:"2021-11-22T00:00:00.000Z",tags:["定时任务"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/SchedulingConfigurer.html",relativePath:"views/backend/SchedulingConfigurer.md",key:"v-0b69064b",path:"/views/backend/SchedulingConfigurer.html",headers:[{level:3,title:"修改定时任务不重启项目，SpringBoot如何实现？",slug:"修改定时任务不重启项目-springboot如何实现",normalizedTitle:"修改定时任务不重启项目，springboot如何实现？",charIndex:3},{level:3,title:"1、建表 管理定时任务",slug:"_1、建表-管理定时任务",normalizedTitle:"1、建表 管理定时任务",charIndex:34},{level:3,title:"2、代码实现",slug:"_2、代码实现",normalizedTitle:"2、代码实现",charIndex:49},{level:3,title:"3、效果展示",slug:"_3、效果展示",normalizedTitle:"3、效果展示",charIndex:59},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:69},{level:3,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:75}],headersStr:"修改定时任务不重启项目，SpringBoot如何实现？ 1、建表 管理定时任务 2、代码实现 3、效果展示 总结 参考",content:' * 修改定时任务不重启项目，SpringBoot如何实现？\n * 1、建表 管理定时任务\n * 2、代码实现\n * 3、效果展示\n * 总结\n * 参考\n\n\n\n\n# 修改定时任务不重启项目，SpringBoot如何实现？\n\n业务场景描述：定时任务的任务名称，cron（定时任务表达式），定时任务开关，存储在数据库表中。在不重启项目的情况下，修改定时任务表达式，可以实时获取新的定时任务执行时间规则；修改定时任务执行状态，可以随时开关定时任务。\n\n使用技术：基于接口 SchedulingConfigurer\n\n\n# 1、建表 管理定时任务\n\nDROP TABLE IF EXISTS `scheduled_cron`;\nCREATE TABLE `scheduled` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) DEFAULT NULL,\n  `cron` varchar(30) DEFAULT NULL,\n  `description` varchar(30) DEFAULT NULL COMMENT \'描述\',\n  `create_user` varchar(30) DEFAULT NULL COMMENT \'创建人\',\n  `status` tinyint(1) DEFAULT NULL COMMENT \'1开启， 0关闭\',\n  `create_time` datetime DEFAULT NULL COMMENT \'创建时间\',\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n \n-- ----------------------------\n-- Records of scheduled\n-- ----------------------------\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2、代码实现\n\n下面来看看可以在不停服务的情况下动态修改任务周期的实现，步骤如下：\n\n在定时任务类上增加@EnableScheduling注解，并实现SchedulingConfigurer接口。（值得注意的是：@EnableScheduling对Spring的版本要求比较高，一开始使用的3.2.6版本时一直未成功，后来改成4.2.5版本就可以了） 设置一个静态变量cron，用于存放任务执行周期参数。 另辟一线程，用于模拟实际业务中外部原因修改了任务执行周期。 设置任务触发器，触发任务执行，其中就可以修改任务的执行周期。\n\n定时任务配置类：\n\npackage com.example.demo.scheduled;\n \nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.scheduling.annotation.EnableScheduling;\nimport org.springframework.scheduling.annotation.SchedulingConfigurer;\nimport org.springframework.scheduling.config.ScheduledTaskRegistrar;\nimport org.springframework.scheduling.support.CronTrigger;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\n \n/**\n * @Description: 基于接口SchedulingConfigurer的动态定时任务\n */\n@Configuration\n@EnableScheduling\npublic abstract class SchedulingAbstractDynamicCroTask implements SchedulingConfigurer {\n \n    //定时任务周期表达式\n    private String cron;\n    \n    /** \n     * @Description:  重写配置定时任务的方法\n     */\n    @Override\n    public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {\n        scheduledTaskRegistrar.setScheduler(taskScheduler());\n        scheduledTaskRegistrar.addTriggerTask(\n                //执行定时任务\n                () ->\n                {\n                    if(getSwitch()) {\n                        taskService();\n                    }\n                },\n                //设置触发器\n                triggerContext -> {\n                   cron = getCron();//获取定时任务周期表达式\n                   CronTrigger trigger = new CronTrigger(cron);\n                   return trigger.nextExecutionTime(triggerContext);\n                }\n        );\n \n    }\n \n    @Bean\n    public Executor taskScheduler() {\n        //设置线程名称\n        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build();\n        //创建线程池\n        return Executors.newScheduledThreadPool(5, namedThreadFactory);\n    }\n \n    /**\n     * @Description: 执行定时任务\n     */\n    public abstract void taskService();\n \n    /**\n     * @Description: 获取定时任务周期表达式\n     */\n    public abstract String getCron();\n    \n    /**\n     * @Description: 定时任务开关，true为执行\n     */\n    public abstract boolean getSwitch();\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n定时任务\n\npackage com.example.demo.scheduled;\n \nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.example.demo.dao.CronMapper;\nimport com.example.demo.entity.Scheduled;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\n \nimport java.time.LocalDateTime;\n \n/**\n * @Description:\n * @Author: \n */\n@Configuration\npublic class TaskDemo extends ConfigurerSchedulingDemo {\n \n    @Autowired      //注入mapper\n    @SuppressWarnings("all")\n    CronMapper cronMapper;\n    \n    private boolean openFlag = true;\n \n    @Override\n    public void taskService() {\n        System.out.println("定时任务demo1:"\n                           + LocalDateTime.now()+"，线程名称："+Thread.currentThread().getName()\n                           + " 线程id："+Thread.currentThread().getId());\n    }\n \n    @Override\n    public String getCron() {\n        final String defaultCron = "0 */10 * * * ?";\n        QueryWrapper<Scheduled> queryWrapper = new QueryWrapper<>();\n        queryWrapper.eq("name","demo1");\n        Scheduled scheduled = cronMapper.selectOne(queryWrapper);\n        if(scheduled != null) {\n            String cron = scheduled.getCron();\n            Integer status = scheduled.getStatus();\n            openFlag = status == 1 ? true : false;\n            if(!openFalg) {\n                logger.warn("定时任务状态为关闭，不执行此次任务。scheduled:[{}]", scheduled)\n            }\n            return cron;\n        }\n        logger.error("获取cron失败，采用默认cron。scheduled:[{}]", scheduled);\n        return defaultCron;\n    }\n \n    @Override\n    public Integer getSwitch() {\n        return openFlag;\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 3、效果展示\n\n启动项目：控制台输出展示\n\n\n\n修改数据库 demo1的执行时间为每15秒一次：\n\n\n\n关闭demo1的定时任务，将demo1的open状态改为0：\n\n\n\n\n# 总结\n\n此方法，是在触发运行的时候，刷新定时规则，这种方法的缺点是，刷新规则的时间必须是在某次触发运行的时候。\n\n另一种是：https://blog.csdn.net/jianggujin/article/details/77937316\n\n此方法基于 SchedulingConfigurer 的源码，捕获 ScheduledTaskRegistrar 类的实例，通过该类中的 TaskScheduler 实例操作定时任务的增删，而非采用 ScheduledTaskRegistrar.addTriggerTask 方法维护定时任务。所以需要自行写代码维护定时任务列表，控制任务的删减，代码的实现比较繁琐。\n\n如果想要实现可以动态修改的定时策略，建议使用开源组件 Quartz。\n\n\n# 参考\n\n * https://blog.csdn.net/chenping1993/article/details/108274814',normalizedContent:' * 修改定时任务不重启项目，springboot如何实现？\n * 1、建表 管理定时任务\n * 2、代码实现\n * 3、效果展示\n * 总结\n * 参考\n\n\n\n\n# 修改定时任务不重启项目，springboot如何实现？\n\n业务场景描述：定时任务的任务名称，cron（定时任务表达式），定时任务开关，存储在数据库表中。在不重启项目的情况下，修改定时任务表达式，可以实时获取新的定时任务执行时间规则；修改定时任务执行状态，可以随时开关定时任务。\n\n使用技术：基于接口 schedulingconfigurer\n\n\n# 1、建表 管理定时任务\n\ndrop table if exists `scheduled_cron`;\ncreate table `scheduled` (\n  `id` int(11) not null auto_increment,\n  `name` varchar(20) default null,\n  `cron` varchar(30) default null,\n  `description` varchar(30) default null comment \'描述\',\n  `create_user` varchar(30) default null comment \'创建人\',\n  `status` tinyint(1) default null comment \'1开启， 0关闭\',\n  `create_time` datetime default null comment \'创建时间\',\n) engine=innodb default charset=utf8;\n \n-- ----------------------------\n-- records of scheduled\n-- ----------------------------\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2、代码实现\n\n下面来看看可以在不停服务的情况下动态修改任务周期的实现，步骤如下：\n\n在定时任务类上增加@enablescheduling注解，并实现schedulingconfigurer接口。（值得注意的是：@enablescheduling对spring的版本要求比较高，一开始使用的3.2.6版本时一直未成功，后来改成4.2.5版本就可以了） 设置一个静态变量cron，用于存放任务执行周期参数。 另辟一线程，用于模拟实际业务中外部原因修改了任务执行周期。 设置任务触发器，触发任务执行，其中就可以修改任务的执行周期。\n\n定时任务配置类：\n\npackage com.example.demo.scheduled;\n \nimport com.google.common.util.concurrent.threadfactorybuilder;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.scheduling.annotation.enablescheduling;\nimport org.springframework.scheduling.annotation.schedulingconfigurer;\nimport org.springframework.scheduling.config.scheduledtaskregistrar;\nimport org.springframework.scheduling.support.crontrigger;\nimport java.util.concurrent.executor;\nimport java.util.concurrent.executors;\nimport java.util.concurrent.threadfactory;\n \n/**\n * @description: 基于接口schedulingconfigurer的动态定时任务\n */\n@configuration\n@enablescheduling\npublic abstract class schedulingabstractdynamiccrotask implements schedulingconfigurer {\n \n    //定时任务周期表达式\n    private string cron;\n    \n    /** \n     * @description:  重写配置定时任务的方法\n     */\n    @override\n    public void configuretasks(scheduledtaskregistrar scheduledtaskregistrar) {\n        scheduledtaskregistrar.setscheduler(taskscheduler());\n        scheduledtaskregistrar.addtriggertask(\n                //执行定时任务\n                () ->\n                {\n                    if(getswitch()) {\n                        taskservice();\n                    }\n                },\n                //设置触发器\n                triggercontext -> {\n                   cron = getcron();//获取定时任务周期表达式\n                   crontrigger trigger = new crontrigger(cron);\n                   return trigger.nextexecutiontime(triggercontext);\n                }\n        );\n \n    }\n \n    @bean\n    public executor taskscheduler() {\n        //设置线程名称\n        threadfactory namedthreadfactory = new threadfactorybuilder().setnameformat("demo-pool-%d").build();\n        //创建线程池\n        return executors.newscheduledthreadpool(5, namedthreadfactory);\n    }\n \n    /**\n     * @description: 执行定时任务\n     */\n    public abstract void taskservice();\n \n    /**\n     * @description: 获取定时任务周期表达式\n     */\n    public abstract string getcron();\n    \n    /**\n     * @description: 定时任务开关，true为执行\n     */\n    public abstract boolean getswitch();\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n定时任务\n\npackage com.example.demo.scheduled;\n \nimport com.baomidou.mybatisplus.core.conditions.query.querywrapper;\nimport com.example.demo.dao.cronmapper;\nimport com.example.demo.entity.scheduled;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.context.annotation.configuration;\n \nimport java.time.localdatetime;\n \n/**\n * @description:\n * @author: \n */\n@configuration\npublic class taskdemo extends configurerschedulingdemo {\n \n    @autowired      //注入mapper\n    @suppresswarnings("all")\n    cronmapper cronmapper;\n    \n    private boolean openflag = true;\n \n    @override\n    public void taskservice() {\n        system.out.println("定时任务demo1:"\n                           + localdatetime.now()+"，线程名称："+thread.currentthread().getname()\n                           + " 线程id："+thread.currentthread().getid());\n    }\n \n    @override\n    public string getcron() {\n        final string defaultcron = "0 */10 * * * ?";\n        querywrapper<scheduled> querywrapper = new querywrapper<>();\n        querywrapper.eq("name","demo1");\n        scheduled scheduled = cronmapper.selectone(querywrapper);\n        if(scheduled != null) {\n            string cron = scheduled.getcron();\n            integer status = scheduled.getstatus();\n            openflag = status == 1 ? true : false;\n            if(!openfalg) {\n                logger.warn("定时任务状态为关闭，不执行此次任务。scheduled:[{}]", scheduled)\n            }\n            return cron;\n        }\n        logger.error("获取cron失败，采用默认cron。scheduled:[{}]", scheduled);\n        return defaultcron;\n    }\n \n    @override\n    public integer getswitch() {\n        return openflag;\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 3、效果展示\n\n启动项目：控制台输出展示\n\n\n\n修改数据库 demo1的执行时间为每15秒一次：\n\n\n\n关闭demo1的定时任务，将demo1的open状态改为0：\n\n\n\n\n# 总结\n\n此方法，是在触发运行的时候，刷新定时规则，这种方法的缺点是，刷新规则的时间必须是在某次触发运行的时候。\n\n另一种是：https://blog.csdn.net/jianggujin/article/details/77937316\n\n此方法基于 schedulingconfigurer 的源码，捕获 scheduledtaskregistrar 类的实例，通过该类中的 taskscheduler 实例操作定时任务的增删，而非采用 scheduledtaskregistrar.addtriggertask 方法维护定时任务。所以需要自行写代码维护定时任务列表，控制任务的删减，代码的实现比较繁琐。\n\n如果想要实现可以动态修改的定时策略，建议使用开源组件 quartz。\n\n\n# 参考\n\n * https://blog.csdn.net/chenping1993/article/details/108274814',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"SSH架构知识点概览",frontmatter:{title:"SSH架构知识点概览",date:"2017-07-24T16:41:12.000Z",tags:["Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/SSH.html",relativePath:"views/backend/SSH.md",key:"v-9ebad7d2",path:"/views/backend/SSH.html",headers:[{level:2,title:"关于SSH架构的所有东西，看这一篇就够了",slug:"关于ssh架构的所有东西-看这一篇就够了",normalizedTitle:"关于ssh架构的所有东西，看这一篇就够了",charIndex:3},{level:3,title:"基本公司面试要求",slug:"基本公司面试要求",normalizedTitle:"基本公司面试要求",charIndex:29},{level:3,title:"面试准备",slug:"面试准备",normalizedTitle:"面试准备",charIndex:43},{level:4,title:"1. java基础知识",slug:"_1-java基础知识",normalizedTitle:"1. java基础知识",charIndex:499},{level:4,title:"2. SSH框架",slug:"_2-ssh框架",normalizedTitle:"2. ssh框架",charIndex:514},{level:4,title:"3. SOA架构(对比微服务架构)",slug:"_3-soa架构-对比微服务架构",normalizedTitle:"3. soa架构(对比微服务架构)",charIndex:545},{level:4,title:"4. XML",slug:"_4-xml",normalizedTitle:"4. xml",charIndex:583},{level:4,title:"5. WebService及HttpClient,电网项目尤其是WebService",slug:"_5-webservice及httpclient-电网项目尤其是webservice",normalizedTitle:"5. webservice及httpclient,电网项目尤其是webservice",charIndex:647},{level:4,title:"6. flex",slug:"_6-flex",normalizedTitle:"6. flex",charIndex:719},{level:4,title:"7. jsp(几种语言和九大隐含对象)",slug:"_7-jsp-几种语言和九大隐含对象",normalizedTitle:"7. jsp(几种语言和九大隐含对象)",charIndex:764},{level:4,title:"8. servlet",slug:"_8-servlet",normalizedTitle:"8. servlet",charIndex:824},{level:4,title:"9. jdbc",slug:"_9-jdbc",normalizedTitle:"9. jdbc",charIndex:878},{level:4,title:"10. SG_UAP平台的了解",slug:"_10-sg-uap平台的了解",normalizedTitle:"10. sg_uap平台的了解",charIndex:908},{level:4,title:"11. Tomcat与weblogic容器的区别及常用部署命令",slug:"_11-tomcat与weblogic容器的区别及常用部署命令",normalizedTitle:"11. tomcat与weblogic容器的区别及常用部署命令",charIndex:971},{level:4,title:"12. Oracle数据库,常用sql函数,存储过程的编写",slug:"_12-oracle数据库-常用sql函数-存储过程的编写",normalizedTitle:"12. oracle数据库,常用sql函数,存储过程的编写",charIndex:1052},{level:3,title:"面试流程及可能遇到的问题",slug:"面试流程及可能遇到的问题",normalizedTitle:"面试流程及可能遇到的问题",charIndex:53},{level:4,title:"项目相关",slug:"项目相关",normalizedTitle:"项目相关",charIndex:1166},{level:4,title:"可能问到的问题",slug:"可能问到的问题",normalizedTitle:"可能问到的问题",charIndex:1235},{level:3,title:"面试时注意的问题",slug:"面试时注意的问题",normalizedTitle:"面试时注意的问题",charIndex:71},{level:3,title:"自我介绍模板",slug:"自我介绍模板",normalizedTitle:"自我介绍模板",charIndex:85}],headersStr:"关于SSH架构的所有东西，看这一篇就够了 基本公司面试要求 面试准备 1. java基础知识 2. SSH框架 3. SOA架构(对比微服务架构) 4. XML 5. WebService及HttpClient,电网项目尤其是WebService 6. flex 7. jsp(几种语言和九大隐含对象) 8. servlet 9. jdbc 10. SG_UAP平台的了解 11. Tomcat与weblogic容器的区别及常用部署命令 12. Oracle数据库,常用sql函数,存储过程的编写 面试流程及可能遇到的问题 项目相关 可能问到的问题 面试时注意的问题 自我介绍模板",content:" * 关于SSH架构的所有东西，看这一篇就够了\n   * 基本公司面试要求\n   * 面试准备\n   * 面试流程及可能遇到的问题\n   * 面试时注意的问题\n   * 自我介绍模板\n\n\n\n\n# 关于SSH架构的所有东西，看这一篇就够了\n\n\n# 基本公司面试要求\n\n 1. 计算机相关专业本科以上学历，精通java语言，具有一定的软件项目开发的实际工作经验，熟悉SSH等开源框架，了解jdk的基本内容，从事过相关开发工作；\n 2. 熟悉J2EE平台企业应用开发以及SOA架构，精通XML、Web Service等相关技术，使用过flex、jsp、servlet、jdbc等相关技术开发；\n 3. 熟悉SSH、SG_UAP平台开发者优先考虑；\n 4. 了解tomcat、weblogic等web服务器；\n 5. 了解Oracle数据库，精通Sql语法，有存储过程编写经验者优先；\n 6. 责任心强，有相当强的工作压力承受能力；\n 7. 具备良好的语言沟通能力和团队协作精神；\n 8. 有良好的编写代码基础,学习能力强，有较强文字能力；\n 9. 有代码安全漏洞处理经验者优先。\n\n\n# 面试准备\n\n# 1. java基础知识\n\n# 2. SSH框架\n\n * 这个写的比较好 -- 传送门\n\n# 3. SOA架构(对比微服务架构)\n\n * SOA专题 -- 传送门\n\n# 4. XML\n\n * W3school XML教程 -- 传送门\n * 但是推荐看一下Dom4j解析xml -- 传送门\n\n# 5. WebService及HttpClient,电网项目尤其是WebService\n\n * WebService cxf -- 传送门\n\n# 6. flex\n\n * 和jsp差不多，相当于一个组件，可以自定义标签到html中\n\n# 7. jsp(几种语言和九大隐含对象)\n\n * 这篇文章写的很好,但是重点都在后边，多往后划拉划拉 -- 传送门\n\n# 8. servlet\n\n * 个人感觉是写的最好的了，知识点全覆盖有图示还带有源码讲解 -- 传送们\n\n# 9. jdbc\n\n * 基本的crud -- 传送门\n\n# 10. SG_UAP平台的了解\n\n * 听说过，类似一个开发工具，可以实现权限管理、任务调度、报表统计、系统监督等功能\n\n# 11. Tomcat与weblogic容器的区别及常用部署命令\n\n> Tomcat开源免费 WebLogic不开源不免费\n\n * 可以看看这 -- 传送门\n\n# 12. Oracle数据库,常用sql函数,存储过程的编写\n\n * Oracle 数据库 -- 传送门\n * Oracle 存储过程 -- 传送门\n * JAVA调用存储过程 --传送门\n\n\n# 面试流程及可能遇到的问题\n\n# 项目相关\n\n# 1. 做过哪些项目？介绍项目涉及的业务流程。\n\n# 2. 项目中遇到过什么困难，怎么解决的？体现个人解决问题的能力\n\n# 可能问到的问题\n\n# 程序相关\n\n# 1. 介绍自己熟悉的开发框架。比如：spring、structs\n\n * SpringMVC与structs2区别 -- 传送们\n   \n   >  * springmvc的入口是servlet，而struts2是filter\n   >  * spring mvc是基于方法的设计，而sturts是基于类(一次请求创建一个action)\n   >  * springmvc通过形参获取数据，而struts2是通过属性获取数据\n   >  * springmvc处理ajsx @ResponseBody，而struts2较麻烦\n\n# 2. 线程、进程的区别？\n\n * 一个迅雷搞定\n\n# 3. 系统性能优化\n\n * 代码优化\n * 数据库优化\n\n# 4. 第三方系统接口的开发和调用，比如restful、webService（cxf、xfire）\n\n一般就是webservice和httpclient,具体上文有介绍\n\n# 5. 服务器集群\n\n# 6. Redis、kafka、MQ\n\n * Redis简单介绍 -- 传送门\n * Spring整合Redis -- 传送门\n\n# 7. 数据加密\n\n# 8. 定时器（定时任务）\n\n * Spring整合Quartz实现定时任务的配置方法 -- 传送们\n\n# 数据库相关\n\n# 1. Oracle和MySQL的区别\n\n>  * Oracle使用rownum来实现分页，MySQL使用limit实现分页\n>  * Oracle没有主键自增特性,可以使用调用序列的方式来实现主键自增；MySQL可以在主键列之后添加auto_increment设置自增特性\n>  * Oracle有表空间的概念，MySQL没有表空间\n>  * Oracle的分组函数中select之后不能直接写非分组的其他列；MySQL如果没有聚组函数则可以写 其他列\n>  * Oracle的表存放在用户（其实是schema对象）所属的表空间的数据文件中， mySQL的表存放在某个database中（mysql一个root用户下可以有很多database）\n>  * Oracle中的一些函数和MySQL也不一样，如： ORACLE:SELECT to_date('2009-3-6','yyyy-mm-dd') VAULE FROM DUAL MySQL: SELECT STR_TO_DATE('2004-03-01', '%Y-%m-%d') VAULE\n>  * Oracle中的字符类型可以使用varchar2 MySQL不能使用该类型\n\n# 2. 存储过程、触发器是不是写过\n\n * Oracle 存储过程 -- 传送门\n\n# 3. 数据库SQL调优。可以结合自己做过的项目进行说明\n\n * sql语句调优 -- 传送门\n * 写存储过程调优\n\n# 4. 数据库备份命令、备份策略（增量备份--每天或每周、全量备份--每月或每年）\n\n * Oracle数据库三种备份方案 -- 传送门\n\n# 5. Oracle行转列、列转行\n\n * Oracle行转列(pivot、wm_concat、decode)使用总结 -- 传送门\n   \n   > 列转行： unpivot 行转列： WM_CONCAT、pivot\n\n# 其他\n\n# 1. Linux常用命令\n\n * Linux常用命令 -- 传送门\n\n# 2. Linux下部署tomcat、Weblogic服务\n\n# 3. 集群服务部署\n\n * 常见的部署出现的问题\n   \n   * 各部属的版本是否对应(如jdk版本和服务器版本)\n   * 环境的账号密码是否正确(测试环境和正式环境)\n   * 部署的url地址是否正确\n\n\n# 面试时注意的问题\n\n 1. 面试着装要正式,自然大方;\n 2. 态度要严肃认真,言谈举止等,不紧张,不散漫;可以看一下贾哥的姿态\n 3. 进门基本的问候语要有;\n 4. 自我介绍要有逻辑(毕业年限,工作年限,参与的项目(项目大概介绍,负责功能,涉及技术)必须和简历上匹配起来),工作的新得等\n 5. 问到不会的技术,能说多少就说多少,最后得表明一下,自己也是正在实践中积累学习\n 6. 介绍技术时,要挑自己熟悉的,擅长的项目介绍;能和甲方技术要求匹配最好\n\n\n# 自我介绍模板\n\n>  * 自然进门，安稳落下\n>  * 领导下午好，很高兴能来参加这次面试，我叫XXX，从事java开发XX年了， 曾用过SSH,SSM框架做过开发，了解Spring、SpringMVC， 数据库用过Oracle、MySQL, 前端框架用过BootStrap、EasyUI\n>  * 最近做过的一个项目是大东全渠道项目，大东是一家做鞋的公司，然后它想 给自己做一套零售系统嘛。 我负责的模块主要有：门店信息管理，店员信息的管理和维护，人资信息管理 和报表统计管理等。 这个项目用的技术是SSM+MySQl+dubbo+EasyUI，我在这个项目中主要学会了 dubbo通信、httpClient调接口、和项目版本管理工具git的使用\n>  * 我的基本情况就这些,请领导指示 ... ...\n>  * 待面试结束后 -> 谢谢领导！",normalizedContent:" * 关于ssh架构的所有东西，看这一篇就够了\n   * 基本公司面试要求\n   * 面试准备\n   * 面试流程及可能遇到的问题\n   * 面试时注意的问题\n   * 自我介绍模板\n\n\n\n\n# 关于ssh架构的所有东西，看这一篇就够了\n\n\n# 基本公司面试要求\n\n 1. 计算机相关专业本科以上学历，精通java语言，具有一定的软件项目开发的实际工作经验，熟悉ssh等开源框架，了解jdk的基本内容，从事过相关开发工作；\n 2. 熟悉j2ee平台企业应用开发以及soa架构，精通xml、web service等相关技术，使用过flex、jsp、servlet、jdbc等相关技术开发；\n 3. 熟悉ssh、sg_uap平台开发者优先考虑；\n 4. 了解tomcat、weblogic等web服务器；\n 5. 了解oracle数据库，精通sql语法，有存储过程编写经验者优先；\n 6. 责任心强，有相当强的工作压力承受能力；\n 7. 具备良好的语言沟通能力和团队协作精神；\n 8. 有良好的编写代码基础,学习能力强，有较强文字能力；\n 9. 有代码安全漏洞处理经验者优先。\n\n\n# 面试准备\n\n# 1. java基础知识\n\n# 2. ssh框架\n\n * 这个写的比较好 -- 传送门\n\n# 3. soa架构(对比微服务架构)\n\n * soa专题 -- 传送门\n\n# 4. xml\n\n * w3school xml教程 -- 传送门\n * 但是推荐看一下dom4j解析xml -- 传送门\n\n# 5. webservice及httpclient,电网项目尤其是webservice\n\n * webservice cxf -- 传送门\n\n# 6. flex\n\n * 和jsp差不多，相当于一个组件，可以自定义标签到html中\n\n# 7. jsp(几种语言和九大隐含对象)\n\n * 这篇文章写的很好,但是重点都在后边，多往后划拉划拉 -- 传送门\n\n# 8. servlet\n\n * 个人感觉是写的最好的了，知识点全覆盖有图示还带有源码讲解 -- 传送们\n\n# 9. jdbc\n\n * 基本的crud -- 传送门\n\n# 10. sg_uap平台的了解\n\n * 听说过，类似一个开发工具，可以实现权限管理、任务调度、报表统计、系统监督等功能\n\n# 11. tomcat与weblogic容器的区别及常用部署命令\n\n> tomcat开源免费 weblogic不开源不免费\n\n * 可以看看这 -- 传送门\n\n# 12. oracle数据库,常用sql函数,存储过程的编写\n\n * oracle 数据库 -- 传送门\n * oracle 存储过程 -- 传送门\n * java调用存储过程 --传送门\n\n\n# 面试流程及可能遇到的问题\n\n# 项目相关\n\n# 1. 做过哪些项目？介绍项目涉及的业务流程。\n\n# 2. 项目中遇到过什么困难，怎么解决的？体现个人解决问题的能力\n\n# 可能问到的问题\n\n# 程序相关\n\n# 1. 介绍自己熟悉的开发框架。比如：spring、structs\n\n * springmvc与structs2区别 -- 传送们\n   \n   >  * springmvc的入口是servlet，而struts2是filter\n   >  * spring mvc是基于方法的设计，而sturts是基于类(一次请求创建一个action)\n   >  * springmvc通过形参获取数据，而struts2是通过属性获取数据\n   >  * springmvc处理ajsx @responsebody，而struts2较麻烦\n\n# 2. 线程、进程的区别？\n\n * 一个迅雷搞定\n\n# 3. 系统性能优化\n\n * 代码优化\n * 数据库优化\n\n# 4. 第三方系统接口的开发和调用，比如restful、webservice（cxf、xfire）\n\n一般就是webservice和httpclient,具体上文有介绍\n\n# 5. 服务器集群\n\n# 6. redis、kafka、mq\n\n * redis简单介绍 -- 传送门\n * spring整合redis -- 传送门\n\n# 7. 数据加密\n\n# 8. 定时器（定时任务）\n\n * spring整合quartz实现定时任务的配置方法 -- 传送们\n\n# 数据库相关\n\n# 1. oracle和mysql的区别\n\n>  * oracle使用rownum来实现分页，mysql使用limit实现分页\n>  * oracle没有主键自增特性,可以使用调用序列的方式来实现主键自增；mysql可以在主键列之后添加auto_increment设置自增特性\n>  * oracle有表空间的概念，mysql没有表空间\n>  * oracle的分组函数中select之后不能直接写非分组的其他列；mysql如果没有聚组函数则可以写 其他列\n>  * oracle的表存放在用户（其实是schema对象）所属的表空间的数据文件中， mysql的表存放在某个database中（mysql一个root用户下可以有很多database）\n>  * oracle中的一些函数和mysql也不一样，如： oracle:select to_date('2009-3-6','yyyy-mm-dd') vaule from dual mysql: select str_to_date('2004-03-01', '%y-%m-%d') vaule\n>  * oracle中的字符类型可以使用varchar2 mysql不能使用该类型\n\n# 2. 存储过程、触发器是不是写过\n\n * oracle 存储过程 -- 传送门\n\n# 3. 数据库sql调优。可以结合自己做过的项目进行说明\n\n * sql语句调优 -- 传送门\n * 写存储过程调优\n\n# 4. 数据库备份命令、备份策略（增量备份--每天或每周、全量备份--每月或每年）\n\n * oracle数据库三种备份方案 -- 传送门\n\n# 5. oracle行转列、列转行\n\n * oracle行转列(pivot、wm_concat、decode)使用总结 -- 传送门\n   \n   > 列转行： unpivot 行转列： wm_concat、pivot\n\n# 其他\n\n# 1. linux常用命令\n\n * linux常用命令 -- 传送门\n\n# 2. linux下部署tomcat、weblogic服务\n\n# 3. 集群服务部署\n\n * 常见的部署出现的问题\n   \n   * 各部属的版本是否对应(如jdk版本和服务器版本)\n   * 环境的账号密码是否正确(测试环境和正式环境)\n   * 部署的url地址是否正确\n\n\n# 面试时注意的问题\n\n 1. 面试着装要正式,自然大方;\n 2. 态度要严肃认真,言谈举止等,不紧张,不散漫;可以看一下贾哥的姿态\n 3. 进门基本的问候语要有;\n 4. 自我介绍要有逻辑(毕业年限,工作年限,参与的项目(项目大概介绍,负责功能,涉及技术)必须和简历上匹配起来),工作的新得等\n 5. 问到不会的技术,能说多少就说多少,最后得表明一下,自己也是正在实践中积累学习\n 6. 介绍技术时,要挑自己熟悉的,擅长的项目介绍;能和甲方技术要求匹配最好\n\n\n# 自我介绍模板\n\n>  * 自然进门，安稳落下\n>  * 领导下午好，很高兴能来参加这次面试，我叫xxx，从事java开发xx年了， 曾用过ssh,ssm框架做过开发，了解spring、springmvc， 数据库用过oracle、mysql, 前端框架用过bootstrap、easyui\n>  * 最近做过的一个项目是大东全渠道项目，大东是一家做鞋的公司，然后它想 给自己做一套零售系统嘛。 我负责的模块主要有：门店信息管理，店员信息的管理和维护，人资信息管理 和报表统计管理等。 这个项目用的技术是ssm+mysql+dubbo+easyui，我在这个项目中主要学会了 dubbo通信、httpclient调接口、和项目版本管理工具git的使用\n>  * 我的基本情况就这些,请领导指示 ... ...\n>  * 待面试结束后 -> 谢谢领导！",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"线程池 - 简介",frontmatter:{title:"线程池 - 简介",date:"2020-03-31T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/ThreadLocal.html",relativePath:"views/backend/ThreadLocal.md",key:"v-74fedb77",path:"/views/backend/ThreadLocal.html",headers:[{level:2,title:"适用场景",slug:"适用场景",normalizedTitle:"适用场景",charIndex:3},{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:11},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:17},{level:2,title:"ThreadLocalMap与内存泄漏",slug:"threadlocalmap与内存泄漏",normalizedTitle:"threadlocalmap与内存泄漏",charIndex:23},{level:3,title:"防止内存泄露",slug:"防止内存泄露",normalizedTitle:"防止内存泄露",charIndex:48},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:58},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:64}],headersStr:"适用场景 简介 实例 ThreadLocalMap与内存泄漏 防止内存泄露 总结 参考",content:' * 适用场景\n * 简介\n * 实例\n * ThreadLocalMap与内存泄漏\n   * 防止内存泄露\n * 总结\n * 参考\n\n\n\n\n# 适用场景\n\n * 每个线程需要有自己单独的实例\n * 实例需要在多个方法中共享，但不希望被多线程共享\n * 线程间数据隔离，数据库连接，Session会话管理。\n\n每个线程都对应一个ThreadLocalMap, 而Threadlocal负责访问和维护ThreadLocalMap。 set()方法就是把Threadlocal插入当前Thread维护的ThreadLocalMap中，如果你在线程1里面去set()，那么你在线程2里面去获取的时候，它取得是线程2的ThreadLocalMap，但是线程2里面的ThreadLocalMap并没有插入ThreadLocal。\n\n\n# 简介\n\nThreadLocal的目的是为了解决多线程访问资源时的共享问题 。\n\n可以把ThreadLocal看成一个全局Map：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key。\n\nThreadLocal 变量通常被private static修饰。 ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。\n\n也就是说，不管你有多少个线程，ThreadLocal 相当于在每一个线程中映射一个副本，各线程间只会访问自己线程的ThreadLocal 。\n\n\n# 实例\n\n代码示例（点击展开）\n\npublic class TestThreadLocal {\n    private static ThreadLocal<Long> longLocal = new ThreadLocal<Long>();\n    private static ThreadLocal<String> stringLocal = new ThreadLocal<String>(){\n        /* 1. ThreadLocal 设置默认值的方式 */\n        protected String initialValue() {\n            return Thread.currentThread().getName();\n        };\n    };\n \n    public void set() {\n        /* 2. ThreadLocal 赋值方式 */\n        longLocal.set(Thread.currentThread().getId());\n        // stringLocal.set(Thread.currentThread().getName());\n    }\n     \n    public long getLong() {\n        /* 3. ThreadLocal 取值方式 */\n        return longLocal.get();\n    }\n     \n    public String getString() {\n        return stringLocal.get();\n    }\n     \n    public static void main(String[] args) throws InterruptedException {\n        final TestThreadLocal test = new TestThreadLocal();\n         \n        //当前线程\n        test.set();\n        System.out.println("main线程：  " + test.getLong());\n        System.out.println("main线程：  " + test.getString());\n \n        Thread thread1 = new Thread(){\n            public void run() {\n                //其它线程\n                test.set();\n                System.out.println("新线程：  " + test.getLong());\n                System.out.println("新线程：  " + test.getString());\n            };\n        };\n        thread1.start();\n        thread1.join();\n         \n        //当前线程\n        System.out.println("main线程：  " + test.getLong());\n        System.out.println("main线程：  " + test.getString());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# ThreadLocalMap与内存泄漏\n\n该方案中，Map 由 ThreadLocal 类的静态内部类 ThreadLocalMap 提供。该类的实例维护某个 ThreadLocal 与具体实例的映射。与 HashMap 不同的是，ThreadLocalMap 的每个 Entry 都是一个对 *键* 的弱引用，这一点从super(k)可看出。另外，每个 Entry 都包含了一个对 *值* 的强引用。\n\nstatic class Entry extends WeakReference<ThreadLocal<?>> {  \n    /** The value associated with this ThreadLocal. */  \n    Object value;  \n    Entry(ThreadLocal<?> k, Object v) {    \n        super(k);    \n        value = v;  \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用弱引用的原因在于，当没有强引用指向 ThreadLocal 变量时，它可被回收，从而避免上文所述 ThreadLocal 不能被回收而造成的内存泄漏的问题。\n\n但是，这里又可能出现另外一种内存泄漏的问题。ThreadLocalMap 维护 ThreadLocal 变量与具体实例的映射，当 ThreadLocal 变量被回收后，该映射的键变为 null，该 Entry 无法被移除。从而使得实例被该 Entry 引用而无法被回收造成内存泄漏。\n\n注：Entry虽然是弱引用，但它是 ThreadLocal 类型的弱引用（也即上文所述它是对 *键* 的弱引用），而非具体实例的的弱引用，所以无法避免具体实例相关的内存泄漏。\n\n\n# 防止内存泄露\n\n 1. 特别注意ThreadLocal一定要在finally中清除：\n\ntry {\n    threadLocalUser.set(user);\n    ...\n} finally {\n    threadLocalUser.remove();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。\n\n 2. 为了保证能释放ThreadLocal关联的实例，我们可以通过AutoCloseable接口配合try (resource) {...}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的ThreadLocal可以封装为一个UserContext对象：\n\npublic class UserContext implements AutoCloseable {\n\n    static final ThreadLocal<String> ctx = new ThreadLocal<>();\n\n    public UserContext(String user) {\n        ctx.set(user);\n    }\n\n    public static String currentUser() {\n        return ctx.get();\n    }\n\n    @Override\n    public void close() {\n        ctx.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用的时候，我们借助try (resource) {...}结构，可以这么写：\n\ntry (var ctx = new UserContext("Bob")) {\n    // 可任意调用UserContext.currentUser():\n    String currentUser = UserContext.currentUser();\n} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象\n\n\n1\n2\n3\n4\n\n\n这样就在UserContext中完全封装了ThreadLocal，外部代码在try (resource) {...}内部可以随时调用UserContext.currentUser()获取当前线程绑定的用户名。\n\n\n# 总结\n\n * ThreadLocal 并不解决线程间共享数据的问题\n * ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题\n * 每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题\n * ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题\n * ThreadLocalMap 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏\n * ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景\n\n\n# 参考\n\nhttp://www.jasongj.com/java/threadlocal/\n\nhttps://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/\n\nThreadLocal内存泄漏问题\n\n廖雪峰的官方网站',normalizedContent:' * 适用场景\n * 简介\n * 实例\n * threadlocalmap与内存泄漏\n   * 防止内存泄露\n * 总结\n * 参考\n\n\n\n\n# 适用场景\n\n * 每个线程需要有自己单独的实例\n * 实例需要在多个方法中共享，但不希望被多线程共享\n * 线程间数据隔离，数据库连接，session会话管理。\n\n每个线程都对应一个threadlocalmap, 而threadlocal负责访问和维护threadlocalmap。 set()方法就是把threadlocal插入当前thread维护的threadlocalmap中，如果你在线程1里面去set()，那么你在线程2里面去获取的时候，它取得是线程2的threadlocalmap，但是线程2里面的threadlocalmap并没有插入threadlocal。\n\n\n# 简介\n\nthreadlocal的目的是为了解决多线程访问资源时的共享问题 。\n\n可以把threadlocal看成一个全局map：每个线程获取threadlocal变量时，总是使用thread自身作为key。\n\nthreadlocal 变量通常被private static修饰。 threadlocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。\n\n也就是说，不管你有多少个线程，threadlocal 相当于在每一个线程中映射一个副本，各线程间只会访问自己线程的threadlocal 。\n\n\n# 实例\n\n代码示例（点击展开）\n\npublic class testthreadlocal {\n    private static threadlocal<long> longlocal = new threadlocal<long>();\n    private static threadlocal<string> stringlocal = new threadlocal<string>(){\n        /* 1. threadlocal 设置默认值的方式 */\n        protected string initialvalue() {\n            return thread.currentthread().getname();\n        };\n    };\n \n    public void set() {\n        /* 2. threadlocal 赋值方式 */\n        longlocal.set(thread.currentthread().getid());\n        // stringlocal.set(thread.currentthread().getname());\n    }\n     \n    public long getlong() {\n        /* 3. threadlocal 取值方式 */\n        return longlocal.get();\n    }\n     \n    public string getstring() {\n        return stringlocal.get();\n    }\n     \n    public static void main(string[] args) throws interruptedexception {\n        final testthreadlocal test = new testthreadlocal();\n         \n        //当前线程\n        test.set();\n        system.out.println("main线程：  " + test.getlong());\n        system.out.println("main线程：  " + test.getstring());\n \n        thread thread1 = new thread(){\n            public void run() {\n                //其它线程\n                test.set();\n                system.out.println("新线程：  " + test.getlong());\n                system.out.println("新线程：  " + test.getstring());\n            };\n        };\n        thread1.start();\n        thread1.join();\n         \n        //当前线程\n        system.out.println("main线程：  " + test.getlong());\n        system.out.println("main线程：  " + test.getstring());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# threadlocalmap与内存泄漏\n\n该方案中，map 由 threadlocal 类的静态内部类 threadlocalmap 提供。该类的实例维护某个 threadlocal 与具体实例的映射。与 hashmap 不同的是，threadlocalmap 的每个 entry 都是一个对 *键* 的弱引用，这一点从super(k)可看出。另外，每个 entry 都包含了一个对 *值* 的强引用。\n\nstatic class entry extends weakreference<threadlocal<?>> {  \n    /** the value associated with this threadlocal. */  \n    object value;  \n    entry(threadlocal<?> k, object v) {    \n        super(k);    \n        value = v;  \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用弱引用的原因在于，当没有强引用指向 threadlocal 变量时，它可被回收，从而避免上文所述 threadlocal 不能被回收而造成的内存泄漏的问题。\n\n但是，这里又可能出现另外一种内存泄漏的问题。threadlocalmap 维护 threadlocal 变量与具体实例的映射，当 threadlocal 变量被回收后，该映射的键变为 null，该 entry 无法被移除。从而使得实例被该 entry 引用而无法被回收造成内存泄漏。\n\n注：entry虽然是弱引用，但它是 threadlocal 类型的弱引用（也即上文所述它是对 *键* 的弱引用），而非具体实例的的弱引用，所以无法避免具体实例相关的内存泄漏。\n\n\n# 防止内存泄露\n\n 1. 特别注意threadlocal一定要在finally中清除：\n\ntry {\n    threadlocaluser.set(user);\n    ...\n} finally {\n    threadlocaluser.remove();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果threadlocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。\n\n 2. 为了保证能释放threadlocal关联的实例，我们可以通过autocloseable接口配合try (resource) {...}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的threadlocal可以封装为一个usercontext对象：\n\npublic class usercontext implements autocloseable {\n\n    static final threadlocal<string> ctx = new threadlocal<>();\n\n    public usercontext(string user) {\n        ctx.set(user);\n    }\n\n    public static string currentuser() {\n        return ctx.get();\n    }\n\n    @override\n    public void close() {\n        ctx.remove();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用的时候，我们借助try (resource) {...}结构，可以这么写：\n\ntry (var ctx = new usercontext("bob")) {\n    // 可任意调用usercontext.currentuser():\n    string currentuser = usercontext.currentuser();\n} // 在此自动调用usercontext.close()方法释放threadlocal关联对象\n\n\n1\n2\n3\n4\n\n\n这样就在usercontext中完全封装了threadlocal，外部代码在try (resource) {...}内部可以随时调用usercontext.currentuser()获取当前线程绑定的用户名。\n\n\n# 总结\n\n * threadlocal 并不解决线程间共享数据的问题\n * threadlocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题\n * 每个线程持有一个 map 并维护了 threadlocal 对象与具体实例的映射，该 map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题\n * threadlocalmap 的 entry 对 threadlocal 的引用为弱引用，避免了 threadlocal 对象无法被回收的问题\n * threadlocalmap 的 set 方法通过调用 replacestaleentry 方法回收键为 null 的 entry 对象的值（即为具体实例）以及 entry 对象本身从而防止内存泄漏\n * threadlocal 适用于变量在线程间隔离且在方法间共享的场景\n\n\n# 参考\n\nhttp://www.jasongj.com/java/threadlocal/\n\nhttps://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/\n\nthreadlocal内存泄漏问题\n\n廖雪峰的官方网站',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Spring的IOC源码以及流程分析",frontmatter:{title:"Spring的IOC源码以及流程分析",date:"2022-04-02T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html",relativePath:"views/backend/Spring的IOC源码以及流程分析.md",key:"v-3c7afeb6",path:"/views/backend/Spring%E7%9A%84IOC%E6%BA%90%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html",headers:[{level:2,title:"一 前言",slug:"一-前言",normalizedTitle:"一 前言",charIndex:152},{level:2,title:"二 反射基础",slug:"二-反射基础",normalizedTitle:"二 反射基础",charIndex:160},{level:2,title:"三 设计模式",slug:"三-设计模式",normalizedTitle:"三 设计模式",charIndex:170},{level:2,title:"四 IOC流程分析",slug:"四-ioc流程分析",normalizedTitle:"四 ioc流程分析",charIndex:180},{level:3,title:"4.1 IOC流程图",slug:"_4-1-ioc流程图",normalizedTitle:"4.1 ioc流程图",charIndex:195},{level:3,title:"4.2 IOC流程图讲解",slug:"_4-2-ioc流程图讲解",normalizedTitle:"4.2 ioc流程图讲解",charIndex:211},{level:2,title:"五 核心类分析",slug:"五-核心类分析",normalizedTitle:"五 核心类分析",charIndex:227},{level:3,title:"5.0 ContextLoaderListener与它的父类ContextLoader",slug:"_5-0-contextloaderlistener与它的父类contextloader",normalizedTitle:"5.0 contextloaderlistener与它的父类contextloader",charIndex:240},{level:3,title:"5.1 classPathXmlApplicationContext",slug:"_5-1-classpathxmlapplicationcontext",normalizedTitle:"5.1 classpathxmlapplicationcontext",charIndex:289},{level:3,title:"5.2 AbstractApplicationContext",slug:"_5-2-abstractapplicationcontext",normalizedTitle:"5.2 abstractapplicationcontext",charIndex:329},{level:3,title:"5.3 prepareRefresh()",slug:"_5-3-preparerefresh",normalizedTitle:"5.3 preparerefresh()",charIndex:365},{level:3,title:"5.4 核心方法之一  obtainFreshBeanFactory()",slug:"_5-4-核心方法之一-obtainfreshbeanfactory",normalizedTitle:"5.4 核心方法之一  obtainfreshbeanfactory()",charIndex:null},{level:3,title:"5.5 prepareBeanFactory()",slug:"_5-5-preparebeanfactory",normalizedTitle:"5.5 preparebeanfactory()",charIndex:432},{level:3,title:"5.6 postProcessBeanFactory()",slug:"_5-6-postprocessbeanfactory",normalizedTitle:"5.6 postprocessbeanfactory()",charIndex:462},{level:3,title:"5.7 核心方法之一  invokeBeanFactoryPostProcessors()",slug:"_5-7-核心方法之一-invokebeanfactorypostprocessors",normalizedTitle:"5.7 核心方法之一  invokebeanfactorypostprocessors()",charIndex:null},{level:3,title:"5.8 核心方法之一  registerBeanPostProcessors()",slug:"_5-8-核心方法之一-registerbeanpostprocessors",normalizedTitle:"5.8 核心方法之一  registerbeanpostprocessors()",charIndex:null},{level:3,title:"5.9 initMessageSource()",slug:"_5-9-initmessagesource",normalizedTitle:"5.9 initmessagesource()",charIndex:591},{level:3,title:"5.10 initApplicationEventMulticaster()",slug:"_5-10-initapplicationeventmulticaster",normalizedTitle:"5.10 initapplicationeventmulticaster()",charIndex:620},{level:3,title:"5.11 onRefresh()",slug:"_5-11-onrefresh",normalizedTitle:"5.11 onrefresh()",charIndex:664},{level:3,title:"5.12 registerListeners()",slug:"_5-12-registerlisteners",normalizedTitle:"5.12 registerlisteners()",charIndex:686},{level:3,title:"5.13 核心方法之一  finishBeanFactoryInitialization(beanFactory)",slug:"_5-13-核心方法之一-finishbeanfactoryinitialization-beanfactory",normalizedTitle:"5.13 核心方法之一  finishbeanfactoryinitialization(beanfactory)",charIndex:null},{level:3,title:"5.14 finishRefresh()",slug:"_5-14-finishrefresh",normalizedTitle:"5.14 finishrefresh()",charIndex:778},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:802},{level:3,title:"源码分析中比较重要的类有",slug:"源码分析中比较重要的类有",normalizedTitle:"源码分析中比较重要的类有",charIndex:810},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:826}],excerpt:"<Boxx/>\n<Toc/>\n<p>IOC的流程分析，深入理解具体的接口和类，内容包括ApplicationContext，BeanDefinitionReader，BeanFactory,BeanFactoryPostProcessor,FactoryBean,BeanPostProcessor,Environment等。</p>\n",headersStr:"一 前言 二 反射基础 三 设计模式 四 IOC流程分析 4.1 IOC流程图 4.2 IOC流程图讲解 五 核心类分析 5.0 ContextLoaderListener与它的父类ContextLoader 5.1 classPathXmlApplicationContext 5.2 AbstractApplicationContext 5.3 prepareRefresh() 5.4 核心方法之一  obtainFreshBeanFactory() 5.5 prepareBeanFactory() 5.6 postProcessBeanFactory() 5.7 核心方法之一  invokeBeanFactoryPostProcessors() 5.8 核心方法之一  registerBeanPostProcessors() 5.9 initMessageSource() 5.10 initApplicationEventMulticaster() 5.11 onRefresh() 5.12 registerListeners() 5.13 核心方法之一  finishBeanFactoryInitialization(beanFactory) 5.14 finishRefresh() 总结 源码分析中比较重要的类有 参考",content:'IOC的流程分析，深入理解具体的接口和类，内容包括ApplicationContext，BeanDefinitionReader，BeanFactory,BeanFactoryPostProcessor,FactoryBean,BeanPostProcessor,Environment等。\n\n\n\n * 一 前言\n * 二 反射基础\n * 三 设计模式\n * 四 IOC流程分析\n   * 4.1 IOC流程图\n   * 4.2 IOC流程图讲解\n * 五 核心类分析\n   * 5.0 ContextLoaderListener与它的父类ContextLoader\n   * 5.1 classPathXmlApplicationContext\n   * 5.2 AbstractApplicationContext\n   * 5.3 prepareRefresh()\n   * 5.4 核心方法之一 obtainFreshBeanFactory()\n   * 5.5 prepareBeanFactory()\n   * 5.6 postProcessBeanFactory()\n   * 5.7 核心方法之一 invokeBeanFactoryPostProcessors()\n   * 5.8 核心方法之一 registerBeanPostProcessors()\n   * 5.9 initMessageSource()\n   * 5.10 initApplicationEventMulticaster()\n   * 5.11 onRefresh()\n   * 5.12 registerListeners()\n   * 5.13 核心方法之一 finishBeanFactoryInitialization(beanFactory)\n   * 5.14 finishRefresh()\n * 总结\n   * 源码分析中比较重要的类有\n * 参考\n\n\n\n\n# 一 前言\n\n本文章的主要内容：\n\n（1）反射，反射是框架设计的灵魂，必须会的。\n\n（2）设计模式，框架里面体现了很多设计模式，比如单例模式，观察者模式，工厂模式等\n\n（3）IOC的流程分析，spring源码之所以难，是因为里面的接口和类真的很多，可以将其中的核心接口和类了解清楚流程，并深入看一下其中的内容。想全部的掌握spring源码很难，并且没有那么大的必要，它已经封装好了，封装就是为了让你使用的。所以，我们只要把它的核心源码弄清楚就可以了。\n\n（4）深入理解具体的接口和类，内容包括ApplicationContext，BeanDefinitionReader，BeanFactory,BeanFactoryPostProcessor,FactoryBean,BeanPostProcessor,Environment等。\n\n\n# 二 反射基础\n\n反射基础的话我为大家找了一篇清晰易懂的文章，这不是本文章的重点，请参考：\n\n传送门\n\n\n# 三 设计模式\n\n设计模式的话，重点看其中的单例，观察者，工厂即可，参考：\n\n传送门\n\n\n# 四 IOC流程分析\n\n\n# 4.1 IOC流程图\n\n\n\n百度找的马士兵教育的流程图，侵删。\n\n\n# 4.2 IOC流程图讲解\n\n（1）从XML，配置类，annotation中读取响应的配置信息。\n\n（2）如果想要对配置的信息进行人为的修改，可以采用BeanFactoryProcessor\n\n（3）然后创建对应的BeanFactory，如果这个时候扩展的话，就可以利用FactoryBean，它是用来扩展的。\n\n（4）实例化之前还可以利用BeanPostProcessor进行扩展\n\n（5）利用反射进行实例化的过程。\n\n（6）如果想要在容器的不同阶段做不同的事情，可以利用观察者模式，也就是监听器进行处理。\n\n（7）其中的Environment也是一个重要的类，获取一些环境的属性。\n\n先在脑海中有这样一张大概的流程图，然后再去看相应的源码部分抠细节。\n\n\n# 五 核心类分析\n\n以下类的内容都是双击shift查找得到的源码，由于源码过长，我真粘贴其中重要的部分进行分析。\n\n\n# 5.0 ContextLoaderListener与它的父类ContextLoader\n\n容器构建启动入口\n\n容器构建启动的入口有多种多样，这边以常用的 web.xml 配置的方式来说。\n\n首先，我们会在 web.xml 中配置 ContextLoaderListener 监听器，当 Tomcat 启动时，会触发 ContextLoaderListener 的 contextInitialized 方法，从而开始 IoC 的构建流程。\n\n另一个常用的参数是 contextConfigLocation，用于指定 Spring 配置文件的路径。\n\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app version="2.5" xmlns="Java EE: XML Schemas for Java EE Deployment Descriptors" \n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="Java EE: XML Schemas for Java EE Deployment Descriptors\n         http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">\n    <display-name>open-joonwhee-service WAR</display-name>\n \n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>\n            classpath*:config/spring/appcontext-*.xml\n        </param-value>\n    </context-param>\n \n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nContextLoaderListener 是 Spring 的入口\n\n并且的它的父类ContextLoader存在这样一个方法，可以实现扩功能先简单知道一下\n\nrefresh（）方法是核心，并且在它之前也需要做一些准备\n\n请参考：https://blog.csdn.net/v123411739/article/details/86555733\n\nprotected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) {\n\tList<Class<ApplicationContextInitializer<ConfigurableApplicationContext>>> initializerClasses =\n\t\t\tdetermineContextInitializerClasses(sc);\n \n\tfor (Class<ApplicationContextInitializer<ConfigurableApplicationContext>> initializerClass : initializerClasses) {\n\t\tClass<?> initializerContextClass =\n\t\t\t\tGenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class);\n\t\tif (initializerContextClass != null && !initializerContextClass.isInstance(wac)) {\n\t\t\tthrow new ApplicationContextException(String.format(\n\t\t\t\t\t"Could not apply context initializer [%s] since its generic parameter [%s] " +\n\t\t\t\t\t"is not assignable from the type of application context used by this " +\n\t\t\t\t\t"context loader: [%s]", initializerClass.getName(), initializerContextClass.getName(),\n\t\t\t\t\twac.getClass().getName()));\n\t\t}\n\t\tthis.contextInitializers.add(BeanUtils.instantiateClass(initializerClass));\n\t}\n \n\tAnnotationAwareOrderComparator.sort(this.contextInitializers);\n\tfor (ApplicationContextInitializer<ConfigurableApplicationContext> initializer : this.contextInitializers) {\n\t\tinitializer.initialize(wac);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 5.1 classPathXmlApplicationContext\n\n从这个类的注释我提取出了这样两句话\n\ntaking the context definition files from the class path\n\nloading the definitions from the given XML files\n\n意思就是从class path下提取全局的配置文件，加载给定的XML文件，也就知道了这个类大概就是加载一些配置的。\n\n然后发现其中有两个构造方法中有refresh方法，那么这个refresh方法是干什么的呢？其实这是一个非常重要的方法，它将整个IOC的过程进行了一个串联，最关键的部分。\n\n\n\n\n# 5.2 AbstractApplicationContext\n\n上面提到了refresh方法，右键这个方法，goto，实现方法，就会到达这个重要的类，这是一个核心类，将所有的IOC过程进行了一个串联，那下面我们就对这个类的refresh方法进行一个详细的分析，依照四中给的图。然后我们将对其中的每一个方法进行具体的源码分析，深入每个方法之中。\n\n其中最重要的几个方法：\n\nConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\n1\n\n\ninvokeBeanFactoryPostProcessors(beanFactory);\n\n\n1\n\n\nregisterBeanPostProcessors(beanFactory);\n\n\n1\n\n\nfinishBeanFactoryInitialization(beanFactory);\n\n\n1\n\n\n然后我们将在后面的小结依次讲解各个方法。\n\npublic void refresh() throws BeansException, IllegalStateException {\n\tsynchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        prepareRefresh();\n        // Tell the subclass to refresh the internal bean factory.\n\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n \n\t\t// Prepare the bean factory for use in this context.\n\t\tprepareBeanFactory(beanFactory);\n \n\t\ttry {\n\t\t\t// Allows post-processing of the bean factory in context subclasses.\n\t\t\tpostProcessBeanFactory(beanFactory);\n \n\t\t\t// Invoke factory processors registered as beans in the context.\n\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n \n\t\t\t// Register bean processors that intercept bean creation.\n\t\t\tregisterBeanPostProcessors(beanFactory);\n \n\t\t\t// Initialize message source for this context.\n\t\t\tinitMessageSource();\n \n\t\t\t// Initialize event multicaster for this context.\n\t\t\tinitApplicationEventMulticaster();\n \n\t\t\t// Initialize other special beans in specific context subclasses.\n\t\t\tonRefresh();\n \n\t\t\t// Check for listener beans and register them.\n\t\t\tregisterListeners();\n \n\t\t\t// Instantiate all remaining (non-lazy-init) singletons.\n\t\t\tfinishBeanFactoryInitialization(beanFactory);\n \n\t\t\t// Last step: publish corresponding event.\n\t\t\tfinishRefresh();\n\t\t}\n \n\t\tcatch (BeansException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn("Exception encountered during context initialization - " +\n\t\t\t\t\t\t"cancelling refresh attempt: " + ex);\n\t\t\t}\n \n\t\t\t// Destroy already created singletons to avoid dangling resources.\n\t\t\tdestroyBeans();\n \n\t\t\t// Reset \'active\' flag.\n\t\t\tcancelRefresh(ex);\n \n\t\t\t// Propagate exception to caller.\n\t\t\tthrow ex;\n\t\t}\n \n\t\tfinally {\n\t\t\t// Reset common introspection caches in Spring\'s core, since we\n\t\t\t// might not ever need metadata for singleton beans anymore...\n\t\t\tresetCommonCaches();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 5.3 prepareRefresh()\n\n这个方法还是比较简单的，也就是做了一个时间戳，日志，环境校验，初始化监听器容器，初始化ApplicationEvents容器\n\nprotected void prepareRefresh() {\n\t// Switch to active.\n        //前面这些就是记录以下启动的时间\n\tthis.startupDate = System.currentTimeMillis();\n\tthis.closed.set(false);\n\tthis.active.set(true);\n\t\t//进行一些日志的设置\n\tif (logger.isDebugEnabled()) {\n\t\tif (logger.isTraceEnabled()) {\n            logger.trace("Refreshing " + this);\n        }\n        else {\n            logger.debug("Refreshing " + getDisplayName());\n        }\n\t}\n\t// Initialize any placeholder property sources in the context environment.\n\t\t//这是一个空的方法，目前spring没有对其做任何事\n\tinitPropertySources();\n \n\t// Validate that all properties marked as required are resolvable:\n\t// see ConfigurablePropertyResolver#setRequiredProperties\n            //验证配置文件的有效性\n            //Environment这个类主要用于当前环境的判断，判断有效性之类的\n            //getEnvironment这个方法的逻辑你可以试着点进去，发现就是\n            //有的话直接返回，没有的话就创建一个\n\tgetEnvironment().validateRequiredProperties();\n \n\t// Store pre-refresh ApplicationListeners...\n            //在最开始的图中我们也提到了监听器，这里就是监听器\n            //准备的时候创建一个监听器的容器\n\tif (this.earlyApplicationListeners == null) {\n\t\tthis.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);\n\t}\n\telse {\n\t\t// Reset local application listeners to pre-refresh state.\n\t\tthis.applicationListeners.clear();\n\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);\n\t}\n \n\t// Allow for the collection of early ApplicationEvents,\n\t// to be published once the multicaster is available...\n            //在multicaster设置之前发布的ApplicationEvents\n\tthis.earlyApplicationEvents = new LinkedHashSet<>();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 5.4 核心方法之一 obtainFreshBeanFactory()\n\n这个地方方法走的比较多，解释我基本都会写在注释当中\n\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n\t\t//一共有两步\n                //关闭旧的beanFactory 创建新的beanFactory 并注册\n                refreshBeanFactory();\n                //返回创造的对象\n                之后我们将具体来看一下这两个方法\n\t\treturn getBeanFactory();\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n右键， refreshBeanFactory()，goto，来到相应的方法，这个方法在\n\nAbstractRefreshableApplicationContext类当中\n\nprotected final void refreshBeanFactory() throws BeansException {\n    //这一步很简单，如果有的话，就关闭之前的，重新创建\n    if (hasBeanFactory()) {\n        destroyBeans();\n        closeBeanFactory();\n    }\n    try {\n        //这一步又要详细分析这四个方法了\n        //这个方法里面就一句话\n        //new DefaultListableBeanFactory(getInternalParentBeanFactory());\n        //也就是创建一个beanFactory这个类，初步形成\n        DefaultListableBeanFactory beanFactory = createBeanFactory();\n\n        //设置序列化ID\n        beanFactory.setSerializationId(getId());\n        //这个地方有点意思，需要讲一下，在下面看一下它的方法\n        //customize是定制的意思，所以英文对程序员真的很有用\n        customizeBeanFactory(beanFactory);\n        //这是创建的时候最核心的方法，一层一层深入看一下吧\n        loadBeanDefinitions(beanFactory);\n        //设置到这个类的属性当中，用于返回对象方法时的使用\n        synchronized (this.beanFactoryMonitor) {\n            this.beanFactory = beanFactory;\n        }\n    }\n    catch (IOException ex) {\n        throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\ncustomizeBeanFactory方法，定义覆盖以及循环依赖的问题\n\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n\n\tif (this.allowBeanDefinitionOverriding != null) {\n\t\t//是否允许bean定义的覆盖\n\t\t// BeanDefinition 的覆盖问题大家也许会碰到，\n\t\t// 就是在配置文件中定义 bean 时使用了相同的 id 或 name\n\t\t// ，默认情况下，allowBeanDefinitionOverriding 属性为 null，\n\t\t// 如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\t\tbeanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n\t}\n\tif (this.allowCircularReferences != null) {\n\t\t//是否允许bean 间的循环依赖\n\t\t// A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A\n\t\t// 默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。\n\t\tbeanFactory.setAllowCircularReferences(this.allowCircularReferences);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n核心方法：loadBeanDefinitions(beanFactory)，这里就和我们图中的beanDefinitionReader联系在一起了，有内味儿了\n\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n\t// Create a new XmlBeanDefinitionReader for the given BeanFactory.\n\t// 创建同一个XmlBeanDefinitionReader 见名知意 xml的BeanDefine读取器转换器 也就是将xml文件转化为BeanDefinition\n\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\t// Configure the bean definition reader with this context\'s\n\t// resource loading environment.\n\t// 设置当前环境\n\tbeanDefinitionReader.setEnvironment(this.getEnvironment());\n\t//这里的setResourceLoader赋值 我们在refresh方法的时候就已经给this赋值\n\t//且看\n\t// \t\tsuper(parent);\n\t//\t\t// 将配置文件路径设置给AbstractRefreshableConfigApplicationContext 的        configLocations的属性\n\t//\t\tsetConfigLocations(configLocations); //这个方法就将配置路径赋值了\n\t//\t\t// 由上面的参数传进refresh为true 下面我们就进入refresh方法 spring初始化全程\n\t//\t\tif (refresh) {\n\t//\t\t\trefresh();\n\t//\t\t}\n\tbeanDefinitionReader.setResourceLoader(this);\n\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\t// Allow a subclass to provide custom initialization of the reader,\n\t// then proceed with actually loading the bean definitions.\n\tinitBeanDefinitionReader(beanDefinitionReader);\n\t//下面方法是核心\n\tloadBeanDefinitions(beanDefinitionReader);\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n继续进入loadBeanDefinitions(beanDefinitionReader);方法\n\n点进reader.loadBeanDefinitions(configLocations);方法\n\n点进loadBeanDefinitions方法\n\n点进doLoadBeanDefinitions方法，在spring中带do的都是干实事的\n\n \nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n    throws BeanDefinitionStoreException {\n    try {\n        //这里我们将资源文件转化为Document对象\n        Document doc = doLoadDocument(inputSource, resource);\n        //开始注册对应的BeanDefinition 我们继续进去\n        int count = registerBeanDefinitions(doc, resource);\n        if (logger.isDebugEnabled()) {\n            logger.debug("Loaded " + count + " bean definitions from " + resource);\n        }\n        return count;\n    }\n    catch (BeanDefinitionStoreException ex) {\n        throw ex；\n    }\n    catch (SAXParseException ex) {\n        throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                                                  "Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);\n    }\n    catch (SAXException ex) {\n        throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                                                  "XML document from " + resource + " is invalid", ex);\n    }\n    catch (ParserConfigurationException ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                                               "Parser configuration exception parsing XML from " + resource, ex);\n    }\n    catch (IOException ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                                               "IOException parsing XML document from " + resource, ex);\n    }\n    catch (Throwable ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                                               "Unexpected exception parsing XML document from " + resource, ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n直接进入DefaultBeanDefinitionDocumentReader 下面的doRegisterBeanDefinitions\n\nprotected void doRegisterBeanDefinitions(Element root) {\n\t\t// Any nested <beans> elements will cause recursion in this method. In\n\t\t// rder to propagate and preserve <beans> default-* attributes correctly,\n\t\t// keep track of the current (parent) delegate, which may be null. Create\n\t\t// the new (child) delegate with a reference to the parent for fallback purposes,\n\t\t// then ultimately reset this.delegate back to its original (parent) reference.\n\t\t// this behavior emulates a stack of delegates without actually necessitating one.\n\t\tBeanDefinitionParserDelegate parent = this.delegate;\n\t\tthis.delegate = createDelegate(getReaderContext(), root, parent);\nif (this.delegate.isDefaultNamespace(root)) {\n\t\t\tString profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n\t\t\tif (StringUtils.hasText(profileSpec)) {\n\t\t\t\tString[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n\t\t\t\t\t\tprofileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\t\t// We cannot use Profiles.of(...) since profile expressions are not supported\n\t\t\t\t// in XML config. See SPR-12458 for details.\n\t\t\t\tif (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +\n\t\t\t\t\t\t\t\t"] not matching: " + getReaderContext().getResource());\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpreProcessXml(root);\n\t\t// 解析xml 将xml元素转化为BeanDefinition\n\t\tparseBeanDefinitions(root, this.delegate);\n\t\tpostProcessXml(root);\n\t\tthis.delegate = parent;\n \n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n根据上面的解释我们直接进入parseBeanDefinitions(root, this.delegate);\n\n再进入parseDefaultElement(ele, delegate)\n\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n\tif (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n\t\t//处理import标签\n\t\timportBeanDefinitionResource(ele);\n\t}\n\telse if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n\t\t//处理alias标签\n\t\tprocessAliasRegistration(ele);\n\t}\n\telse if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n\t\t//处理bean标签\n\t\tprocessBeanDefinition(ele, delegate);\n\t}\n\telse if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n\t\t// 处理beans标签\n\t\tdoRegisterBeanDefinitions(ele);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n进入processBeanDefinition(ele, delegate);我们只关心bean\n\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t// xml节点信息转化为BeanDefinitionHolder对象\n\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\tif (bdHolder != null) {\n\t\t//如果有自定义属性的话 进行相应的解析\n\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\ttry {\n\t\t\t// Register the final decorated instance.\n\t\t\t// 这一步就是注册bean啦\n\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t}\n\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\tgetReaderContext().error("Failed to register bean definition with name \'" +\n\t\t\t\t\tbdHolder.getBeanName() + "\'", ele, ex);\n\t\t}\n\t\t// Send registration event.\n\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n进入registerBeanDefinition方法\n\n\tpublic static void registerBeanDefinition(\n\t\t\tBeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n\t\t\tthrows BeanDefinitionStoreException {\n \n\t\t// Register bean definition under primary name.\n\t\tString beanName = definitionHolder.getBeanName();\n\t\tregistry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n \n\t\t// Register aliases for bean name, if any.\n\t\tString[] aliases = definitionHolder.getAliases();\n\t\tif (aliases != null) {\n\t\t\tfor (String alias : aliases) {\n\t\t\t\tregistry.registerAlias(beanName, alias);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n再进入registry.registerBeanDefinition\n\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n    Assert.hasText(beanName, "Bean name must not be empty");\n    Assert.notNull(beanDefinition, "BeanDefinition must not be null");\n\n    if (beanDefinition instanceof AbstractBeanDefinition) {\n        try {\n            ((AbstractBeanDefinition) beanDefinition).validate();\n        }\n        catch (BeanDefinitionValidationException ex) {\n            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n                                                   "Validation of bean definition failed", ex);\n        }\n    }\n\n    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n    if (existingDefinition != null) {\n        if (!isAllowBeanDefinitionOverriding()) {\n            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n        }\n        else if (existingDefinition.getRole() < beanDefinition.getRole()) {\n            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE\n            if (logger.isInfoEnabled()) {\n                logger.info("Overriding user-defined bean definition for bean \'" + beanName +\n                            "\' with a framework-generated bean definition: replacing [" +\n                            existingDefinition + "] with [" + beanDefinition + "]");\n            }\n        }\n        else if (!beanDefinition.equals(existingDefinition)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug("Overriding bean definition for bean \'" + beanName +\n                             "\' with a different definition: replacing [" + existingDefinition +\n                             "] with [" + beanDefinition + "]");\n            }\n        }\n        else {\n            if (logger.isTraceEnabled()) {\n                logger.trace("Overriding bean definition for bean \'" + beanName +\n                             "\' with an equivalent definition: replacing [" + existingDefinition +\n                             "] with [" + beanDefinition + "]");\n            }\n        }\n        this.beanDefinitionMap.put(beanName, beanDefinition);\n    }\n    else {\n        if (hasBeanCreationStarted()) {\n            // Cannot modify startup-time collection elements anymore (for stable iteration)\n            synchronized (this.beanDefinitionMap) {\n                this.beanDefinitionMap.put(beanName, beanDefinition);\n                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);\n                updatedDefinitions.addAll(this.beanDefinitionNames);\n                updatedDefinitions.add(beanName);\n                this.beanDefinitionNames = updatedDefinitions;\n                removeManualSingletonName(beanName);\n            }\n        }\n        else {\n            // Still in startup registration phase\n            this.beanDefinitionMap.put(beanName, beanDefinition);\n            this.beanDefinitionNames.add(beanName);\n            removeManualSingletonName(beanName);\n        }\n        this.frozenBeanDefinitionNames = null;\n    }\n\n    if (existingDefinition != null || containsSingleton(beanName)) {\n        resetBeanDefinition(beanName);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n然后我们看看这个DefaultListableBeanFactory的关系图\n\n\n\n到此为止基本就创建完了，最后执行获取这个操作了。\n\n\tpublic final ConfigurableListableBeanFactory getBeanFactory() {\n \n            //因为在刚才的refreshBeanFactory()方法中，我们已经将beanFactory这个类设置到this当中了\n            //所以在这个地方直接获取\n\tsynchronized (this.beanFactoryMonitor) {\n\t\tif (this.beanFactory == null) {\n\t\t\tthrow new IllegalStateException("BeanFactory not initialized or already closed - " +\n\t\t\t\t\t"call \'refresh\' before accessing beans via the ApplicationContext");\n\t\t}\n\t\treturn this.beanFactory;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 5.5 prepareBeanFactory()\n\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n    //设置类加载器：存在则直接设置/不存在则新建一个默认类加载器\n    beanFactory.setBeanClassLoader(getClassLoader());\n    //设置EL表达式解析器（Bean初始化完成后填充属性时会用到）\n    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n    //设置属性注册解析器PropertyEditor\n    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n    // 将当前的ApplicationContext对象交给ApplicationContextAwareProcessor类来处理，从而在Aware接口实现类中的注入applicationContext\n    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n    //设置忽略自动装配的接口\n    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n    //注册可以解析的自动装配\n    // MessageSource registered (and found for autowiring) as a bean.\n    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n    beanFactory.registerResolvableDependency(ResourceLoader.class, this);\n    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n    beanFactory.registerResolvableDependency(ApplicationContext.class, this);\n    //如果当前BeanFactory包含loadTimeWeaver Bean，说明存在类加载期织入AspectJ，则把当前BeanFactory交给类加载期BeanPostProcessor实现类LoadTimeWeaverAwareProcessor来处理，从而实现类加载期织入AspectJ的目的。\n    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n        // Set a temporary ClassLoader for type matching.\n        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n    }\n    //注册当前容器环境environment组件Bean\n    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n    }\n    //注册系统配置systemProperties组件Bean\n    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n    }\n    //注册系统环境systemEnvironment组件Bean\n    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 5.6 postProcessBeanFactory()\n\nspring中并没有具体去实现postProcessBeanFactory方法，作用是在BeanFactory准备工作完成后做一些定制化的处理。\n\n\n# 5.7 核心方法之一 invokeBeanFactoryPostProcessors()\n\nInstantiate and invoke all registered BeanFactoryPostProcessor beans,respecting explicit order if given.\n\n上面是对这个方法的描述，调用所有注册的BeanFactoryPostProcessor，并遵循显式顺序（如果给定的话）。\n\nBeanFactoryPostProcessor 接口是 Spring 初始化 BeanFactory 时对外暴露的扩展点，Spring IoC 容器允许 BeanFactoryPostProcessor 在容器实例化任何 bean 之前读取 bean 的定义，并可以修改它。\n\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n            //getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值\n            //invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor\n            PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n \n\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n\tif (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这一段代码的核心在于获取和调用，下面进行详细的讲解 getBeanFactoryPostProcessors()，这个方法默认是没有的，返回null\n\npublic List<BeanFactoryPostProcessor> getBeanFactoryPostProcessors() {\n\treturn this.beanFactoryPostProcessors;\n}\n\n\n1\n2\n3\n\n\n如何添加自定义 BeanFactoryPostProcessor 到 this.beanFactoryPostProcessors 变量中了？\n\n新建一个 ApplicationContextInitializer 的实现类 SpringApplicationContextInitializer ，并在 initialize 方法中写我们的逻辑。\n\npackage com.joonwhee.open.demo.spring;\nimport org.springframework.context.ApplicationContextInitializer;\nimport org.springframework.context.ConfigurableApplicationContext;\n/**\n * @author joonwhee\n * @date 2019/1/19\n */\npublic class SpringApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {\n    @Override\n    public void initialize(ConfigurableApplicationContext applicationContext) {\n        FirstBeanDefinitionRegistryPostProcessor firstBeanDefinitionRegistryPostProcessor = new FirstBeanDefinitionRegistryPostProcessor();\n        // 将自定义的firstBeanDefinitionRegistryPostProcessor添加到应用上下文中\n        applicationContext.addBeanFactoryPostProcessor(firstBeanDefinitionRegistryPostProcessor);\n        // ...自定义操作\n        System.out.println("SpringApplicationContextInitializer#initialize");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n将 SpringApplicationContextInitializer 作为初始化参数 contextInitializerClasses 配置到 web.xml 中。\n\n<context-param>\n    <param-name>contextInitializerClasses</param-name>\n    <param-value>\n        com.joonwhee.open.demo.spring.SpringApplicationContextInitializer\n    </param-value>\n</context-param>\n\n\n1\n2\n3\n4\n5\n6\n\n\ninvokeBeanFactoryPostProcessors方法\n\n \npublic static void invokeBeanFactoryPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {\n \n \n \n    // Invoke BeanDefinitionRegistryPostProcessors first, if any.\n \n    Set<String> processedBeans = new HashSet<String>();\n \n \n \n    // 1.判断beanFactory是否为BeanDefinitionRegistry，beanFactory为DefaultListableBeanFactory,\n \n    // 而DefaultListableBeanFactory实现了BeanDefinitionRegistry接口，因此这边为true\n \n    if (beanFactory instanceof BeanDefinitionRegistry) {\n \n        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n \n        // 用于存放普通的BeanFactoryPostProcessor\n \n        List<BeanFactoryPostProcessor> regularPostProcessors = new LinkedList<BeanFactoryPostProcessor>();\n \n        // 用于存放BeanDefinitionRegistryPostProcessor\n \n        List<BeanDefinitionRegistryPostProcessor> registryProcessors = new LinkedList<BeanDefinitionRegistryPostProcessor>();\n \n \n \n        // 2.首先处理入参中的beanFactoryPostProcessors\n \n        // 遍历所有的beanFactoryPostProcessors, 将BeanDefinitionRegistryPostProcessor和普通BeanFactoryPostProcessor区分开\n \n        for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {\n \n            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {\n \n                // 2.1 如果是BeanDefinitionRegistryPostProcessor\n \n                BeanDefinitionRegistryPostProcessor registryProcessor =\n \n                        (BeanDefinitionRegistryPostProcessor) postProcessor;\n \n                // 2.1.1 直接执行BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法\n \n                registryProcessor.postProcessBeanDefinitionRegistry(registry);\n \n                // 2.1.2 添加到registryProcessors(用于最后执行postProcessBeanFactory方法)\n \n                registryProcessors.add(registryProcessor);\n \n            } else {\n \n                // 2.2 否则，只是普通的BeanFactoryPostProcessor\n \n                // 2.2.1 添加到regularPostProcessors(用于最后执行postProcessBeanFactory方法)\n \n                regularPostProcessors.add(postProcessor);\n \n            }\n \n        }\n \n \n \n        // Do not initialize FactoryBeans here: We need to leave all regular beans\n \n        // uninitialized to let the bean factory post-processors apply to them!\n \n        // Separate between BeanDefinitionRegistryPostProcessors that implement\n \n        // PriorityOrdered, Ordered, and the rest.\n \n        // 用于保存本次要执行的BeanDefinitionRegistryPostProcessor\n \n        List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();\n \n \n \n        // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n \n        // 3.调用所有实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor实现类\n \n        // 3.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的Bean的beanName\n \n        String[] postProcessorNames =\n \n                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n \n        // 3.2 遍历postProcessorNames\n \n        for (String ppName : postProcessorNames) {\n \n            // 3.3 校验是否实现了PriorityOrdered接口\n \n            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n \n                // 3.4 获取ppName对应的bean实例, 添加到currentRegistryProcessors中,\n \n                // beanFactory.getBean: 这边getBean方法会触发创建ppName对应的bean对象, 目前暂不深入解析\n \n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n \n                // 3.5 将要被执行的加入processedBeans，避免后续重复执行\n \n                processedBeans.add(ppName);\n \n            }\n \n        }\n \n        // 3.6 进行排序(根据是否实现PriorityOrdered、Ordered接口和order值来排序)\n \n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n \n        // 3.7 添加到registryProcessors(用于最后执行postProcessBeanFactory方法)\n \n        registryProcessors.addAll(currentRegistryProcessors);\n \n        // 3.8 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法\n \n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n \n        // 3.9 执行完毕后, 清空currentRegistryProcessors\n \n        currentRegistryProcessors.clear();\n \n \n \n        // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n \n        // 4.调用所有实现了Ordered接口的BeanDefinitionRegistryPostProcessor实现类（过程跟上面的步骤3基本一样）\n \n        // 4.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的类, 这边重复查找是因为执行完上面的BeanDefinitionRegistryPostProcessor,\n \n        // 可能会新增了其他的BeanDefinitionRegistryPostProcessor, 因此需要重新查找\n \n        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n \n        for (String ppName : postProcessorNames) {\n \n            // 校验是否实现了Ordered接口，并且还未执行过\n \n            if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {\n \n                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n \n                processedBeans.add(ppName);\n \n            }\n \n        }\n \n        sortPostProcessors(currentRegistryProcessors, beanFactory);\n \n        registryProcessors.addAll(currentRegistryProcessors);\n \n        // 4.2 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法\n \n        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n \n        currentRegistryProcessors.clear();\n \n \n \n        // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n \n        // 5.最后, 调用所有剩下的BeanDefinitionRegistryPostProcessors\n \n        boolean reiterate = true;\n \n        while (reiterate) {\n \n            reiterate = false;\n \n            // 5.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的类\n \n            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n \n            for (String ppName : postProcessorNames) {\n \n                // 5.2 跳过已经执行过的\n \n                if (!processedBeans.contains(ppName)) {\n \n                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n \n                    processedBeans.add(ppName);\n \n                    // 5.3 如果有BeanDefinitionRegistryPostProcessor被执行, 则有可能会产生新的BeanDefinitionRegistryPostProcessor,\n \n                    // 因此这边将reiterate赋值为true, 代表需要再循环查找一次\n \n                    reiterate = true;\n \n                }\n \n            }\n \n            sortPostProcessors(currentRegistryProcessors, beanFactory);\n \n            registryProcessors.addAll(currentRegistryProcessors);\n \n            // 5.4 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法\n \n            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n \n            currentRegistryProcessors.clear();\n \n        }\n \n \n \n        // Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n \n        // 6.调用所有BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法(BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor)\n \n        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\n \n        // 7.最后, 调用入参beanFactoryPostProcessors中的普通BeanFactoryPostProcessor的postProcessBeanFactory方法\n \n        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n \n    } else {\n \n        // Invoke factory processors registered with the context instance.\n \n        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n \n    }\n \n \n \n    // 到这里 , 入参beanFactoryPostProcessors和容器中的所有BeanDefinitionRegistryPostProcessor已经全部处理完毕,\n \n    // 下面开始处理容器中的所有BeanFactoryPostProcessor\n \n \n \n    // Do not initialize FactoryBeans here: We need to leave all regular beans\n \n    // uninitialized to let the bean factory post-processors apply to them!\n \n    // 8.找出所有实现BeanFactoryPostProcessor接口的类\n \n    String[] postProcessorNames =\n \n            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n \n \n \n    // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n \n    // Ordered, and the rest.\n \n    // 用于存放实现了PriorityOrdered接口的BeanFactoryPostProcessor\n \n    List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n \n    // 用于存放实现了Ordered接口的BeanFactoryPostProcessor的beanName\n \n    List<String> orderedPostProcessorNames = new ArrayList<String>();\n \n    // 用于存放普通BeanFactoryPostProcessor的beanName\n \n    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();\n \n    // 8.1 遍历postProcessorNames, 将BeanFactoryPostProcessor按实现PriorityOrdered、实现Ordered接口、普通三种区分开\n \n    for (String ppName : postProcessorNames) {\n \n        // 8.2 跳过已经执行过的\n \n        if (processedBeans.contains(ppName)) {\n \n            // skip - already processed in first phase above\n \n        } else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n \n            // 8.3 添加实现了PriorityOrdered接口的BeanFactoryPostProcessor\n \n            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n \n        } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n \n            // 8.4 添加实现了Ordered接口的BeanFactoryPostProcessor的beanName\n \n            orderedPostProcessorNames.add(ppName);\n \n        } else {\n \n            // 8.5 添加剩下的普通BeanFactoryPostProcessor的beanName\n \n            nonOrderedPostProcessorNames.add(ppName);\n \n        }\n \n    }\n \n \n \n    // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n \n    // 9.调用所有实现PriorityOrdered接口的BeanFactoryPostProcessor\n \n    // 9.1 对priorityOrderedPostProcessors排序\n \n    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n \n    // 9.2 遍历priorityOrderedPostProcessors, 执行postProcessBeanFactory方法\n \n    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n \n \n \n    // Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n \n    // 10.调用所有实现Ordered接口的BeanFactoryPostProcessor\n \n    List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n \n    for (String postProcessorName : orderedPostProcessorNames) {\n \n        // 10.1 获取postProcessorName对应的bean实例, 添加到orderedPostProcessors, 准备执行\n \n        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n \n    }\n \n    // 10.2 对orderedPostProcessors排序\n \n    sortPostProcessors(orderedPostProcessors, beanFactory);\n \n    // 10.3 遍历orderedPostProcessors, 执行postProcessBeanFactory方法\n \n    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n \n \n \n    // Finally, invoke all other BeanFactoryPostProcessors.\n \n    // 11.调用所有剩下的BeanFactoryPostProcessor\n \n    List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();\n \n    for (String postProcessorName : nonOrderedPostProcessorNames) {\n \n        // 11.1 获取postProcessorName对应的bean实例, 添加到nonOrderedPostProcessors, 准备执行\n \n        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n \n    }\n \n    // 11.2 遍历nonOrderedPostProcessors, 执行postProcessBeanFactory方法\n \n    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n \n \n \n    // Clear cached merged bean definitions since the post-processors might have\n \n    // modified the original metadata, e.g. replacing placeholders in values...\n \n    // 12.清除元数据缓存（mergedBeanDefinitions、allBeanNamesByType、singletonBeanNamesByType），\n \n    // 因为后处理器可能已经修改了原始元数据，例如， 替换值中的占位符...\n \n    beanFactory.clearMetadataCache();\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n\n\n\n# 5.8 核心方法之一 registerBeanPostProcessors()\n\n本方法会注册所有的 BeanPostProcessor，将所有实现了 BeanPostProcessor 接口的类加载到 BeanFactory 中。BeanPostProcessor 接口是 Spring 初始化 bean 时对外暴露的扩展点，Spring IoC 容器允许 BeanPostProcessor 在容器初始化 bean 的前后，添加自己的逻辑处理。\n\n \npublic static void registerBeanPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n \n \n \n    // 1.找出所有实现BeanPostProcessor接口的类\n \n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n \n \n \n    // Register BeanPostProcessorChecker that logs an info message when\n \n    // a bean is created during BeanPostProcessor instantiation, i.e. when\n \n    // a bean is not eligible for getting processed by all BeanPostProcessors.\n \n    // BeanPostProcessor的目标计数\n \n    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n \n    // 2.添加BeanPostProcessorChecker(主要用于记录信息)到beanFactory中\n \n    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n \n \n \n    // Separate between BeanPostProcessors that implement PriorityOrdered,\n \n    // Ordered, and the rest.\n \n    // 3.定义不同的变量用于区分: 实现PriorityOrdered接口的BeanPostProcessor、实现Ordered接口的BeanPostProcessor、普通BeanPostProcessor\n \n    // 3.1 priorityOrderedPostProcessors: 用于存放实现PriorityOrdered接口的BeanPostProcessor\n \n    List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    // 3.2 internalPostProcessors: 用于存放Spring内部的BeanPostProcessor\n \n    List<BeanPostProcessor> internalPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    // 3.3 orderedPostProcessorNames: 用于存放实现Ordered接口的BeanPostProcessor的beanName\n \n    List<String> orderedPostProcessorNames = new ArrayList<String>();\n \n    // 3.4 nonOrderedPostProcessorNames: 用于存放普通BeanPostProcessor的beanName\n \n    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();\n \n    // 4.遍历postProcessorNames, 将BeanPostProcessors按3.1 - 3.4定义的变量区分开\n \n    for (String ppName : postProcessorNames) {\n \n        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n \n            // 4.1 如果ppName对应的Bean实例实现了PriorityOrdered接口, 则拿到ppName对应的Bean实例并添加到priorityOrderedPostProcessors\n \n            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n            priorityOrderedPostProcessors.add(pp);\n \n            if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n                // 4.2 如果ppName对应的Bean实例也实现了MergedBeanDefinitionPostProcessor接口,\n \n                // 则将ppName对应的Bean实例添加到internalPostProcessors\n \n                internalPostProcessors.add(pp);\n \n            }\n \n        }\n \n        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n \n            // 4.3 如果ppName对应的Bean实例没有实现PriorityOrdered接口, 但是实现了Ordered接口, 则将ppName添加到orderedPostProcessorNames\n \n            orderedPostProcessorNames.add(ppName);\n \n        }\n \n        else {\n \n            // 4.4 否则, 将ppName添加到nonOrderedPostProcessorNames\n \n            nonOrderedPostProcessorNames.add(ppName);\n \n        }\n \n    }\n \n \n \n    // First, register the BeanPostProcessors that implement PriorityOrdered.\n \n    // 5.首先, 注册实现PriorityOrdered接口的BeanPostProcessors\n \n    // 5.1 对priorityOrderedPostProcessors进行排序\n \n    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n \n    // 5.2 注册priorityOrderedPostProcessors\n \n    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n \n \n \n    // Next, register the BeanPostProcessors that implement Ordered.\n \n    // 6.接下来, 注册实现Ordered接口的BeanPostProcessors\n \n    List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    for (String ppName : orderedPostProcessorNames) {\n \n        // 6.1 拿到ppName对应的BeanPostProcessor实例对象\n \n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n        // 6.2 将ppName对应的BeanPostProcessor实例对象添加到orderedPostProcessors, 准备执行注册\n \n        orderedPostProcessors.add(pp);\n \n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n            // 6.3 如果ppName对应的Bean实例也实现了MergedBeanDefinitionPostProcessor接口,\n \n            // 则将ppName对应的Bean实例添加到internalPostProcessors\n \n            internalPostProcessors.add(pp);\n \n        }\n \n    }\n \n    // 6.4 对orderedPostProcessors进行排序\n \n    sortPostProcessors(orderedPostProcessors, beanFactory);\n \n    // 6.5 注册orderedPostProcessors\n \n    registerBeanPostProcessors(beanFactory, orderedPostProcessors);\n \n \n \n    // Now, register all regular BeanPostProcessors.\n \n    // 7.注册所有常规的BeanPostProcessors（过程与6类似）\n \n    List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    for (String ppName : nonOrderedPostProcessorNames) {\n \n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n        nonOrderedPostProcessors.add(pp);\n \n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n            internalPostProcessors.add(pp);\n \n        }\n \n    }\n \n    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n \n \n \n    // Finally, re-register all internal BeanPostProcessors.\n \n    // 8.最后, 重新注册所有内部BeanPostProcessors（相当于内部的BeanPostProcessor会被移到处理器链的末尾）\n \n    // 8.1 对internalPostProcessors进行排序\n \n    sortPostProcessors(internalPostProcessors, beanFactory);\n \n    // 8.2注册internalPostProcessors\n \n    registerBeanPostProcessors(beanFactory, internalPostProcessors);\n \n \n \n    // Re-register post-processor for detecting inner beans as ApplicationListeners,\n \n    // moving it to the end of the processor chain (for picking up proxies etc).\n \n    // 9.重新注册ApplicationListenerDetector（跟8类似，主要是为了移动到处理器链的末尾）\n \n    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n使用：可以在bean的初始化前后添加自己想要的代码\n\n \npublic static void registerBeanPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n \n \n \n    // 1.找出所有实现BeanPostProcessor接口的类\n \n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n \n \n \n    // Register BeanPostProcessorChecker that logs an info message when\n \n    // a bean is created during BeanPostProcessor instantiation, i.e. when\n \n    // a bean is not eligible for getting processed by all BeanPostProcessors.\n \n    // BeanPostProcessor的目标计数\n \n    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n \n    // 2.添加BeanPostProcessorChecker(主要用于记录信息)到beanFactory中\n \n    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n \n \n \n    // Separate between BeanPostProcessors that implement PriorityOrdered,\n \n    // Ordered, and the rest.\n \n    // 3.定义不同的变量用于区分: 实现PriorityOrdered接口的BeanPostProcessor、实现Ordered接口的BeanPostProcessor、普通BeanPostProcessor\n \n    // 3.1 priorityOrderedPostProcessors: 用于存放实现PriorityOrdered接口的BeanPostProcessor\n \n    List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    // 3.2 internalPostProcessors: 用于存放Spring内部的BeanPostProcessor\n \n    List<BeanPostProcessor> internalPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    // 3.3 orderedPostProcessorNames: 用于存放实现Ordered接口的BeanPostProcessor的beanName\n \n    List<String> orderedPostProcessorNames = new ArrayList<String>();\n \n    // 3.4 nonOrderedPostProcessorNames: 用于存放普通BeanPostProcessor的beanName\n \n    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();\n \n    // 4.遍历postProcessorNames, 将BeanPostProcessors按3.1 - 3.4定义的变量区分开\n \n    for (String ppName : postProcessorNames) {\n \n        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n \n            // 4.1 如果ppName对应的Bean实例实现了PriorityOrdered接口, 则拿到ppName对应的Bean实例并添加到priorityOrderedPostProcessors\n \n            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n            priorityOrderedPostProcessors.add(pp);\n \n            if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n                // 4.2 如果ppName对应的Bean实例也实现了MergedBeanDefinitionPostProcessor接口,\n \n                // 则将ppName对应的Bean实例添加到internalPostProcessors\n \n                internalPostProcessors.add(pp);\n \n            }\n \n        }\n \n        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n \n            // 4.3 如果ppName对应的Bean实例没有实现PriorityOrdered接口, 但是实现了Ordered接口, 则将ppName添加到orderedPostProcessorNames\n \n            orderedPostProcessorNames.add(ppName);\n \n        }\n \n        else {\n \n            // 4.4 否则, 将ppName添加到nonOrderedPostProcessorNames\n \n            nonOrderedPostProcessorNames.add(ppName);\n \n        }\n \n    }\n \n \n \n    // First, register the BeanPostProcessors that implement PriorityOrdered.\n \n    // 5.首先, 注册实现PriorityOrdered接口的BeanPostProcessors\n \n    // 5.1 对priorityOrderedPostProcessors进行排序\n \n    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n \n    // 5.2 注册priorityOrderedPostProcessors\n \n    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n \n \n \n    // Next, register the BeanPostProcessors that implement Ordered.\n \n    // 6.接下来, 注册实现Ordered接口的BeanPostProcessors\n \n    List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    for (String ppName : orderedPostProcessorNames) {\n \n        // 6.1 拿到ppName对应的BeanPostProcessor实例对象\n \n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n        // 6.2 将ppName对应的BeanPostProcessor实例对象添加到orderedPostProcessors, 准备执行注册\n \n        orderedPostProcessors.add(pp);\n \n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n            // 6.3 如果ppName对应的Bean实例也实现了MergedBeanDefinitionPostProcessor接口,\n \n            // 则将ppName对应的Bean实例添加到internalPostProcessors\n \n            internalPostProcessors.add(pp);\n \n        }\n \n    }\n \n    // 6.4 对orderedPostProcessors进行排序\n \n    sortPostProcessors(orderedPostProcessors, beanFactory);\n \n    // 6.5 注册orderedPostProcessors\n \n    registerBeanPostProcessors(beanFactory, orderedPostProcessors);\n \n \n \n    // Now, register all regular BeanPostProcessors.\n \n    // 7.注册所有常规的BeanPostProcessors（过程与6类似）\n \n    List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n \n    for (String ppName : nonOrderedPostProcessorNames) {\n \n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n \n        nonOrderedPostProcessors.add(pp);\n \n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n \n            internalPostProcessors.add(pp);\n \n        }\n \n    }\n \n    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n \n \n \n    // Finally, re-register all internal BeanPostProcessors.\n \n    // 8.最后, 重新注册所有内部BeanPostProcessors（相当于内部的BeanPostProcessor会被移到处理器链的末尾）\n \n    // 8.1 对internalPostProcessors进行排序\n \n    sortPostProcessors(internalPostProcessors, beanFactory);\n \n    // 8.2注册internalPostProcessors\n \n    registerBeanPostProcessors(beanFactory, internalPostProcessors);\n \n \n \n    // Re-register post-processor for detecting inner beans as ApplicationListeners,\n \n    // moving it to the end of the processor chain (for picking up proxies etc).\n \n    // 9.重新注册ApplicationListenerDetector（跟8类似，主要是为了移动到处理器链的末尾）\n \n    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n\n# 5.9 initMessageSource()\n\n/**\n* Initialize the MessageSource.\n* Use parent\'s if none defined in this context.\n*/\nprotected void initMessageSource() {\n   //获取Bean工厂，一般是DefaultListBeanFactory\n   ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n   //首先判断是否已有xml文件定义了id为messageSource的bean对象\n   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {\n      //如果有，则从Bean工厂得到这个bean对象\n      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);\n      // Make MessageSource aware of parent MessageSource.\n      //当父类Bean工厂不为空，并且这个bean对象是HierarchicalMessageSource类型\n      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {\n         //为HierarchicalMessageSource的实现类\n         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;\n         //设置父类MessageSource，此处设置内部的parent messageSource\n         if (hms.getParentMessageSource() == null) {\n            // Only set parent context as parent MessageSource if no parent MessageSource\n            // registered already.\n            hms.setParentMessageSource(getInternalParentMessageSource());\n         }\n      }\n      if (logger.isTraceEnabled()) {\n         logger.trace("Using MessageSource [" + this.messageSource + "]");\n      }\n   }\n   else {\n      // Use empty MessageSource to be able to accept getMessage calls.\n      //如果没有xml文件定义信息源对象，新建DelegatingMessageSource类作为messageSource的Bean\n      //因为DelegatingMessageSource类实现了HierarchicalMessageSource接口，而这个接口继承了MessageSource这个类\n      //因此实现了这个接口的类，都是MessageSource的子类，因此DelegatingMessageSource也是一个MessageSource\n      DelegatingMessageSource dms = new DelegatingMessageSource();\n      //给这个DelegatingMessageSource添加父类消息源\n      dms.setParentMessageSource(getInternalParentMessageSource());\n      this.messageSource = dms;\n      //将这个messageSource实例注册到Bean工厂中\n      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);\n      if (logger.isTraceEnabled()) {\n         logger.trace("No \'" + MESSAGE_SOURCE_BEAN_NAME + "\' bean, using [" + this.messageSource + "]");\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 5.10 initApplicationEventMulticaster()\n\n代码很简单，就是分两种情况进行初始化的过程\n\nprotected void initApplicationEventMulticaster() {\n    ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {\n        this.applicationEventMulticaster =\n            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);\n        if (logger.isTraceEnabled()) {\n            logger.trace("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");\n        }\n    }\n    else {\n        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);\n        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);\n        if (logger.isTraceEnabled()) {\n            logger.trace("No \'" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "\' bean, using " +\n                         "[" + this.applicationEventMulticaster.getClass().getSimpleName() + "]");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5.11 onRefresh()\n\n这个方法是空的没有进行实现，官网给的注释是\n\nInitialize other special beans in specific context subclasses.\n\n初始化一些其他的特殊的bean\n\n\n# 5.12 registerListeners()\n\n获取ApplicationContext初始化的listeners，然后添加到EventMulticaster，这个刚才初始化的\n\n这里面的earlyApplicationEvents是在第一步的时候进行初始化的\n\n在prepareRefresh方法中的\n\nthis.earlyApplicationEvents = new LinkedHashSet<>();\n\n\tprotected void registerListeners() {\n\t\t// Register statically specified listeners first.\n\t\tfor (ApplicationListener<?> listener : getApplicationListeners()) {\n\t\t\tgetApplicationEventMulticaster().addApplicationListener(listener);\n\t\t}\n \n\t\t// Do not initialize FactoryBeans here: We need to leave all regular beans\n\t\t// uninitialized to let post-processors apply to them!\n\t\tString[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);\n\t\tfor (String listenerBeanName : listenerBeanNames) {\n\t\t\tgetApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);\n\t\t}\n \n\t\t// Publish early application events now that we finally have a multicaster...\n\t\tSet<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;\n\t\tthis.earlyApplicationEvents = null;\n\t\tif (earlyEventsToProcess != null) {\n\t\t\tfor (ApplicationEvent earlyEvent : earlyEventsToProcess) {\n\t\t\t\tgetApplicationEventMulticaster().multicastEvent(earlyEvent);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n自定义监听器的实现\n\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.event.ContextRefreshedEvent;\nimport org.springframework.stereotype.Component;\n@Component\npublic class MyRefreshedListener implements ApplicationListener<ContextRefreshedEvent> {\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) {\n        // 自己的逻辑处理\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.13 核心方法之一 finishBeanFactoryInitialization(beanFactory)\n\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n    // Initialize conversion service for this context.\n    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\n    beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\n    beanFactory.setConversionService(\n    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\n    }\n\n    // Register a default embedded value resolver if no bean post-processor\n    // (such as a PropertyPlaceholderConfigurer bean) registered any before:\n    // at this point, primarily for resolution in annotation attribute values.\n    if (!beanFactory.hasEmbeddedValueResolver()) {\n    beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));\n    }\n\n    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\n    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\n    for (String weaverAwareName : weaverAwareNames) {\n    getBean(weaverAwareName);\n    }\n\n    // Stop using the temporary ClassLoader for type matching.\n    beanFactory.setTempClassLoader(null);\n\n    // Allow for caching all bean definition metadata, not expecting further changes.\n    beanFactory.freezeConfiguration();\n\n    // Instantiate all remaining (non-lazy-init) singletons.\n    beanFactory.preInstantiateSingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n关键起作用的在最后一行beanFactory.preInstantiateSingletons();我们进入\n\n这个时候发现又进入了我们的老朋友\n\nDefaultListableBeanFactory这个重要的类\n\n这里里面的关键代码在于通过名字获取bean，也就是getBean(beanName);方法\n\npublic void preInstantiateSingletons() throws BeansException {\n    if (logger.isTraceEnabled()) {\n    \tlogger.trace("Pre-instantiating singletons in " + this);\n    }\n    \n    // Iterate over a copy to allow for init methods which in turn register new bean definitions.\n\t// While this may not be part of the regular factory bootstrap, it does otherwise work fine.\n\tList<String> beanNames = new ArrayList<>(this.beanDefinitionNames);\n \n\t// Trigger initialization of all non-lazy singleton beans...\n\tfor (String beanName : beanNames) {\n\t\tRootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n\t\tif (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n\t\t\tif (isFactoryBean(beanName)) {\n\t\t\t\tObject bean = getBean(FACTORY_BEAN_PREFIX + beanName);\n\t\t\t\tif (bean instanceof FactoryBean) {\n\t\t\t\t\tfinal FactoryBean<?> factory = (FactoryBean<?>) bean;\n\t\t\t\t\tboolean isEagerInit;\n\t\t\t\t\tif (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\n\t\t\t\t\t\tisEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)\n\t\t\t\t\t\t\t\t\t\t((SmartFactoryBean<?>) factory)::isEagerInit,\n\t\t\t\t\t\t\t\tgetAccessControlContext());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisEagerInit = (factory instanceof SmartFactoryBean &&\n\t\t\t\t\t\t\t\t((SmartFactoryBean<?>) factory).isEagerInit());\n\t\t\t\t\t}\n\t\t\t\t\tif (isEagerInit) {\n\t\t\t\t\t\tgetBean(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgetBean(beanName);\n\t\t\t}\n\t\t}\n\t}\n \n\t// Trigger post-initialization callback for all applicable beans...\n\tfor (String beanName : beanNames) {\n\t\tObject singletonInstance = getSingleton(beanName);\n\t\tif (singletonInstance instanceof SmartInitializingSingleton) {\n\t\t\tfinal SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\n\t\t\tif (System.getSecurityManager() != null) {\n\t\t\t\tAccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n\t\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t\t\treturn null;\n\t\t\t\t}, getAccessControlContext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmartSingleton.afterSingletonsInstantiated();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n我们进入getBean(beanName);方法\n\npublic Object getBean(String name) throws BeansException {\n\t\treturn doGetBean(name, null, null, false);\n}\n\n\n1\n2\n3\n\n\n发现仅仅是调用了dogetbean这个方法，但是我们在这里看到了do，在spring中do都是干实事的地方，那我们就要知道，创建bean的重点来了。\n\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n    \t@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n    \t\n    final String beanName = transformedBeanName(name);\n\tObject bean;\n \n\t// Eagerly check singleton cache for manually registered singletons.\n            //这部分是通过getSingleton(beanName)方法去singleton缓存中找bean实例，\n            //应该是拿不到的，因为我们是第一次初始化，缓存中肯定不存在。\n\tObject sharedInstance = getSingleton(beanName);\n\tif (sharedInstance != null && args == null) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\tlogger.trace("Returning eagerly cached instance of singleton bean \'" + beanName +\n\t\t\t\t\t\t"\' that is not fully initialized yet - a consequence of a circular reference");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.trace("Returning cached instance of singleton bean \'" + beanName + "\'");\n\t\t\t}\n\t\t}\n\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n\t}\n \n\telse {\n\t\t// Fail if we\'re already creating this bean instance:\n\t\t// We\'re assumably within a circular reference.\n                    //这段是根据当前的beanfactory获取父一级的beanfactory，然后逐级递归的查找我们需要的bean\n\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t}\n \n\t\t// Check if bean definition exists in this factory.\n\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t// Not found -> check parent.\n\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory) {\n\t\t\t\treturn ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n\t\t\t\t\t\tnameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t}\n\t\t\telse if (args != null) {\n\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t}\n\t\t\telse if (requiredType != null) {\n\t\t\t\t// No args -> delegate to standard getBean method.\n\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t}\n\t\t}\n        //第三部分先判断并把需要创建的bean打上正在创建标记，\n        //也就是开头的if判断加markBeanAsCreated(beanName)方法\n        //（这样做的目的是在我创建这个bean之前就先打上创建标记，告诉其它来创建的线程，避免了重复创建，那么这个方法内部肯定是同步的）\n\t\tif (!typeCheckOnly) {\n\t\t\tmarkBeanAsCreated(beanName);\n\t\t}\n \n\t\ttry {\n\t\t\tfinal RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n \n\t\t\t// Guarantee initialization of beans that the current bean depends on.\n\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\tif (dependsOn != null) {\n\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t"Circular depends-on relationship between \'" + beanName + "\' and \'" + dep + "\'");\n\t\t\t\t\t}\n\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t"\'" + beanName + "\' depends on missing bean \'" + dep + "\'", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\t\t// Create bean instance.\n\t\t\tif (mbd.isSingleton()) {\n\t\t\t\tsharedInstance = getSingleton(beanName, () -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t}\n \n\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t// It\'s a prototype -> create a new instance.\n\t\t\t\tObject prototypeInstance = null;\n\t\t\t\ttry {\n\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\tprototypeInstance = createBean(beanName, mbd, args);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t}\n\t\t\t\tbean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t}\n \n\t\t\telse {\n\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\tfinal Scope scope = this.scopes.get(scopeName);\n\t\t\t\tif (scope == null) {\n\t\t\t\t\tthrow new IllegalStateException("No Scope registered for scope name \'" + scopeName + "\'");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject scopedInstance = scope.get(beanName, () -> {\n\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t"Scope \'" + scopeName + "\' is not active for the current thread; consider " +\n\t\t\t\t\t\t\t"defining a scoped proxy for this bean if you intend to refer to it from a singleton",\n\t\t\t\t\t\t\tex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (BeansException ex) {\n\t\t\tcleanupAfterBeanCreationFailure(beanName);\n\t\t\tthrow ex;\n\t\t}\n\t}\n \n\t// Check if required type matches the type of the actual bean instance.\n\tif (requiredType != null && !requiredType.isInstance(bean)) {\n\t\ttry {\n\t\t\tT convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n\t\t\tif (convertedBean == null) {\n\t\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t\t}\n\t\t\treturn convertedBean;\n\t\t}\n\t\tcatch (TypeMismatchException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace("Failed to convert bean \'" + name + "\' to required type \'" +\n\t\t\t\t\t\tClassUtils.getQualifiedName(requiredType) + "\'", ex);\n\t\t\t}\n\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t}\n\t}\n\treturn (T) bean;\n}\n\n\n不知道小伙伴能否在这里体会到反射的思想呢\n\n\n# 5.14 finishRefresh()\n\n最后进行一些收尾工作\n\nprotected void finishRefresh() {\n\t// Clear context-level resource caches (such as ASM metadata from scanning).\n\tclearResourceCaches();\n \n\t// Initialize lifecycle processor for this context.\n\tinitLifecycleProcessor();\n \n\t// Propagate refresh to lifecycle processor first.\n\tgetLifecycleProcessor().onRefresh();\n \n\t// Publish the final event.\n\tpublishEvent(new ContextRefreshedEvent(this));\n \n\t// Participate in LiveBeansView MBean, if active.\n\tLiveBeansView.registerApplicationContext(this);\n}\n\n\n\n# 总结\n\n\n# 源码分析中比较重要的类有\n\nApplicationContet（主要的容器，串联流程）\n\nEnvironment（可以判断环境的有效性）\n\nBeanPostProcessor（用于bean实例化前后的扩展）\n\nBeanFactory（最顶层的一个接口）\n\nFactoryBean（也是用来更好的扩展，他也就有三个方法）\n\nBeanFactoryPostPorcessor（用来工厂后来的扩展）\n\nBeanDefinitionReader（读取前面的一些信息）\n\nclassPathXmlApplicationContext（读取总的配置文件）\n\nContextLoaderListener与它的父类ContextLoader（spring的入口）\n\n\n# 参考\n\n1.https://blog.csdn.net/spring_live_in/article/details/101059038\n\n2.https://blog.csdn.net/sinat_38259539/article/details/71799078?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4\n\n3.https://liteyu.blog.csdn.net/article/details/105754312\n\n4.https://blog.csdn.net/v123411739/article/details/87741251',normalizedContent:'ioc的流程分析，深入理解具体的接口和类，内容包括applicationcontext，beandefinitionreader，beanfactory,beanfactorypostprocessor,factorybean,beanpostprocessor,environment等。\n\n\n\n * 一 前言\n * 二 反射基础\n * 三 设计模式\n * 四 ioc流程分析\n   * 4.1 ioc流程图\n   * 4.2 ioc流程图讲解\n * 五 核心类分析\n   * 5.0 contextloaderlistener与它的父类contextloader\n   * 5.1 classpathxmlapplicationcontext\n   * 5.2 abstractapplicationcontext\n   * 5.3 preparerefresh()\n   * 5.4 核心方法之一 obtainfreshbeanfactory()\n   * 5.5 preparebeanfactory()\n   * 5.6 postprocessbeanfactory()\n   * 5.7 核心方法之一 invokebeanfactorypostprocessors()\n   * 5.8 核心方法之一 registerbeanpostprocessors()\n   * 5.9 initmessagesource()\n   * 5.10 initapplicationeventmulticaster()\n   * 5.11 onrefresh()\n   * 5.12 registerlisteners()\n   * 5.13 核心方法之一 finishbeanfactoryinitialization(beanfactory)\n   * 5.14 finishrefresh()\n * 总结\n   * 源码分析中比较重要的类有\n * 参考\n\n\n\n\n# 一 前言\n\n本文章的主要内容：\n\n（1）反射，反射是框架设计的灵魂，必须会的。\n\n（2）设计模式，框架里面体现了很多设计模式，比如单例模式，观察者模式，工厂模式等\n\n（3）ioc的流程分析，spring源码之所以难，是因为里面的接口和类真的很多，可以将其中的核心接口和类了解清楚流程，并深入看一下其中的内容。想全部的掌握spring源码很难，并且没有那么大的必要，它已经封装好了，封装就是为了让你使用的。所以，我们只要把它的核心源码弄清楚就可以了。\n\n（4）深入理解具体的接口和类，内容包括applicationcontext，beandefinitionreader，beanfactory,beanfactorypostprocessor,factorybean,beanpostprocessor,environment等。\n\n\n# 二 反射基础\n\n反射基础的话我为大家找了一篇清晰易懂的文章，这不是本文章的重点，请参考：\n\n传送门\n\n\n# 三 设计模式\n\n设计模式的话，重点看其中的单例，观察者，工厂即可，参考：\n\n传送门\n\n\n# 四 ioc流程分析\n\n\n# 4.1 ioc流程图\n\n\n\n百度找的马士兵教育的流程图，侵删。\n\n\n# 4.2 ioc流程图讲解\n\n（1）从xml，配置类，annotation中读取响应的配置信息。\n\n（2）如果想要对配置的信息进行人为的修改，可以采用beanfactoryprocessor\n\n（3）然后创建对应的beanfactory，如果这个时候扩展的话，就可以利用factorybean，它是用来扩展的。\n\n（4）实例化之前还可以利用beanpostprocessor进行扩展\n\n（5）利用反射进行实例化的过程。\n\n（6）如果想要在容器的不同阶段做不同的事情，可以利用观察者模式，也就是监听器进行处理。\n\n（7）其中的environment也是一个重要的类，获取一些环境的属性。\n\n先在脑海中有这样一张大概的流程图，然后再去看相应的源码部分抠细节。\n\n\n# 五 核心类分析\n\n以下类的内容都是双击shift查找得到的源码，由于源码过长，我真粘贴其中重要的部分进行分析。\n\n\n# 5.0 contextloaderlistener与它的父类contextloader\n\n容器构建启动入口\n\n容器构建启动的入口有多种多样，这边以常用的 web.xml 配置的方式来说。\n\n首先，我们会在 web.xml 中配置 contextloaderlistener 监听器，当 tomcat 启动时，会触发 contextloaderlistener 的 contextinitialized 方法，从而开始 ioc 的构建流程。\n\n另一个常用的参数是 contextconfiglocation，用于指定 spring 配置文件的路径。\n\n<?xml version="1.0" encoding="utf-8"?>\n<web-app version="2.5" xmlns="java ee: xml schemas for java ee deployment descriptors" \n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="java ee: xml schemas for java ee deployment descriptors\n         http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">\n    <display-name>open-joonwhee-service war</display-name>\n \n    <context-param>\n        <param-name>contextconfiglocation</param-name>\n        <param-value>\n            classpath*:config/spring/appcontext-*.xml\n        </param-value>\n    </context-param>\n \n    <listener>\n        <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n    </listener>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ncontextloaderlistener 是 spring 的入口\n\n并且的它的父类contextloader存在这样一个方法，可以实现扩功能先简单知道一下\n\nrefresh（）方法是核心，并且在它之前也需要做一些准备\n\n请参考：https://blog.csdn.net/v123411739/article/details/86555733\n\nprotected void customizecontext(servletcontext sc, configurablewebapplicationcontext wac) {\n\tlist<class<applicationcontextinitializer<configurableapplicationcontext>>> initializerclasses =\n\t\t\tdeterminecontextinitializerclasses(sc);\n \n\tfor (class<applicationcontextinitializer<configurableapplicationcontext>> initializerclass : initializerclasses) {\n\t\tclass<?> initializercontextclass =\n\t\t\t\tgenerictyperesolver.resolvetypeargument(initializerclass, applicationcontextinitializer.class);\n\t\tif (initializercontextclass != null && !initializercontextclass.isinstance(wac)) {\n\t\t\tthrow new applicationcontextexception(string.format(\n\t\t\t\t\t"could not apply context initializer [%s] since its generic parameter [%s] " +\n\t\t\t\t\t"is not assignable from the type of application context used by this " +\n\t\t\t\t\t"context loader: [%s]", initializerclass.getname(), initializercontextclass.getname(),\n\t\t\t\t\twac.getclass().getname()));\n\t\t}\n\t\tthis.contextinitializers.add(beanutils.instantiateclass(initializerclass));\n\t}\n \n\tannotationawareordercomparator.sort(this.contextinitializers);\n\tfor (applicationcontextinitializer<configurableapplicationcontext> initializer : this.contextinitializers) {\n\t\tinitializer.initialize(wac);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 5.1 classpathxmlapplicationcontext\n\n从这个类的注释我提取出了这样两句话\n\ntaking the context definition files from the class path\n\nloading the definitions from the given xml files\n\n意思就是从class path下提取全局的配置文件，加载给定的xml文件，也就知道了这个类大概就是加载一些配置的。\n\n然后发现其中有两个构造方法中有refresh方法，那么这个refresh方法是干什么的呢？其实这是一个非常重要的方法，它将整个ioc的过程进行了一个串联，最关键的部分。\n\n\n\n\n# 5.2 abstractapplicationcontext\n\n上面提到了refresh方法，右键这个方法，goto，实现方法，就会到达这个重要的类，这是一个核心类，将所有的ioc过程进行了一个串联，那下面我们就对这个类的refresh方法进行一个详细的分析，依照四中给的图。然后我们将对其中的每一个方法进行具体的源码分析，深入每个方法之中。\n\n其中最重要的几个方法：\n\nconfigurablelistablebeanfactory beanfactory = obtainfreshbeanfactory();\n\n\n1\n\n\ninvokebeanfactorypostprocessors(beanfactory);\n\n\n1\n\n\nregisterbeanpostprocessors(beanfactory);\n\n\n1\n\n\nfinishbeanfactoryinitialization(beanfactory);\n\n\n1\n\n\n然后我们将在后面的小结依次讲解各个方法。\n\npublic void refresh() throws beansexception, illegalstateexception {\n\tsynchronized (this.startupshutdownmonitor) {\n        // prepare this context for refreshing.\n        preparerefresh();\n        // tell the subclass to refresh the internal bean factory.\n\t\tconfigurablelistablebeanfactory beanfactory = obtainfreshbeanfactory();\n \n\t\t// prepare the bean factory for use in this context.\n\t\tpreparebeanfactory(beanfactory);\n \n\t\ttry {\n\t\t\t// allows post-processing of the bean factory in context subclasses.\n\t\t\tpostprocessbeanfactory(beanfactory);\n \n\t\t\t// invoke factory processors registered as beans in the context.\n\t\t\tinvokebeanfactorypostprocessors(beanfactory);\n \n\t\t\t// register bean processors that intercept bean creation.\n\t\t\tregisterbeanpostprocessors(beanfactory);\n \n\t\t\t// initialize message source for this context.\n\t\t\tinitmessagesource();\n \n\t\t\t// initialize event multicaster for this context.\n\t\t\tinitapplicationeventmulticaster();\n \n\t\t\t// initialize other special beans in specific context subclasses.\n\t\t\tonrefresh();\n \n\t\t\t// check for listener beans and register them.\n\t\t\tregisterlisteners();\n \n\t\t\t// instantiate all remaining (non-lazy-init) singletons.\n\t\t\tfinishbeanfactoryinitialization(beanfactory);\n \n\t\t\t// last step: publish corresponding event.\n\t\t\tfinishrefresh();\n\t\t}\n \n\t\tcatch (beansexception ex) {\n\t\t\tif (logger.iswarnenabled()) {\n\t\t\t\tlogger.warn("exception encountered during context initialization - " +\n\t\t\t\t\t\t"cancelling refresh attempt: " + ex);\n\t\t\t}\n \n\t\t\t// destroy already created singletons to avoid dangling resources.\n\t\t\tdestroybeans();\n \n\t\t\t// reset \'active\' flag.\n\t\t\tcancelrefresh(ex);\n \n\t\t\t// propagate exception to caller.\n\t\t\tthrow ex;\n\t\t}\n \n\t\tfinally {\n\t\t\t// reset common introspection caches in spring\'s core, since we\n\t\t\t// might not ever need metadata for singleton beans anymore...\n\t\t\tresetcommoncaches();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 5.3 preparerefresh()\n\n这个方法还是比较简单的，也就是做了一个时间戳，日志，环境校验，初始化监听器容器，初始化applicationevents容器\n\nprotected void preparerefresh() {\n\t// switch to active.\n        //前面这些就是记录以下启动的时间\n\tthis.startupdate = system.currenttimemillis();\n\tthis.closed.set(false);\n\tthis.active.set(true);\n\t\t//进行一些日志的设置\n\tif (logger.isdebugenabled()) {\n\t\tif (logger.istraceenabled()) {\n            logger.trace("refreshing " + this);\n        }\n        else {\n            logger.debug("refreshing " + getdisplayname());\n        }\n\t}\n\t// initialize any placeholder property sources in the context environment.\n\t\t//这是一个空的方法，目前spring没有对其做任何事\n\tinitpropertysources();\n \n\t// validate that all properties marked as required are resolvable:\n\t// see configurablepropertyresolver#setrequiredproperties\n            //验证配置文件的有效性\n            //environment这个类主要用于当前环境的判断，判断有效性之类的\n            //getenvironment这个方法的逻辑你可以试着点进去，发现就是\n            //有的话直接返回，没有的话就创建一个\n\tgetenvironment().validaterequiredproperties();\n \n\t// store pre-refresh applicationlisteners...\n            //在最开始的图中我们也提到了监听器，这里就是监听器\n            //准备的时候创建一个监听器的容器\n\tif (this.earlyapplicationlisteners == null) {\n\t\tthis.earlyapplicationlisteners = new linkedhashset<>(this.applicationlisteners);\n\t}\n\telse {\n\t\t// reset local application listeners to pre-refresh state.\n\t\tthis.applicationlisteners.clear();\n\t\tthis.applicationlisteners.addall(this.earlyapplicationlisteners);\n\t}\n \n\t// allow for the collection of early applicationevents,\n\t// to be published once the multicaster is available...\n            //在multicaster设置之前发布的applicationevents\n\tthis.earlyapplicationevents = new linkedhashset<>();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 5.4 核心方法之一 obtainfreshbeanfactory()\n\n这个地方方法走的比较多，解释我基本都会写在注释当中\n\nprotected configurablelistablebeanfactory obtainfreshbeanfactory() {\n\t\t//一共有两步\n                //关闭旧的beanfactory 创建新的beanfactory 并注册\n                refreshbeanfactory();\n                //返回创造的对象\n                之后我们将具体来看一下这两个方法\n\t\treturn getbeanfactory();\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n右键， refreshbeanfactory()，goto，来到相应的方法，这个方法在\n\nabstractrefreshableapplicationcontext类当中\n\nprotected final void refreshbeanfactory() throws beansexception {\n    //这一步很简单，如果有的话，就关闭之前的，重新创建\n    if (hasbeanfactory()) {\n        destroybeans();\n        closebeanfactory();\n    }\n    try {\n        //这一步又要详细分析这四个方法了\n        //这个方法里面就一句话\n        //new defaultlistablebeanfactory(getinternalparentbeanfactory());\n        //也就是创建一个beanfactory这个类，初步形成\n        defaultlistablebeanfactory beanfactory = createbeanfactory();\n\n        //设置序列化id\n        beanfactory.setserializationid(getid());\n        //这个地方有点意思，需要讲一下，在下面看一下它的方法\n        //customize是定制的意思，所以英文对程序员真的很有用\n        customizebeanfactory(beanfactory);\n        //这是创建的时候最核心的方法，一层一层深入看一下吧\n        loadbeandefinitions(beanfactory);\n        //设置到这个类的属性当中，用于返回对象方法时的使用\n        synchronized (this.beanfactorymonitor) {\n            this.beanfactory = beanfactory;\n        }\n    }\n    catch (ioexception ex) {\n        throw new applicationcontextexception("i/o error parsing bean definition source for " + getdisplayname(), ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\ncustomizebeanfactory方法，定义覆盖以及循环依赖的问题\n\nprotected void customizebeanfactory(defaultlistablebeanfactory beanfactory) {\n\n\tif (this.allowbeandefinitionoverriding != null) {\n\t\t//是否允许bean定义的覆盖\n\t\t// beandefinition 的覆盖问题大家也许会碰到，\n\t\t// 就是在配置文件中定义 bean 时使用了相同的 id 或 name\n\t\t// ，默认情况下，allowbeandefinitionoverriding 属性为 null，\n\t\t// 如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。\n\t\tbeanfactory.setallowbeandefinitionoverriding(this.allowbeandefinitionoverriding);\n\t}\n\tif (this.allowcircularreferences != null) {\n\t\t//是否允许bean 间的循环依赖\n\t\t// a 依赖 b，而 b 依赖 a。或 a 依赖 b，b 依赖 c，而 c 依赖 a\n\t\t// 默认情况下，spring 允许循环依赖，当然如果你在 a 的构造方法中依赖 b，在 b 的构造方法中依赖 a 是不行的。\n\t\tbeanfactory.setallowcircularreferences(this.allowcircularreferences);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n核心方法：loadbeandefinitions(beanfactory)，这里就和我们图中的beandefinitionreader联系在一起了，有内味儿了\n\nprotected void loadbeandefinitions(defaultlistablebeanfactory beanfactory) throws beansexception, ioexception {\n\t// create a new xmlbeandefinitionreader for the given beanfactory.\n\t// 创建同一个xmlbeandefinitionreader 见名知意 xml的beandefine读取器转换器 也就是将xml文件转化为beandefinition\n\txmlbeandefinitionreader beandefinitionreader = new xmlbeandefinitionreader(beanfactory);\n\t// configure the bean definition reader with this context\'s\n\t// resource loading environment.\n\t// 设置当前环境\n\tbeandefinitionreader.setenvironment(this.getenvironment());\n\t//这里的setresourceloader赋值 我们在refresh方法的时候就已经给this赋值\n\t//且看\n\t// \t\tsuper(parent);\n\t//\t\t// 将配置文件路径设置给abstractrefreshableconfigapplicationcontext 的        configlocations的属性\n\t//\t\tsetconfiglocations(configlocations); //这个方法就将配置路径赋值了\n\t//\t\t// 由上面的参数传进refresh为true 下面我们就进入refresh方法 spring初始化全程\n\t//\t\tif (refresh) {\n\t//\t\t\trefresh();\n\t//\t\t}\n\tbeandefinitionreader.setresourceloader(this);\n\tbeandefinitionreader.setentityresolver(new resourceentityresolver(this));\n\t// allow a subclass to provide custom initialization of the reader,\n\t// then proceed with actually loading the bean definitions.\n\tinitbeandefinitionreader(beandefinitionreader);\n\t//下面方法是核心\n\tloadbeandefinitions(beandefinitionreader);\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n继续进入loadbeandefinitions(beandefinitionreader);方法\n\n点进reader.loadbeandefinitions(configlocations);方法\n\n点进loadbeandefinitions方法\n\n点进doloadbeandefinitions方法，在spring中带do的都是干实事的\n\n \nprotected int doloadbeandefinitions(inputsource inputsource, resource resource)\n    throws beandefinitionstoreexception {\n    try {\n        //这里我们将资源文件转化为document对象\n        document doc = doloaddocument(inputsource, resource);\n        //开始注册对应的beandefinition 我们继续进去\n        int count = registerbeandefinitions(doc, resource);\n        if (logger.isdebugenabled()) {\n            logger.debug("loaded " + count + " bean definitions from " + resource);\n        }\n        return count;\n    }\n    catch (beandefinitionstoreexception ex) {\n        throw ex；\n    }\n    catch (saxparseexception ex) {\n        throw new xmlbeandefinitionstoreexception(resource.getdescription(),\n                                                  "line " + ex.getlinenumber() + " in xml document from " + resource + " is invalid", ex);\n    }\n    catch (saxexception ex) {\n        throw new xmlbeandefinitionstoreexception(resource.getdescription(),\n                                                  "xml document from " + resource + " is invalid", ex);\n    }\n    catch (parserconfigurationexception ex) {\n        throw new beandefinitionstoreexception(resource.getdescription(),\n                                               "parser configuration exception parsing xml from " + resource, ex);\n    }\n    catch (ioexception ex) {\n        throw new beandefinitionstoreexception(resource.getdescription(),\n                                               "ioexception parsing xml document from " + resource, ex);\n    }\n    catch (throwable ex) {\n        throw new beandefinitionstoreexception(resource.getdescription(),\n                                               "unexpected exception parsing xml document from " + resource, ex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n直接进入defaultbeandefinitiondocumentreader 下面的doregisterbeandefinitions\n\nprotected void doregisterbeandefinitions(element root) {\n\t\t// any nested <beans> elements will cause recursion in this method. in\n\t\t// rder to propagate and preserve <beans> default-* attributes correctly,\n\t\t// keep track of the current (parent) delegate, which may be null. create\n\t\t// the new (child) delegate with a reference to the parent for fallback purposes,\n\t\t// then ultimately reset this.delegate back to its original (parent) reference.\n\t\t// this behavior emulates a stack of delegates without actually necessitating one.\n\t\tbeandefinitionparserdelegate parent = this.delegate;\n\t\tthis.delegate = createdelegate(getreadercontext(), root, parent);\nif (this.delegate.isdefaultnamespace(root)) {\n\t\t\tstring profilespec = root.getattribute(profile_attribute);\n\t\t\tif (stringutils.hastext(profilespec)) {\n\t\t\t\tstring[] specifiedprofiles = stringutils.tokenizetostringarray(\n\t\t\t\t\t\tprofilespec, beandefinitionparserdelegate.multi_value_attribute_delimiters);\n\t\t\t\t// we cannot use profiles.of(...) since profile expressions are not supported\n\t\t\t\t// in xml config. see spr-12458 for details.\n\t\t\t\tif (!getreadercontext().getenvironment().acceptsprofiles(specifiedprofiles)) {\n\t\t\t\t\tif (logger.isdebugenabled()) {\n\t\t\t\t\t\tlogger.debug("skipped xml bean definition file due to specified profiles [" + profilespec +\n\t\t\t\t\t\t\t\t"] not matching: " + getreadercontext().getresource());\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpreprocessxml(root);\n\t\t// 解析xml 将xml元素转化为beandefinition\n\t\tparsebeandefinitions(root, this.delegate);\n\t\tpostprocessxml(root);\n\t\tthis.delegate = parent;\n \n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n根据上面的解释我们直接进入parsebeandefinitions(root, this.delegate);\n\n再进入parsedefaultelement(ele, delegate)\n\nprivate void parsedefaultelement(element ele, beandefinitionparserdelegate delegate) {\n\tif (delegate.nodenameequals(ele, import_element)) {\n\t\t//处理import标签\n\t\timportbeandefinitionresource(ele);\n\t}\n\telse if (delegate.nodenameequals(ele, alias_element)) {\n\t\t//处理alias标签\n\t\tprocessaliasregistration(ele);\n\t}\n\telse if (delegate.nodenameequals(ele, bean_element)) {\n\t\t//处理bean标签\n\t\tprocessbeandefinition(ele, delegate);\n\t}\n\telse if (delegate.nodenameequals(ele, nested_beans_element)) {\n\t\t// 处理beans标签\n\t\tdoregisterbeandefinitions(ele);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n进入processbeandefinition(ele, delegate);我们只关心bean\n\nprotected void processbeandefinition(element ele, beandefinitionparserdelegate delegate) {\n\t// xml节点信息转化为beandefinitionholder对象\n\tbeandefinitionholder bdholder = delegate.parsebeandefinitionelement(ele);\n\tif (bdholder != null) {\n\t\t//如果有自定义属性的话 进行相应的解析\n\t\tbdholder = delegate.decoratebeandefinitionifrequired(ele, bdholder);\n\t\ttry {\n\t\t\t// register the final decorated instance.\n\t\t\t// 这一步就是注册bean啦\n\t\t\tbeandefinitionreaderutils.registerbeandefinition(bdholder, getreadercontext().getregistry());\n\t\t}\n\t\tcatch (beandefinitionstoreexception ex) {\n\t\t\tgetreadercontext().error("failed to register bean definition with name \'" +\n\t\t\t\t\tbdholder.getbeanname() + "\'", ele, ex);\n\t\t}\n\t\t// send registration event.\n\t\tgetreadercontext().firecomponentregistered(new beancomponentdefinition(bdholder));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n进入registerbeandefinition方法\n\n\tpublic static void registerbeandefinition(\n\t\t\tbeandefinitionholder definitionholder, beandefinitionregistry registry)\n\t\t\tthrows beandefinitionstoreexception {\n \n\t\t// register bean definition under primary name.\n\t\tstring beanname = definitionholder.getbeanname();\n\t\tregistry.registerbeandefinition(beanname, definitionholder.getbeandefinition());\n \n\t\t// register aliases for bean name, if any.\n\t\tstring[] aliases = definitionholder.getaliases();\n\t\tif (aliases != null) {\n\t\t\tfor (string alias : aliases) {\n\t\t\t\tregistry.registeralias(beanname, alias);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n再进入registry.registerbeandefinition\n\npublic void registerbeandefinition(string beanname, beandefinition beandefinition)\n\t\t\tthrows beandefinitionstoreexception {\n\n    assert.hastext(beanname, "bean name must not be empty");\n    assert.notnull(beandefinition, "beandefinition must not be null");\n\n    if (beandefinition instanceof abstractbeandefinition) {\n        try {\n            ((abstractbeandefinition) beandefinition).validate();\n        }\n        catch (beandefinitionvalidationexception ex) {\n            throw new beandefinitionstoreexception(beandefinition.getresourcedescription(), beanname,\n                                                   "validation of bean definition failed", ex);\n        }\n    }\n\n    beandefinition existingdefinition = this.beandefinitionmap.get(beanname);\n    if (existingdefinition != null) {\n        if (!isallowbeandefinitionoverriding()) {\n            throw new beandefinitionoverrideexception(beanname, beandefinition, existingdefinition);\n        }\n        else if (existingdefinition.getrole() < beandefinition.getrole()) {\n            // e.g. was role_application, now overriding with role_support or role_infrastructure\n            if (logger.isinfoenabled()) {\n                logger.info("overriding user-defined bean definition for bean \'" + beanname +\n                            "\' with a framework-generated bean definition: replacing [" +\n                            existingdefinition + "] with [" + beandefinition + "]");\n            }\n        }\n        else if (!beandefinition.equals(existingdefinition)) {\n            if (logger.isdebugenabled()) {\n                logger.debug("overriding bean definition for bean \'" + beanname +\n                             "\' with a different definition: replacing [" + existingdefinition +\n                             "] with [" + beandefinition + "]");\n            }\n        }\n        else {\n            if (logger.istraceenabled()) {\n                logger.trace("overriding bean definition for bean \'" + beanname +\n                             "\' with an equivalent definition: replacing [" + existingdefinition +\n                             "] with [" + beandefinition + "]");\n            }\n        }\n        this.beandefinitionmap.put(beanname, beandefinition);\n    }\n    else {\n        if (hasbeancreationstarted()) {\n            // cannot modify startup-time collection elements anymore (for stable iteration)\n            synchronized (this.beandefinitionmap) {\n                this.beandefinitionmap.put(beanname, beandefinition);\n                list<string> updateddefinitions = new arraylist<>(this.beandefinitionnames.size() + 1);\n                updateddefinitions.addall(this.beandefinitionnames);\n                updateddefinitions.add(beanname);\n                this.beandefinitionnames = updateddefinitions;\n                removemanualsingletonname(beanname);\n            }\n        }\n        else {\n            // still in startup registration phase\n            this.beandefinitionmap.put(beanname, beandefinition);\n            this.beandefinitionnames.add(beanname);\n            removemanualsingletonname(beanname);\n        }\n        this.frozenbeandefinitionnames = null;\n    }\n\n    if (existingdefinition != null || containssingleton(beanname)) {\n        resetbeandefinition(beanname);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n然后我们看看这个defaultlistablebeanfactory的关系图\n\n\n\n到此为止基本就创建完了，最后执行获取这个操作了。\n\n\tpublic final configurablelistablebeanfactory getbeanfactory() {\n \n            //因为在刚才的refreshbeanfactory()方法中，我们已经将beanfactory这个类设置到this当中了\n            //所以在这个地方直接获取\n\tsynchronized (this.beanfactorymonitor) {\n\t\tif (this.beanfactory == null) {\n\t\t\tthrow new illegalstateexception("beanfactory not initialized or already closed - " +\n\t\t\t\t\t"call \'refresh\' before accessing beans via the applicationcontext");\n\t\t}\n\t\treturn this.beanfactory;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 5.5 preparebeanfactory()\n\nprotected void preparebeanfactory(configurablelistablebeanfactory beanfactory) {\n    //设置类加载器：存在则直接设置/不存在则新建一个默认类加载器\n    beanfactory.setbeanclassloader(getclassloader());\n    //设置el表达式解析器（bean初始化完成后填充属性时会用到）\n    beanfactory.setbeanexpressionresolver(new standardbeanexpressionresolver(beanfactory.getbeanclassloader()));\n    //设置属性注册解析器propertyeditor\n    beanfactory.addpropertyeditorregistrar(new resourceeditorregistrar(this, getenvironment()));\n    // 将当前的applicationcontext对象交给applicationcontextawareprocessor类来处理，从而在aware接口实现类中的注入applicationcontext\n    beanfactory.addbeanpostprocessor(new applicationcontextawareprocessor(this));\n    //设置忽略自动装配的接口\n    beanfactory.ignoredependencyinterface(resourceloaderaware.class);\n    beanfactory.ignoredependencyinterface(applicationeventpublisheraware.class);\n    beanfactory.ignoredependencyinterface(messagesourceaware.class);\n    beanfactory.ignoredependencyinterface(applicationcontextaware.class);\n    beanfactory.ignoredependencyinterface(environmentaware.class);\n    //注册可以解析的自动装配\n    // messagesource registered (and found for autowiring) as a bean.\n    beanfactory.registerresolvabledependency(beanfactory.class, beanfactory);\n    beanfactory.registerresolvabledependency(resourceloader.class, this);\n    beanfactory.registerresolvabledependency(applicationeventpublisher.class, this);\n    beanfactory.registerresolvabledependency(applicationcontext.class, this);\n    //如果当前beanfactory包含loadtimeweaver bean，说明存在类加载期织入aspectj，则把当前beanfactory交给类加载期beanpostprocessor实现类loadtimeweaverawareprocessor来处理，从而实现类加载期织入aspectj的目的。\n    if (beanfactory.containsbean(load_time_weaver_bean_name)) {\n        beanfactory.addbeanpostprocessor(new loadtimeweaverawareprocessor(beanfactory));\n        // set a temporary classloader for type matching.\n        beanfactory.settempclassloader(new contexttypematchclassloader(beanfactory.getbeanclassloader()));\n    }\n    //注册当前容器环境environment组件bean\n    if (!beanfactory.containslocalbean(environment_bean_name)) {\n        beanfactory.registersingleton(environment_bean_name, getenvironment());\n    }\n    //注册系统配置systemproperties组件bean\n    if (!beanfactory.containslocalbean(system_properties_bean_name)) {\n        beanfactory.registersingleton(system_properties_bean_name, getenvironment().getsystemproperties());\n    }\n    //注册系统环境systemenvironment组件bean\n    if (!beanfactory.containslocalbean(system_environment_bean_name)) {\n        beanfactory.registersingleton(system_environment_bean_name, getenvironment().getsystemenvironment());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 5.6 postprocessbeanfactory()\n\nspring中并没有具体去实现postprocessbeanfactory方法，作用是在beanfactory准备工作完成后做一些定制化的处理。\n\n\n# 5.7 核心方法之一 invokebeanfactorypostprocessors()\n\ninstantiate and invoke all registered beanfactorypostprocessor beans,respecting explicit order if given.\n\n上面是对这个方法的描述，调用所有注册的beanfactorypostprocessor，并遵循显式顺序（如果给定的话）。\n\nbeanfactorypostprocessor 接口是 spring 初始化 beanfactory 时对外暴露的扩展点，spring ioc 容器允许 beanfactorypostprocessor 在容器实例化任何 bean 之前读取 bean 的定义，并可以修改它。\n\nprotected void invokebeanfactorypostprocessors(configurablelistablebeanfactory beanfactory) {\n            //getbeanfactorypostprocessors(): 拿到当前应用上下文beanfactorypostprocessors变量中的值\n            //invokebeanfactorypostprocessors: 实例化并调用所有已注册的beanfactorypostprocessor\n            postprocessorregistrationdelegate.invokebeanfactorypostprocessors(beanfactory, getbeanfactorypostprocessors());\n \n\t// detect a loadtimeweaver and prepare for weaving, if found in the meantime\n\t// (e.g. through an @bean method registered by configurationclasspostprocessor)\n\tif (beanfactory.gettempclassloader() == null && beanfactory.containsbean(load_time_weaver_bean_name)) {\n\t\tbeanfactory.addbeanpostprocessor(new loadtimeweaverawareprocessor(beanfactory));\n\t\tbeanfactory.settempclassloader(new contexttypematchclassloader(beanfactory.getbeanclassloader()));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这一段代码的核心在于获取和调用，下面进行详细的讲解 getbeanfactorypostprocessors()，这个方法默认是没有的，返回null\n\npublic list<beanfactorypostprocessor> getbeanfactorypostprocessors() {\n\treturn this.beanfactorypostprocessors;\n}\n\n\n1\n2\n3\n\n\n如何添加自定义 beanfactorypostprocessor 到 this.beanfactorypostprocessors 变量中了？\n\n新建一个 applicationcontextinitializer 的实现类 springapplicationcontextinitializer ，并在 initialize 方法中写我们的逻辑。\n\npackage com.joonwhee.open.demo.spring;\nimport org.springframework.context.applicationcontextinitializer;\nimport org.springframework.context.configurableapplicationcontext;\n/**\n * @author joonwhee\n * @date 2019/1/19\n */\npublic class springapplicationcontextinitializer implements applicationcontextinitializer<configurableapplicationcontext> {\n    @override\n    public void initialize(configurableapplicationcontext applicationcontext) {\n        firstbeandefinitionregistrypostprocessor firstbeandefinitionregistrypostprocessor = new firstbeandefinitionregistrypostprocessor();\n        // 将自定义的firstbeandefinitionregistrypostprocessor添加到应用上下文中\n        applicationcontext.addbeanfactorypostprocessor(firstbeandefinitionregistrypostprocessor);\n        // ...自定义操作\n        system.out.println("springapplicationcontextinitializer#initialize");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n将 springapplicationcontextinitializer 作为初始化参数 contextinitializerclasses 配置到 web.xml 中。\n\n<context-param>\n    <param-name>contextinitializerclasses</param-name>\n    <param-value>\n        com.joonwhee.open.demo.spring.springapplicationcontextinitializer\n    </param-value>\n</context-param>\n\n\n1\n2\n3\n4\n5\n6\n\n\ninvokebeanfactorypostprocessors方法\n\n \npublic static void invokebeanfactorypostprocessors(\n        configurablelistablebeanfactory beanfactory, list<beanfactorypostprocessor> beanfactorypostprocessors) {\n \n \n \n    // invoke beandefinitionregistrypostprocessors first, if any.\n \n    set<string> processedbeans = new hashset<string>();\n \n \n \n    // 1.判断beanfactory是否为beandefinitionregistry，beanfactory为defaultlistablebeanfactory,\n \n    // 而defaultlistablebeanfactory实现了beandefinitionregistry接口，因此这边为true\n \n    if (beanfactory instanceof beandefinitionregistry) {\n \n        beandefinitionregistry registry = (beandefinitionregistry) beanfactory;\n \n        // 用于存放普通的beanfactorypostprocessor\n \n        list<beanfactorypostprocessor> regularpostprocessors = new linkedlist<beanfactorypostprocessor>();\n \n        // 用于存放beandefinitionregistrypostprocessor\n \n        list<beandefinitionregistrypostprocessor> registryprocessors = new linkedlist<beandefinitionregistrypostprocessor>();\n \n \n \n        // 2.首先处理入参中的beanfactorypostprocessors\n \n        // 遍历所有的beanfactorypostprocessors, 将beandefinitionregistrypostprocessor和普通beanfactorypostprocessor区分开\n \n        for (beanfactorypostprocessor postprocessor : beanfactorypostprocessors) {\n \n            if (postprocessor instanceof beandefinitionregistrypostprocessor) {\n \n                // 2.1 如果是beandefinitionregistrypostprocessor\n \n                beandefinitionregistrypostprocessor registryprocessor =\n \n                        (beandefinitionregistrypostprocessor) postprocessor;\n \n                // 2.1.1 直接执行beandefinitionregistrypostprocessor接口的postprocessbeandefinitionregistry方法\n \n                registryprocessor.postprocessbeandefinitionregistry(registry);\n \n                // 2.1.2 添加到registryprocessors(用于最后执行postprocessbeanfactory方法)\n \n                registryprocessors.add(registryprocessor);\n \n            } else {\n \n                // 2.2 否则，只是普通的beanfactorypostprocessor\n \n                // 2.2.1 添加到regularpostprocessors(用于最后执行postprocessbeanfactory方法)\n \n                regularpostprocessors.add(postprocessor);\n \n            }\n \n        }\n \n \n \n        // do not initialize factorybeans here: we need to leave all regular beans\n \n        // uninitialized to let the bean factory post-processors apply to them!\n \n        // separate between beandefinitionregistrypostprocessors that implement\n \n        // priorityordered, ordered, and the rest.\n \n        // 用于保存本次要执行的beandefinitionregistrypostprocessor\n \n        list<beandefinitionregistrypostprocessor> currentregistryprocessors = new arraylist<beandefinitionregistrypostprocessor>();\n \n \n \n        // first, invoke the beandefinitionregistrypostprocessors that implement priorityordered.\n \n        // 3.调用所有实现priorityordered接口的beandefinitionregistrypostprocessor实现类\n \n        // 3.1 找出所有实现beandefinitionregistrypostprocessor接口的bean的beanname\n \n        string[] postprocessornames =\n \n                beanfactory.getbeannamesfortype(beandefinitionregistrypostprocessor.class, true, false);\n \n        // 3.2 遍历postprocessornames\n \n        for (string ppname : postprocessornames) {\n \n            // 3.3 校验是否实现了priorityordered接口\n \n            if (beanfactory.istypematch(ppname, priorityordered.class)) {\n \n                // 3.4 获取ppname对应的bean实例, 添加到currentregistryprocessors中,\n \n                // beanfactory.getbean: 这边getbean方法会触发创建ppname对应的bean对象, 目前暂不深入解析\n \n                currentregistryprocessors.add(beanfactory.getbean(ppname, beandefinitionregistrypostprocessor.class));\n \n                // 3.5 将要被执行的加入processedbeans，避免后续重复执行\n \n                processedbeans.add(ppname);\n \n            }\n \n        }\n \n        // 3.6 进行排序(根据是否实现priorityordered、ordered接口和order值来排序)\n \n        sortpostprocessors(currentregistryprocessors, beanfactory);\n \n        // 3.7 添加到registryprocessors(用于最后执行postprocessbeanfactory方法)\n \n        registryprocessors.addall(currentregistryprocessors);\n \n        // 3.8 遍历currentregistryprocessors, 执行postprocessbeandefinitionregistry方法\n \n        invokebeandefinitionregistrypostprocessors(currentregistryprocessors, registry);\n \n        // 3.9 执行完毕后, 清空currentregistryprocessors\n \n        currentregistryprocessors.clear();\n \n \n \n        // next, invoke the beandefinitionregistrypostprocessors that implement ordered.\n \n        // 4.调用所有实现了ordered接口的beandefinitionregistrypostprocessor实现类（过程跟上面的步骤3基本一样）\n \n        // 4.1 找出所有实现beandefinitionregistrypostprocessor接口的类, 这边重复查找是因为执行完上面的beandefinitionregistrypostprocessor,\n \n        // 可能会新增了其他的beandefinitionregistrypostprocessor, 因此需要重新查找\n \n        postprocessornames = beanfactory.getbeannamesfortype(beandefinitionregistrypostprocessor.class, true, false);\n \n        for (string ppname : postprocessornames) {\n \n            // 校验是否实现了ordered接口，并且还未执行过\n \n            if (!processedbeans.contains(ppname) && beanfactory.istypematch(ppname, ordered.class)) {\n \n                currentregistryprocessors.add(beanfactory.getbean(ppname, beandefinitionregistrypostprocessor.class));\n \n                processedbeans.add(ppname);\n \n            }\n \n        }\n \n        sortpostprocessors(currentregistryprocessors, beanfactory);\n \n        registryprocessors.addall(currentregistryprocessors);\n \n        // 4.2 遍历currentregistryprocessors, 执行postprocessbeandefinitionregistry方法\n \n        invokebeandefinitionregistrypostprocessors(currentregistryprocessors, registry);\n \n        currentregistryprocessors.clear();\n \n \n \n        // finally, invoke all other beandefinitionregistrypostprocessors until no further ones appear.\n \n        // 5.最后, 调用所有剩下的beandefinitionregistrypostprocessors\n \n        boolean reiterate = true;\n \n        while (reiterate) {\n \n            reiterate = false;\n \n            // 5.1 找出所有实现beandefinitionregistrypostprocessor接口的类\n \n            postprocessornames = beanfactory.getbeannamesfortype(beandefinitionregistrypostprocessor.class, true, false);\n \n            for (string ppname : postprocessornames) {\n \n                // 5.2 跳过已经执行过的\n \n                if (!processedbeans.contains(ppname)) {\n \n                    currentregistryprocessors.add(beanfactory.getbean(ppname, beandefinitionregistrypostprocessor.class));\n \n                    processedbeans.add(ppname);\n \n                    // 5.3 如果有beandefinitionregistrypostprocessor被执行, 则有可能会产生新的beandefinitionregistrypostprocessor,\n \n                    // 因此这边将reiterate赋值为true, 代表需要再循环查找一次\n \n                    reiterate = true;\n \n                }\n \n            }\n \n            sortpostprocessors(currentregistryprocessors, beanfactory);\n \n            registryprocessors.addall(currentregistryprocessors);\n \n            // 5.4 遍历currentregistryprocessors, 执行postprocessbeandefinitionregistry方法\n \n            invokebeandefinitionregistrypostprocessors(currentregistryprocessors, registry);\n \n            currentregistryprocessors.clear();\n \n        }\n \n \n \n        // now, invoke the postprocessbeanfactory callback of all processors handled so far.\n \n        // 6.调用所有beandefinitionregistrypostprocessor的postprocessbeanfactory方法(beandefinitionregistrypostprocessor继承自beanfactorypostprocessor)\n \n        invokebeanfactorypostprocessors(registryprocessors, beanfactory);\n \n        // 7.最后, 调用入参beanfactorypostprocessors中的普通beanfactorypostprocessor的postprocessbeanfactory方法\n \n        invokebeanfactorypostprocessors(regularpostprocessors, beanfactory);\n \n    } else {\n \n        // invoke factory processors registered with the context instance.\n \n        invokebeanfactorypostprocessors(beanfactorypostprocessors, beanfactory);\n \n    }\n \n \n \n    // 到这里 , 入参beanfactorypostprocessors和容器中的所有beandefinitionregistrypostprocessor已经全部处理完毕,\n \n    // 下面开始处理容器中的所有beanfactorypostprocessor\n \n \n \n    // do not initialize factorybeans here: we need to leave all regular beans\n \n    // uninitialized to let the bean factory post-processors apply to them!\n \n    // 8.找出所有实现beanfactorypostprocessor接口的类\n \n    string[] postprocessornames =\n \n            beanfactory.getbeannamesfortype(beanfactorypostprocessor.class, true, false);\n \n \n \n    // separate between beanfactorypostprocessors that implement priorityordered,\n \n    // ordered, and the rest.\n \n    // 用于存放实现了priorityordered接口的beanfactorypostprocessor\n \n    list<beanfactorypostprocessor> priorityorderedpostprocessors = new arraylist<beanfactorypostprocessor>();\n \n    // 用于存放实现了ordered接口的beanfactorypostprocessor的beanname\n \n    list<string> orderedpostprocessornames = new arraylist<string>();\n \n    // 用于存放普通beanfactorypostprocessor的beanname\n \n    list<string> nonorderedpostprocessornames = new arraylist<string>();\n \n    // 8.1 遍历postprocessornames, 将beanfactorypostprocessor按实现priorityordered、实现ordered接口、普通三种区分开\n \n    for (string ppname : postprocessornames) {\n \n        // 8.2 跳过已经执行过的\n \n        if (processedbeans.contains(ppname)) {\n \n            // skip - already processed in first phase above\n \n        } else if (beanfactory.istypematch(ppname, priorityordered.class)) {\n \n            // 8.3 添加实现了priorityordered接口的beanfactorypostprocessor\n \n            priorityorderedpostprocessors.add(beanfactory.getbean(ppname, beanfactorypostprocessor.class));\n \n        } else if (beanfactory.istypematch(ppname, ordered.class)) {\n \n            // 8.4 添加实现了ordered接口的beanfactorypostprocessor的beanname\n \n            orderedpostprocessornames.add(ppname);\n \n        } else {\n \n            // 8.5 添加剩下的普通beanfactorypostprocessor的beanname\n \n            nonorderedpostprocessornames.add(ppname);\n \n        }\n \n    }\n \n \n \n    // first, invoke the beanfactorypostprocessors that implement priorityordered.\n \n    // 9.调用所有实现priorityordered接口的beanfactorypostprocessor\n \n    // 9.1 对priorityorderedpostprocessors排序\n \n    sortpostprocessors(priorityorderedpostprocessors, beanfactory);\n \n    // 9.2 遍历priorityorderedpostprocessors, 执行postprocessbeanfactory方法\n \n    invokebeanfactorypostprocessors(priorityorderedpostprocessors, beanfactory);\n \n \n \n    // next, invoke the beanfactorypostprocessors that implement ordered.\n \n    // 10.调用所有实现ordered接口的beanfactorypostprocessor\n \n    list<beanfactorypostprocessor> orderedpostprocessors = new arraylist<beanfactorypostprocessor>();\n \n    for (string postprocessorname : orderedpostprocessornames) {\n \n        // 10.1 获取postprocessorname对应的bean实例, 添加到orderedpostprocessors, 准备执行\n \n        orderedpostprocessors.add(beanfactory.getbean(postprocessorname, beanfactorypostprocessor.class));\n \n    }\n \n    // 10.2 对orderedpostprocessors排序\n \n    sortpostprocessors(orderedpostprocessors, beanfactory);\n \n    // 10.3 遍历orderedpostprocessors, 执行postprocessbeanfactory方法\n \n    invokebeanfactorypostprocessors(orderedpostprocessors, beanfactory);\n \n \n \n    // finally, invoke all other beanfactorypostprocessors.\n \n    // 11.调用所有剩下的beanfactorypostprocessor\n \n    list<beanfactorypostprocessor> nonorderedpostprocessors = new arraylist<beanfactorypostprocessor>();\n \n    for (string postprocessorname : nonorderedpostprocessornames) {\n \n        // 11.1 获取postprocessorname对应的bean实例, 添加到nonorderedpostprocessors, 准备执行\n \n        nonorderedpostprocessors.add(beanfactory.getbean(postprocessorname, beanfactorypostprocessor.class));\n \n    }\n \n    // 11.2 遍历nonorderedpostprocessors, 执行postprocessbeanfactory方法\n \n    invokebeanfactorypostprocessors(nonorderedpostprocessors, beanfactory);\n \n \n \n    // clear cached merged bean definitions since the post-processors might have\n \n    // modified the original metadata, e.g. replacing placeholders in values...\n \n    // 12.清除元数据缓存（mergedbeandefinitions、allbeannamesbytype、singletonbeannamesbytype），\n \n    // 因为后处理器可能已经修改了原始元数据，例如， 替换值中的占位符...\n \n    beanfactory.clearmetadatacache();\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n\n\n\n# 5.8 核心方法之一 registerbeanpostprocessors()\n\n本方法会注册所有的 beanpostprocessor，将所有实现了 beanpostprocessor 接口的类加载到 beanfactory 中。beanpostprocessor 接口是 spring 初始化 bean 时对外暴露的扩展点，spring ioc 容器允许 beanpostprocessor 在容器初始化 bean 的前后，添加自己的逻辑处理。\n\n \npublic static void registerbeanpostprocessors(\n        configurablelistablebeanfactory beanfactory, abstractapplicationcontext applicationcontext) {\n \n \n \n    // 1.找出所有实现beanpostprocessor接口的类\n \n    string[] postprocessornames = beanfactory.getbeannamesfortype(beanpostprocessor.class, true, false);\n \n \n \n    // register beanpostprocessorchecker that logs an info message when\n \n    // a bean is created during beanpostprocessor instantiation, i.e. when\n \n    // a bean is not eligible for getting processed by all beanpostprocessors.\n \n    // beanpostprocessor的目标计数\n \n    int beanprocessortargetcount = beanfactory.getbeanpostprocessorcount() + 1 + postprocessornames.length;\n \n    // 2.添加beanpostprocessorchecker(主要用于记录信息)到beanfactory中\n \n    beanfactory.addbeanpostprocessor(new beanpostprocessorchecker(beanfactory, beanprocessortargetcount));\n \n \n \n    // separate between beanpostprocessors that implement priorityordered,\n \n    // ordered, and the rest.\n \n    // 3.定义不同的变量用于区分: 实现priorityordered接口的beanpostprocessor、实现ordered接口的beanpostprocessor、普通beanpostprocessor\n \n    // 3.1 priorityorderedpostprocessors: 用于存放实现priorityordered接口的beanpostprocessor\n \n    list<beanpostprocessor> priorityorderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    // 3.2 internalpostprocessors: 用于存放spring内部的beanpostprocessor\n \n    list<beanpostprocessor> internalpostprocessors = new arraylist<beanpostprocessor>();\n \n    // 3.3 orderedpostprocessornames: 用于存放实现ordered接口的beanpostprocessor的beanname\n \n    list<string> orderedpostprocessornames = new arraylist<string>();\n \n    // 3.4 nonorderedpostprocessornames: 用于存放普通beanpostprocessor的beanname\n \n    list<string> nonorderedpostprocessornames = new arraylist<string>();\n \n    // 4.遍历postprocessornames, 将beanpostprocessors按3.1 - 3.4定义的变量区分开\n \n    for (string ppname : postprocessornames) {\n \n        if (beanfactory.istypematch(ppname, priorityordered.class)) {\n \n            // 4.1 如果ppname对应的bean实例实现了priorityordered接口, 则拿到ppname对应的bean实例并添加到priorityorderedpostprocessors\n \n            beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n            priorityorderedpostprocessors.add(pp);\n \n            if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n                // 4.2 如果ppname对应的bean实例也实现了mergedbeandefinitionpostprocessor接口,\n \n                // 则将ppname对应的bean实例添加到internalpostprocessors\n \n                internalpostprocessors.add(pp);\n \n            }\n \n        }\n \n        else if (beanfactory.istypematch(ppname, ordered.class)) {\n \n            // 4.3 如果ppname对应的bean实例没有实现priorityordered接口, 但是实现了ordered接口, 则将ppname添加到orderedpostprocessornames\n \n            orderedpostprocessornames.add(ppname);\n \n        }\n \n        else {\n \n            // 4.4 否则, 将ppname添加到nonorderedpostprocessornames\n \n            nonorderedpostprocessornames.add(ppname);\n \n        }\n \n    }\n \n \n \n    // first, register the beanpostprocessors that implement priorityordered.\n \n    // 5.首先, 注册实现priorityordered接口的beanpostprocessors\n \n    // 5.1 对priorityorderedpostprocessors进行排序\n \n    sortpostprocessors(priorityorderedpostprocessors, beanfactory);\n \n    // 5.2 注册priorityorderedpostprocessors\n \n    registerbeanpostprocessors(beanfactory, priorityorderedpostprocessors);\n \n \n \n    // next, register the beanpostprocessors that implement ordered.\n \n    // 6.接下来, 注册实现ordered接口的beanpostprocessors\n \n    list<beanpostprocessor> orderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    for (string ppname : orderedpostprocessornames) {\n \n        // 6.1 拿到ppname对应的beanpostprocessor实例对象\n \n        beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n        // 6.2 将ppname对应的beanpostprocessor实例对象添加到orderedpostprocessors, 准备执行注册\n \n        orderedpostprocessors.add(pp);\n \n        if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n            // 6.3 如果ppname对应的bean实例也实现了mergedbeandefinitionpostprocessor接口,\n \n            // 则将ppname对应的bean实例添加到internalpostprocessors\n \n            internalpostprocessors.add(pp);\n \n        }\n \n    }\n \n    // 6.4 对orderedpostprocessors进行排序\n \n    sortpostprocessors(orderedpostprocessors, beanfactory);\n \n    // 6.5 注册orderedpostprocessors\n \n    registerbeanpostprocessors(beanfactory, orderedpostprocessors);\n \n \n \n    // now, register all regular beanpostprocessors.\n \n    // 7.注册所有常规的beanpostprocessors（过程与6类似）\n \n    list<beanpostprocessor> nonorderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    for (string ppname : nonorderedpostprocessornames) {\n \n        beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n        nonorderedpostprocessors.add(pp);\n \n        if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n            internalpostprocessors.add(pp);\n \n        }\n \n    }\n \n    registerbeanpostprocessors(beanfactory, nonorderedpostprocessors);\n \n \n \n    // finally, re-register all internal beanpostprocessors.\n \n    // 8.最后, 重新注册所有内部beanpostprocessors（相当于内部的beanpostprocessor会被移到处理器链的末尾）\n \n    // 8.1 对internalpostprocessors进行排序\n \n    sortpostprocessors(internalpostprocessors, beanfactory);\n \n    // 8.2注册internalpostprocessors\n \n    registerbeanpostprocessors(beanfactory, internalpostprocessors);\n \n \n \n    // re-register post-processor for detecting inner beans as applicationlisteners,\n \n    // moving it to the end of the processor chain (for picking up proxies etc).\n \n    // 9.重新注册applicationlistenerdetector（跟8类似，主要是为了移动到处理器链的末尾）\n \n    beanfactory.addbeanpostprocessor(new applicationlistenerdetector(applicationcontext));\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n使用：可以在bean的初始化前后添加自己想要的代码\n\n \npublic static void registerbeanpostprocessors(\n        configurablelistablebeanfactory beanfactory, abstractapplicationcontext applicationcontext) {\n \n \n \n    // 1.找出所有实现beanpostprocessor接口的类\n \n    string[] postprocessornames = beanfactory.getbeannamesfortype(beanpostprocessor.class, true, false);\n \n \n \n    // register beanpostprocessorchecker that logs an info message when\n \n    // a bean is created during beanpostprocessor instantiation, i.e. when\n \n    // a bean is not eligible for getting processed by all beanpostprocessors.\n \n    // beanpostprocessor的目标计数\n \n    int beanprocessortargetcount = beanfactory.getbeanpostprocessorcount() + 1 + postprocessornames.length;\n \n    // 2.添加beanpostprocessorchecker(主要用于记录信息)到beanfactory中\n \n    beanfactory.addbeanpostprocessor(new beanpostprocessorchecker(beanfactory, beanprocessortargetcount));\n \n \n \n    // separate between beanpostprocessors that implement priorityordered,\n \n    // ordered, and the rest.\n \n    // 3.定义不同的变量用于区分: 实现priorityordered接口的beanpostprocessor、实现ordered接口的beanpostprocessor、普通beanpostprocessor\n \n    // 3.1 priorityorderedpostprocessors: 用于存放实现priorityordered接口的beanpostprocessor\n \n    list<beanpostprocessor> priorityorderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    // 3.2 internalpostprocessors: 用于存放spring内部的beanpostprocessor\n \n    list<beanpostprocessor> internalpostprocessors = new arraylist<beanpostprocessor>();\n \n    // 3.3 orderedpostprocessornames: 用于存放实现ordered接口的beanpostprocessor的beanname\n \n    list<string> orderedpostprocessornames = new arraylist<string>();\n \n    // 3.4 nonorderedpostprocessornames: 用于存放普通beanpostprocessor的beanname\n \n    list<string> nonorderedpostprocessornames = new arraylist<string>();\n \n    // 4.遍历postprocessornames, 将beanpostprocessors按3.1 - 3.4定义的变量区分开\n \n    for (string ppname : postprocessornames) {\n \n        if (beanfactory.istypematch(ppname, priorityordered.class)) {\n \n            // 4.1 如果ppname对应的bean实例实现了priorityordered接口, 则拿到ppname对应的bean实例并添加到priorityorderedpostprocessors\n \n            beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n            priorityorderedpostprocessors.add(pp);\n \n            if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n                // 4.2 如果ppname对应的bean实例也实现了mergedbeandefinitionpostprocessor接口,\n \n                // 则将ppname对应的bean实例添加到internalpostprocessors\n \n                internalpostprocessors.add(pp);\n \n            }\n \n        }\n \n        else if (beanfactory.istypematch(ppname, ordered.class)) {\n \n            // 4.3 如果ppname对应的bean实例没有实现priorityordered接口, 但是实现了ordered接口, 则将ppname添加到orderedpostprocessornames\n \n            orderedpostprocessornames.add(ppname);\n \n        }\n \n        else {\n \n            // 4.4 否则, 将ppname添加到nonorderedpostprocessornames\n \n            nonorderedpostprocessornames.add(ppname);\n \n        }\n \n    }\n \n \n \n    // first, register the beanpostprocessors that implement priorityordered.\n \n    // 5.首先, 注册实现priorityordered接口的beanpostprocessors\n \n    // 5.1 对priorityorderedpostprocessors进行排序\n \n    sortpostprocessors(priorityorderedpostprocessors, beanfactory);\n \n    // 5.2 注册priorityorderedpostprocessors\n \n    registerbeanpostprocessors(beanfactory, priorityorderedpostprocessors);\n \n \n \n    // next, register the beanpostprocessors that implement ordered.\n \n    // 6.接下来, 注册实现ordered接口的beanpostprocessors\n \n    list<beanpostprocessor> orderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    for (string ppname : orderedpostprocessornames) {\n \n        // 6.1 拿到ppname对应的beanpostprocessor实例对象\n \n        beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n        // 6.2 将ppname对应的beanpostprocessor实例对象添加到orderedpostprocessors, 准备执行注册\n \n        orderedpostprocessors.add(pp);\n \n        if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n            // 6.3 如果ppname对应的bean实例也实现了mergedbeandefinitionpostprocessor接口,\n \n            // 则将ppname对应的bean实例添加到internalpostprocessors\n \n            internalpostprocessors.add(pp);\n \n        }\n \n    }\n \n    // 6.4 对orderedpostprocessors进行排序\n \n    sortpostprocessors(orderedpostprocessors, beanfactory);\n \n    // 6.5 注册orderedpostprocessors\n \n    registerbeanpostprocessors(beanfactory, orderedpostprocessors);\n \n \n \n    // now, register all regular beanpostprocessors.\n \n    // 7.注册所有常规的beanpostprocessors（过程与6类似）\n \n    list<beanpostprocessor> nonorderedpostprocessors = new arraylist<beanpostprocessor>();\n \n    for (string ppname : nonorderedpostprocessornames) {\n \n        beanpostprocessor pp = beanfactory.getbean(ppname, beanpostprocessor.class);\n \n        nonorderedpostprocessors.add(pp);\n \n        if (pp instanceof mergedbeandefinitionpostprocessor) {\n \n            internalpostprocessors.add(pp);\n \n        }\n \n    }\n \n    registerbeanpostprocessors(beanfactory, nonorderedpostprocessors);\n \n \n \n    // finally, re-register all internal beanpostprocessors.\n \n    // 8.最后, 重新注册所有内部beanpostprocessors（相当于内部的beanpostprocessor会被移到处理器链的末尾）\n \n    // 8.1 对internalpostprocessors进行排序\n \n    sortpostprocessors(internalpostprocessors, beanfactory);\n \n    // 8.2注册internalpostprocessors\n \n    registerbeanpostprocessors(beanfactory, internalpostprocessors);\n \n \n \n    // re-register post-processor for detecting inner beans as applicationlisteners,\n \n    // moving it to the end of the processor chain (for picking up proxies etc).\n \n    // 9.重新注册applicationlistenerdetector（跟8类似，主要是为了移动到处理器链的末尾）\n \n    beanfactory.addbeanpostprocessor(new applicationlistenerdetector(applicationcontext));\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n\n# 5.9 initmessagesource()\n\n/**\n* initialize the messagesource.\n* use parent\'s if none defined in this context.\n*/\nprotected void initmessagesource() {\n   //获取bean工厂，一般是defaultlistbeanfactory\n   configurablelistablebeanfactory beanfactory = getbeanfactory();\n   //首先判断是否已有xml文件定义了id为messagesource的bean对象\n   if (beanfactory.containslocalbean(message_source_bean_name)) {\n      //如果有，则从bean工厂得到这个bean对象\n      this.messagesource = beanfactory.getbean(message_source_bean_name, messagesource.class);\n      // make messagesource aware of parent messagesource.\n      //当父类bean工厂不为空，并且这个bean对象是hierarchicalmessagesource类型\n      if (this.parent != null && this.messagesource instanceof hierarchicalmessagesource) {\n         //为hierarchicalmessagesource的实现类\n         hierarchicalmessagesource hms = (hierarchicalmessagesource) this.messagesource;\n         //设置父类messagesource，此处设置内部的parent messagesource\n         if (hms.getparentmessagesource() == null) {\n            // only set parent context as parent messagesource if no parent messagesource\n            // registered already.\n            hms.setparentmessagesource(getinternalparentmessagesource());\n         }\n      }\n      if (logger.istraceenabled()) {\n         logger.trace("using messagesource [" + this.messagesource + "]");\n      }\n   }\n   else {\n      // use empty messagesource to be able to accept getmessage calls.\n      //如果没有xml文件定义信息源对象，新建delegatingmessagesource类作为messagesource的bean\n      //因为delegatingmessagesource类实现了hierarchicalmessagesource接口，而这个接口继承了messagesource这个类\n      //因此实现了这个接口的类，都是messagesource的子类，因此delegatingmessagesource也是一个messagesource\n      delegatingmessagesource dms = new delegatingmessagesource();\n      //给这个delegatingmessagesource添加父类消息源\n      dms.setparentmessagesource(getinternalparentmessagesource());\n      this.messagesource = dms;\n      //将这个messagesource实例注册到bean工厂中\n      beanfactory.registersingleton(message_source_bean_name, this.messagesource);\n      if (logger.istraceenabled()) {\n         logger.trace("no \'" + message_source_bean_name + "\' bean, using [" + this.messagesource + "]");\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 5.10 initapplicationeventmulticaster()\n\n代码很简单，就是分两种情况进行初始化的过程\n\nprotected void initapplicationeventmulticaster() {\n    configurablelistablebeanfactory beanfactory = getbeanfactory();\n    if (beanfactory.containslocalbean(application_event_multicaster_bean_name)) {\n        this.applicationeventmulticaster =\n            beanfactory.getbean(application_event_multicaster_bean_name, applicationeventmulticaster.class);\n        if (logger.istraceenabled()) {\n            logger.trace("using applicationeventmulticaster [" + this.applicationeventmulticaster + "]");\n        }\n    }\n    else {\n        this.applicationeventmulticaster = new simpleapplicationeventmulticaster(beanfactory);\n        beanfactory.registersingleton(application_event_multicaster_bean_name, this.applicationeventmulticaster);\n        if (logger.istraceenabled()) {\n            logger.trace("no \'" + application_event_multicaster_bean_name + "\' bean, using " +\n                         "[" + this.applicationeventmulticaster.getclass().getsimplename() + "]");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5.11 onrefresh()\n\n这个方法是空的没有进行实现，官网给的注释是\n\ninitialize other special beans in specific context subclasses.\n\n初始化一些其他的特殊的bean\n\n\n# 5.12 registerlisteners()\n\n获取applicationcontext初始化的listeners，然后添加到eventmulticaster，这个刚才初始化的\n\n这里面的earlyapplicationevents是在第一步的时候进行初始化的\n\n在preparerefresh方法中的\n\nthis.earlyapplicationevents = new linkedhashset<>();\n\n\tprotected void registerlisteners() {\n\t\t// register statically specified listeners first.\n\t\tfor (applicationlistener<?> listener : getapplicationlisteners()) {\n\t\t\tgetapplicationeventmulticaster().addapplicationlistener(listener);\n\t\t}\n \n\t\t// do not initialize factorybeans here: we need to leave all regular beans\n\t\t// uninitialized to let post-processors apply to them!\n\t\tstring[] listenerbeannames = getbeannamesfortype(applicationlistener.class, true, false);\n\t\tfor (string listenerbeanname : listenerbeannames) {\n\t\t\tgetapplicationeventmulticaster().addapplicationlistenerbean(listenerbeanname);\n\t\t}\n \n\t\t// publish early application events now that we finally have a multicaster...\n\t\tset<applicationevent> earlyeventstoprocess = this.earlyapplicationevents;\n\t\tthis.earlyapplicationevents = null;\n\t\tif (earlyeventstoprocess != null) {\n\t\t\tfor (applicationevent earlyevent : earlyeventstoprocess) {\n\t\t\t\tgetapplicationeventmulticaster().multicastevent(earlyevent);\n\t\t\t}\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n自定义监听器的实现\n\nimport org.springframework.context.applicationlistener;\nimport org.springframework.context.event.contextrefreshedevent;\nimport org.springframework.stereotype.component;\n@component\npublic class myrefreshedlistener implements applicationlistener<contextrefreshedevent> {\n    @override\n    public void onapplicationevent(contextrefreshedevent event) {\n        // 自己的逻辑处理\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.13 核心方法之一 finishbeanfactoryinitialization(beanfactory)\n\nprotected void finishbeanfactoryinitialization(configurablelistablebeanfactory beanfactory) {\n    // initialize conversion service for this context.\n    if (beanfactory.containsbean(conversion_service_bean_name) &&\n    beanfactory.istypematch(conversion_service_bean_name, conversionservice.class)) {\n    beanfactory.setconversionservice(\n    beanfactory.getbean(conversion_service_bean_name, conversionservice.class));\n    }\n\n    // register a default embedded value resolver if no bean post-processor\n    // (such as a propertyplaceholderconfigurer bean) registered any before:\n    // at this point, primarily for resolution in annotation attribute values.\n    if (!beanfactory.hasembeddedvalueresolver()) {\n    beanfactory.addembeddedvalueresolver(strval -> getenvironment().resolveplaceholders(strval));\n    }\n\n    // initialize loadtimeweaveraware beans early to allow for registering their transformers early.\n    string[] weaverawarenames = beanfactory.getbeannamesfortype(loadtimeweaveraware.class, false, false);\n    for (string weaverawarename : weaverawarenames) {\n    getbean(weaverawarename);\n    }\n\n    // stop using the temporary classloader for type matching.\n    beanfactory.settempclassloader(null);\n\n    // allow for caching all bean definition metadata, not expecting further changes.\n    beanfactory.freezeconfiguration();\n\n    // instantiate all remaining (non-lazy-init) singletons.\n    beanfactory.preinstantiatesingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n关键起作用的在最后一行beanfactory.preinstantiatesingletons();我们进入\n\n这个时候发现又进入了我们的老朋友\n\ndefaultlistablebeanfactory这个重要的类\n\n这里里面的关键代码在于通过名字获取bean，也就是getbean(beanname);方法\n\npublic void preinstantiatesingletons() throws beansexception {\n    if (logger.istraceenabled()) {\n    \tlogger.trace("pre-instantiating singletons in " + this);\n    }\n    \n    // iterate over a copy to allow for init methods which in turn register new bean definitions.\n\t// while this may not be part of the regular factory bootstrap, it does otherwise work fine.\n\tlist<string> beannames = new arraylist<>(this.beandefinitionnames);\n \n\t// trigger initialization of all non-lazy singleton beans...\n\tfor (string beanname : beannames) {\n\t\trootbeandefinition bd = getmergedlocalbeandefinition(beanname);\n\t\tif (!bd.isabstract() && bd.issingleton() && !bd.islazyinit()) {\n\t\t\tif (isfactorybean(beanname)) {\n\t\t\t\tobject bean = getbean(factory_bean_prefix + beanname);\n\t\t\t\tif (bean instanceof factorybean) {\n\t\t\t\t\tfinal factorybean<?> factory = (factorybean<?>) bean;\n\t\t\t\t\tboolean iseagerinit;\n\t\t\t\t\tif (system.getsecuritymanager() != null && factory instanceof smartfactorybean) {\n\t\t\t\t\t\tiseagerinit = accesscontroller.doprivileged((privilegedaction<boolean>)\n\t\t\t\t\t\t\t\t\t\t((smartfactorybean<?>) factory)::iseagerinit,\n\t\t\t\t\t\t\t\tgetaccesscontrolcontext());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tiseagerinit = (factory instanceof smartfactorybean &&\n\t\t\t\t\t\t\t\t((smartfactorybean<?>) factory).iseagerinit());\n\t\t\t\t\t}\n\t\t\t\t\tif (iseagerinit) {\n\t\t\t\t\t\tgetbean(beanname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgetbean(beanname);\n\t\t\t}\n\t\t}\n\t}\n \n\t// trigger post-initialization callback for all applicable beans...\n\tfor (string beanname : beannames) {\n\t\tobject singletoninstance = getsingleton(beanname);\n\t\tif (singletoninstance instanceof smartinitializingsingleton) {\n\t\t\tfinal smartinitializingsingleton smartsingleton = (smartinitializingsingleton) singletoninstance;\n\t\t\tif (system.getsecuritymanager() != null) {\n\t\t\t\taccesscontroller.doprivileged((privilegedaction<object>) () -> {\n\t\t\t\t\tsmartsingleton.aftersingletonsinstantiated();\n\t\t\t\t\treturn null;\n\t\t\t\t}, getaccesscontrolcontext());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmartsingleton.aftersingletonsinstantiated();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n我们进入getbean(beanname);方法\n\npublic object getbean(string name) throws beansexception {\n\t\treturn dogetbean(name, null, null, false);\n}\n\n\n1\n2\n3\n\n\n发现仅仅是调用了dogetbean这个方法，但是我们在这里看到了do，在spring中do都是干实事的地方，那我们就要知道，创建bean的重点来了。\n\nprotected <t> t dogetbean(final string name, @nullable final class<t> requiredtype,\n    \t@nullable final object[] args, boolean typecheckonly) throws beansexception {\n    \t\n    final string beanname = transformedbeanname(name);\n\tobject bean;\n \n\t// eagerly check singleton cache for manually registered singletons.\n            //这部分是通过getsingleton(beanname)方法去singleton缓存中找bean实例，\n            //应该是拿不到的，因为我们是第一次初始化，缓存中肯定不存在。\n\tobject sharedinstance = getsingleton(beanname);\n\tif (sharedinstance != null && args == null) {\n\t\tif (logger.istraceenabled()) {\n\t\t\tif (issingletoncurrentlyincreation(beanname)) {\n\t\t\t\tlogger.trace("returning eagerly cached instance of singleton bean \'" + beanname +\n\t\t\t\t\t\t"\' that is not fully initialized yet - a consequence of a circular reference");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.trace("returning cached instance of singleton bean \'" + beanname + "\'");\n\t\t\t}\n\t\t}\n\t\tbean = getobjectforbeaninstance(sharedinstance, name, beanname, null);\n\t}\n \n\telse {\n\t\t// fail if we\'re already creating this bean instance:\n\t\t// we\'re assumably within a circular reference.\n                    //这段是根据当前的beanfactory获取父一级的beanfactory，然后逐级递归的查找我们需要的bean\n\t\tif (isprototypecurrentlyincreation(beanname)) {\n\t\t\tthrow new beancurrentlyincreationexception(beanname);\n\t\t}\n \n\t\t// check if bean definition exists in this factory.\n\t\tbeanfactory parentbeanfactory = getparentbeanfactory();\n\t\tif (parentbeanfactory != null && !containsbeandefinition(beanname)) {\n\t\t\t// not found -> check parent.\n\t\t\tstring nametolookup = originalbeanname(name);\n\t\t\tif (parentbeanfactory instanceof abstractbeanfactory) {\n\t\t\t\treturn ((abstractbeanfactory) parentbeanfactory).dogetbean(\n\t\t\t\t\t\tnametolookup, requiredtype, args, typecheckonly);\n\t\t\t}\n\t\t\telse if (args != null) {\n\t\t\t\t// delegation to parent with explicit args.\n\t\t\t\treturn (t) parentbeanfactory.getbean(nametolookup, args);\n\t\t\t}\n\t\t\telse if (requiredtype != null) {\n\t\t\t\t// no args -> delegate to standard getbean method.\n\t\t\t\treturn parentbeanfactory.getbean(nametolookup, requiredtype);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (t) parentbeanfactory.getbean(nametolookup);\n\t\t\t}\n\t\t}\n        //第三部分先判断并把需要创建的bean打上正在创建标记，\n        //也就是开头的if判断加markbeanascreated(beanname)方法\n        //（这样做的目的是在我创建这个bean之前就先打上创建标记，告诉其它来创建的线程，避免了重复创建，那么这个方法内部肯定是同步的）\n\t\tif (!typecheckonly) {\n\t\t\tmarkbeanascreated(beanname);\n\t\t}\n \n\t\ttry {\n\t\t\tfinal rootbeandefinition mbd = getmergedlocalbeandefinition(beanname);\n\t\t\tcheckmergedbeandefinition(mbd, beanname, args);\n \n\t\t\t// guarantee initialization of beans that the current bean depends on.\n\t\t\tstring[] dependson = mbd.getdependson();\n\t\t\tif (dependson != null) {\n\t\t\t\tfor (string dep : dependson) {\n\t\t\t\t\tif (isdependent(beanname, dep)) {\n\t\t\t\t\t\tthrow new beancreationexception(mbd.getresourcedescription(), beanname,\n\t\t\t\t\t\t\t\t"circular depends-on relationship between \'" + beanname + "\' and \'" + dep + "\'");\n\t\t\t\t\t}\n\t\t\t\t\tregisterdependentbean(dep, beanname);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tgetbean(dep);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (nosuchbeandefinitionexception ex) {\n\t\t\t\t\t\tthrow new beancreationexception(mbd.getresourcedescription(), beanname,\n\t\t\t\t\t\t\t\t"\'" + beanname + "\' depends on missing bean \'" + dep + "\'", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\t\t// create bean instance.\n\t\t\tif (mbd.issingleton()) {\n\t\t\t\tsharedinstance = getsingleton(beanname, () -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn createbean(beanname, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (beansexception ex) {\n\t\t\t\t\t\t// explicitly remove instance from singleton cache: it might have been put there\n\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t// also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\tdestroysingleton(beanname);\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbean = getobjectforbeaninstance(sharedinstance, name, beanname, mbd);\n\t\t\t}\n \n\t\t\telse if (mbd.isprototype()) {\n\t\t\t\t// it\'s a prototype -> create a new instance.\n\t\t\t\tobject prototypeinstance = null;\n\t\t\t\ttry {\n\t\t\t\t\tbeforeprototypecreation(beanname);\n\t\t\t\t\tprototypeinstance = createbean(beanname, mbd, args);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tafterprototypecreation(beanname);\n\t\t\t\t}\n\t\t\t\tbean = getobjectforbeaninstance(prototypeinstance, name, beanname, mbd);\n\t\t\t}\n \n\t\t\telse {\n\t\t\t\tstring scopename = mbd.getscope();\n\t\t\t\tfinal scope scope = this.scopes.get(scopename);\n\t\t\t\tif (scope == null) {\n\t\t\t\t\tthrow new illegalstateexception("no scope registered for scope name \'" + scopename + "\'");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tobject scopedinstance = scope.get(beanname, () -> {\n\t\t\t\t\t\tbeforeprototypecreation(beanname);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createbean(beanname, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tafterprototypecreation(beanname);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbean = getobjectforbeaninstance(scopedinstance, name, beanname, mbd);\n\t\t\t\t}\n\t\t\t\tcatch (illegalstateexception ex) {\n\t\t\t\t\tthrow new beancreationexception(beanname,\n\t\t\t\t\t\t\t"scope \'" + scopename + "\' is not active for the current thread; consider " +\n\t\t\t\t\t\t\t"defining a scoped proxy for this bean if you intend to refer to it from a singleton",\n\t\t\t\t\t\t\tex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (beansexception ex) {\n\t\t\tcleanupafterbeancreationfailure(beanname);\n\t\t\tthrow ex;\n\t\t}\n\t}\n \n\t// check if required type matches the type of the actual bean instance.\n\tif (requiredtype != null && !requiredtype.isinstance(bean)) {\n\t\ttry {\n\t\t\tt convertedbean = gettypeconverter().convertifnecessary(bean, requiredtype);\n\t\t\tif (convertedbean == null) {\n\t\t\t\tthrow new beannotofrequiredtypeexception(name, requiredtype, bean.getclass());\n\t\t\t}\n\t\t\treturn convertedbean;\n\t\t}\n\t\tcatch (typemismatchexception ex) {\n\t\t\tif (logger.istraceenabled()) {\n\t\t\t\tlogger.trace("failed to convert bean \'" + name + "\' to required type \'" +\n\t\t\t\t\t\tclassutils.getqualifiedname(requiredtype) + "\'", ex);\n\t\t\t}\n\t\t\tthrow new beannotofrequiredtypeexception(name, requiredtype, bean.getclass());\n\t\t}\n\t}\n\treturn (t) bean;\n}\n\n\n不知道小伙伴能否在这里体会到反射的思想呢\n\n\n# 5.14 finishrefresh()\n\n最后进行一些收尾工作\n\nprotected void finishrefresh() {\n\t// clear context-level resource caches (such as asm metadata from scanning).\n\tclearresourcecaches();\n \n\t// initialize lifecycle processor for this context.\n\tinitlifecycleprocessor();\n \n\t// propagate refresh to lifecycle processor first.\n\tgetlifecycleprocessor().onrefresh();\n \n\t// publish the final event.\n\tpublishevent(new contextrefreshedevent(this));\n \n\t// participate in livebeansview mbean, if active.\n\tlivebeansview.registerapplicationcontext(this);\n}\n\n\n\n# 总结\n\n\n# 源码分析中比较重要的类有\n\napplicationcontet（主要的容器，串联流程）\n\nenvironment（可以判断环境的有效性）\n\nbeanpostprocessor（用于bean实例化前后的扩展）\n\nbeanfactory（最顶层的一个接口）\n\nfactorybean（也是用来更好的扩展，他也就有三个方法）\n\nbeanfactorypostporcessor（用来工厂后来的扩展）\n\nbeandefinitionreader（读取前面的一些信息）\n\nclasspathxmlapplicationcontext（读取总的配置文件）\n\ncontextloaderlistener与它的父类contextloader（spring的入口）\n\n\n# 参考\n\n1.https://blog.csdn.net/spring_live_in/article/details/101059038\n\n2.https://blog.csdn.net/sinat_38259539/article/details/71799078?utm_medium=distribute.pc_relevant.none-task-blog-blogcommendfrombaidu-4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-blogcommendfrombaidu-4\n\n3.https://liteyu.blog.csdn.net/article/details/105754312\n\n4.https://blog.csdn.net/v123411739/article/details/87741251',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"API网关概述",frontmatter:{title:"API网关概述",date:"2022-04-16T00:00:00.000Z",tags:["分布式","网关"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html",relativePath:"views/backend/API网关概述.md",key:"v-1c8f87f8",path:"/views/backend/API%E7%BD%91%E5%85%B3%E6%A6%82%E8%BF%B0.html",headers:[{level:2,title:"何为API网关",slug:"何为api网关",normalizedTitle:"何为api网关",charIndex:94},{level:2,title:"API网关架构",slug:"api网关架构",normalizedTitle:"api网关架构",charIndex:105},{level:2,title:"Gateway核心设计",slug:"gateway核心设计",normalizedTitle:"gateway核心设计",charIndex:116},{level:2,title:"API网关基本功能",slug:"api网关基本功能",normalizedTitle:"api网关基本功能",charIndex:131},{level:2,title:"插件列表",slug:"插件列表",normalizedTitle:"插件列表",charIndex:144},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:152}],excerpt:"<Boxx/>\n<p>API网关是一个聚合多个不同API的统一出口，同时对API进行流量控制/统计、身份校验、报文转换等操作。</p>\n<p>API网关和API的区别主要在于一个是聚合工具，一个是实际干活的。</p>\n",headersStr:"何为API网关 API网关架构 Gateway核心设计 API网关基本功能 插件列表 参考",content:"API网关是一个聚合多个不同API的统一出口，同时对API进行流量控制/统计、身份校验、报文转换等操作。\n\nAPI网关和API的区别主要在于一个是聚合工具，一个是实际干活的。\n\n\n\n * 何为API网关\n * API网关架构\n * Gateway核心设计\n * API网关基本功能\n * 插件列表\n * 参考\n\n\n\n\n# 何为API网关\n\n\n\n根据目前所在的自研网关架构项目组，简单点举个例子：\n\n * API网关地址 https://www.znote.openapi.com\n\n * 有3个API：\n   \n   a. 订单接口 https://www.aaa.com/aaaOrder\n   b. 商品接口 https://www.bbb.com/bbbGoods\n   c. 促销接口 https://www.ccc.com/cccPromotion\n   \n\n未接入API网关前：系统需要暴露 a、b、c 3个接口地址，客户方调用\n\n接入API网关后：系统只需暴露网关地址 https://www.znote.openapi.com 即可，客户方根据SDK调用不同接口，同时API网关还可对已接入的API进行参数转换、流控、权限、监控等一系列管理操作。\n\n看到上面的图示与描述，我们可能会想到另外一个与网关类似的东西——代理。网关与代理的区别：代理是纯粹的数据透传，协议不会发生变化；网关在数据透传的背景下，还会设计协议的转换，比如上图中用户请求传输到网关的协议是HTTP，通过网关透传到下游则可能已经转换成企业内部的RPC了（比如JSF、Dubbo等企业自研的RPC框架）。\n\n\n# API网关架构\n\n在一个大型微服务网络中，大概架构分为几层：\n\n 1. 渠道层 接受客户端请求和各种协议等\n 2. 场景层 是否直连，是否走F5，是否走网关\n 3. 接入层 f5，安全网关，API网关等\n 4. 集成层 集中管理，rpc远程调用\n 5. 服务层 各业务逻辑分页、缓存等\n 6. 产品层 各服务分片\n\nAPI网关处于接入层角色，具有承上启下的作用，承担着报文转换、参数处理、协议适配、权限管理、监控告警等一系列重要角色信息。\n\n内部网关架构不宜分享，但以开源的 Soul 网关为例：\n\n\n\n涵盖有：Admin管理中心、zk配置中心和Gateway三部分组成。\n\n * Admin管理中心：统一管理接入API网关的接口\n\n * zk配置中心：经Admin管理中心配置好数据后，由zk负责完成网关的同步信息，保证网关的高可用，承担着网关数据源的角色\n\n * Gateway：由Netty实现，基于异步的、事件驱动的、高性能、高并发解决方案\n\n\n# Gateway核心设计\n\nAPI网关基本请求流程：\n\n 1. 确定API映射关系和参数协议报文等要素，通过Admin管理中心接入API网关\n 2. 在Admin管理中心对接口进行场景绑定、应用绑定、授权上线同步zk配置中心，接入网关\n 3. API网关下发SDK和公私钥、APP_ID等文件，客户方引入SDK加密加签调用相应接口\n 4. 给客户方开通权限，客户方联调，上送请求报文，请求报文流转于Gateway中\n\n\n\nGateway基于Netty Pipeline Handler的处理模式，以 过滤链 + 插件化 的方式将请求流转于Gateway，进一步对请求进行解密验签、参数转换、限流熔断、权限过滤等不同功能处理。\n\n同时可针对不同场景、不同功能做出不同的定制化插件开发。\n\n\n# API网关基本功能\n\nAPI管理：基于Admin管理中心进行接口的配置、上线、关系绑定等。\n\n参数处理：基于Admin管理中心对参数进行映射处理（如将真实入参requestId暴露为req_id）；对参数进行动态绑定、对参数进行合理化输出等。\n\n动态配置：基于Admin管理中心对接口进行系统化操作后，基于zk配置中心实现热部署式接口上线、更新、发布等操作。\n\n定制化插件：Gateway支持通过插件的形式对网关请求做出不同功能。\n\n\n# 插件列表\n\n请求头转换插件：可对请求头和响应头进行配置化定制\n\n鉴权配置插件：支持JWT和OAUTH2鉴权和自定义Jar鉴权\n\n限流配置插件：使用分布式令牌桶的形式对每个服务进行差别化限流\n\n熔断降级配置插件：使用resilience4j来进行熔断降级，如果后端服务有异常处理，可以进行降级\n\n请求报文校验插件：采用json schema对报文体或部分报文体的格式校验\n\nGroovy脚本插件：可动态在调用链中插入一段java脚本，来执行需要的逻辑\n\nMock插件：mock请求结果，配置该插件后，请求不会再转发给后端服务，根据配置好的freemarker模板直接响应给调用方\n\nRpc路由转换插件：配置将http请求转化为dubbo请求时需要的参数，如服务名，参数转化逻辑\n\nUrl重写插件：该插件可对Tesla请求到后端的url进行差异化配置，支持直接转发和占位符转发\n\n创建token插件：可根据响应报文内容抽取参数后生成JWT\n\n执行上传jar包插件：如果有特殊化的功能，当前插件体系无法满足时，可以使用该插件自己编写逻辑\n\n查询聚合插件：该插件可实现调用方一次查询，聚合多个后端接口数据的效果\n\n消除鉴权插件：该插件用于当API的鉴权类型不是开放时，但个别endpoint不希望鉴权时使用，如/login，/logout等\n\n缓存结果插件：该插件可根据配置缓存请求结果\n\n请求报文转换插件：该插件根据配置的freemarker脚本对请求体和响应体的报文进行转换\n\n支持自定义插件。\n\n\n# 参考\n\nhttps://gitee.com/mirrors/soul\n\nhttps://github.com/jiangjunwei/tesla\n\nhttps://www.jianshu.com/p/7baab672b822",normalizedContent:"api网关是一个聚合多个不同api的统一出口，同时对api进行流量控制/统计、身份校验、报文转换等操作。\n\napi网关和api的区别主要在于一个是聚合工具，一个是实际干活的。\n\n\n\n * 何为api网关\n * api网关架构\n * gateway核心设计\n * api网关基本功能\n * 插件列表\n * 参考\n\n\n\n\n# 何为api网关\n\n\n\n根据目前所在的自研网关架构项目组，简单点举个例子：\n\n * api网关地址 https://www.znote.openapi.com\n\n * 有3个api：\n   \n   a. 订单接口 https://www.aaa.com/aaaorder\n   b. 商品接口 https://www.bbb.com/bbbgoods\n   c. 促销接口 https://www.ccc.com/cccpromotion\n   \n\n未接入api网关前：系统需要暴露 a、b、c 3个接口地址，客户方调用\n\n接入api网关后：系统只需暴露网关地址 https://www.znote.openapi.com 即可，客户方根据sdk调用不同接口，同时api网关还可对已接入的api进行参数转换、流控、权限、监控等一系列管理操作。\n\n看到上面的图示与描述，我们可能会想到另外一个与网关类似的东西——代理。网关与代理的区别：代理是纯粹的数据透传，协议不会发生变化；网关在数据透传的背景下，还会设计协议的转换，比如上图中用户请求传输到网关的协议是http，通过网关透传到下游则可能已经转换成企业内部的rpc了（比如jsf、dubbo等企业自研的rpc框架）。\n\n\n# api网关架构\n\n在一个大型微服务网络中，大概架构分为几层：\n\n 1. 渠道层 接受客户端请求和各种协议等\n 2. 场景层 是否直连，是否走f5，是否走网关\n 3. 接入层 f5，安全网关，api网关等\n 4. 集成层 集中管理，rpc远程调用\n 5. 服务层 各业务逻辑分页、缓存等\n 6. 产品层 各服务分片\n\napi网关处于接入层角色，具有承上启下的作用，承担着报文转换、参数处理、协议适配、权限管理、监控告警等一系列重要角色信息。\n\n内部网关架构不宜分享，但以开源的 soul 网关为例：\n\n\n\n涵盖有：admin管理中心、zk配置中心和gateway三部分组成。\n\n * admin管理中心：统一管理接入api网关的接口\n\n * zk配置中心：经admin管理中心配置好数据后，由zk负责完成网关的同步信息，保证网关的高可用，承担着网关数据源的角色\n\n * gateway：由netty实现，基于异步的、事件驱动的、高性能、高并发解决方案\n\n\n# gateway核心设计\n\napi网关基本请求流程：\n\n 1. 确定api映射关系和参数协议报文等要素，通过admin管理中心接入api网关\n 2. 在admin管理中心对接口进行场景绑定、应用绑定、授权上线同步zk配置中心，接入网关\n 3. api网关下发sdk和公私钥、app_id等文件，客户方引入sdk加密加签调用相应接口\n 4. 给客户方开通权限，客户方联调，上送请求报文，请求报文流转于gateway中\n\n\n\ngateway基于netty pipeline handler的处理模式，以 过滤链 + 插件化 的方式将请求流转于gateway，进一步对请求进行解密验签、参数转换、限流熔断、权限过滤等不同功能处理。\n\n同时可针对不同场景、不同功能做出不同的定制化插件开发。\n\n\n# api网关基本功能\n\napi管理：基于admin管理中心进行接口的配置、上线、关系绑定等。\n\n参数处理：基于admin管理中心对参数进行映射处理（如将真实入参requestid暴露为req_id）；对参数进行动态绑定、对参数进行合理化输出等。\n\n动态配置：基于admin管理中心对接口进行系统化操作后，基于zk配置中心实现热部署式接口上线、更新、发布等操作。\n\n定制化插件：gateway支持通过插件的形式对网关请求做出不同功能。\n\n\n# 插件列表\n\n请求头转换插件：可对请求头和响应头进行配置化定制\n\n鉴权配置插件：支持jwt和oauth2鉴权和自定义jar鉴权\n\n限流配置插件：使用分布式令牌桶的形式对每个服务进行差别化限流\n\n熔断降级配置插件：使用resilience4j来进行熔断降级，如果后端服务有异常处理，可以进行降级\n\n请求报文校验插件：采用json schema对报文体或部分报文体的格式校验\n\ngroovy脚本插件：可动态在调用链中插入一段java脚本，来执行需要的逻辑\n\nmock插件：mock请求结果，配置该插件后，请求不会再转发给后端服务，根据配置好的freemarker模板直接响应给调用方\n\nrpc路由转换插件：配置将http请求转化为dubbo请求时需要的参数，如服务名，参数转化逻辑\n\nurl重写插件：该插件可对tesla请求到后端的url进行差异化配置，支持直接转发和占位符转发\n\n创建token插件：可根据响应报文内容抽取参数后生成jwt\n\n执行上传jar包插件：如果有特殊化的功能，当前插件体系无法满足时，可以使用该插件自己编写逻辑\n\n查询聚合插件：该插件可实现调用方一次查询，聚合多个后端接口数据的效果\n\n消除鉴权插件：该插件用于当api的鉴权类型不是开放时，但个别endpoint不希望鉴权时使用，如/login，/logout等\n\n缓存结果插件：该插件可根据配置缓存请求结果\n\n请求报文转换插件：该插件根据配置的freemarker脚本对请求体和响应体的报文进行转换\n\n支持自定义插件。\n\n\n# 参考\n\nhttps://gitee.com/mirrors/soul\n\nhttps://github.com/jiangjunwei/tesla\n\nhttps://www.jianshu.com/p/7baab672b822",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"线程池 - 进阶",frontmatter:{title:"线程池 - 进阶",date:"2020-03-03T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/ThreadPool.html",relativePath:"views/backend/ThreadPool.md",key:"v-a3d48a82",path:"/views/backend/ThreadPool.html",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:3},{level:2,title:"初识Executors",slug:"初识executors",normalizedTitle:"初识executors",charIndex:9},{level:2,title:"步入ThreadPoolExecutor",slug:"步入threadpoolexecutor",normalizedTitle:"步入threadpoolexecutor",charIndex:24},{level:3,title:"handler拒绝策略",slug:"handler拒绝策略",normalizedTitle:"handler拒绝策略",charIndex:50},{level:3,title:"workQueue任务队列",slug:"workqueue任务队列",normalizedTitle:"workqueue任务队列",charIndex:67},{level:2,title:"线程池的工作顺序",slug:"线程池的工作顺序",normalizedTitle:"线程池的工作顺序",charIndex:84},{level:2,title:"Executors弊端",slug:"executors弊端",normalizedTitle:"executors弊端",charIndex:96},{level:2,title:"正确的使用线程池",slug:"正确的使用线程池",normalizedTitle:"正确的使用线程池",charIndex:111},{level:3,title:"线程超时时间",slug:"线程超时时间",normalizedTitle:"线程超时时间",charIndex:125}],headersStr:"前言 初识Executors 步入ThreadPoolExecutor handler拒绝策略 workQueue任务队列 线程池的工作顺序 Executors弊端 正确的使用线程池 线程超时时间",content:' * 前言\n * 初识Executors\n * 步入ThreadPoolExecutor\n   * handler拒绝策略\n   * workQueue任务队列\n * 线程池的工作顺序\n * Executors弊端\n * 正确的使用线程池\n   * 线程超时时间\n\n\n\n\n# 前言\n\n * Java中创建线程池很简单，Java提供了 Executors 这个强大的线程池工具类，我们创造线程池只需调用某个方法即可，比如Executors.newFixedThreadPool(int nThreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。\n\n * 而强大的 Executors 在创建线程池时，也只是依赖ThreadPoolExecutor类，修改其中几个方法参数而已。\n\n * 同时，在阿里规范中也明确【强制】指出 通过 ThreadPoolExecutor 创建线程池。\n   \n   1. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 正例：\n   \n   public class TimerTaskThread extends Thread {\n       public TimerTaskThread(){\n           super.setName("TimerTaskThread"); \n           ...\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   2. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。\n   \n   3. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n\n# 初识Executors\n\n1. Executors.newCachedThreadPool(); 说明: 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程. 内部实现：\n\n// 无界线程池\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2. Executors.newFixedThreadPool(int); 说明: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 内部实现：\n\n// 固定大小线程池\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n3. Executors.newSingleThreadExecutor(); 说明:创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照顺序执行。 内部实现：\n\n// 单个后台线程\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n4. Executors.newScheduledThreadPool(int); 说明:创建一个定长线程池，支持定时及周期性任务执行。 内部实现：\n\nnew ScheduledThreadPoolExecutor(corePoolSize)\n\n\n1\n\n\n\n# 步入ThreadPoolExecutor\n\n * 核心参数\n\n// Java线程池的完整构造函数\npublic ThreadPoolExecutor(\n  int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。\n  int maximumPoolSize, // 线程数的上限\n  long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，\n                                     // 时长的单位\n  BlockingQueue<Runnable> workQueue, // 任务的排队队列\n  ThreadFactory threadFactory, // 新线程的产生方式\n  RejectedExecutionHandler handler) // 拒绝策略\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n参数                说明\ncorePoolSize      核心线程数量，线程池维护线程的最少数量\nmaximumPoolSize   线程池维护线程的最大数量\nkeepAliveTime     线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁\nunit              keepAliveTime的单位，TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS\nworkQueue         线程池所使用的任务缓冲队列\nthreadFactory     线程工厂，用于创建线程，一般用默认的即可\nhandler           线程池对拒绝任务的处理策略\n\n\n# handler拒绝策略\n\n当线程池任务处理不过来的时候，可以通过handler指定的策略进行处理，ThreadPoolExecutor提供了四种策略：\n\n 1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常；也是默认的处理方式。\n 2. ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。\n 3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。\n 4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务\n\n可以通过实现RejectedExecutionHandler接口自定义处理方式。\n\n\n# workQueue任务队列\n\n 1. ArrayBlockingQueue： 这是一个由数组实现的容量固定的有界阻塞队列。\n 2. SynchronousQueue： 没有容量，不能缓存数据；每个put必须等待一个take; offer()的时候如果没有另一个线程在poll()或者take()的话返回false。\n 3. LinkedBlockingQueue： 这是一个由单链表实现的默认×××的阻塞队列。LinkedBlockingQueue提供了一个可选有界的构造函数，而在未指明容量时，容量默认为Integer.MAX_VALUE。\n\n\n# 线程池的工作顺序\n\n * corePoolSize -> workQueue 任务队列 -> maximumPoolSize -> handler 拒绝策略\n   \n   跟银行类似：有2个窗口（corePoolSize）办理业务，有人来了就先到候客区（workQueue）等着，候客区如果满了就再多开几个窗口（maximumPoolSize）办理业务，如果候客区和能开的窗口都满了，那保安就拒绝（handler）别人再进入银行。业务办理的差不多了，多开的窗口等待一定时间（keepAliveTime ）还没有人办理业务，那就把它关了吧浪费。\n\n\n# Executors弊端\n\n 1. FixedThreadPool 和 SingleThreadPool:\n    \n    允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n\n 2. CachedThreadPool 和 ScheduledThreadPool:\n    \n    允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。\n\n\n# 正确的使用线程池\n\n// 返回可用处理器的Java虚拟机的数量(获取本机cpu核心数)\nint poolSize = Runtime.getRuntime().availableProcessors() * 2;\n// 使用有界队列，避免OOM\nBlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(512);\n// 指定拒绝策略\nRejectedExecutionHandler policy = new ThreadPoolExecutor.DiscardPolicy();\n\n//自定义的线程池\nExecutorService executorService = new ThreadPoolExecutor(poolSize, poolSize,\n    0, TimeUnit.SECONDS,queue,policy);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 线程超时时间\n\n * 单个任务的超时时间\n\nV Future.get(long timeout, TimeUnit unit)方法可以指定等待的超时时间，超时未完成会抛出TimeoutException。\n\n * 多个任务的超时时间\n\n等待多个任务完成，并设置最大等待时间，可以通过CountDownLatch完成：\n\npublic void testLatch(ExecutorService executorService, List<Runnable> tasks) \n    throws InterruptedException{\n      \n    CountDownLatch latch = new CountDownLatch(tasks.size());\n      for(Runnable r : tasks){\n          executorService.submit(new Runnable() {\n              @Override\n              public void run() {\n                  try{\n                      r.run();\n                  }finally {\n                      latch.countDown();// countDown\n                  }\n              }\n          });\n      }\n      latch.await(10, TimeUnit.SECONDS); // 指定超时时间\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:' * 前言\n * 初识executors\n * 步入threadpoolexecutor\n   * handler拒绝策略\n   * workqueue任务队列\n * 线程池的工作顺序\n * executors弊端\n * 正确的使用线程池\n   * 线程超时时间\n\n\n\n\n# 前言\n\n * java中创建线程池很简单，java提供了 executors 这个强大的线程池工具类，我们创造线程池只需调用某个方法即可，比如executors.newfixedthreadpool(int nthreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（oom，线程耗尽）。\n\n * 而强大的 executors 在创建线程池时，也只是依赖threadpoolexecutor类，修改其中几个方法参数而已。\n\n * 同时，在阿里规范中也明确【强制】指出 通过 threadpoolexecutor 创建线程池。\n   \n   1. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 正例：\n   \n   public class timertaskthread extends thread {\n       public timertaskthread(){\n           super.setname("timertaskthread"); \n           ...\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   2. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。\n   \n   3. 【强制】线程池不允许使用 executors 去创建，而是通过 threadpoolexecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n\n# 初识executors\n\n1. executors.newcachedthreadpool(); 说明: 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程. 内部实现：\n\n// 无界线程池\npublic static executorservice newcachedthreadpool() {\n    return new threadpoolexecutor(0, integer.max_value,\n                                  60l, timeunit.seconds,\n                                  new synchronousqueue<runnable>());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n2. executors.newfixedthreadpool(int); 说明: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 内部实现：\n\n// 固定大小线程池\npublic static executorservice newfixedthreadpool(int nthreads) {\n    return new threadpoolexecutor(nthreads, nthreads,\n                                  0l, timeunit.milliseconds,\n                                  new linkedblockingqueue<runnable>());\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n3. executors.newsinglethreadexecutor(); 说明:创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照顺序执行。 内部实现：\n\n// 单个后台线程\npublic static executorservice newsinglethreadexecutor() {\n    return new finalizabledelegatedexecutorservice\n        (new threadpoolexecutor(1, 1,\n                                0l, timeunit.milliseconds,\n                                new linkedblockingqueue<runnable>()));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n4. executors.newscheduledthreadpool(int); 说明:创建一个定长线程池，支持定时及周期性任务执行。 内部实现：\n\nnew scheduledthreadpoolexecutor(corepoolsize)\n\n\n1\n\n\n\n# 步入threadpoolexecutor\n\n * 核心参数\n\n// java线程池的完整构造函数\npublic threadpoolexecutor(\n  int corepoolsize, // 线程池长期维持的线程数，即使线程处于idle状态，也不会回收。\n  int maximumpoolsize, // 线程数的上限\n  long keepalivetime, timeunit unit, // 超过corepoolsize的线程的idle时长，\n                                     // 时长的单位\n  blockingqueue<runnable> workqueue, // 任务的排队队列\n  threadfactory threadfactory, // 新线程的产生方式\n  rejectedexecutionhandler handler) // 拒绝策略\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n参数                说明\ncorepoolsize      核心线程数量，线程池维护线程的最少数量\nmaximumpoolsize   线程池维护线程的最大数量\nkeepalivetime     线程池除核心线程外的其他线程的最长空闲时间，超过该时间的空闲线程会被销毁\nunit              keepalivetime的单位，timeunit中的几个静态属性：nanoseconds、microseconds、milliseconds、seconds\nworkqueue         线程池所使用的任务缓冲队列\nthreadfactory     线程工厂，用于创建线程，一般用默认的即可\nhandler           线程池对拒绝任务的处理策略\n\n\n# handler拒绝策略\n\n当线程池任务处理不过来的时候，可以通过handler指定的策略进行处理，threadpoolexecutor提供了四种策略：\n\n 1. threadpoolexecutor.abortpolicy:丢弃任务并抛出rejectedexecutionexception异常；也是默认的处理方式。\n 2. threadpoolexecutor.discardpolicy：丢弃任务，但是不抛出异常。\n 3. threadpoolexecutor.discardoldestpolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。\n 4. threadpoolexecutor.callerrunspolicy：由调用线程处理该任务\n\n可以通过实现rejectedexecutionhandler接口自定义处理方式。\n\n\n# workqueue任务队列\n\n 1. arrayblockingqueue： 这是一个由数组实现的容量固定的有界阻塞队列。\n 2. synchronousqueue： 没有容量，不能缓存数据；每个put必须等待一个take; offer()的时候如果没有另一个线程在poll()或者take()的话返回false。\n 3. linkedblockingqueue： 这是一个由单链表实现的默认×××的阻塞队列。linkedblockingqueue提供了一个可选有界的构造函数，而在未指明容量时，容量默认为integer.max_value。\n\n\n# 线程池的工作顺序\n\n * corepoolsize -> workqueue 任务队列 -> maximumpoolsize -> handler 拒绝策略\n   \n   跟银行类似：有2个窗口（corepoolsize）办理业务，有人来了就先到候客区（workqueue）等着，候客区如果满了就再多开几个窗口（maximumpoolsize）办理业务，如果候客区和能开的窗口都满了，那保安就拒绝（handler）别人再进入银行。业务办理的差不多了，多开的窗口等待一定时间（keepalivetime ）还没有人办理业务，那就把它关了吧浪费。\n\n\n# executors弊端\n\n 1. fixedthreadpool 和 singlethreadpool:\n    \n    允许的请求队列长度为 integer.max_value，可能会堆积大量的请求，从而导致 oom。\n\n 2. cachedthreadpool 和 scheduledthreadpool:\n    \n    允许的创建线程数量为 integer.max_value， 可能会创建大量的线程，从而导致 oom。\n\n\n# 正确的使用线程池\n\n// 返回可用处理器的java虚拟机的数量(获取本机cpu核心数)\nint poolsize = runtime.getruntime().availableprocessors() * 2;\n// 使用有界队列，避免oom\nblockingqueue<runnable> queue = new arrayblockingqueue<>(512);\n// 指定拒绝策略\nrejectedexecutionhandler policy = new threadpoolexecutor.discardpolicy();\n\n//自定义的线程池\nexecutorservice executorservice = new threadpoolexecutor(poolsize, poolsize,\n    0, timeunit.seconds,queue,policy);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 线程超时时间\n\n * 单个任务的超时时间\n\nv future.get(long timeout, timeunit unit)方法可以指定等待的超时时间，超时未完成会抛出timeoutexception。\n\n * 多个任务的超时时间\n\n等待多个任务完成，并设置最大等待时间，可以通过countdownlatch完成：\n\npublic void testlatch(executorservice executorservice, list<runnable> tasks) \n    throws interruptedexception{\n      \n    countdownlatch latch = new countdownlatch(tasks.size());\n      for(runnable r : tasks){\n          executorservice.submit(new runnable() {\n              @override\n              public void run() {\n                  try{\n                      r.run();\n                  }finally {\n                      latch.countdown();// countdown\n                  }\n              }\n          });\n      }\n      latch.await(10, timeunit.seconds); // 指定超时时间\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"线程池 - 动态调节参数",frontmatter:{title:"线程池 - 动态调节参数",date:"2021-11-24T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/ThreadPool2.html",relativePath:"views/backend/ThreadPool2.md",key:"v-6dc818d2",path:"/views/backend/ThreadPool2.html",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:144},{level:2,title:"线程池任务调度机制",slug:"线程池任务调度机制",normalizedTitle:"线程池任务调度机制",charIndex:150},{level:2,title:"动态调节线程池参数实现",slug:"动态调节线程池参数实现",normalizedTitle:"动态调节线程池参数实现",charIndex:163},{level:3,title:"调节核心和最大线程数的原理",slug:"调节核心和最大线程数的原理",normalizedTitle:"调节核心和最大线程数的原理",charIndex:180},{level:3,title:"调节工作队列大小的原理",slug:"调节工作队列大小的原理",normalizedTitle:"调节工作队列大小的原理",charIndex:199},{level:2,title:"这个过程中涉及到的面试题有哪些？",slug:"这个过程中涉及到的面试题有哪些",normalizedTitle:"这个过程中涉及到的面试题有哪些？",charIndex:214},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:234}],excerpt:"<Boxx/>\n<p>线程池是一种基于池化思想管理线程的工具，使用线程池可以减少创建销毁线程的开销，避免线程过多导致系统资源耗尽。在高并发的任务处理场景，线程池的使用是必不可少的。在双11主项目中为了提升处理性能，很多地方使用到了线程池。随着线程池的使用，逐渐发现一个问题，线程池的参数如何设置？</p>\n",headersStr:"背景 线程池任务调度机制 动态调节线程池参数实现 调节核心和最大线程数的原理 调节工作队列大小的原理 这个过程中涉及到的面试题有哪些？ 参考",content:"线程池是一种基于池化思想管理线程的工具，使用线程池可以减少创建销毁线程的开销，避免线程过多导致系统资源耗尽。在高并发的任务处理场景，线程池的使用是必不可少的。在双11主项目中为了提升处理性能，很多地方使用到了线程池。随着线程池的使用，逐渐发现一个问题，线程池的参数如何设置？\n\n\n\n * 背景\n * 线程池任务调度机制\n * 动态调节线程池参数实现\n   * 调节核心和最大线程数的原理\n   * 调节工作队列大小的原理\n * 这个过程中涉及到的面试题有哪些？\n * 参考\n\n\n\n\n# 背景\n\n根据任务的类型，线程池可以区分为IO密集型和CPU密集型，对于CPU密集型，一般经验是设置corePoolSize=CPU核数+1，对于IO密集型需要根据具体的RT和流量来设置，没有普适的经验值。然而，我们一般遇到的情况多数是处理IO密集型任务，如果线程池参数不可动态调节，就没办法根据实际情况实时调整处理速度，只能通过发布代码调整参数。\n\n如果线程池参数不合理会导致什么问题呢？下面列举几种可能出现的场景：最大线程数设置偏小，工作队列大小设置偏小，导致服务接口大量抛出RejectedExecutionException。\n\n最大线程数设置偏小，工作队列大小设置过大，任务堆积过度，接口响应时长变长。\n\n最大线程数设置过大，线程调度开销增大，处理速度反而下降。\n\n核心线程数设置过小，流量突增时需要先创建线程，导致响应时长过大。\n\n核心线程数设置过大，空闲线程太多，占用系统资源。\n\n\n# 线程池任务调度机制\n\n要明白线程池参数对运行时的影响，就必须理解其中的原理，所以下面先简单总结了线程池的核心原理。\n\nJava中的线程池核心实现类是ThreadPoolExecutor，ThreadPoolExecutor一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。\n\nThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\n\n\n\n所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。\n\n如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。\n\n如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\n\n如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\n\n如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n线程池参数中有几个比较关键的参数，分别是：\n\n 1. corePoolSize：核心线程数大小，不管它们创建以后是不是空闲的。线程池需要保持 corePoolSize 数量的线程，除非设置了 allowCoreThreadTimeOut；\n 2. maximumPoolSize：最大线程数，线程池中最多允许创建 maximumPoolSize 个线程;\n 3. keepAliveTime：存活时间，如果经过 keepAliveTime 时间后，超过核心线程数的线程还没有接受到新的任务，那就回收;\n 4. unit： keepAliveTime 的时间单位;\n 5. workQueue：存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被 execute 方法提交的 Runnable 任务; 目前JDK提供了以下阻塞队列的实现：\n\n\n\n 6. threadFactory：线程工厂，用来创建线程工厂。比如这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼；\n 7. handler ：拒绝策略，当队列里面放满了任务、最大线程数的线程都在工作时，这时继续提交的任务线程池就处理不了，应该执行怎么样的拒绝策略；\n\n\n\n\n# 动态调节线程池参数实现\n\n线程池相关的重要参数有三个，分别是核心线程数、最大线程数和工作队列大小，接下来将阐述如何实现动态调节线程池参数。\n\n\n# 调节核心和最大线程数的原理\n\nThreadPoolExecutor已经提供了两个方法在运行时设置核心线程数和最大线程数，分别是ThreadPoolExecutor.setCorePoolSize()和ThreadPoolExecutor.setMaximumPoolSize()。\n\nsetCorePoolSize方法的执行流程是：首先会覆盖之前构造函数设置的corePoolSize，然后，如果新的值比原始值要小，当多余的工作线程下次变成空闲状态的时候会被中断并销毁，如果新的值比原来的值要大且工作队列不为空，则会创建新的工作线程。流程图如下：\n\nsetMaximumPoolSize方法执行流程是：首先会覆盖之前构造函数设置的maximumPoolSize，然后，如果新的值比原来的值要小，当多余的工作线程下次变成空闲状态的时候会被中断并销毁。\n\n代码设置：\n\n\n\n\n# 调节工作队列大小的原理\n\n线程池中是以生产者消费者模式，通过一个阻塞队列来缓存任务，工作线程从阻塞队列中获取任务。工作队列的接口是阻塞队列(BlockingQueue)，在队列为空时，获取元素的线程会等待队列变为非空，当队列满时，存储元素的线程会等待队列可用。\n\n目前JDK提供了以下阻塞队列的实现：\n\n\n\n但是很不幸，这些阻塞队列的实现都不支持动态调整大小，那么为什么不自己实现一个可动态调整大小的阻塞队列呢。重复造轮子是不可取的，所以选择改造轮子。LinkedBlockingQueue是比较常用的一个阻塞队列，它无法修改大小的原因是capacity字段设置成了final private final int capacity;。如果把final去掉，并提供修改capacity的方法，是不是就满足我们的需求呢？事实证明是可行的。\n\n所以要想动态修改只能自己实现一个BlockingQueue，然后capacity可以动态修改即可；复制一个LinkedBlockingQueue源码，将capacity的final修饰去掉，添加set方法，保存为ResizableCapacityLinkedBlockingQueue.java即可，然后使用ResizableCapacityLinkedBlockingQueue作为任务队列；\n\n\n\n\n# 这个过程中涉及到的面试题有哪些？\n\n问题一：线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？\n\n答：线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法：\n\nprestartCoreThread()和prestartAllCoreThreads()\n\n问题二：核心线程数会被回收吗？需要什么设置？\n\n答：核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：allowCoreThreadTimeOut();\n\n\n# 参考\n\nJava-线程池动态修改大小\n\njava动态线程池_可动态调节参数的线程池实现",normalizedContent:"线程池是一种基于池化思想管理线程的工具，使用线程池可以减少创建销毁线程的开销，避免线程过多导致系统资源耗尽。在高并发的任务处理场景，线程池的使用是必不可少的。在双11主项目中为了提升处理性能，很多地方使用到了线程池。随着线程池的使用，逐渐发现一个问题，线程池的参数如何设置？\n\n\n\n * 背景\n * 线程池任务调度机制\n * 动态调节线程池参数实现\n   * 调节核心和最大线程数的原理\n   * 调节工作队列大小的原理\n * 这个过程中涉及到的面试题有哪些？\n * 参考\n\n\n\n\n# 背景\n\n根据任务的类型，线程池可以区分为io密集型和cpu密集型，对于cpu密集型，一般经验是设置corepoolsize=cpu核数+1，对于io密集型需要根据具体的rt和流量来设置，没有普适的经验值。然而，我们一般遇到的情况多数是处理io密集型任务，如果线程池参数不可动态调节，就没办法根据实际情况实时调整处理速度，只能通过发布代码调整参数。\n\n如果线程池参数不合理会导致什么问题呢？下面列举几种可能出现的场景：最大线程数设置偏小，工作队列大小设置偏小，导致服务接口大量抛出rejectedexecutionexception。\n\n最大线程数设置偏小，工作队列大小设置过大，任务堆积过度，接口响应时长变长。\n\n最大线程数设置过大，线程调度开销增大，处理速度反而下降。\n\n核心线程数设置过小，流量突增时需要先创建线程，导致响应时长过大。\n\n核心线程数设置过大，空闲线程太多，占用系统资源。\n\n\n# 线程池任务调度机制\n\n要明白线程池参数对运行时的影响，就必须理解其中的原理，所以下面先简单总结了线程池的核心原理。\n\njava中的线程池核心实现类是threadpoolexecutor，threadpoolexecutor一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供runnable对象，将任务的运行逻辑提交到执行器(executor)中，由executor框架完成线程的调配和任务的执行部分。\n\nthreadpoolexecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\n\n\n\n所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：首先检测线程池运行状态，如果不是running，则直接拒绝，线程池要保证在running的状态下执行任务。\n\n如果workercount < corepoolsize，则创建并启动一个线程来执行新提交的任务。\n\n如果workercount >= corepoolsize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\n\n如果workercount >= corepoolsize && workercount < maximumpoolsize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\n\n如果workercount >= maximumpoolsize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n线程池参数中有几个比较关键的参数，分别是：\n\n 1. corepoolsize：核心线程数大小，不管它们创建以后是不是空闲的。线程池需要保持 corepoolsize 数量的线程，除非设置了 allowcorethreadtimeout；\n 2. maximumpoolsize：最大线程数，线程池中最多允许创建 maximumpoolsize 个线程;\n 3. keepalivetime：存活时间，如果经过 keepalivetime 时间后，超过核心线程数的线程还没有接受到新的任务，那就回收;\n 4. unit： keepalivetime 的时间单位;\n 5. workqueue：存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在这里。它仅仅用来存放被 execute 方法提交的 runnable 任务; 目前jdk提供了以下阻塞队列的实现：\n\n\n\n 6. threadfactory：线程工厂，用来创建线程工厂。比如这里面可以自定义线程名称，当进行虚拟机栈分析时，看着名字就知道这个线程是哪里来的，不会懵逼；\n 7. handler ：拒绝策略，当队列里面放满了任务、最大线程数的线程都在工作时，这时继续提交的任务线程池就处理不了，应该执行怎么样的拒绝策略；\n\n\n\n\n# 动态调节线程池参数实现\n\n线程池相关的重要参数有三个，分别是核心线程数、最大线程数和工作队列大小，接下来将阐述如何实现动态调节线程池参数。\n\n\n# 调节核心和最大线程数的原理\n\nthreadpoolexecutor已经提供了两个方法在运行时设置核心线程数和最大线程数，分别是threadpoolexecutor.setcorepoolsize()和threadpoolexecutor.setmaximumpoolsize()。\n\nsetcorepoolsize方法的执行流程是：首先会覆盖之前构造函数设置的corepoolsize，然后，如果新的值比原始值要小，当多余的工作线程下次变成空闲状态的时候会被中断并销毁，如果新的值比原来的值要大且工作队列不为空，则会创建新的工作线程。流程图如下：\n\nsetmaximumpoolsize方法执行流程是：首先会覆盖之前构造函数设置的maximumpoolsize，然后，如果新的值比原来的值要小，当多余的工作线程下次变成空闲状态的时候会被中断并销毁。\n\n代码设置：\n\n\n\n\n# 调节工作队列大小的原理\n\n线程池中是以生产者消费者模式，通过一个阻塞队列来缓存任务，工作线程从阻塞队列中获取任务。工作队列的接口是阻塞队列(blockingqueue)，在队列为空时，获取元素的线程会等待队列变为非空，当队列满时，存储元素的线程会等待队列可用。\n\n目前jdk提供了以下阻塞队列的实现：\n\n\n\n但是很不幸，这些阻塞队列的实现都不支持动态调整大小，那么为什么不自己实现一个可动态调整大小的阻塞队列呢。重复造轮子是不可取的，所以选择改造轮子。linkedblockingqueue是比较常用的一个阻塞队列，它无法修改大小的原因是capacity字段设置成了final private final int capacity;。如果把final去掉，并提供修改capacity的方法，是不是就满足我们的需求呢？事实证明是可行的。\n\n所以要想动态修改只能自己实现一个blockingqueue，然后capacity可以动态修改即可；复制一个linkedblockingqueue源码，将capacity的final修饰去掉，添加set方法，保存为resizablecapacitylinkedblockingqueue.java即可，然后使用resizablecapacitylinkedblockingqueue作为任务队列；\n\n\n\n\n# 这个过程中涉及到的面试题有哪些？\n\n问题一：线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？\n\n答：线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法：\n\nprestartcorethread()和prestartallcorethreads()\n\n问题二：核心线程数会被回收吗？需要什么设置？\n\n答：核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：allowcorethreadtimeout();\n\n\n# 参考\n\njava-线程池动态修改大小\n\njava动态线程池_可动态调节参数的线程池实现",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"找出某个Java进程中最耗费CPU的Java线程",frontmatter:{title:"找出某个Java进程中最耗费CPU的Java线程",date:"2021-12-06T00:00:00.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/ThreadTopCPU.html",relativePath:"views/backend/ThreadTopCPU.md",key:"v-cdecc45e",path:"/views/backend/ThreadTopCPU.html",headers:[{level:2,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:72},{level:2,title:"排查步骤",slug:"排查步骤",normalizedTitle:"排查步骤",charIndex:80},{level:3,title:"jps",slug:"jps",normalizedTitle:"jps",charIndex:90},{level:3,title:"jstack",slug:"jstack",normalizedTitle:"jstack",charIndex:53},{level:2,title:"其他问题排查",slug:"其他问题排查",normalizedTitle:"其他问题排查",charIndex:109},{level:2,title:"相关脚本",slug:"相关脚本",normalizedTitle:"相关脚本",charIndex:119}],excerpt:"<Boxx/>\n<p>找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有：ps、top、printf、jstack、grep。</p>\n",headersStr:"问题原因 排查步骤 jps jstack 其他问题排查 相关脚本",content:'找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有：ps、top、printf、jstack、grep。\n\n\n\n * 问题原因\n * 排查步骤\n   * jps\n   * jstack\n * 其他问题排查\n * 相关脚本\n\n\n\n\n# 问题原因\n\n现实企业级Java应用开发、维护中，有时候我们会碰到下面这些问题：\n\n * OutOfMemoryError，内存不足\n * 内存泄露\n * 线程死锁\n * 锁争用（Lock Contention）\n * Java进程消耗CPU过高 ......\n\n这些问题在日常开发、维护中可能被很多人忽视（比如有的人遇到上面的问题只是重启服务器或者调大内存，而不会深究问题根源），但能够理解并解决这些问题是Java程序员进阶的必备要求。\n\n\n# 排查步骤\n\n\n# jps\n\njps主要用来输出JVM中运行的进程状态信息。语法格式如下：\n\njps [options] [hostid]\n\n\n1\n\n\n如果不指定hostid就默认为当前主机或服务器。\n\n命令行参数选项说明如下：\n\n-q 不输出类名,Jar名和传入main方法的参数\n\n-m 输出传入main方法的参数\n\n-l 输出main类或Jar的全限名\n\n-v 输出传入JVM的参数\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n比如下面：\n\nroot@ubuntu:/# jps -m -l\n2458 org.artifactory.standalone.main.Main /usr/local/artifactory-2.2.5/etc/jetty.xml\n29920 com.sun.tools.hat.Main -port 9998 /tmp/dump.dat\n3149 org.apache.catalina.startup.Bootstrap start\n30972 sun.tools.jps.Jps -m -l\n8247 org.apache.catalina.startup.Bootstrap start\n25687 com.sun.tools.hat.Main -port 9999 dump.dat\n21711 mrf-center.jar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# jstack\n\njstack主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：\n\njstack [option] pid\njstack [option] executable core\njstack [option] [server-id@]remote-hostname-or-ip\n\n\n1\n2\n3\n\n\n命令行参数选项说明如下：\n\n# 会打印出额外的锁信息\n# 在发生死锁时可以用 jstack -l pid 来观察锁持有情况\n# -m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）\n-l long listings\n\n\n1\n2\n3\n4\n\n\njstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。\n\n下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。\n\n----------------------------------------\n\n第一步： 先找出Java进程ID，服务器上的Java应用名称为 wordcount.jar：\n\n[root@storm-master home] ps -ef | grep wordcount\nroot    2860  2547 13 02:09 pts/0  00:02:03 java -jar wordcount.jar /home/input 3 \n\n\n1\n2\n\n\n得到进程ID为 2860 。\n\n----------------------------------------\n\n第二步： 找出该进程内最耗费CPU的线程，可以使用如下3个命令，这里我们使用第3个命令得出如下结果：\n\n 1. ps -Lfp pid ： 即 ps -Lfp 2860\n\n 2. ps -mp pid -o THREAD, tid, time ：即 ps -mp 2860 -o THREAD,tid,time\n\n 3. top -Hp pid： 即 top -Hp 2860\n\n这里用第三个命令：top -Hp 2860\n\ntop -Hp 2860\n\n\n1\n\n\n输出如下：\n\n\n\nTIME列就是各个Java线程耗费的CPU时间，显然CPU时间最长的是ID为2968的线程，用\n\nprintf "%x\\n" 2968\n\n\n1\n\n\n得到2968的十六进制值为b98，下面会用到。\n\n----------------------------------------\n\n第三步： 终于轮到jstack上场了，它用来输出进程2860的堆栈信息，然后根据线程ID的十六进制值grep，如下：\n\n[root@storm-master home] jstack 2860 | grep b98 \n"SessionTracker" prio=10 tid=0x00007f55a44e4800 nid=0xb53 in Object.wait() [0x00007f558e06c000 \n\n\n1\n2\n\n\n可以看到CPU消耗在SessionTracker这个类的Object.wait()，于是就能很容易的定位到相关的代码了。\n\n当然，可以 jstack -l pid > /tmp/thread.txt 在导出的文件中搜索，就可以定位到具体的线程，类。\n\n----------------------------------------\n\n\n# 其他问题排查\n\n查看某进程及某线程占用 CPU 的例子\n\n * jps: 列出 java 进程,找到 pid.\n * pidstat -p pid -u 1 3 -u -t: 查看 pid 的进程所有线程的 cpu 使用情况.\n * jstack -l pid > /tmp/thread.txt: 导出指定 Java 应用的所有线程.\n\n然后查看 nid=xxx(即第二步里线程号的线程),即可定位到某段代码.\n\n查看某进程及某线程占用 IO 的例子\n\n * jps: 列出 java 进程,找到 pid.\n * pidstat -p pid -u 1 3 -d -t: 查看 pid 的进程所有线程的 IO 使用情况.\n * jstack -l pid > /tmp/thread.txt: 导出指定 Java 应用的所有线程.\n\n然后查看 nid=xxx(即第二步里线程号的线程),即可定位到某段代码.\n\n\n# 相关脚本\n\n 1. 阿里开源的 Arthas\n\n 2. 看了下有位大神提个 issue , 推荐了个自动化脚本, 亲测更好用点. 这样子就可以免去上面的一步一步地查找和计算了. 所以, 这里也直接引用这个工具, 有需要的可以用下.\n    show-busy-java-threads',normalizedContent:'找出某个java进程中最耗费cpu的java线程并定位堆栈信息，用到的命令有：ps、top、printf、jstack、grep。\n\n\n\n * 问题原因\n * 排查步骤\n   * jps\n   * jstack\n * 其他问题排查\n * 相关脚本\n\n\n\n\n# 问题原因\n\n现实企业级java应用开发、维护中，有时候我们会碰到下面这些问题：\n\n * outofmemoryerror，内存不足\n * 内存泄露\n * 线程死锁\n * 锁争用（lock contention）\n * java进程消耗cpu过高 ......\n\n这些问题在日常开发、维护中可能被很多人忽视（比如有的人遇到上面的问题只是重启服务器或者调大内存，而不会深究问题根源），但能够理解并解决这些问题是java程序员进阶的必备要求。\n\n\n# 排查步骤\n\n\n# jps\n\njps主要用来输出jvm中运行的进程状态信息。语法格式如下：\n\njps [options] [hostid]\n\n\n1\n\n\n如果不指定hostid就默认为当前主机或服务器。\n\n命令行参数选项说明如下：\n\n-q 不输出类名,jar名和传入main方法的参数\n\n-m 输出传入main方法的参数\n\n-l 输出main类或jar的全限名\n\n-v 输出传入jvm的参数\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n比如下面：\n\nroot@ubuntu:/# jps -m -l\n2458 org.artifactory.standalone.main.main /usr/local/artifactory-2.2.5/etc/jetty.xml\n29920 com.sun.tools.hat.main -port 9998 /tmp/dump.dat\n3149 org.apache.catalina.startup.bootstrap start\n30972 sun.tools.jps.jps -m -l\n8247 org.apache.catalina.startup.bootstrap start\n25687 com.sun.tools.hat.main -port 9999 dump.dat\n21711 mrf-center.jar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# jstack\n\njstack主要用来查看某个java进程内的线程堆栈信息。语法格式如下：\n\njstack [option] pid\njstack [option] executable core\njstack [option] [server-id@]remote-hostname-or-ip\n\n\n1\n2\n3\n\n\n命令行参数选项说明如下：\n\n# 会打印出额外的锁信息\n# 在发生死锁时可以用 jstack -l pid 来观察锁持有情况\n# -m mixed mode，不仅会输出java堆栈信息，还会输出c/c++堆栈信息（比如native方法）\n-l long listings\n\n\n1\n2\n3\n4\n\n\njstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在jvm性能调优中使用得非常多。\n\n下面我们来一个实例找出某个java进程中最耗费cpu的java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。\n\n----------------------------------------\n\n第一步： 先找出java进程id，服务器上的java应用名称为 wordcount.jar：\n\n[root@storm-master home] ps -ef | grep wordcount\nroot    2860  2547 13 02:09 pts/0  00:02:03 java -jar wordcount.jar /home/input 3 \n\n\n1\n2\n\n\n得到进程id为 2860 。\n\n----------------------------------------\n\n第二步： 找出该进程内最耗费cpu的线程，可以使用如下3个命令，这里我们使用第3个命令得出如下结果：\n\n 1. ps -lfp pid ： 即 ps -lfp 2860\n\n 2. ps -mp pid -o thread, tid, time ：即 ps -mp 2860 -o thread,tid,time\n\n 3. top -hp pid： 即 top -hp 2860\n\n这里用第三个命令：top -hp 2860\n\ntop -hp 2860\n\n\n1\n\n\n输出如下：\n\n\n\ntime列就是各个java线程耗费的cpu时间，显然cpu时间最长的是id为2968的线程，用\n\nprintf "%x\\n" 2968\n\n\n1\n\n\n得到2968的十六进制值为b98，下面会用到。\n\n----------------------------------------\n\n第三步： 终于轮到jstack上场了，它用来输出进程2860的堆栈信息，然后根据线程id的十六进制值grep，如下：\n\n[root@storm-master home] jstack 2860 | grep b98 \n"sessiontracker" prio=10 tid=0x00007f55a44e4800 nid=0xb53 in object.wait() [0x00007f558e06c000 \n\n\n1\n2\n\n\n可以看到cpu消耗在sessiontracker这个类的object.wait()，于是就能很容易的定位到相关的代码了。\n\n当然，可以 jstack -l pid > /tmp/thread.txt 在导出的文件中搜索，就可以定位到具体的线程，类。\n\n----------------------------------------\n\n\n# 其他问题排查\n\n查看某进程及某线程占用 cpu 的例子\n\n * jps: 列出 java 进程,找到 pid.\n * pidstat -p pid -u 1 3 -u -t: 查看 pid 的进程所有线程的 cpu 使用情况.\n * jstack -l pid > /tmp/thread.txt: 导出指定 java 应用的所有线程.\n\n然后查看 nid=xxx(即第二步里线程号的线程),即可定位到某段代码.\n\n查看某进程及某线程占用 io 的例子\n\n * jps: 列出 java 进程,找到 pid.\n * pidstat -p pid -u 1 3 -d -t: 查看 pid 的进程所有线程的 io 使用情况.\n * jstack -l pid > /tmp/thread.txt: 导出指定 java 应用的所有线程.\n\n然后查看 nid=xxx(即第二步里线程号的线程),即可定位到某段代码.\n\n\n# 相关脚本\n\n 1. 阿里开源的 arthas\n\n 2. 看了下有位大神提个 issue , 推荐了个自动化脚本, 亲测更好用点. 这样子就可以免去上面的一步一步地查找和计算了. 所以, 这里也直接引用这个工具, 有需要的可以用下.\n    show-busy-java-threads',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"注解+AOP实现日志记录",frontmatter:{title:"注解+AOP实现日志记录",date:"2019-06-13T00:00:00.000Z",tags:["日志"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/annotationLog.html",relativePath:"views/backend/annotationLog.md",key:"v-8cb01f92",path:"/views/backend/annotationLog.html",headers:[{level:2,title:"1. 编写注解",slug:"_1-编写注解",normalizedTitle:"1. 编写注解",charIndex:3},{level:3,title:"相关注解",slug:"相关注解",normalizedTitle:"相关注解",charIndex:16},{level:2,title:"2. AOP切入",slug:"_2-aop切入",normalizedTitle:"2. aop切入",charIndex:24},{level:3,title:"相关注解",slug:"相关注解-2",normalizedTitle:"相关注解",charIndex:16},{level:4,title:"Aspect方法执行顺序",slug:"aspect方法执行顺序",normalizedTitle:"aspect方法执行顺序",charIndex:2688},{level:3,title:"JoinPoint解析",slug:"joinpoint解析",normalizedTitle:"joinpoint解析",charIndex:48},{level:3,title:"核心方法handleLogInfo()",slug:"核心方法handleloginfo",normalizedTitle:"核心方法handleloginfo()",charIndex:65}],headersStr:"1. 编写注解 相关注解 2. AOP切入 相关注解 Aspect方法执行顺序 JoinPoint解析 核心方法handleLogInfo()",content:' * 1. 编写注解\n   * 相关注解\n * 2. AOP切入\n   * 相关注解\n   * JoinPoint解析\n   * 核心方法handleLogInfo()\n\n\n\n\n# 注解+AOP实现日志记录\n\n * 使用注解+AOP实现日志记录\n\n\n# 1. 编写注解\n\n * com.xxx.xx.util.AuditLogger\n\n\n# 相关注解\n\n 1. @Retention(RetentionPolicy.RUNTIME)：生命周期为运行时\n 2. @Target( { java.lang.annotation.ElementType.METHOD,\n    java.lang.annotation.ElementType.TYPE }) ：该注解可以用于 类、接口，方法 上\n\npackage com.sgcc.bsp.util;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target( { java.lang.annotation.ElementType.METHOD,  \n        java.lang.annotation.ElementType.TYPE })  \npublic @interface AuditLogger {  \n    \n    //日志记录\n    public abstract String log();  \n    //作用于类和方法上，如果方法注解中该属性不为空,则该方法的类型会覆盖类定义的类型\n    public CodeEnum typeCode() default CodeEnum.NULL;\n    //作用于方法上，用于标记增加、删除、修改操作，这些操作必须被记录，不能被关闭\n    public boolean forceRecord() default false;\n    \n    public enum CodeEnum {\n    \t\n    \tSYSTEM("0"),//系统日志\n    \tNULL(""),\n    \tMANAGEMENT("1"),//管理模块\n    \tOTHER("2"),//其它模块等\n    \tprivate String code;\n    \t\n    \tprivate CodeEnum(String code){\n    \t\tthis.code = code;\n    \t}\n    \tpublic String getCode() {\n    \t\treturn code;\n    \t}\n    \t\n    \tpublic void setCode(String code) {\n    \t\tthis.code = code;\n    \t}\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 2. AOP切入\n\n * com.xxx.xx.util.WebLogAspect\n\n\n# 相关注解\n\n 1. @Aspect：作用是把当前类标识为一个切面类供spring容器读取\n\n 2. @Pointcut：Pointcut是植入Advice的触发条件。每个Pointcut的定义包括2部分，一是表达式，二是方法签名。\n\n方法签名必须是 public及void型。可以将Pointcut中的方法看作是一个被Advice引用的助记符，因为表达式不直观，因此我们可以通过方法签名的方式为 此表达式命名。因此Pointcut中的方法只需要方法签名，而不需要在方法体内编写实际代码。\n\n 3. @Around：环绕增强，相当于MethodInterceptor\n\n 4. @AfterReturning：后置增强，相当于AfterReturningAdvice，方法正常退出时执行\n\n 5. @Before：标识一个前置增强方法，相当于BeforeAdvice的功能，相似功能的还有\n\n 6. @AfterThrowing：异常抛出增强，相当于ThrowsAdvice\n\n 7. @After: final增强，不管是抛出异常或者正常退出都会执行\n\n@Aspect\npublic class WebLogAspect {\n\n    @Pointcut("@annotation(com.xxx.xx.util.AuditLogger)")\n    public void webLog(){}\n\n    @Before("webLog()")\n    public void doBefore(JoinPoint joinPoint) throws Throwable {\n    }\n    \n    @After("webLog()")\n    public void doAfter(JoinPoint joinPoint) throws Throwable {\n    }\n\n    @AfterReturning(returning = "ret", pointcut = "webLog()")\n    public void doAfterReturning(JoinPoint joinPoint,Object ret) throws Throwable {\n\t\thandleLogInfo(joinPoint,null);\n    }\n    \n    @AfterThrowing(pointcut = "webLog()", throwing= "error")\n    public void afterThrowingAdvice(JoinPoint joinPoint, Throwable error) throws Exception{\n\t\thandleLogInfo(joinPoint,error);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# Aspect方法执行顺序\n\nbefore around\nbefore\n-- sayHello() --\nafter around\nafter\nafter return\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# JoinPoint解析\n\n * 获取代理类和被代理类对象\n\n方法名                         功能\nSignature getSignature();   获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息\nObject[] getArgs();         获取传入目标方法的参数对象\nObject getTarget();         获取被代理的对象\nObject getThis();           获取代理对象\n\n * 常用方法\n\n//1.获取被代理类上注解\njoinPoint.getTarget().getClass().getAnnotation(注解类.class);\n//2.获取包名、类名\njoinPoint.getTarget().getClass().getPackage());\njoinPoint.getTarget().getClass().getSimpleName();\n//3.获取被代理类方法上的注解\nMethodSignature signature = (MethodSignature) joinPoint.getSignature();\n注解 methodAnnotion = signature.getMethod().getAnnotation(注解类.class);\n//4.获取方法名\nsignature.getMethod().getName();\n//5.获取第一个方法参数\nHashMap mapParam = (HashMap) joinPoint.getArgs()[0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 核心方法handleLogInfo()\n\n * 处理逻辑\n\n 1. 获取typeCode属性（会根据它配置相应模块的日志记录开关）：\n    判断切入的类和方法的某一注解上有没有对typeCode属性进行赋值，若都没有则默认不进行日志记录，直接return结束\n\n 2. 获取方法注解中forceRecord属性值（相当于判断是否必须记录）：\n    判断是否为需要强制记录的方法（增删改）\n    如果不是强制记录的方法，则根据日志类型（typeCode）查询判断记录开关是否为必须记录，是则记录\n\n 3. 书写逻辑，获取request和JoinPoint拼装参数进行日志记录\n\n 4. 对记录信息入库\n\n 5. 根据逻辑判断是否需要发送告警邮件',normalizedContent:' * 1. 编写注解\n   * 相关注解\n * 2. aop切入\n   * 相关注解\n   * joinpoint解析\n   * 核心方法handleloginfo()\n\n\n\n\n# 注解+aop实现日志记录\n\n * 使用注解+aop实现日志记录\n\n\n# 1. 编写注解\n\n * com.xxx.xx.util.auditlogger\n\n\n# 相关注解\n\n 1. @retention(retentionpolicy.runtime)：生命周期为运行时\n 2. @target( { java.lang.annotation.elementtype.method,\n    java.lang.annotation.elementtype.type }) ：该注解可以用于 类、接口，方法 上\n\npackage com.sgcc.bsp.util;\nimport java.lang.annotation.retention;\nimport java.lang.annotation.retentionpolicy;\nimport java.lang.annotation.target;\n\n@retention(retentionpolicy.runtime)\n@target( { java.lang.annotation.elementtype.method,  \n        java.lang.annotation.elementtype.type })  \npublic @interface auditlogger {  \n    \n    //日志记录\n    public abstract string log();  \n    //作用于类和方法上，如果方法注解中该属性不为空,则该方法的类型会覆盖类定义的类型\n    public codeenum typecode() default codeenum.null;\n    //作用于方法上，用于标记增加、删除、修改操作，这些操作必须被记录，不能被关闭\n    public boolean forcerecord() default false;\n    \n    public enum codeenum {\n    \t\n    \tsystem("0"),//系统日志\n    \tnull(""),\n    \tmanagement("1"),//管理模块\n    \tother("2"),//其它模块等\n    \tprivate string code;\n    \t\n    \tprivate codeenum(string code){\n    \t\tthis.code = code;\n    \t}\n    \tpublic string getcode() {\n    \t\treturn code;\n    \t}\n    \t\n    \tpublic void setcode(string code) {\n    \t\tthis.code = code;\n    \t}\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 2. aop切入\n\n * com.xxx.xx.util.weblogaspect\n\n\n# 相关注解\n\n 1. @aspect：作用是把当前类标识为一个切面类供spring容器读取\n\n 2. @pointcut：pointcut是植入advice的触发条件。每个pointcut的定义包括2部分，一是表达式，二是方法签名。\n\n方法签名必须是 public及void型。可以将pointcut中的方法看作是一个被advice引用的助记符，因为表达式不直观，因此我们可以通过方法签名的方式为 此表达式命名。因此pointcut中的方法只需要方法签名，而不需要在方法体内编写实际代码。\n\n 3. @around：环绕增强，相当于methodinterceptor\n\n 4. @afterreturning：后置增强，相当于afterreturningadvice，方法正常退出时执行\n\n 5. @before：标识一个前置增强方法，相当于beforeadvice的功能，相似功能的还有\n\n 6. @afterthrowing：异常抛出增强，相当于throwsadvice\n\n 7. @after: final增强，不管是抛出异常或者正常退出都会执行\n\n@aspect\npublic class weblogaspect {\n\n    @pointcut("@annotation(com.xxx.xx.util.auditlogger)")\n    public void weblog(){}\n\n    @before("weblog()")\n    public void dobefore(joinpoint joinpoint) throws throwable {\n    }\n    \n    @after("weblog()")\n    public void doafter(joinpoint joinpoint) throws throwable {\n    }\n\n    @afterreturning(returning = "ret", pointcut = "weblog()")\n    public void doafterreturning(joinpoint joinpoint,object ret) throws throwable {\n\t\thandleloginfo(joinpoint,null);\n    }\n    \n    @afterthrowing(pointcut = "weblog()", throwing= "error")\n    public void afterthrowingadvice(joinpoint joinpoint, throwable error) throws exception{\n\t\thandleloginfo(joinpoint,error);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# aspect方法执行顺序\n\nbefore around\nbefore\n-- sayhello() --\nafter around\nafter\nafter return\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# joinpoint解析\n\n * 获取代理类和被代理类对象\n\n方法名                         功能\nsignature getsignature();   获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的class等信息\nobject[] getargs();         获取传入目标方法的参数对象\nobject gettarget();         获取被代理的对象\nobject getthis();           获取代理对象\n\n * 常用方法\n\n//1.获取被代理类上注解\njoinpoint.gettarget().getclass().getannotation(注解类.class);\n//2.获取包名、类名\njoinpoint.gettarget().getclass().getpackage());\njoinpoint.gettarget().getclass().getsimplename();\n//3.获取被代理类方法上的注解\nmethodsignature signature = (methodsignature) joinpoint.getsignature();\n注解 methodannotion = signature.getmethod().getannotation(注解类.class);\n//4.获取方法名\nsignature.getmethod().getname();\n//5.获取第一个方法参数\nhashmap mapparam = (hashmap) joinpoint.getargs()[0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 核心方法handleloginfo()\n\n * 处理逻辑\n\n 1. 获取typecode属性（会根据它配置相应模块的日志记录开关）：\n    判断切入的类和方法的某一注解上有没有对typecode属性进行赋值，若都没有则默认不进行日志记录，直接return结束\n\n 2. 获取方法注解中forcerecord属性值（相当于判断是否必须记录）：\n    判断是否为需要强制记录的方法（增删改）\n    如果不是强制记录的方法，则根据日志类型（typecode）查询判断记录开关是否为必须记录，是则记录\n\n 3. 书写逻辑，获取request和joinpoint拼装参数进行日志记录\n\n 4. 对记录信息入库\n\n 5. 根据逻辑判断是否需要发送告警邮件',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"iText：PDF导出",frontmatter:{title:"iText：PDF导出",date:"2019-10-07T20:53:26.000Z",sidebar:!0,tags:["Java","pdf"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/itext.html",relativePath:"views/backend/itext.md",key:"v-196b8f52",path:"/views/backend/itext.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:9},{level:3,title:"生成图示",slug:"生成图示",normalizedTitle:"生成图示",charIndex:19},{level:2,title:"简要步骤",slug:"简要步骤",normalizedTitle:"简要步骤",charIndex:27},{level:2,title:"SpringBoot中使用iText",slug:"springboot中使用itext",normalizedTitle:"springboot中使用itext",charIndex:35},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:59},{level:3,title:"一个简单PDF生成",slug:"一个简单pdf生成",normalizedTitle:"一个简单pdf生成",charIndex:69},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:82}],headersStr:"简介 使用场景 生成图示 简要步骤 SpringBoot中使用iText 添加依赖 一个简单PDF生成 其它",content:' * 简介\n * 使用场景\n   * 生成图示\n * 简要步骤\n * SpringBoot中使用iText\n   * 添加依赖\n   * 一个简单PDF生成\n * 其它\n\n\n\n\n# 简介\n\n> 官网：https://itextpdf.com\n\n * iText是著名的开放源码的站点sourceforge一个项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。\n\n\n# 使用场景\n\n * 简单的：Java生成PDF报表、文档或其它（PDF中可以添加文字、图片、水印等）\n * 复杂的：结合echarts、phantomjs动态生成echar图片插入PDF中\n\n\n# 生成图示\n\n\n\n\n\n * 图示这个比较复杂，具体代码可见git或联系我\n\n\n# 简要步骤\n\n * 用iText生成PDF文档需要5个步骤：\n   \n   ① 建立com.itextpdf.text.Document对象的实例。\n   \n   Document document= new Document();\n   \n   ② 建立一个书写器(Writer)与document对象关联，通过书写器(Writer)可以将文档写入到磁盘中。\n   \n   PDFWriter.getInstance(document,new FileOutputStream("D:\\\\\\ITextTest.pdf"));\n   \n   ③ 打开文档。\n   \n   document.open();\n   \n   ④ 向文档中添加内容。\n   \n   document.add(newParagraph("IText Test"));\n   \n   ⑤ 关闭文档。\n   \n   document.close();\n   \n   通过上面的5个步骤，就能产生一个ITextTest.PDF的文件，文件内容为"ITextTest"。\n\n\n# SpringBoot中使用iText\n\n\n# 添加依赖\n\n\x3c!-- itext方式导出pdf --\x3e\n<dependency>\n    <groupId>com.itextpdf</groupId>\n    <artifactId>itextpdf</artifactId>\n    <version>5.5.10</version>\n</dependency>\n<dependency>\n    <groupId>com.itextpdf</groupId>\n    <artifactId>itext-asian</artifactId>\n    <version>5.2.0</version>\n</dependency>\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 一个简单PDF生成\n\npackage com.wh;\n \nimportjava.io.FileOutputStream;\nimportcom.itextpdf.text.BaseColor;\nimportcom.itextpdf.text.Document;\nimportcom.itextpdf.text.Element;\nimportcom.itextpdf.text.Font;\nimportcom.itextpdf.text.Paragraph;\nimportcom.itextpdf.text.Rectangle;\nimportcom.itextpdf.text.pdf.BaseFont;\nimportcom.itextpdf.text.pdf.PdfPTable;\nimportcom.itextpdf.text.pdf.PdfWriter;\n \npublic class ToPDF{\n       // 表头\n       public static final String[] tableHeader= { "姓名", "性别", "年龄",\n                     "学院", "专业", "年级"};\n \n       // 数据表字段数\n       private static final int colNumber = 6;\n \n       // 表格的设置\n       private static final int spacing = 2;\n \n       // 表格的设置\n       private static final int padding = 2;\n \n       // 导出Pdf文挡\n       public static void exportPdfDocument() {\n              // 创建文Pdf文挡50, 50, 50,50左右上下距离\n              Document document = newDocument(new Rectangle(1500, 2000), 50, 50, 50,\n                            50);\n              try {\n                     //使用PDFWriter进行写文件操作\n                     PdfWriter.getInstance(document,new FileOutputStream(\n                                   "d:\\\\学生信息.pdf"));\n                     document.open();\n                     // 中文字体\n                     BaseFont bfChinese =BaseFont.createFont("STSong-Light",\n                                   "UniGB-UCS2-H",BaseFont.NOT_EMBEDDED);\n                     Font fontChinese = newFont(bfChinese, 12, Font.NORMAL);\n                     // 创建有colNumber(6)列的表格\n                     PdfPTable datatable = newPdfPTable(colNumber);\n                     //定义表格的宽度\n                     int[] cellsWidth = { 8, 2,2, 8, 5, 3 };\n                     datatable.setWidths(cellsWidth);\n                     // 表格的宽度百分比\n                     datatable.setWidthPercentage(100);\n                     datatable.getDefaultCell().setPadding(padding);\n                     datatable.getDefaultCell().setBorderWidth(spacing);\n                     //设置表格的底色\n                     datatable.getDefaultCell().setBackgroundColor(BaseColor.GREEN);\n                     datatable.getDefaultCell().setHorizontalAlignment(\n                                   Element.ALIGN_CENTER);\n                     // 添加表头元素\n                     for (int i = 0; i <colNumber; i++) {\n                            datatable.addCell(newParagraph(tableHeader[i], fontChinese));\n                     }\n                     // 添加子元素\n                     for (int i = 0; i <colNumber; i++) {\n                            datatable.addCell(newParagraph(tableHeader[i], fontChinese));\n                     }\n                     document.add(datatable);\n              } catch (Exception e) {\n                     e.printStackTrace();\n              }\n              document.close();\n       }\n \n       public static void main(String[] args)throws Exception {\n              exportPdfDocument();\n       }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 其它\n\nJava操作PDF之iText超入门\n\niText API',normalizedContent:' * 简介\n * 使用场景\n   * 生成图示\n * 简要步骤\n * springboot中使用itext\n   * 添加依赖\n   * 一个简单pdf生成\n * 其它\n\n\n\n\n# 简介\n\n> 官网：https://itextpdf.com\n\n * itext是著名的开放源码的站点sourceforge一个项目，是用于生成pdf文档的一个java类库。通过itext不仅可以生成pdf或rtf的文档，而且可以将xml、html文件转化为pdf文件。\n\n\n# 使用场景\n\n * 简单的：java生成pdf报表、文档或其它（pdf中可以添加文字、图片、水印等）\n * 复杂的：结合echarts、phantomjs动态生成echar图片插入pdf中\n\n\n# 生成图示\n\n\n\n\n\n * 图示这个比较复杂，具体代码可见git或联系我\n\n\n# 简要步骤\n\n * 用itext生成pdf文档需要5个步骤：\n   \n   ① 建立com.itextpdf.text.document对象的实例。\n   \n   document document= new document();\n   \n   ② 建立一个书写器(writer)与document对象关联，通过书写器(writer)可以将文档写入到磁盘中。\n   \n   pdfwriter.getinstance(document,new fileoutputstream("d:\\\\\\itexttest.pdf"));\n   \n   ③ 打开文档。\n   \n   document.open();\n   \n   ④ 向文档中添加内容。\n   \n   document.add(newparagraph("itext test"));\n   \n   ⑤ 关闭文档。\n   \n   document.close();\n   \n   通过上面的5个步骤，就能产生一个itexttest.pdf的文件，文件内容为"itexttest"。\n\n\n# springboot中使用itext\n\n\n# 添加依赖\n\n\x3c!-- itext方式导出pdf --\x3e\n<dependency>\n    <groupid>com.itextpdf</groupid>\n    <artifactid>itextpdf</artifactid>\n    <version>5.5.10</version>\n</dependency>\n<dependency>\n    <groupid>com.itextpdf</groupid>\n    <artifactid>itext-asian</artifactid>\n    <version>5.2.0</version>\n</dependency>\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 一个简单pdf生成\n\npackage com.wh;\n \nimportjava.io.fileoutputstream;\nimportcom.itextpdf.text.basecolor;\nimportcom.itextpdf.text.document;\nimportcom.itextpdf.text.element;\nimportcom.itextpdf.text.font;\nimportcom.itextpdf.text.paragraph;\nimportcom.itextpdf.text.rectangle;\nimportcom.itextpdf.text.pdf.basefont;\nimportcom.itextpdf.text.pdf.pdfptable;\nimportcom.itextpdf.text.pdf.pdfwriter;\n \npublic class topdf{\n       // 表头\n       public static final string[] tableheader= { "姓名", "性别", "年龄",\n                     "学院", "专业", "年级"};\n \n       // 数据表字段数\n       private static final int colnumber = 6;\n \n       // 表格的设置\n       private static final int spacing = 2;\n \n       // 表格的设置\n       private static final int padding = 2;\n \n       // 导出pdf文挡\n       public static void exportpdfdocument() {\n              // 创建文pdf文挡50, 50, 50,50左右上下距离\n              document document = newdocument(new rectangle(1500, 2000), 50, 50, 50,\n                            50);\n              try {\n                     //使用pdfwriter进行写文件操作\n                     pdfwriter.getinstance(document,new fileoutputstream(\n                                   "d:\\\\学生信息.pdf"));\n                     document.open();\n                     // 中文字体\n                     basefont bfchinese =basefont.createfont("stsong-light",\n                                   "unigb-ucs2-h",basefont.not_embedded);\n                     font fontchinese = newfont(bfchinese, 12, font.normal);\n                     // 创建有colnumber(6)列的表格\n                     pdfptable datatable = newpdfptable(colnumber);\n                     //定义表格的宽度\n                     int[] cellswidth = { 8, 2,2, 8, 5, 3 };\n                     datatable.setwidths(cellswidth);\n                     // 表格的宽度百分比\n                     datatable.setwidthpercentage(100);\n                     datatable.getdefaultcell().setpadding(padding);\n                     datatable.getdefaultcell().setborderwidth(spacing);\n                     //设置表格的底色\n                     datatable.getdefaultcell().setbackgroundcolor(basecolor.green);\n                     datatable.getdefaultcell().sethorizontalalignment(\n                                   element.align_center);\n                     // 添加表头元素\n                     for (int i = 0; i <colnumber; i++) {\n                            datatable.addcell(newparagraph(tableheader[i], fontchinese));\n                     }\n                     // 添加子元素\n                     for (int i = 0; i <colnumber; i++) {\n                            datatable.addcell(newparagraph(tableheader[i], fontchinese));\n                     }\n                     document.add(datatable);\n              } catch (exception e) {\n                     e.printstacktrace();\n              }\n              document.close();\n       }\n \n       public static void main(string[] args)throws exception {\n              exportpdfdocument();\n       }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 其它\n\njava操作pdf之itext超入门\n\nitext api',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Docker的基本了解和使用",frontmatter:{title:"Docker的基本了解和使用",date:"2018-06-09T09:56:47.000Z",tags:["Docker"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/docker.html",relativePath:"views/backend/docker.md",key:"v-989d2c6a",path:"/views/backend/docker.html",headers:[{level:2,title:"1、简介",slug:"_1、简介",normalizedTitle:"1、简介",charIndex:37},{level:2,title:"2、核心概念",slug:"_2、核心概念",normalizedTitle:"2、核心概念",charIndex:45},{level:2,title:"3、安装Docker",slug:"_3、安装docker",normalizedTitle:"3、安装docker",charIndex:55},{level:3,title:"1）、安装linux虚拟机",slug:"_1-、安装linux虚拟机",normalizedTitle:"1）、安装linux虚拟机",charIndex:71},{level:3,title:"2）、在linux虚拟机上安装docker",slug:"_2-、在linux虚拟机上安装docker",normalizedTitle:"2）、在linux虚拟机上安装docker",charIndex:90},{level:2,title:"4、Docker常用命令&操作",slug:"_4、docker常用命令-操作",normalizedTitle:"4、docker常用命令&amp;操作",charIndex:null},{level:3,title:"1）、镜像操作",slug:"_1-、镜像操作",normalizedTitle:"1）、镜像操作",charIndex:136},{level:3,title:"2）、容器操作",slug:"_2-、容器操作",normalizedTitle:"2）、容器操作",charIndex:149},{level:3,title:"3）、安装MySQL示例",slug:"_3-、安装mysql示例",normalizedTitle:"3）、安装mysql示例",charIndex:162},{level:2,title:"5、其它",slug:"_5、其它",normalizedTitle:"5、其它",charIndex:178}],excerpt:"<Boxx/>\n<p><strong>Docker</strong>是一个开源的应用容器引擎，是一个轻量级容器技术。</p>\n",headersStr:"1、简介 2、核心概念 3、安装Docker 1）、安装linux虚拟机 2）、在linux虚拟机上安装docker 4、Docker常用命令&操作 1）、镜像操作 2）、容器操作 3）、安装MySQL示例 5、其它",content:'Docker是一个开源的应用容器引擎，是一个轻量级容器技术。\n\n\n\n * 1、简介\n * 2、核心概念\n * 3、安装Docker\n   * 1）、安装linux虚拟机\n   * 2）、在linux虚拟机上安装docker\n * 4、Docker常用命令&操作\n   * 1）、镜像操作\n   * 2）、容器操作\n   * 3）、安装MySQL示例\n * 5、其它\n\n\n\n\n# 1、简介\n\nDocker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；\n\n运行中的这个镜像称为容器，容器启动是非常快速的。\n\n\n\n\n\n\n# 2、核心概念\n\ndocker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；\n\ndocker客户端(Client)：连接docker主机进行操作；\n\ndocker仓库(Registry)：用来保存各种打包好的软件镜像；\n\ndocker镜像(Images)：软件打包好的镜像；放在docker仓库中；\n\ndocker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用\n\n\n\n使用Docker的步骤：\n\n1）、安装Docker\n\n2）、去Docker仓库找到这个软件对应的镜像；\n\n3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；\n\n4）、对容器的启动停止就是对软件的启动停止；\n\n\n# 3、安装Docker\n\n\n# 1）、安装linux虚拟机\n\n1）、VMWare、VirtualBox（安装）；\n\n2）、导入虚拟机文件centos7；（安装linux）\n\n3）、双击启动linux虚拟机;使用 root/ 123456登陆\n\n4）、使用客户端连接linux服务器进行命令操作；\n\n5）、设置虚拟机网络；\n\n桥接网络===选好网卡====接入网线；\n\n6）、设置好网络以后使用命令重启虚拟机的网络\n\nservice network restart\n\n\n1\n\n\n7）、查看linux的ip地址\n\nip addr\n\n\n1\n\n\n8）、使用客户端连接linux；\n\n\n# 2）、在linux虚拟机上安装docker\n\n步骤：\n\n1、检查内核版本，必须是3.10及以上\nuname -r\n2、安装docker\nyum install docker\n3、输入y确认安装\n4、启动docker\n[root@localhost ~]# systemctl start docker\n[root@localhost ~]# docker -v\nDocker version 1.12.6, build 3e8e77d/1.12.6\n5、开机启动docker\n[root@localhost ~]# systemctl enable docker\nCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.\n6、停止docker\nsystemctl stop docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 4、Docker常用命令&操作\n\n\n# 1）、镜像操作\n\n操作   命令                                         说明\n检索   docker search 关键字 eg：docker search redis   我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。\n拉取   docker pull 镜像名:tag                        :tag是可选的，tag表示标签，多为软件的版本，默认是latest\n列表   docker images                              查看所有本地镜像\n删除   docker rmi image-id                        删除指定的本地镜像\n\nhttps://hub.docker.com/\n\n\n# 2）、容器操作\n\n软件镜像（QQ安装程序）----运行镜像----产生一个容器（正在运行的软件，运行的QQ）；\n\n步骤：\n\n1、搜索镜像\n[root@localhost ~]# docker search tomcat\n2、拉取镜像\n[root@localhost ~]# docker pull tomcat\n3、根据镜像启动容器\ndocker run --name mytomcat -d tomcat:latest\n4、docker ps\n查看运行中的容器\n5、 停止运行中的容器\ndocker stop  容器的id\n6、查看所有的容器\ndocker ps -a\n7、启动容器\ndocker start 容器id\n8、删除一个容器\n docker rm 容器id\n9、启动一个做了端口映射的tomcat\n[root@localhost ~]# docker run -d -p 8888:8080 tomcat\n-d：后台运行\n-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口\n\n10、为了演示简单关闭了linux的防火墙\nservice firewalld status ；查看防火墙状态\nservice firewalld stop：关闭防火墙\n11、查看容器的日志\ndocker logs container-name/container-id\n\n更多命令参看\nhttps://docs.docker.com/engine/reference/commandline/docker/\n可以参考每一个镜像的文档\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3）、安装MySQL示例\n\ndocker pull mysql\n\n\n1\n\n\n错误的启动\n\n[root@localhost ~]# docker run --name mysql01 -d mysql\n42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846\n\nmysql退出了\n[root@localhost ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES\n42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01\n538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_\ngoldstine\nc4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi\n81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan\n\n\n//错误日志\n[root@localhost ~]# docker logs 42f09819908b\nerror: database is uninitialized and password option is not specified\n  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n正确的启动\n\n[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\nb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\nb874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01\n\n\n1\n2\n3\n4\n5\n\n\n做了端口映射\n\n[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\nad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434\n[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\nad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306->3306/tcp   mysql02\n\n\n1\n2\n3\n4\n5\n\n\n几个其他的高级操作\n\ndocker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag\n把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面\n改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）\n\ndocker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n指定mysql的一些配置参数\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5、其它\n\n * 开发者必备Docker命令\n * 使用Maven插件构建Docker镜像\n * Docker在Linux下的各种操作\n * 使用Dockerfile为SpringBoot应用构建Docker镜像\n * 使用Docker Compose部署SpringBoot应用',normalizedContent:'docker是一个开源的应用容器引擎，是一个轻量级容器技术。\n\n\n\n * 1、简介\n * 2、核心概念\n * 3、安装docker\n   * 1）、安装linux虚拟机\n   * 2）、在linux虚拟机上安装docker\n * 4、docker常用命令&操作\n   * 1）、镜像操作\n   * 2）、容器操作\n   * 3）、安装mysql示例\n * 5、其它\n\n\n\n\n# 1、简介\n\ndocker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；\n\n运行中的这个镜像称为容器，容器启动是非常快速的。\n\n\n\n\n\n\n# 2、核心概念\n\ndocker主机(host)：安装了docker程序的机器（docker直接安装在操作系统之上）；\n\ndocker客户端(client)：连接docker主机进行操作；\n\ndocker仓库(registry)：用来保存各种打包好的软件镜像；\n\ndocker镜像(images)：软件打包好的镜像；放在docker仓库中；\n\ndocker容器(container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用\n\n\n\n使用docker的步骤：\n\n1）、安装docker\n\n2）、去docker仓库找到这个软件对应的镜像；\n\n3）、使用docker运行这个镜像，这个镜像就会生成一个docker容器；\n\n4）、对容器的启动停止就是对软件的启动停止；\n\n\n# 3、安装docker\n\n\n# 1）、安装linux虚拟机\n\n1）、vmware、virtualbox（安装）；\n\n2）、导入虚拟机文件centos7；（安装linux）\n\n3）、双击启动linux虚拟机;使用 root/ 123456登陆\n\n4）、使用客户端连接linux服务器进行命令操作；\n\n5）、设置虚拟机网络；\n\n桥接网络===选好网卡====接入网线；\n\n6）、设置好网络以后使用命令重启虚拟机的网络\n\nservice network restart\n\n\n1\n\n\n7）、查看linux的ip地址\n\nip addr\n\n\n1\n\n\n8）、使用客户端连接linux；\n\n\n# 2）、在linux虚拟机上安装docker\n\n步骤：\n\n1、检查内核版本，必须是3.10及以上\nuname -r\n2、安装docker\nyum install docker\n3、输入y确认安装\n4、启动docker\n[root@localhost ~]# systemctl start docker\n[root@localhost ~]# docker -v\ndocker version 1.12.6, build 3e8e77d/1.12.6\n5、开机启动docker\n[root@localhost ~]# systemctl enable docker\ncreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.\n6、停止docker\nsystemctl stop docker\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 4、docker常用命令&操作\n\n\n# 1）、镜像操作\n\n操作   命令                                         说明\n检索   docker search 关键字 eg：docker search redis   我们经常去docker hub上检索镜像的详细信息，如镜像的tag。\n拉取   docker pull 镜像名:tag                        :tag是可选的，tag表示标签，多为软件的版本，默认是latest\n列表   docker images                              查看所有本地镜像\n删除   docker rmi image-id                        删除指定的本地镜像\n\nhttps://hub.docker.com/\n\n\n# 2）、容器操作\n\n软件镜像（qq安装程序）----运行镜像----产生一个容器（正在运行的软件，运行的qq）；\n\n步骤：\n\n1、搜索镜像\n[root@localhost ~]# docker search tomcat\n2、拉取镜像\n[root@localhost ~]# docker pull tomcat\n3、根据镜像启动容器\ndocker run --name mytomcat -d tomcat:latest\n4、docker ps\n查看运行中的容器\n5、 停止运行中的容器\ndocker stop  容器的id\n6、查看所有的容器\ndocker ps -a\n7、启动容器\ndocker start 容器id\n8、删除一个容器\n docker rm 容器id\n9、启动一个做了端口映射的tomcat\n[root@localhost ~]# docker run -d -p 8888:8080 tomcat\n-d：后台运行\n-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口\n\n10、为了演示简单关闭了linux的防火墙\nservice firewalld status ；查看防火墙状态\nservice firewalld stop：关闭防火墙\n11、查看容器的日志\ndocker logs container-name/container-id\n\n更多命令参看\nhttps://docs.docker.com/engine/reference/commandline/docker/\n可以参考每一个镜像的文档\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3）、安装mysql示例\n\ndocker pull mysql\n\n\n1\n\n\n错误的启动\n\n[root@localhost ~]# docker run --name mysql01 -d mysql\n42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846\n\nmysql退出了\n[root@localhost ~]# docker ps -a\ncontainer id        image               command                  created             status                           ports               names\n42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      exited (1) 33 seconds ago                            mysql01\n538bde63e500        tomcat              "catalina.sh run"        about an hour ago   exited (143) about an hour ago                       compassionate_\ngoldstine\nc4f1ac60b3fc        tomcat              "catalina.sh run"        about an hour ago   exited (143) about an hour ago                       lonely_fermi\n81ec743a5271        tomcat              "catalina.sh run"        about an hour ago   exited (143) about an hour ago                       sick_ramanujan\n\n\n//错误日志\n[root@localhost ~]# docker logs 42f09819908b\nerror: database is uninitialized and password option is not specified\n  you need to specify one of mysql_root_password, mysql_allow_empty_password and mysql_random_root_password；这个三个参数必须指定一个\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n正确的启动\n\n[root@localhost ~]# docker run --name mysql01 -e mysql_root_password=123456 -d mysql\nb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f\n[root@localhost ~]# docker ps\ncontainer id        image               command                  created             status              ports               names\nb874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       up 3 seconds        3306/tcp            mysql01\n\n\n1\n2\n3\n4\n5\n\n\n做了端口映射\n\n[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e mysql_root_password=123456 -d mysql\nad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434\n[root@localhost ~]# docker ps\ncontainer id        image               command                  created             status              ports                    names\nad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       up 2 seconds        0.0.0.0:3306->3306/tcp   mysql02\n\n\n1\n2\n3\n4\n5\n\n\n几个其他的高级操作\n\ndocker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e mysql_root_password=my-secret-pw -d mysql:tag\n把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面\n改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）\n\ndocker run --name some-mysql -e mysql_root_password=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n指定mysql的一些配置参数\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5、其它\n\n * 开发者必备docker命令\n * 使用maven插件构建docker镜像\n * docker在linux下的各种操作\n * 使用dockerfile为springboot应用构建docker镜像\n * 使用docker compose部署springboot应用',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Java中的各种锁",frontmatter:{title:"Java中的各种锁",date:"2020-04-27T00:00:00.000Z",tags:["Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/javaLock.html",relativePath:"views/backend/javaLock.md",key:"v-04d0dd31",path:"/views/backend/javaLock.html",headers:[{level:2,title:"公平锁",slug:"公平锁",normalizedTitle:"公平锁",charIndex:3},{level:2,title:"非公平锁",slug:"非公平锁",normalizedTitle:"非公平锁",charIndex:2},{level:2,title:"可重入锁",slug:"可重入锁",normalizedTitle:"可重入锁",charIndex:7},{level:2,title:"自旋锁:",slug:"自旋锁",normalizedTitle:"自旋锁:",charIndex:51},{level:2,title:"读写锁",slug:"读写锁",normalizedTitle:"读写锁",charIndex:16},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:66}],excerpt:"<Boxx/>\n<p>公平非公平锁，可重入锁，自旋锁，读写锁等。</p>\n",headersStr:"公平锁 非公平锁 可重入锁 自旋锁: 读写锁 其他",content:'公平非公平锁，可重入锁，自旋锁，读写锁等。\n\n\n\n * 公平锁\n * 非公平锁\n * 可重入锁\n * 自旋锁:\n * 读写锁\n * 其他\n\n\n\n\n# 公平锁\n\n指根据线程在队列中的优先级获取锁，比如线程优先加入阻塞队列，那么线程就优先获取锁（火车站买票排队）\n\n\n# 非公平锁\n\n指在获取锁的时候，每个线程都会去争抢，并且都有机会获取到锁，无关线程的优先级（火车站买票可插队）\n\n\n# 可重入锁\n\n一个线程获取到锁后，如果继续遇到被相同锁修饰的资源或方法，那么可以继续获取该锁（允许多道锁，小区门口上锁，单元门上锁，厕所再上一把锁）\n\n对 synchronized 来说，每个锁都有线程持有者和锁计数器，每次线程获取到锁,会记录下改线程，并且锁的计数器就+1，当线程退出synchronized代码块的时候，线程计数就会-1，当锁计数为0的时候，就释放锁。\n\n\n# 自旋锁:\n\n指当锁被获取后，其他线程并不会停止获取，而是一直去尝试获取（while + CAS实现的锁，各自线程不断地去看锁有没有释放）\n\npublic class SpinLock {\n\n    private static final AtomicReference<Thread> atomicReference = new AtomicReference<>();\n\n    public  void lock(){\n        //当前线程作为锁资源\n        Thread thread = Thread.currentThread();\n\n        //如果期盼值是null,也就是代表没有锁引用了,就设置为当前线程引用,如果不成功就while\n        while (!atomicReference.compareAndSet(null,thread)){\n\n        }\n    }\n\n    public  void unlock(){\n        //当前获取锁的线程\n        Thread thread = Thread.currentThread();\n        \n        //释放锁,让下一个线程获取\n        atomicReference.compareAndSet(thread,null);\n    }\n    \n    public static void main(String[] args) throws Exception{\n        SpinLock spinLock = new SpinLock();\n\n        new Thread(()->{\n            spinLock.lock();\n            //其他操作...\n            spinLock.unlock();\n        },"A").start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这样做的好处是减少上下文开销，缺点是增加cpu消耗。\n\nCAS底层就使用了自旋操作（不是自旋锁，而是如果预期值和原值比较不成功就会一直比较）\n\n\n# 读写锁\n\n * 独占锁:（一个坑只能有一个人拉屎）\n   \n   锁一次只能被一个线程占有使用，Synchronized和ReetrantLock都是独占锁。\n\n * 共享锁:（允许多个人同时看到那个牌子：厕所有人，正在拉屎。。）\n   \n   锁可以被多个线程持有，对于ReentrantReadWriteLock而言，它的读锁是共享锁，写锁是独占锁 。\n\n//模拟hibernate缓存被读和被写\npublic class ReadWriteLockDemo{\n    \n    static class Cache{\n        //用map来充当缓存容器\n        private HashMap<String,Object> cache = new HashMap<>();\n        private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\t\t\n        public void put(String key , Object val){\n            readWriteLock.writeLock().lock();\n            try{\n                System.out.println(Thread.currentThread().getName()+" 开始写入");\n                cache.put(key,val);\n                System.out.println(Thread.currentThread().getName()+" 写入完成");\n            }\n            catch(Exception e){\n                e.printStackTrace();\n            }\n            finally{\n                readWriteLock.writeLock().unlock();\n            }\n        }\n\n\n        public void get(String key)\n        {\n            readWriteLock.readLock().lock();\n            try{\n                System.out.println(Thread.currentThread().getName() + " 开始读取");\n                Object obj = cache.get(key);\n                System.out.println(Thread.currentThread().getName() + " 读取完成 : " + obj);\n            }\n            catch(Exception e){\n                e.printStackTrace();\n            }\n            finally{\n               readWriteLock.readLock().unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        Cache cache = new Cache();\n        for (int i = 0 ; i < 5; ++i){\n            final int tempI = i;\n            new Thread(()->{\n               cache.put(String.valueOf(tempI),tempI);\n            }).start();\n        }\n\n        for (int i = 0 ; i < 5; ++i){\n            final int tempI = i;\n            new Thread(()->{\n                cache.get(String.valueOf(tempI));\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 其他\n\n * 刚发现美团写的不错 -- 传送门',normalizedContent:'公平非公平锁，可重入锁，自旋锁，读写锁等。\n\n\n\n * 公平锁\n * 非公平锁\n * 可重入锁\n * 自旋锁:\n * 读写锁\n * 其他\n\n\n\n\n# 公平锁\n\n指根据线程在队列中的优先级获取锁，比如线程优先加入阻塞队列，那么线程就优先获取锁（火车站买票排队）\n\n\n# 非公平锁\n\n指在获取锁的时候，每个线程都会去争抢，并且都有机会获取到锁，无关线程的优先级（火车站买票可插队）\n\n\n# 可重入锁\n\n一个线程获取到锁后，如果继续遇到被相同锁修饰的资源或方法，那么可以继续获取该锁（允许多道锁，小区门口上锁，单元门上锁，厕所再上一把锁）\n\n对 synchronized 来说，每个锁都有线程持有者和锁计数器，每次线程获取到锁,会记录下改线程，并且锁的计数器就+1，当线程退出synchronized代码块的时候，线程计数就会-1，当锁计数为0的时候，就释放锁。\n\n\n# 自旋锁:\n\n指当锁被获取后，其他线程并不会停止获取，而是一直去尝试获取（while + cas实现的锁，各自线程不断地去看锁有没有释放）\n\npublic class spinlock {\n\n    private static final atomicreference<thread> atomicreference = new atomicreference<>();\n\n    public  void lock(){\n        //当前线程作为锁资源\n        thread thread = thread.currentthread();\n\n        //如果期盼值是null,也就是代表没有锁引用了,就设置为当前线程引用,如果不成功就while\n        while (!atomicreference.compareandset(null,thread)){\n\n        }\n    }\n\n    public  void unlock(){\n        //当前获取锁的线程\n        thread thread = thread.currentthread();\n        \n        //释放锁,让下一个线程获取\n        atomicreference.compareandset(thread,null);\n    }\n    \n    public static void main(string[] args) throws exception{\n        spinlock spinlock = new spinlock();\n\n        new thread(()->{\n            spinlock.lock();\n            //其他操作...\n            spinlock.unlock();\n        },"a").start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这样做的好处是减少上下文开销，缺点是增加cpu消耗。\n\ncas底层就使用了自旋操作（不是自旋锁，而是如果预期值和原值比较不成功就会一直比较）\n\n\n# 读写锁\n\n * 独占锁:（一个坑只能有一个人拉屎）\n   \n   锁一次只能被一个线程占有使用，synchronized和reetrantlock都是独占锁。\n\n * 共享锁:（允许多个人同时看到那个牌子：厕所有人，正在拉屎。。）\n   \n   锁可以被多个线程持有，对于reentrantreadwritelock而言，它的读锁是共享锁，写锁是独占锁 。\n\n//模拟hibernate缓存被读和被写\npublic class readwritelockdemo{\n    \n    static class cache{\n        //用map来充当缓存容器\n        private hashmap<string,object> cache = new hashmap<>();\n        private readwritelock readwritelock = new reentrantreadwritelock();\n\t\t\n        public void put(string key , object val){\n            readwritelock.writelock().lock();\n            try{\n                system.out.println(thread.currentthread().getname()+" 开始写入");\n                cache.put(key,val);\n                system.out.println(thread.currentthread().getname()+" 写入完成");\n            }\n            catch(exception e){\n                e.printstacktrace();\n            }\n            finally{\n                readwritelock.writelock().unlock();\n            }\n        }\n\n\n        public void get(string key)\n        {\n            readwritelock.readlock().lock();\n            try{\n                system.out.println(thread.currentthread().getname() + " 开始读取");\n                object obj = cache.get(key);\n                system.out.println(thread.currentthread().getname() + " 读取完成 : " + obj);\n            }\n            catch(exception e){\n                e.printstacktrace();\n            }\n            finally{\n               readwritelock.readlock().unlock();\n            }\n        }\n    }\n\n    public static void main(string[] args){\n        cache cache = new cache();\n        for (int i = 0 ; i < 5; ++i){\n            final int tempi = i;\n            new thread(()->{\n               cache.put(string.valueof(tempi),tempi);\n            }).start();\n        }\n\n        for (int i = 0 ; i < 5; ++i){\n            final int tempi = i;\n            new thread(()->{\n                cache.get(string.valueof(tempi));\n            }).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 其他\n\n * 刚发现美团写的不错 -- 传送门',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"IO模型",frontmatter:{title:"IO模型",date:"2022-02-03T00:00:00.000Z",tags:["IO模型"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html",relativePath:"views/backend/java_io模型.md",key:"v-1ba7191d",path:"/views/backend/java_io%E6%A8%A1%E5%9E%8B.html",headers:[{level:3,title:"1. 阻塞I/O模型",slug:"_1-阻塞i-o模型",normalizedTitle:"1. 阻塞i/o模型",charIndex:3},{level:3,title:"2. 非阻塞I/O模型",slug:"_2-非阻塞i-o模型",normalizedTitle:"2. 非阻塞i/o模型",charIndex:17},{level:3,title:"3. I/O复用模型",slug:"_3-i-o复用模型",normalizedTitle:"3. i/o复用模型",charIndex:32},{level:3,title:"4. 信号驱动I/O模型",slug:"_4-信号驱动i-o模型",normalizedTitle:"4. 信号驱动i/o模型",charIndex:46},{level:3,title:"5. 异步I/O模型",slug:"_5-异步i-o模型",normalizedTitle:"5. 异步i/o模型",charIndex:62},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:730},{level:2,title:"其他参考",slug:"其他参考",normalizedTitle:"其他参考",charIndex:1236}],headersStr:"1. 阻塞I/O模型 2. 非阻塞I/O模型 3. I/O复用模型 4. 信号驱动I/O模型 5. 异步I/O模型 总结 其他参考",content:" * 1. 阻塞I/O模型\n * 2. 非阻塞I/O模型\n * 3. I/O复用模型\n * 4. 信号驱动I/O模型\n * 5. 异步I/O模型\n\n\n\n借用知乎用于levin的回答，对各种模型讲个故事，描述下各个IO模型的区别：\n\n故事情节为：老李去买火车票，三天后买到一张退票。参演人员（老李，黄牛，售票员，快递员），往返车站耗费1小时。\n\n\n# 1. 阻塞I/O模型\n\n老李去火车站买票，排队三天买到一张退票。\n\n耗费：在车站吃喝拉撒睡 3天，其他事一件没干。\n\n\n# 2. 非阻塞I/O模型\n\n老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。\n\n耗费：往返车站6次，路上6小时，其他时间做了好多事。\n\n\n# 3. I/O复用模型\n\n * select/poll（有selector选择器，去轮询选择器）\n\n老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次\n\n * epoll（事件回调）\n\n老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话\n\n\n# 4. 信号驱动I/O模型\n\n老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话\n\n\n# 5. 异步I/O模型\n\n老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。\n\n耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话\n\n\n# 总结\n\n1同2的区别是：自己轮询\n\n2同3的区别是：委托黄牛\n\n3同4的区别是：电话代替黄牛\n\n4同5的区别是：电话通知是自取还是送票上门\n\n * 阻塞I/O模型：单线程一直阻塞直到事件发生才处理，期间干不了其他事情\n\n * 非阻塞I/O模型：while(true) 不断循环看有没有事件发生才处理，期间可以干其他事情，但是需要自己不断的去监测\n\n * I/O复用模型：基于事件驱动（类似与页面的一个button一个事件），有事件发生才处理，期间可以干其他事情，可以理解有一个中间人selector替我们监听， 有事件后通知我们去处理\n\n              同步阻塞IO   伪异步IO    NIO       AIO\n客户端数目 ：IO线程   1 : 1    m : n    m : 1     m : 0\nIO模型          同步阻塞IO   同步阻塞IO   同步非阻塞IO   异步非阻塞IO\n吞吐量           低        中        高         高\n编程复杂度         简单       简单       非常复杂      复杂\n\n\n# 其他参考\n\n * BIO、NIO、Netty示例demo",normalizedContent:" * 1. 阻塞i/o模型\n * 2. 非阻塞i/o模型\n * 3. i/o复用模型\n * 4. 信号驱动i/o模型\n * 5. 异步i/o模型\n\n\n\n借用知乎用于levin的回答，对各种模型讲个故事，描述下各个io模型的区别：\n\n故事情节为：老李去买火车票，三天后买到一张退票。参演人员（老李，黄牛，售票员，快递员），往返车站耗费1小时。\n\n\n# 1. 阻塞i/o模型\n\n老李去火车站买票，排队三天买到一张退票。\n\n耗费：在车站吃喝拉撒睡 3天，其他事一件没干。\n\n\n# 2. 非阻塞i/o模型\n\n老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。\n\n耗费：往返车站6次，路上6小时，其他时间做了好多事。\n\n\n# 3. i/o复用模型\n\n * select/poll（有selector选择器，去轮询选择器）\n\n老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次\n\n * epoll（事件回调）\n\n老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话\n\n\n# 4. 信号驱动i/o模型\n\n老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。\n\n耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话\n\n\n# 5. 异步i/o模型\n\n老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。\n\n耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话\n\n\n# 总结\n\n1同2的区别是：自己轮询\n\n2同3的区别是：委托黄牛\n\n3同4的区别是：电话代替黄牛\n\n4同5的区别是：电话通知是自取还是送票上门\n\n * 阻塞i/o模型：单线程一直阻塞直到事件发生才处理，期间干不了其他事情\n\n * 非阻塞i/o模型：while(true) 不断循环看有没有事件发生才处理，期间可以干其他事情，但是需要自己不断的去监测\n\n * i/o复用模型：基于事件驱动（类似与页面的一个button一个事件），有事件发生才处理，期间可以干其他事情，可以理解有一个中间人selector替我们监听， 有事件后通知我们去处理\n\n              同步阻塞io   伪异步io    nio       aio\n客户端数目 ：io线程   1 : 1    m : n    m : 1     m : 0\nio模型          同步阻塞io   同步阻塞io   同步非阻塞io   异步非阻塞io\n吞吐量           低        中        高         高\n编程复杂度         简单       简单       非常复杂      复杂\n\n\n# 其他参考\n\n * bio、nio、netty示例demo",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"JVM 和 GC",frontmatter:{title:"JVM 和 GC",date:"2020-01-12T00:00:00.000Z",tags:["jvm","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/jvm.html",relativePath:"views/backend/jvm.md",key:"v-6bf3fa77",path:"/views/backend/jvm.html",headers:[{level:2,title:"JVM",slug:"jvm",normalizedTitle:"jvm",charIndex:3},{level:3,title:"类装载器",slug:"类装载器",normalizedTitle:"类装载器",charIndex:12},{level:4,title:"ClassLoader的双亲委派机制",slug:"classloader的双亲委派机制",normalizedTitle:"classloader的双亲委派机制",charIndex:442},{level:3,title:"Execution Engine执行引擎",slug:"execution-engine执行引擎",normalizedTitle:"execution engine执行引擎",charIndex:22},{level:3,title:"Native Interface本地接口",slug:"native-interface本地接口",normalizedTitle:"native interface本地接口",charIndex:48},{level:3,title:"永久代（元空间）",slug:"永久代-元空间",normalizedTitle:"永久代（元空间）",charIndex:74},{level:3,title:"栈 stack",slug:"栈-stack",normalizedTitle:"栈 stack",charIndex:88},{level:3,title:"堆 heap",slug:"堆-heap",normalizedTitle:"堆 heap",charIndex:101},{level:3,title:"jvm 调优",slug:"jvm-调优",normalizedTitle:"jvm 调优",charIndex:113},{level:2,title:"GC",slug:"gc",normalizedTitle:"gc",charIndex:123},{level:3,title:"MinorGC的过程（复制->清空->互换）",slug:"minorgc的过程-复制-清空-互换",normalizedTitle:"minorgc的过程（复制-&gt;清空-&gt;互换）",charIndex:null},{level:3,title:"GC算法",slug:"gc算法",normalizedTitle:"gc算法",charIndex:159},{level:2,title:"Minor GC 和 Full GC",slug:"minor-gc-和-full-gc",normalizedTitle:"minor gc 和 full gc",charIndex:167},{level:2,title:"栈溢出和堆溢出",slug:"栈溢出和堆溢出",normalizedTitle:"栈溢出和堆溢出",charIndex:189}],headersStr:"JVM 类装载器 ClassLoader的双亲委派机制 Execution Engine执行引擎 Native Interface本地接口 永久代（元空间） 栈 stack 堆 heap jvm 调优 GC MinorGC的过程（复制->清空->互换） GC算法 Minor GC 和 Full GC 栈溢出和堆溢出",content:" * JVM\n   * 类装载器\n   * Execution Engine执行引擎\n   * Native Interface本地接口\n   * 永久代（元空间）\n   * 栈 stack\n   * 堆 heap\n   * jvm 调优\n * GC\n   * MinorGC的过程（复制->清空->互换）\n   * GC算法\n * Minor GC 和 Full GC\n * 栈溢出和堆溢出\n\n\n\n\n# JVM\n\n * JVM是运行在操作系统之上的，它与硬件没有直接的交互\n\n\n\n\n# 类装载器\n\n 1. 启动类加载器（Bootstrap）C++编写：Java程序入口，加载Java基础包\n 2. 扩展类加载器（Extension）Java编写：加载 javax 包\n 3. 应用类加载器（AppClassLoader）Java编写：加载我们自己写的类\n 4. 用户自定义加载器：对自带的三种加载器不满足的话，继承ClassLoader，自定义一个我们自己需求的类加载器\n\n\n\n# ClassLoader的双亲委派机制\n\n * 比如我们自己也写了一个名为Java.Lang.String的类，但启动会报错，因为Java类加载是从顶部的启动类加载器：Bootstrap开始加载的\n\n> 当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成。\n> \n> 每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到BootStrap中，只有当父类加载器反馈无法完成这个请求的时候（在它的加载路径下没有找到所需的Class文件），子类加载器才会尝试自己去加载。\n\n * 正因为这样，所以Java是沙箱安全的：防止我们自己写的代码污染Java源代码\n\n\n# Execution Engine执行引擎\n\n * 相当于解释执行器：负责将.Class二进制代码文件翻译为操作系统能读懂的机器码，提交操作系统执行\n\n\n# Native Interface本地接口\n\n * 本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies。\n * 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的架构领域间的通信很发达，比如可以使用 Socket通信，也可以使用Web Service等等，不多做介绍。\n\n\n# 永久代（元空间）\n\n * 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。\n\n\n# 栈 stack\n\n * 先进后出，负责Java程序的运行，随着线程的创建而开始，随着线程的消亡而结束\n * 在程序从第一个方法（main）开始运行时，每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息\n * 栈帧中主要保存3 类数据：\n   1. 本地变量（Local Variables）：输入参数和输出参数以及方法内的变量\n   2. 栈操作（Operand Stack）：记录出栈、入栈的操作\n   3. 栈帧数据（Frame Data）：包括类文件、方法等等\n\n\n\n\n# 堆 heap\n\n\n\n 1. 新生代\n    * 伊甸区：占新生代的8/10 （98%的GC回收都在这）\n    * from区： 占新生代的 1/10 （ GC杀完伊甸区没杀干净的 ）\n    * to区： 占新生代的 1/10 （ GC杀伊甸区和from区没杀干净的 ）\n 2. 老年代\n    * GC回收完新生代后残余的（新生代活过15次的）占堆内存的 2/3\n    * GC回收一般只在新生代，只有Full GC的时候才会回收老年代\n 3. 元空间\n    * 跟堆内存没有关系\n\n * 堆调优\n   \n   参数                   含义\n   -Xms                 设置初始分配大小，默认为物理内存的 1/64\n   -Xmx                 最大分配内存，默认为物理内存的 1/4\n   -XX:PrintGCDetails   输出详细的GC处理日志\n   \n   一般jvm调优指的就是堆调优\n\n\n# jvm 调优\n\n * 如何调优：一般初始内存-Xms和最大内存-Xmx调成一样大小，避免GC和应用程序争抢内存，导致内存值忽高忽低\n\n * 配置：在IDEA中 -> 菜单栏Run -> Eidt Configurations -> VM optioins 中输入调优参数\n\n * OOM: java.lang.OutOfMemory：\n\n> 比方说配置的堆内存是4M，但是我们new了一个5M的数组，就会报堆内存溢出异常\n\n> 如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。\n\n\n# GC\n\n\n\n\n# MinorGC的过程（复制->清空->互换）\n\n 1. eden、SurvivorFrom 复制到 SurvivorTo，年龄+1 首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到To区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1\n 2. 清空 eden、SurvivorFrom 然后，清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to\n 3. SurvivorTo和 SurvivorFrom 互换 最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代\n\n\n# GC算法\n\n 1. 引用计数法\n    \n    what：记录的是一个对象被引用的次数（有几个箭头指向我这个地址），如果有人用我就+1，没人用我就-1，到0的时候就被回收\n    \n    缺点：1）每次对象赋值的时候都要维护计数器，且计数器本身也有一定的消耗。2）较难处理循环引用\n    \n    谁用了：微软的COM，python\n\n 2. 复制算法\n    \n    > 年轻代中使用的Minor GC，这种GC算法用的就是复制算法\n    \n    \n    \n    缺点： 消耗空间（每次都从from区复制到to区，也正是from区和to区所占空间为1:1的原因）\n    \n    （对象存活率非常低才适合用）\n    \n    优点：不会产生内存碎片，效率高\n\n 3. 标记清除法\n    \n    > 老年代一般是由标记清除或者是标记清除与标记整理的混合实现\n    \n    \n    \n    \n    \n    what：算法分为“标记”和“清除”两个阶段，首先标记出所需要回收的对象，在标记完成后统一回收掉所有被标记的对象。\n    \n    缺点：1）效率问题：标记和清除的效率都不高(遍历)。2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致大对象无法分配到足够的连续内存，从而不得不提前触发GC，甚至程序中断。\n\n 4. 标记整理法\n    \n    \n    \n    在标记清除后，再对存活对象内存和可用内存进行一遍有序整理（相当于解决内存碎片问题），相当于标记清除的升级版，但效率肯定更慢一点。\n\n 5. 分代收集算法\n    \n    次数上频繁收集young区，次数上较少收集old区，基本不动元空间\n\n\n# Minor GC 和 Full GC\n\n> 都发生在堆中\n\n * Minor GC：是新生代GC，指的是发生在新生代的垃圾收集动作。由于Java对象大都是朝生夕死，所以Minor GC的发生非常频繁，一般回收速度也比较快。\n\n * Full GC/Major GC：是老年代的GC，出现Major GC一般都伴有Minor GC，Major GC肯定比Minor GC慢很多。\n\n * 何时发生？\n   \n   Minor GC：当jvm无法为新对象分配空间的时候就会发生Minor GC，所以new对象的频率越高，越容易触发。\n   \n   Full GC：① 当老年代空间不足的时候会触发Full GC，Full GC 会同时将老年代和新生代的垃圾进行回收。 ②当发生Minor GC的时候可能触发Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不知道自己要担保多少空间，因此老年代采用动态估值的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次Minor GC之后，存活的对象剧增（假设），但此时老年代并没有满，但是此时平均值增加了，就会发生Full GC。\n\n\n# 栈溢出和堆溢出\n\n * 栈溢出：栈溢出是指不断的调用方法，不断的压栈，最终超出了栈允许的栈深度，就会发生栈溢出，比如递归操作没有终止，死循环。\n\n * 栈内存溢出：对于一台服务器而言，每一个用户请求，都会产生一个线程来处理这个请求，每一个线程对应着一个栈，栈会分配内存，此时如果请求过多，这时候内存不够了，就会发生栈内存溢出。\n\n * 堆溢出：不断的new 一个对象，一直创建新的对象， 或者直接创建的对象太大了超过了堆内存（夸张的说）。",normalizedContent:" * jvm\n   * 类装载器\n   * execution engine执行引擎\n   * native interface本地接口\n   * 永久代（元空间）\n   * 栈 stack\n   * 堆 heap\n   * jvm 调优\n * gc\n   * minorgc的过程（复制->清空->互换）\n   * gc算法\n * minor gc 和 full gc\n * 栈溢出和堆溢出\n\n\n\n\n# jvm\n\n * jvm是运行在操作系统之上的，它与硬件没有直接的交互\n\n\n\n\n# 类装载器\n\n 1. 启动类加载器（bootstrap）c++编写：java程序入口，加载java基础包\n 2. 扩展类加载器（extension）java编写：加载 javax 包\n 3. 应用类加载器（appclassloader）java编写：加载我们自己写的类\n 4. 用户自定义加载器：对自带的三种加载器不满足的话，继承classloader，自定义一个我们自己需求的类加载器\n\n\n\n# classloader的双亲委派机制\n\n * 比如我们自己也写了一个名为java.lang.string的类，但启动会报错，因为java类加载是从顶部的启动类加载器：bootstrap开始加载的\n\n> 当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成。\n> \n> 每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到bootstrap中，只有当父类加载器反馈无法完成这个请求的时候（在它的加载路径下没有找到所需的class文件），子类加载器才会尝试自己去加载。\n\n * 正因为这样，所以java是沙箱安全的：防止我们自己写的代码污染java源代码\n\n\n# execution engine执行引擎\n\n * 相当于解释执行器：负责将.class二进制代码文件翻译为操作系统能读懂的机器码，提交操作系统执行\n\n\n# native interface本地接口\n\n * 本地接口的作用是融合不同的编程语言为 java 所用，它的初衷是融合 c/c++程序，java 诞生的时候是 c/c++横行的时候，要想立足，必须调用 c/c++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 native method stack中登记 native方法，在execution engine 执行时加载native libraies。\n * 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过java程序驱动打印机或者java系统管理生产设备，在企业级应用中已经比较少见。因为现在的架构领域间的通信很发达，比如可以使用 socket通信，也可以使用web service等等，不多做介绍。\n\n\n# 永久代（元空间）\n\n * 永久存储区是一个常驻内存区域，用于存放jdk自身所携带的 class,interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 jvm 才会释放此区域所占用的内存。\n\n\n# 栈 stack\n\n * 先进后出，负责java程序的运行，随着线程的创建而开始，随着线程的消亡而结束\n * 在程序从第一个方法（main）开始运行时，每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息\n * 栈帧中主要保存3 类数据：\n   1. 本地变量（local variables）：输入参数和输出参数以及方法内的变量\n   2. 栈操作（operand stack）：记录出栈、入栈的操作\n   3. 栈帧数据（frame data）：包括类文件、方法等等\n\n\n\n\n# 堆 heap\n\n\n\n 1. 新生代\n    * 伊甸区：占新生代的8/10 （98%的gc回收都在这）\n    * from区： 占新生代的 1/10 （ gc杀完伊甸区没杀干净的 ）\n    * to区： 占新生代的 1/10 （ gc杀伊甸区和from区没杀干净的 ）\n 2. 老年代\n    * gc回收完新生代后残余的（新生代活过15次的）占堆内存的 2/3\n    * gc回收一般只在新生代，只有full gc的时候才会回收老年代\n 3. 元空间\n    * 跟堆内存没有关系\n\n * 堆调优\n   \n   参数                   含义\n   -xms                 设置初始分配大小，默认为物理内存的 1/64\n   -xmx                 最大分配内存，默认为物理内存的 1/4\n   -xx:printgcdetails   输出详细的gc处理日志\n   \n   一般jvm调优指的就是堆调优\n\n\n# jvm 调优\n\n * 如何调优：一般初始内存-xms和最大内存-xmx调成一样大小，避免gc和应用程序争抢内存，导致内存值忽高忽低\n\n * 配置：在idea中 -> 菜单栏run -> eidt configurations -> vm optioins 中输入调优参数\n\n * oom: java.lang.outofmemory：\n\n> 比方说配置的堆内存是4m，但是我们new了一个5m的数组，就会报堆内存溢出异常\n\n> 如果出现java.lang.outofmemoryerror: java heap space异常，说明java虚拟机的堆内存不够。原因有二： （1）java虚拟机的堆内存设置不够，可以通过参数-xms、-xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。\n\n\n# gc\n\n\n\n\n# minorgc的过程（复制->清空->互换）\n\n 1. eden、survivorfrom 复制到 survivorto，年龄+1 首先，当eden区满的时候会触发第一次gc,把还活着的对象拷贝到survivorfrom区，当eden区再次触发gc的时候会扫描eden区和from区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到to区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1\n 2. 清空 eden、survivorfrom 然后，清空eden和survivorfrom中的对象，也即复制之后有交换，谁空谁是to\n 3. survivorto和 survivorfrom 互换 最后，survivorto和survivorfrom互换，原survivorto成为下一次gc时的survivorfrom区。部分对象会在from和to区域中复制来复制去,如此交换15次(由jvm参数maxtenuringthreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代\n\n\n# gc算法\n\n 1. 引用计数法\n    \n    what：记录的是一个对象被引用的次数（有几个箭头指向我这个地址），如果有人用我就+1，没人用我就-1，到0的时候就被回收\n    \n    缺点：1）每次对象赋值的时候都要维护计数器，且计数器本身也有一定的消耗。2）较难处理循环引用\n    \n    谁用了：微软的com，python\n\n 2. 复制算法\n    \n    > 年轻代中使用的minor gc，这种gc算法用的就是复制算法\n    \n    \n    \n    缺点： 消耗空间（每次都从from区复制到to区，也正是from区和to区所占空间为1:1的原因）\n    \n    （对象存活率非常低才适合用）\n    \n    优点：不会产生内存碎片，效率高\n\n 3. 标记清除法\n    \n    > 老年代一般是由标记清除或者是标记清除与标记整理的混合实现\n    \n    \n    \n    \n    \n    what：算法分为“标记”和“清除”两个阶段，首先标记出所需要回收的对象，在标记完成后统一回收掉所有被标记的对象。\n    \n    缺点：1）效率问题：标记和清除的效率都不高(遍历)。2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致大对象无法分配到足够的连续内存，从而不得不提前触发gc，甚至程序中断。\n\n 4. 标记整理法\n    \n    \n    \n    在标记清除后，再对存活对象内存和可用内存进行一遍有序整理（相当于解决内存碎片问题），相当于标记清除的升级版，但效率肯定更慢一点。\n\n 5. 分代收集算法\n    \n    次数上频繁收集young区，次数上较少收集old区，基本不动元空间\n\n\n# minor gc 和 full gc\n\n> 都发生在堆中\n\n * minor gc：是新生代gc，指的是发生在新生代的垃圾收集动作。由于java对象大都是朝生夕死，所以minor gc的发生非常频繁，一般回收速度也比较快。\n\n * full gc/major gc：是老年代的gc，出现major gc一般都伴有minor gc，major gc肯定比minor gc慢很多。\n\n * 何时发生？\n   \n   minor gc：当jvm无法为新对象分配空间的时候就会发生minor gc，所以new对象的频率越高，越容易触发。\n   \n   full gc：① 当老年代空间不足的时候会触发full gc，full gc 会同时将老年代和新生代的垃圾进行回收。 ②当发生minor gc的时候可能触发full gc，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不知道自己要担保多少空间，因此老年代采用动态估值的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次minor gc之后，存活的对象剧增（假设），但此时老年代并没有满，但是此时平均值增加了，就会发生full gc。\n\n\n# 栈溢出和堆溢出\n\n * 栈溢出：栈溢出是指不断的调用方法，不断的压栈，最终超出了栈允许的栈深度，就会发生栈溢出，比如递归操作没有终止，死循环。\n\n * 栈内存溢出：对于一台服务器而言，每一个用户请求，都会产生一个线程来处理这个请求，每一个线程对应着一个栈，栈会分配内存，此时如果请求过多，这时候内存不够了，就会发生栈内存溢出。\n\n * 堆溢出：不断的new 一个对象，一直创建新的对象， 或者直接创建的对象太大了超过了堆内存（夸张的说）。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"JWT登陆认证",frontmatter:{title:"JWT登陆认证",date:"2019-04-21T00:00:00.000Z",tags:["jwt"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/jwt.html",relativePath:"views/backend/jwt.md",key:"v-2ed49eb7",path:"/views/backend/jwt.html",headers:[{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:47},{level:2,title:"初识JWT",slug:"初识jwt",normalizedTitle:"初识jwt",charIndex:55},{level:3,title:"jwt的组成",slug:"jwt的组成",normalizedTitle:"jwt的组成",charIndex:66},{level:3,title:"jwt实例",slug:"jwt实例",normalizedTitle:"jwt实例",charIndex:78},{level:2,title:"JWT登陆认证",slug:"jwt登陆认证",normalizedTitle:"jwt登陆认证",charIndex:87},{level:3,title:"认证原理",slug:"认证原理",normalizedTitle:"认证原理",charIndex:100},{level:3,title:"引入pom依赖",slug:"引入pom依赖",normalizedTitle:"引入pom依赖",charIndex:110},{level:3,title:"JwtTokenUtil工具类",slug:"jwttokenutil工具类",normalizedTitle:"jwttokenutil工具类",charIndex:123},{level:2,title:"客户端添加请求头",slug:"客户端添加请求头",normalizedTitle:"客户端添加请求头",charIndex:142},{level:2,title:"jwt+redis使用流程",slug:"jwt-redis使用流程",normalizedTitle:"jwt+redis使用流程",charIndex:154},{level:2,title:"安全问题",slug:"安全问题",normalizedTitle:"安全问题",charIndex:171},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:179},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:185}],excerpt:"<Boxx/>\n<p>基于客户端的用户登录认证（ <strong>轻量</strong>，<strong>安全</strong>，服务端不用记录用户状态信息(<strong>无状态</strong>) ）</p>\n",headersStr:"使用场景 初识JWT jwt的组成 jwt实例 JWT登陆认证 认证原理 引入pom依赖 JwtTokenUtil工具类 客户端添加请求头 jwt+redis使用流程 安全问题 总结 其他",content:'基于客户端的用户登录认证（ 轻量，安全，服务端不用记录用户状态信息(无状态) ）\n\n\n\n * 使用场景\n * 初识JWT\n   * jwt的组成\n   * jwt实例\n * JWT登陆认证\n   * 认证原理\n   * 引入pom依赖\n   * JwtTokenUtil工具类\n * 客户端添加请求头\n * jwt+redis使用流程\n * 安全问题\n * 总结\n * 其他\n\n\n\n\n# 使用场景\n\n * 分布式的登录认证\n * Token 可以是无状态的，可以在多个服务间共享\n\n\n# 初识JWT\n\n * 官网： https://jwt.io/\n\n\n# jwt的组成\n\njwt的组成方式： header.payload.signature\n\n第一部分我们称它为头部（header)， 用于存放签名的生成算法\n\n{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n\n\n1\n2\n3\n4\n\n\n第二部分我们称其为载荷（payload)，用于存放内容\n\n{\n  "sub": "1234567890",\n  "name": "John Doe",\n  "iat": 1516239022\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三部分是签证（String signature)， 一旦header和payload被篡改，验证将失败\n\n//secret为加密算法的密钥，密钥只能由服务端和客户端知悉\nHMACSHA256(\n  base64UrlEncode(header) + "." +\n  base64UrlEncode(payload),your-256-bit-secret\n) \n\n\n1\n2\n3\n4\n5\n\n\n\n# jwt实例\n\n\n\n * 最终的JWT串\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\n\n1\n\n\n\n# JWT登陆认证\n\n\n# 认证原理\n\n * 用户调用登录接口，登录成功后获取到JWT的token；\n * 之后用户每次调用接口都在http的header中添加一个叫Authorization的头，值为JWT的token；\n * 后台程序通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权。\n * JWT登录授权过滤器，拦截请求，从每个请求中获取token，从token中获取负载，从负载中获取用户名放入SpringSecurity中，之后认证授权由SpringSecurity框架管理。\n * 第一次登陆还没有token，用户的登陆信息由SpringSecurity管理认证通过之后，生成jwtToken返回给客户端保存，客户端之后发送请求头携带我们需要的token即可\n\n\n# 引入pom依赖\n\n\x3c!-- JWT --\x3e\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.9.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# JwtTokenUtil工具类\n\n * 主要包括生成token，设置过期时间，验证token是否有效，获取token负载等\n * 工具类可具体参考mall项目\n\npackage com.macro.mall.tiny.common.utils;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * JwtToken生成的工具类\n * Created by macro on 2018/4/26.\n */\n@Component\npublic class JwtTokenUtil {\n    private static final Logger LOGGER = LoggerFactory.getLogger(JwtTokenUtil.class);\n    private static final String CLAIM_KEY_USERNAME = "sub";\n    private static final String CLAIM_KEY_CREATED = "created";\n    @Value("${jwt.secret}")\n    private String secret;\n    @Value("${jwt.expiration}")\n    private Long expiration;\n\n    /**\n     * 根据负责生成JWT的token\n     */\n    private String generateToken(Map<String, Object> claims) {\n        return Jwts.builder()\n                .setClaims(claims)\n                .setExpiration(generateExpirationDate())\n                .signWith(SignatureAlgorithm.HS512, secret)\n                .compact();\n    }\n\n    /**\n     * 从token中获取JWT中的负载\n     */\n    private Claims getClaimsFromToken(String token) {\n        Claims claims = null;\n        try {\n            claims = Jwts.parser()\n                    .setSigningKey(secret)\n                    .parseClaimsJws(token)\n                    .getBody();\n        } catch (Exception e) {\n            LOGGER.info("JWT格式验证失败:{}",token);\n        }\n        return claims;\n    }\n\n    /**\n     * 生成token的过期时间\n     */\n    private Date generateExpirationDate() {\n        return new Date(System.currentTimeMillis() + expiration * 1000);\n    }\n\n    /**\n     * 从token中获取登录用户名\n     */\n    public String getUserNameFromToken(String token) {\n        String username;\n        try {\n            Claims claims = getClaimsFromToken(token);\n            username =  claims.getSubject();\n        } catch (Exception e) {\n            username = null;\n        }\n        return username;\n    }\n\n    /**\n     * 验证token是否还有效\n     *\n     * @param token       客户端传入的token\n     * @param userDetails 从数据库中查询出来的用户信息\n     */\n    public boolean validateToken(String token, UserDetails userDetails) {\n        String username = getUserNameFromToken(token);\n        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);\n    }\n\n    /**\n     * 判断token是否已经失效\n     */\n    private boolean isTokenExpired(String token) {\n        Date expiredDate = getExpiredDateFromToken(token);\n        return expiredDate.before(new Date());\n    }\n\n    /**\n     * 从token中获取过期时间\n     */\n    private Date getExpiredDateFromToken(String token) {\n        Claims claims = getClaimsFromToken(token);\n        return claims.getExpiration();\n    }\n\n    /**\n     * 根据用户信息生成token\n     */\n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());\n        claims.put(CLAIM_KEY_CREATED, new Date());\n        return generateToken(claims);\n    }\n\n    /**\n     * 判断token是否可以被刷新\n     */\n    public boolean canRefresh(String token) {\n        return !isTokenExpired(token);\n    }\n\n    /**\n     * 刷新token\n     */\n    public String refreshToken(String token) {\n        Claims claims = getClaimsFromToken(token);\n        claims.put(CLAIM_KEY_CREATED, new Date());\n        return generateToken(claims);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n\n\n\n# 客户端添加请求头\n\n * js操作cookie\n * js发送请求头\n   * jQuery Ajax可以通过headers或beforeSend修改request的HTTP headers，例如：\n\n$.ajax({\n\turl: "./test.php",\n\ttype: "POST",\n    headers: {\n   \t\t"Accept" : "text/plain; charset=utf-8",\n   \t\t"Content-Type": "text/plain; charset=utf-8"\n    },\n    /*\n    beforeSend: function(jqXHR, settings) {\n    \tjqXHR.setRequestHeader(\'Accept\', \'text/plain; charset=utf-8\');\n    \tjqXHR.setRequestHeader(\'Content-Type\', \'text/plain; charset=utf-8\');\n    },\n    */\n    data: {"user" : "min", "pass" : "he"},\n    error: function(jqXHR, textStatus, errorThrown) {\n    \t//....\n    },\n    success: function(data, textStatus, jqXHR) {\n    \t//....\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# jwt+redis使用流程\n\n 1. 登录：用户第一次登录，校验通过，生成token并存到redis里，返回客户端（token设置过期时间1天，redis设置过期时间0.5小时）。\n\n 2. 鉴权：之后客户端每次请求都携带token，服务端校验token通过并且redis过期时间没过，则redis续期然后返回token；服务端校验token通过但如果redis中token已过期，则失效。\n\n 3. 登出：服务端校验token通过，将redis中的token删除。\n\n\n# 安全问题\n\n 1. 如果其他用户获得我们电脑上的token,那么他们就能模仿真实用户进行操作（黑客监控电脑，获得网站发送的token,进行操作）？\n    \n    对于敏感的api接口，需使用https 。https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。\n\n 2. 我们是否可以伪造用户token进行访问？\n    \n    不可以，因为你无法使用服务器的签名，就是你自己的密钥签名的信息服务器识别不了。\n\n 3. 我们是否可以修改token中body的信息？\n    \n    不能，修改了之后签名信息就不正确，然后就无法验证签名，说明数据被修改了。\n\n 4. app登录后，服务端返回一个token，app存在客户端，下次再打开app时，直接读token，传token到服务端做验证，免去重新输入用户密码的麻烦，这个token存储在header里，目前看大多数app都是这样做，但如果黑客抓包获取到token，伪造http 请求，对服务器做操作，那岂不是很不安全。。。\n    \n    这方法确实不好啊，不能只依赖于http的header里的东西来认证，太容易模仿。最简单的方法可能就是走https，客户端只要接受服务器端的签名即可。\n    \n    理解：签名就是验证信息的唯一性，如果中间人进行获得token，那么无法进行公钥签名，服务器获得token之后还要进行解密的，因此这个方法可以进行避免攻击。\n\n\n# 总结\n\n * 优点：在非跨域环境下使用JWT机制是一个非常不错的选择，实现方式简单，操作方便，能够快速实现。由于服务端不存储用户状态信息，因此大用户量，对后台服务也不会造成压力。\n\n * 缺点：跨域实现相对比较麻烦，安全性也有待探讨。因为JWT令牌返回到页面中，可以使用js获取到，如果遇到XSS攻击令牌可能会被盗取，在JWT还没超时的情况下，就会被获取到敏感数据信息。\n\n * 对于安全问题：\n   \n   对于敏感的api接口，需使用https 。https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。采用https 或者 代码层面也可以做安全检测，比如ip地址发生变化，MAC地址发生变化等等，可以要求重新登录\n\n\n# 其他\n\n * 10分钟了解JSON Web令牌（JWT）\n * 使用JWT实现单点登录（完全跨域方案）*\n * SpringBoot+Security+JWT基础\n * SpringBoot集成JWT实现token验证\n * JWT的使用流程\n * 掌握基于JWT实现的Token身份认证',normalizedContent:'基于客户端的用户登录认证（ 轻量，安全，服务端不用记录用户状态信息(无状态) ）\n\n\n\n * 使用场景\n * 初识jwt\n   * jwt的组成\n   * jwt实例\n * jwt登陆认证\n   * 认证原理\n   * 引入pom依赖\n   * jwttokenutil工具类\n * 客户端添加请求头\n * jwt+redis使用流程\n * 安全问题\n * 总结\n * 其他\n\n\n\n\n# 使用场景\n\n * 分布式的登录认证\n * token 可以是无状态的，可以在多个服务间共享\n\n\n# 初识jwt\n\n * 官网： https://jwt.io/\n\n\n# jwt的组成\n\njwt的组成方式： header.payload.signature\n\n第一部分我们称它为头部（header)， 用于存放签名的生成算法\n\n{\n  "alg": "hs256",\n  "typ": "jwt"\n}\n\n\n1\n2\n3\n4\n\n\n第二部分我们称其为载荷（payload)，用于存放内容\n\n{\n  "sub": "1234567890",\n  "name": "john doe",\n  "iat": 1516239022\n}\n\n\n1\n2\n3\n4\n5\n\n\n第三部分是签证（string signature)， 一旦header和payload被篡改，验证将失败\n\n//secret为加密算法的密钥，密钥只能由服务端和客户端知悉\nhmacsha256(\n  base64urlencode(header) + "." +\n  base64urlencode(payload),your-256-bit-secret\n) \n\n\n1\n2\n3\n4\n5\n\n\n\n# jwt实例\n\n\n\n * 最终的jwt串\n\neyjhbgcioijiuzi1niisinr5cci6ikpxvcj9.eyjzdwiioiixmjm0nty3odkwiiwibmftzsi6ikpvag4grg9liiwiawf0ijoxnte2mjm5mdiyfq.sflkxwrjsmekkf2qt4fwpmejf36pok6yjv_adqssw5c\n\n\n1\n\n\n\n# jwt登陆认证\n\n\n# 认证原理\n\n * 用户调用登录接口，登录成功后获取到jwt的token；\n * 之后用户每次调用接口都在http的header中添加一个叫authorization的头，值为jwt的token；\n * 后台程序通过对authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权。\n * jwt登录授权过滤器，拦截请求，从每个请求中获取token，从token中获取负载，从负载中获取用户名放入springsecurity中，之后认证授权由springsecurity框架管理。\n * 第一次登陆还没有token，用户的登陆信息由springsecurity管理认证通过之后，生成jwttoken返回给客户端保存，客户端之后发送请求头携带我们需要的token即可\n\n\n# 引入pom依赖\n\n\x3c!-- jwt --\x3e\n<dependency>\n    <groupid>io.jsonwebtoken</groupid>\n    <artifactid>jjwt</artifactid>\n    <version>0.9.0</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# jwttokenutil工具类\n\n * 主要包括生成token，设置过期时间，验证token是否有效，获取token负载等\n * 工具类可具体参考mall项目\n\npackage com.macro.mall.tiny.common.utils;\n\nimport io.jsonwebtoken.claims;\nimport io.jsonwebtoken.jwts;\nimport io.jsonwebtoken.signaturealgorithm;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.security.core.userdetails.userdetails;\nimport org.springframework.stereotype.component;\n\nimport java.util.date;\nimport java.util.hashmap;\nimport java.util.map;\n\n/**\n * jwttoken生成的工具类\n * created by macro on 2018/4/26.\n */\n@component\npublic class jwttokenutil {\n    private static final logger logger = loggerfactory.getlogger(jwttokenutil.class);\n    private static final string claim_key_username = "sub";\n    private static final string claim_key_created = "created";\n    @value("${jwt.secret}")\n    private string secret;\n    @value("${jwt.expiration}")\n    private long expiration;\n\n    /**\n     * 根据负责生成jwt的token\n     */\n    private string generatetoken(map<string, object> claims) {\n        return jwts.builder()\n                .setclaims(claims)\n                .setexpiration(generateexpirationdate())\n                .signwith(signaturealgorithm.hs512, secret)\n                .compact();\n    }\n\n    /**\n     * 从token中获取jwt中的负载\n     */\n    private claims getclaimsfromtoken(string token) {\n        claims claims = null;\n        try {\n            claims = jwts.parser()\n                    .setsigningkey(secret)\n                    .parseclaimsjws(token)\n                    .getbody();\n        } catch (exception e) {\n            logger.info("jwt格式验证失败:{}",token);\n        }\n        return claims;\n    }\n\n    /**\n     * 生成token的过期时间\n     */\n    private date generateexpirationdate() {\n        return new date(system.currenttimemillis() + expiration * 1000);\n    }\n\n    /**\n     * 从token中获取登录用户名\n     */\n    public string getusernamefromtoken(string token) {\n        string username;\n        try {\n            claims claims = getclaimsfromtoken(token);\n            username =  claims.getsubject();\n        } catch (exception e) {\n            username = null;\n        }\n        return username;\n    }\n\n    /**\n     * 验证token是否还有效\n     *\n     * @param token       客户端传入的token\n     * @param userdetails 从数据库中查询出来的用户信息\n     */\n    public boolean validatetoken(string token, userdetails userdetails) {\n        string username = getusernamefromtoken(token);\n        return username.equals(userdetails.getusername()) && !istokenexpired(token);\n    }\n\n    /**\n     * 判断token是否已经失效\n     */\n    private boolean istokenexpired(string token) {\n        date expireddate = getexpireddatefromtoken(token);\n        return expireddate.before(new date());\n    }\n\n    /**\n     * 从token中获取过期时间\n     */\n    private date getexpireddatefromtoken(string token) {\n        claims claims = getclaimsfromtoken(token);\n        return claims.getexpiration();\n    }\n\n    /**\n     * 根据用户信息生成token\n     */\n    public string generatetoken(userdetails userdetails) {\n        map<string, object> claims = new hashmap<>();\n        claims.put(claim_key_username, userdetails.getusername());\n        claims.put(claim_key_created, new date());\n        return generatetoken(claims);\n    }\n\n    /**\n     * 判断token是否可以被刷新\n     */\n    public boolean canrefresh(string token) {\n        return !istokenexpired(token);\n    }\n\n    /**\n     * 刷新token\n     */\n    public string refreshtoken(string token) {\n        claims claims = getclaimsfromtoken(token);\n        claims.put(claim_key_created, new date());\n        return generatetoken(claims);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n\n\n\n# 客户端添加请求头\n\n * js操作cookie\n * js发送请求头\n   * jquery ajax可以通过headers或beforesend修改request的http headers，例如：\n\n$.ajax({\n\turl: "./test.php",\n\ttype: "post",\n    headers: {\n   \t\t"accept" : "text/plain; charset=utf-8",\n   \t\t"content-type": "text/plain; charset=utf-8"\n    },\n    /*\n    beforesend: function(jqxhr, settings) {\n    \tjqxhr.setrequestheader(\'accept\', \'text/plain; charset=utf-8\');\n    \tjqxhr.setrequestheader(\'content-type\', \'text/plain; charset=utf-8\');\n    },\n    */\n    data: {"user" : "min", "pass" : "he"},\n    error: function(jqxhr, textstatus, errorthrown) {\n    \t//....\n    },\n    success: function(data, textstatus, jqxhr) {\n    \t//....\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# jwt+redis使用流程\n\n 1. 登录：用户第一次登录，校验通过，生成token并存到redis里，返回客户端（token设置过期时间1天，redis设置过期时间0.5小时）。\n\n 2. 鉴权：之后客户端每次请求都携带token，服务端校验token通过并且redis过期时间没过，则redis续期然后返回token；服务端校验token通过但如果redis中token已过期，则失效。\n\n 3. 登出：服务端校验token通过，将redis中的token删除。\n\n\n# 安全问题\n\n 1. 如果其他用户获得我们电脑上的token,那么他们就能模仿真实用户进行操作（黑客监控电脑，获得网站发送的token,进行操作）？\n    \n    对于敏感的api接口，需使用https 。https是在http超文本传输协议加入ssl层，它在网络间通信是加密的，所以需要加密证书。\n\n 2. 我们是否可以伪造用户token进行访问？\n    \n    不可以，因为你无法使用服务器的签名，就是你自己的密钥签名的信息服务器识别不了。\n\n 3. 我们是否可以修改token中body的信息？\n    \n    不能，修改了之后签名信息就不正确，然后就无法验证签名，说明数据被修改了。\n\n 4. app登录后，服务端返回一个token，app存在客户端，下次再打开app时，直接读token，传token到服务端做验证，免去重新输入用户密码的麻烦，这个token存储在header里，目前看大多数app都是这样做，但如果黑客抓包获取到token，伪造http 请求，对服务器做操作，那岂不是很不安全。。。\n    \n    这方法确实不好啊，不能只依赖于http的header里的东西来认证，太容易模仿。最简单的方法可能就是走https，客户端只要接受服务器端的签名即可。\n    \n    理解：签名就是验证信息的唯一性，如果中间人进行获得token，那么无法进行公钥签名，服务器获得token之后还要进行解密的，因此这个方法可以进行避免攻击。\n\n\n# 总结\n\n * 优点：在非跨域环境下使用jwt机制是一个非常不错的选择，实现方式简单，操作方便，能够快速实现。由于服务端不存储用户状态信息，因此大用户量，对后台服务也不会造成压力。\n\n * 缺点：跨域实现相对比较麻烦，安全性也有待探讨。因为jwt令牌返回到页面中，可以使用js获取到，如果遇到xss攻击令牌可能会被盗取，在jwt还没超时的情况下，就会被获取到敏感数据信息。\n\n * 对于安全问题：\n   \n   对于敏感的api接口，需使用https 。https是在http超文本传输协议加入ssl层，它在网络间通信是加密的，所以需要加密证书。采用https 或者 代码层面也可以做安全检测，比如ip地址发生变化，mac地址发生变化等等，可以要求重新登录\n\n\n# 其他\n\n * 10分钟了解json web令牌（jwt）\n * 使用jwt实现单点登录（完全跨域方案）*\n * springboot+security+jwt基础\n * springboot集成jwt实现token验证\n * jwt的使用流程\n * 掌握基于jwt实现的token身份认证',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"MyBatis中的一、二级缓存",frontmatter:{title:"MyBatis中的一、二级缓存",date:"2021-04-23T00:00:00.000Z",tags:["MyBatis"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html",relativePath:"views/backend/mybatis一二级缓存.md",key:"v-90af05e8",path:"/views/backend/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.html",headers:[{level:2,title:"MyBatis 一级缓存介绍",slug:"mybatis-一级缓存介绍",normalizedTitle:"mybatis 一级缓存介绍",charIndex:3},{level:3,title:"一级缓存是如何失效的",slug:"一级缓存是如何失效的",normalizedTitle:"一级缓存是如何失效的",charIndex:23},{level:2,title:"MyBatis 二级缓存介绍",slug:"mybatis-二级缓存介绍",normalizedTitle:"mybatis 二级缓存介绍",charIndex:37},{level:3,title:"二级缓存开启条件",slug:"二级缓存开启条件",normalizedTitle:"二级缓存开启条件",charIndex:57},{level:3,title:"是否应该使用二级缓存？",slug:"是否应该使用二级缓存",normalizedTitle:"是否应该使用二级缓存？",charIndex:71},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:86}],headersStr:"MyBatis 一级缓存介绍 一级缓存是如何失效的 MyBatis 二级缓存介绍 二级缓存开启条件 是否应该使用二级缓存？ 其他",content:' * MyBatis 一级缓存介绍\n   * 一级缓存是如何失效的\n * MyBatis 二级缓存介绍\n   * 二级缓存开启条件\n   * 是否应该使用二级缓存？\n * 其他\n\n\n\n\n# MyBatis 一级缓存介绍\n\n一级缓存是 SqlSession级别 的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个(内存区域)数据结构（HashMap）用于存储缓存数据。不同的 sqlSession 之间的缓存数据区域（HashMap）是互相不影响的。用一张图来表示一下一级缓存，其中每一个 SqlSession 的内部都会有一个一级缓存对象。\n\n\n\n在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。\n\n\n# 一级缓存是如何失效的\n\n 1. 增删改操作会清空缓存\n\n 2. 不同请求（会话）中的同一个查询，各是各自的缓存，一级缓存是基于会话的。\n    \n    需要注意的是 当Mybatis整合Spring后，直接通过Spring注入Mapper的形式，如果不是在同一个事务中每个Mapper的每次查询操作都对应一个全新的SqlSession实例，这个时候就不会有一级缓存的命中，但是在同一个事务中时共用的是同一个SqlSession。\n\n\n# MyBatis 二级缓存介绍\n\nMyBatis 一级缓存最大的共享范围就是一个SqlSession内部，那么如果多个 SqlSession 需要共享缓存，则需要开启二级缓存，开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示\n\n\n\n当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个共同的 cache，也就是二级缓存被多个 SqlSession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。\n\n\n# 二级缓存开启条件\n\n二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。开启二级缓存的条件也是比较简单，通过直接在 MyBatis 配置文件中通过\n\n<settings>\n\t<setting name = "cacheEnabled" value = "true" />\n</settings>\n\n\n1\n2\n3\n\n\n来开启二级缓存，还需要在 Mapper 的xml 配置文件中加入 <cache>标签\n\n\n# 是否应该使用二级缓存？\n\n那么究竟应该不应该使用二级缓存呢？先来看一下二级缓存的注意事项：\n\n 1. 缓存是以namespace为单位的，不同namespace下的操作互不影响。\n 2. insert,update,delete操作会清空所在namespace下的全部缓存。\n 3. 通常使用MyBatis Generator生成的代码中，都是各个表独立的，每个表都有自己的namespace。\n 4. 多表操作一定不要使用二级缓存，因为多表操作进行更新操作，一定会产生脏数据。（同一个namespace下，多表级联第一次查询后，对其中一张单表更新，再次查询多表级联语句，还是返回第一次查询后的）\n\n如果你遵守二级缓存的注意事项，那么你就可以使用二级缓存。\n\n但是，如果不能使用多表操作，二级缓存不就可以用一级缓存来替换掉吗？而且二级缓存是表级缓存，开销大，没有一级缓存直接使用 HashMap 来存储的效率更高，所以二级缓存并不推荐使用。\n\n\n# 其他\n\nMyBatis 一级缓存\n\nMyBatis 二级缓存',normalizedContent:' * mybatis 一级缓存介绍\n   * 一级缓存是如何失效的\n * mybatis 二级缓存介绍\n   * 二级缓存开启条件\n   * 是否应该使用二级缓存？\n * 其他\n\n\n\n\n# mybatis 一级缓存介绍\n\n一级缓存是 sqlsession级别 的缓存。在操作数据库时需要构造 sqlsession 对象，在对象中有一个(内存区域)数据结构（hashmap）用于存储缓存数据。不同的 sqlsession 之间的缓存数据区域（hashmap）是互相不影响的。用一张图来表示一下一级缓存，其中每一个 sqlsession 的内部都会有一个一级缓存对象。\n\n\n\n在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的sql，mybatis 提供了一级缓存的方案优化这部分场景，如果是相同的sql语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。\n\n\n# 一级缓存是如何失效的\n\n 1. 增删改操作会清空缓存\n\n 2. 不同请求（会话）中的同一个查询，各是各自的缓存，一级缓存是基于会话的。\n    \n    需要注意的是 当mybatis整合spring后，直接通过spring注入mapper的形式，如果不是在同一个事务中每个mapper的每次查询操作都对应一个全新的sqlsession实例，这个时候就不会有一级缓存的命中，但是在同一个事务中时共用的是同一个sqlsession。\n\n\n# mybatis 二级缓存介绍\n\nmybatis 一级缓存最大的共享范围就是一个sqlsession内部，那么如果多个 sqlsession 需要共享缓存，则需要开启二级缓存，开启二级缓存后，会使用 cachingexecutor 装饰 executor，进入一级缓存的查询流程前，先在cachingexecutor 进行二级缓存的查询，具体的工作流程如下所示\n\n\n\n当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个共同的 cache，也就是二级缓存被多个 sqlsession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。\n\n\n# 二级缓存开启条件\n\n二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，mybatis要求返回的pojo必须是可序列化的。开启二级缓存的条件也是比较简单，通过直接在 mybatis 配置文件中通过\n\n<settings>\n\t<setting name = "cacheenabled" value = "true" />\n</settings>\n\n\n1\n2\n3\n\n\n来开启二级缓存，还需要在 mapper 的xml 配置文件中加入 <cache>标签\n\n\n# 是否应该使用二级缓存？\n\n那么究竟应该不应该使用二级缓存呢？先来看一下二级缓存的注意事项：\n\n 1. 缓存是以namespace为单位的，不同namespace下的操作互不影响。\n 2. insert,update,delete操作会清空所在namespace下的全部缓存。\n 3. 通常使用mybatis generator生成的代码中，都是各个表独立的，每个表都有自己的namespace。\n 4. 多表操作一定不要使用二级缓存，因为多表操作进行更新操作，一定会产生脏数据。（同一个namespace下，多表级联第一次查询后，对其中一张单表更新，再次查询多表级联语句，还是返回第一次查询后的）\n\n如果你遵守二级缓存的注意事项，那么你就可以使用二级缓存。\n\n但是，如果不能使用多表操作，二级缓存不就可以用一级缓存来替换掉吗？而且二级缓存是表级缓存，开销大，没有一级缓存直接使用 hashmap 来存储的效率更高，所以二级缓存并不推荐使用。\n\n\n# 其他\n\nmybatis 一级缓存\n\nmybatis 二级缓存',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"MySQL慢查询优化",frontmatter:{title:"MySQL慢查询优化",date:"2020-05-16T00:00:00.000Z",tags:["sql优化"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/mysql_explain.html",relativePath:"views/backend/mysql_explain.md",key:"v-73fde4d7",path:"/views/backend/mysql_explain.html",headers:[{level:2,title:"explain 使用介绍",slug:"explain-使用介绍",normalizedTitle:"explain 使用介绍",charIndex:27},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:43}],excerpt:"<Boxx/>\n<p>通过 <strong>explain</strong> 解析sql运行情况</p>\n",headersStr:"explain 使用介绍 其它",content:"通过 explain 解析sql运行情况\n\n\n\n * explain 使用介绍\n * 其它\n\n\n\n\n# explain 使用介绍\n\n通过 explain，可以查看 sql 语句的执行情况（比如查询的表，使用的索引以及 mysql 在表中找到所需行的方式等） 用 explain 查询 mysql 查询计划的输出参数有:\n\n列名              说明\nid              执行编号，标识 select 所属的行。如果在语句中没子查询或关联查询，只有唯一的 select，每行都将显示\n                1。否则，内层的 select 语句一般会顺序编号，对应于其在原始语句中的位置\nselect_type     显示本行是简单或复杂 select。如果查询有任何复杂的子查询，则最外层标记为\n                PRIMARY（DERIVED、UNION、UNION RESUlT）\ntable           访问引用哪个表（引用某个查询，如 “derived3”）\ntype            数据访问 / 读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL）\npossible_keys   揭示哪一些索引可能有利于高效的查找\nkey             显示 mysql 决定采用哪个索引来优化查询\nkey_len         显示 mysql 在索引里使用的字节数\nref             显示了之前的表在 key 列记录的索引中查找值所用的列或常量\nrows            为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有 rows 列值相乘，可粗略估算整个查询会检查的行数\nExtra           额外信息，如 using index、filesort 等\n\n需要注意的是我们重点关注 type 即可！！！\n\ntype 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL ，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。\n\n类型       说明\nAll      最坏的情况，全表扫描\nindex    和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序，但是开销仍然非常大。如在 Extra\n         列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多\nrange    范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用 =、 <>、>、>=、<、<=、IS\n         NULL、<=>、BETWEEN 或者 IN 操作符，用常量比较关键字列时，可以使用 range\nref      一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟\n         eq_ref 不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是 UNIQUE 和 PRIMARY\n         KEY。ref 可以用于使用 = 或 <=> 操作符的带索引的列。\neq_ref   最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效）\nconst    当确定最多只会有一行匹配的时候，MySQL 优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入 where\n         子句时，mysql 把这个查询转为一个常量（高效）\nsystem   这是 const 连接类型的一种特例，表仅有一行满足条件。\nNull     意味说 mysql 能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效）\n\n\n# 其它\n\n * 0529看见的掘金很nice啊",normalizedContent:"通过 explain 解析sql运行情况\n\n\n\n * explain 使用介绍\n * 其它\n\n\n\n\n# explain 使用介绍\n\n通过 explain，可以查看 sql 语句的执行情况（比如查询的表，使用的索引以及 mysql 在表中找到所需行的方式等） 用 explain 查询 mysql 查询计划的输出参数有:\n\n列名              说明\nid              执行编号，标识 select 所属的行。如果在语句中没子查询或关联查询，只有唯一的 select，每行都将显示\n                1。否则，内层的 select 语句一般会顺序编号，对应于其在原始语句中的位置\nselect_type     显示本行是简单或复杂 select。如果查询有任何复杂的子查询，则最外层标记为\n                primary（derived、union、union result）\ntable           访问引用哪个表（引用某个查询，如 “derived3”）\ntype            数据访问 / 读取操作类型（all、index、range、ref、eq_ref、const/system、null）\npossible_keys   揭示哪一些索引可能有利于高效的查找\nkey             显示 mysql 决定采用哪个索引来优化查询\nkey_len         显示 mysql 在索引里使用的字节数\nref             显示了之前的表在 key 列记录的索引中查找值所用的列或常量\nrows            为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有 rows 列值相乘，可粗略估算整个查询会检查的行数\nextra           额外信息，如 using index、filesort 等\n\n需要注意的是我们重点关注 type 即可！！！\n\ntype 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > all ，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。\n\n类型       说明\nall      最坏的情况，全表扫描\nindex    和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序，但是开销仍然非常大。如在 extra\n         列看到 using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多\nrange    范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用 =、 <>、>、>=、<、<=、is\n         null、<=>、between 或者 in 操作符，用常量比较关键字列时，可以使用 range\nref      一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟\n         eq_ref 不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是 unique 和 primary\n         key。ref 可以用于使用 = 或 <=> 操作符的带索引的列。\neq_ref   最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效）\nconst    当确定最多只会有一行匹配的时候，mysql 优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入 where\n         子句时，mysql 把这个查询转为一个常量（高效）\nsystem   这是 const 连接类型的一种特例，表仅有一行满足条件。\nnull     意味说 mysql 能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效）\n\n\n# 其它\n\n * 0529看见的掘金很nice啊",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"IOC底层实现原理介绍，手动实现IOC容器",frontmatter:{title:"IOC底层实现原理介绍，手动实现IOC容器",date:"2022-03-23T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/mini-ioc.html",relativePath:"views/backend/mini-ioc.md",key:"v-3e9083fd",path:"/views/backend/mini-ioc.html",headers:[{level:3,title:"需要实现的IOC功能",slug:"需要实现的ioc功能",normalizedTitle:"需要实现的ioc功能",charIndex:103},{level:3,title:"实现简易IOC设计的类",slug:"实现简易ioc设计的类",normalizedTitle:"实现简易ioc设计的类",charIndex:117},{level:3,title:"类之间关系模型",slug:"类之间关系模型",normalizedTitle:"类之间关系模型",charIndex:132},{level:4,title:"前期准备",slug:"前期准备",normalizedTitle:"前期准备",charIndex:693},{level:2,title:"mini-IOC容器-定义类",slug:"mini-ioc容器-定义类",normalizedTitle:"mini-ioc容器-定义类",charIndex:3291},{level:2,title:"mini-IOC容器--解析注册",slug:"mini-ioc容器-解析注册",normalizedTitle:"mini-ioc容器--解析注册",charIndex:7191},{level:2,title:"mini-IOC容器-getBean",slug:"mini-ioc容器-getbean",normalizedTitle:"mini-ioc容器-getbean",charIndex:10612},{level:2,title:"mini-IOC容器-单例对象初始化",slug:"mini-ioc容器-单例对象初始化",normalizedTitle:"mini-ioc容器-单例对象初始化",charIndex:15785},{level:2,title:"mini-IOC容器-测试和小结",slug:"mini-ioc容器-测试和小结",normalizedTitle:"mini-ioc容器-测试和小结",charIndex:16396},{level:2,title:"IOC容器源码及其它面试细节",slug:"ioc容器源码及其它面试细节",normalizedTitle:"ioc容器源码及其它面试细节",charIndex:16740},{level:3,title:"扩展: 容器如何创建对象",slug:"扩展-容器如何创建对象",normalizedTitle:"扩展: 容器如何创建对象",charIndex:16759},{level:3,title:"扩展: bean的生命周期",slug:"扩展-bean的生命周期",normalizedTitle:"扩展: bean的生命周期",charIndex:16917},{level:3,title:"扩展: bean的循环依赖问题",slug:"扩展-bean的循环依赖问题",normalizedTitle:"扩展: bean的循环依赖问题",charIndex:17475},{level:3,title:"扩展: bean的覆盖问题",slug:"扩展-bean的覆盖问题",normalizedTitle:"扩展: bean的覆盖问题",charIndex:18682}],excerpt:"<Boxx/>\n<p>Spring源码晦涩难懂怎么办呢? 自己手动实现一个mini ioc容器吧，实现后再回头看Spring源码事半功倍哦，就算直接和面试官讲也完全可以哦，类名完全按照源码设计，话不多说直接开干~!</p>\n",headersStr:"需要实现的IOC功能 实现简易IOC设计的类 类之间关系模型 前期准备 mini-IOC容器-定义类 mini-IOC容器--解析注册 mini-IOC容器-getBean mini-IOC容器-单例对象初始化 mini-IOC容器-测试和小结 IOC容器源码及其它面试细节 扩展: 容器如何创建对象 扩展: bean的生命周期 扩展: bean的循环依赖问题 扩展: bean的覆盖问题",content:'Spring源码晦涩难懂怎么办呢? 自己手动实现一个mini ioc容器吧，实现后再回头看Spring源码事半功倍哦，就算直接和面试官讲也完全可以哦，类名完全按照源码设计，话不多说直接开干~!\n\n\n\n * 需要实现的IOC功能\n * 实现简易IOC设计的类\n * 类之间关系模型\n\n\n\n\n# 需要实现的IOC功能\n\n * 可以通过xml配置bean信息\n * 可以通过容器getBean获取对象\n * 能够根据Bean的依赖属性实现依赖注入\n * 可以配置Bean的单例多例\n\n\n# 实现简易IOC设计的类\n\n类/接口                         说明\nBeanFactory                  IOC容器的基础接口，提供IOC容器的基本功能\nDefaultListableBeanFactory   IOC容器的核心实现类，提供多个map集合用来存储bean的定义对象，提供getBean方法的核心实现\nXmlBeanFactory               IOC容器的实现类，基于xml构建bean信息\nXmlBeanDefinitionReader      用于解析xml信息，并提供解析Document文档的方法，并将解析到的BeanDefinition对象注册到核心容器中\nBeanDefinition               封装Bean的定义对象，如: bean的id class,scope ..等等\nProperty                     封装Bean所关联依赖的属性\n\n\n# 类之间关系模型\n\n\n\n# 前期准备\n\n创建maven项目引入依赖\n\n<dependencies>\n    \x3c!-- 解析xml --\x3e\n    <dependency>\n        <groupId>dom4j</groupId>\n        <artifactId>dom4j</artifactId>\n        <version>1.1</version>\n    </dependency>\n    \x3c!-- BeanUtils    --\x3e\n    <dependency>\n        <groupId>commons-beanutils</groupId>\n        <artifactId>commons-beanutils</artifactId>\n        <version>1.9.3</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n准备3个bean的实体类\n\n/**\n * 学生类  \n * 学生类依赖班级对象\n * 并提供 sayHello() 方法\n **/\npublic class Student {\n    private String name;\n    private TClass tClass;\n    public void sayHello(){\n        System.out.println("大家好,我是" +this.name+" 我的班级是==>"+tClass.getCname() + " 我的老师是"+tClass.getTeacher().getTname());\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public TClass gettClass() {\n        return tClass;\n    }\n    public void settClass(TClass tClass) {\n        this.tClass = tClass;\n    }\n}\n/**\n * 班级类\n * 班级类依赖教师对象\n **/\npublic class TClass {\n    private String cname;// 班级名称\n    private Teacher teacher; // 老师\n    public String getCname() {\n        return cname;\n    }\n    public void setCname(String cname) {\n        this.cname = cname;\n    }\n    public com.itcast.ioc.bean.Teacher getTeacher() {\n        return teacher;\n    }\n    public void setTeacher(com.itcast.ioc.bean.Teacher teacher) {\n        this.teacher = teacher;\n    }\n}\n/**\n * 教师类\n **/\npublic class Teacher {\n    private String tname;// 老师名称\n    public String getTname() {\n        return tname;\n    }\n    public void setTname(String tname) {\n        this.tname = tname;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\nxml配置对象\n\n配置学生对象: 小明\n\n依赖班级对象: 3年2班\n\n依赖教师对象: 陈老师\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans>\n    \x3c!-- 配置IOC容器要管理的对象   bean作用域: 单例  原型 --\x3e\n    <bean id="student" class="com.itcast.ioc.bean.Student" scope="singleton"\n          lazy-init="true">\n        \x3c!-- 依赖注入:   属性注入    构造器注入   注解注入--\x3e\n        <property name="name" value="小明"></property>\n        <property name="tClass" ref="tclass"></property>\n    </bean>\n    <bean id="tclass" class="com.itcast.ioc.bean.TClass">\n        <property name="cname" value="3年2班"></property>\n        <property name="teacher" ref="teacher"></property>\n    </bean>\n    <bean id="teacher" class="com.itcast.ioc.bean.Teacher">\n        <property name="tname" value="陈老师"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# mini-IOC容器-定义类\n\n定义BeanFactory\n\n/**\n * 容器的基础接口\n * 提供容器最基本的功能\n */\npublic interface BeanFactory {\n    // 核心方法 获取对象\n    Object getBean(String beanName);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n定义DefaultListableBeanFactory\n\npackage com.itcast.ioc.core;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * 基础容器的核心实现\n * 提供 beanDefinitionMap 存储bean的定义\n * 提供 singletonObjects 存储bean的对象实例\n **/\npublic class DefaultListableBeanFactory implements BeanFactory {\n    // 提供 beanDefinitionMap 存储bean的定义\n    private Map<String,BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>();\n    // 提供 singletonObjects 存储bean的对象实例 (scope为singleton的)\n    private Map<String,Object> singletonObjects = new ConcurrentHashMap<>();\n    /**\n     * 实现getBean方法\n     * @param beanName\n     * @return\n     */\n    @Override\n    public Object getBean(String beanName) {\n        return null;\n    }\n    /**\n     * 将bean注册到容器中\n     * @param beanDefinition\n     */\n    public void registerBeanDefinition(BeanDefinition beanDefinition){\n        beanDefinitionMap.put(beanDefinition.getBeanName(),beanDefinition);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n定义BeanDefnition\n\n/**\n * 用于描述Bean的定义\n **/\npublic class BeanDefinition {\n    private String beanName; // bean标签的ID 作为bean的唯一标识\n    private String className; // bean的所属class\n    private String scope = "singleton";  // bean的scope作用域\n    private List<Property> propertyList = new ArrayList<>();\n    public String getBeanName() {\n        return beanName;\n    }\n    public void setBeanName(String beanName) {\n        this.beanName = beanName;\n    }\n    public String getClassName() {\n        return className;\n    }\n    public void setClassName(String className) {\n        this.className = className;\n    }\n    public String getScope() {\n        return scope;\n    }\n    public void setScope(String scope) {\n        this.scope = scope;\n    }\n    public List<Property> getPropertyList() {\n        return propertyList;\n    }\n    public void setPropertyList(List<Property> propertyList) {\n        this.propertyList = propertyList;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n定义Property\n\n/**\n * 用于封装一个property标签\n * 属性数据\n **/\npublic class Property {\n    private String name; // 属性名称\n    private String value; // 属性的值\n    private String ref; // 属性的引用\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getValue() {\n        return value;\n    }\n    public void setValue(String value) {\n        this.value = value;\n    }\n    public String getRef() {\n        return ref;\n    }\n    public void setRef(String ref) {\n        this.ref = ref;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n定义XmlBeanFactory\n\n/**\n * 继承核心实现类\n * 基于xml配置bean的实现类\n **/\npublic class XmlBeanFactory extends DefaultListableBeanFactory {\n    /**\n     * 将解析配置文件 注册bean的所有工作交给reader对象\n     */\n    final XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(this);\n    /**\n     * 构造器需要传入xml配置文件\n     * @param configPath\n     */\n    public XmlBeanFactory(String configPath) {\n        // 使用reader对象 解析配置  注册Bean\n        this.xmlBeanDefinitionReader.loadBeanDefinitions(configPath);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n定义XmlBeanDefinitionReader\n\n/**\n * 解析配置\n * 注册到容器中\n **/\npublic class XmlBeanDefinitionReader {\n    // 核心beanfactory对象 用于将解析后的bean注册到beanfactory中\n    final DefaultListableBeanFactory beanFactory;\n    public XmlBeanDefinitionReader(DefaultListableBeanFactory beanFactory) {\n        this.beanFactory = beanFactory;\n    }\n    /**\n     * 根据传递的配置文件\n     * 解析配置\n     * 注册bean\n     * @param configPath\n     */\n    void loadBeanDefinitions(String configPath){\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# mini-IOC容器--解析注册\n\n实现步骤\n\n 1. 通过dom4j解析xml得到Document文档\n\n 2. 遍历文档所有Bean标签\n\n 3. 解析每一个Bean标签 封装一个BeanDefinition对象\n\n 4. 解析每一个Bean标签下的所有Property标签 封装一个Property对象\n\n 5. 将BeanDefinition和Property对象注册到容器\n\n实现xml解析及bean注册\n\n/**\n * 解析配置\n * 注册到容器中\n **/\npublic class XmlBeanDefinitionReader {\n    // 核心beanfactory对象 用于将解析后的bean注册到beanfactory中\n    final DefaultListableBeanFactory beanFactory;\n    public XmlBeanDefinitionReader(DefaultListableBeanFactory beanFactory) {\n        this.beanFactory = beanFactory;\n    }\n    /**\n     * 根据传递的配置文件\n     * 解析配置\n     * 注册bean\n     * @param configPath\n     */\n    void loadBeanDefinitions(String configPath){\n        // 1. 通过dom4j解析xml得到Document文档\n        Document document = doLoadDocument(configPath);\n        // 2. 遍历文档所有Bean标签\n        Element rootElement = document.getRootElement();\n        List<Element> list = rootElement.selectNodes("//bean");\n        for (Element element : list) {\n            // 3. 解析每一个Bean标签 封装一个BeanDefinition对象\n            BeanDefinition beanDefinition = parseBeanDefinition(element);\n            // 5. 将BeanDefinition和Property对象注册到容器\n            beanFactory.registerBeanDefinition(beanDefinition);\n        }\n    }\n    /**\n     * 3. 解析每一个Bean标签 封装一个BeanDefinition对象\n     * 4. 解析每一个Bean标签下的所有Property标签 封装一个Property对象\n     */\n    BeanDefinition parseBeanDefinition(Element element){\n        BeanDefinition beanDefinition = new BeanDefinition();\n        String beanName = element.attributeValue("id");\n        String className = element.attributeValue("class");\n        String scope = element.attributeValue("scope");\n        beanDefinition.setBeanName(beanName);\n        beanDefinition.setClassName(className);\n        if(scope!=null&&!"".equals(scope)){\n            beanDefinition.setScope(scope);\n        }\n        List<Element> propertyList = element.elements("property");\n        for (Element propertyEle : propertyList) {\n            Property property = new Property();\n            property.setName(propertyEle.attributeValue("name"));\n            property.setValue(propertyEle.attributeValue("value"));\n            property.setRef(propertyEle.attributeValue("ref"));\n            beanDefinition.getPropertyList().add(property);\n        }\n        return beanDefinition;\n    }\n    /**\n     * 解析Document文档\n     * @param configPath\n     * @return\n     */\n    Document doLoadDocument(String configPath){\n        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(configPath);\n        SAXReader saxReader = new SAXReader();\n        try {\n            return saxReader.read(inputStream);\n        } catch (DocumentException e) {\n            e.printStackTrace();\n            System.out.println("解析xml出现异常==>"+e.getMessage());\n            throw new RuntimeException(e.getMessage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n准备测试类\n\n/**\n * 测试类\n **/\npublic class IocTest {\n    public static void main(String[] args) {\n        // 创建IOC容器\n        BeanFactory beanFactory = new XmlBeanFactory("applicationContext.xml");\n        // 通过容器获取对象\n        Student student = (Student)beanFactory.getBean("student");\n        // 调用对象sayHello方法\n        student.sayHello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n断点查看注册情况\n\n可以看到我们配置的xml内容 已经解析成了BeanDefinition对象，注册到了核心容器的map中\n\n\n\n\n# mini-IOC容器-getBean\n\n实现步骤\n\n 1. 先从单例的map集合中获取 是否有指定beanName的对象\n\n·有直接返回\n\n·没有下一步\n\n 2. 从注册集合中获取bean的定义对象\n\n·有下一步\n\n·没有抛异常NoSuchBeanDefinition\n\n 3. 判断bean的scope作用域\n\nsingleton单例\n\n· createBean对象\n\n·存入单例集合\n\n·返回对象\n\nprototype多例\n\n·createBean对象\n\n·返回对象\n\n 4. createBean方法\n\n获取BeanDefinition中的className\n\n通过反射API得到Class对象\n\n通过反射API得到bean实例\n\n获取BeanDefinition中依赖的属性列表\n\n实现属性的依赖注入\n\n实现getBean及createBean方法\n\n/**\n * 基础容器的核心实现\n * 提供 beanDefinitionMap 存储bean的定义\n * 提供 singletonObjects 存储bean的对象实例\n **/\npublic class DefaultListableBeanFactory implements BeanFactory {\n    // 提供 beanDefinitionMap 存储bean的定义\n    private Map<String,BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>();\n    // 提供 singletonObjects 存储bean的对象实例 (scope为singleton的)\n    private Map<String,Object> singletonObjects = new ConcurrentHashMap<>();\n    /**\n     * 实现getBean方法\n     * @param beanName\n     * @return\n     */\n    @Override\n    public Object getBean(String beanName) {\n//        1. 先从单例的map集合中获取 是否有指定beanName的对象\n        Object singletonObj = singletonObjects.get(beanName);\n//                有直接返回\n        if(singletonObj!=null){\n            return singletonObj;\n        }\n//                没有下一步\n//        2. 从注册集合中获取bean的定义对象\n        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);\n//                有下一步\n//        没有抛异常NoSuchBeanDefinition\n        if(beanDefinition==null){\n            throw new RuntimeException("NoSuchBeanDefinition : 你找的 "+beanName+" 对象 不存在");\n        }\n//        3. 判断bean的scope作用域\n        String scope = beanDefinition.getScope();\n//                singleton单例\n        if("singleton".equals(scope)){\n//        createBean对象\n            Object obj = createBean(beanDefinition);\n//        存入单例集合\n            singletonObjects.put(beanName,obj);\n//        返回对象\n            return obj;\n        }else {\n//        prototype多例\n//        createBean对象\n            return createBean(beanDefinition);\n//        返回对象\n        }\n    }\n    /**\n     * //4. createBean方法\n     * //获取BeanDefinition中的className\n     * //通过反射API得到Class对象\n     * //通过反射API得到bean实例\n     * //获取BeanDefinition中依赖的属性列表\n     * //实现属性的依赖注入\n     * 创建对象\n     * @param beanDefinition\n     * @return\n     */\n    Object createBean(BeanDefinition beanDefinition){\n        String className = beanDefinition.getClassName();\n        Class<?> aClass;\n        try {\n            aClass = Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            throw new RuntimeException("类未找到"+e.getMessage());\n        }\n        // 创建对象:\n        Object obj;\n        try {\n            obj = aClass.newInstance();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n            throw new RuntimeException("创建对象失败"+e.getMessage());\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n            throw new RuntimeException("非法访问"+e.getMessage());\n        }\n        // 依赖注入\n        List<Property> propertyList = beanDefinition.getPropertyList();\n        for (Property property : propertyList) {\n            String name = property.getName();\n            String value = property.getValue();\n            String ref = property.getRef();\n            // 属性名不为空 进行注入\n            if(name!=null&&!"".equals(name)){\n                // 如果配置的是value值 直接注入\n                if(value!=null&&!"".equals(value)){\n                    Map<String,String> params = new HashMap<>();\n                    params.put(name,value);\n                    try {\n                        BeanUtils.populate(obj,params);\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                        throw new RuntimeException("非法访问"+e.getMessage());\n                    } catch (InvocationTargetException e) {\n                        e.printStackTrace();\n                        throw new RuntimeException("调用目标对象失败"+e.getMessage());\n                    }\n                }\n                // 如果配置的是ref需要获取其它对象注入\n                if(ref!=null&&!"".equals(ref)){\n                    try {\n                        BeanUtils.setProperty(obj,name,getBean(ref));\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                        throw new RuntimeException("非法访问"+e.getMessage());\n                    } catch (InvocationTargetException e) {\n                        e.printStackTrace();\n                        throw new RuntimeException("调用目标对象失败"+e.getMessage());\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n    /**\n     * 将bean注册到容器中\n     * @param beanDefinition\n     */\n    public void registerBeanDefinition(BeanDefinition beanDefinition){\n        beanDefinitionMap.put(beanDefinition.getBeanName(),beanDefinition);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n\n# mini-IOC容器-单例对象初始化\n\nDefaultListableBeanFactory增加初始化方法\n\npublic void preInstaniceSingletons(){\n        beanDefinitionMap.forEach((beanName,beanDefinition)->{\n            String scope = beanDefinition.getScope();\n            // 判断单例  非抽象   不懒加载\n            if("singleton".equals(scope)){\n                this.getBean(beanName);\n            }\n        });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nXmlBeanFactory增加单例对象初始化\n\npublic XmlBeanFactory(String configPath) {\n   // 使用reader对象 解析配置  注册Bean\n   this.xmlBeanDefinitionReader.loadBeanDefinitions(configPath);\n   // 初始化单例对象\n   this.preInstaniceSingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# mini-IOC容器-测试和小结\n\n测试对象能否获取\n\npublic class IocTest {\n    public static void main(Stiring[] args) {\n        BeanFactory beanFactory = new XmlBeanFactory("applicationContext.xml");\n        Student student = (Student) beanFactory.getBean("student");\n        student.sayHello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n查看bean的注册及单例集合信息\n\n可以通过变更scope的值查看对应的变化\n\n\n\n\n# IOC容器源码及其它面试细节\n\n\n# 扩展: 容器如何创建对象\n\nIOC容器在准备创建对象时， 会判断是否有配置 factory-method方法\n\n如果有配置 会调用factory-method所指向的方法构建对象.\n\n如果没配置，会检查是否有配置构造参数\n\n无构造参数: 调用默认构造器创建对象\n\n有构造参数: 根据参数情况匹配对应的构造器\n\n\n# 扩展: bean的生命周期\n\nspring 容器中的bean的完整生命周期一共分为十一步完成。\n\n1.bean对象的实例化\n\n2.封装属性，也就是设置properties中的属性值\n\n3.如果bean实现了BeanNameAware，则执行setBeanName方法,也就是bean中的id值\n\n4.如果实现BeanFactoryAware或者ApplicationContextAware ，需要设置setBeanFactory或者上下文对象setApplicationContext\n\n5.如果存在类实现BeanPostProcessor后处理bean，执行postProcessBeforeInitialization，可以在初始化之前执行一些方法\n\n6.如果bean实现了InitializingBean，则执行afterPropertiesSet，执行属性设置之后的操作\n\n7.调用执行指定的初始化方法\n\n8.如果存在类实现BeanPostProcessor则执行postProcessAfterInitialization，执行初始化之后的操作\n\n9.执行自身的业务方法\n\n10.如果bean实现了DisposableBean，则执行spring的的销毁方法\n\n11.调用执行自定义的销毁方法。\n\n\n# 扩展: bean的循环依赖问题\n\nA 依赖 B B 依赖 A 产生闭环，称为循环依赖\n\n·Spring 默认允许单例对象的属性注入 所产生的循环依赖\n\n单例对象的循环依赖 Spring通过3级缓存来解决\n\n比如一个类A中有一个属性是B类，B类中有一个属性是A类，这时看Spring是怎么解决他们的相互依赖的。Spring注入一个类的大体步骤分为两部分，一是先完成对类的构造工作，二是会对类的属性进行设置和填充。首先Spring构造A类，通过AbstractAutowireCapableBeanFactory的doCreateBean方法中调用addSingletonFactory方法将A类曝光到singletonFactories中。这时完成A的构造后，需要填充B属性，继续第二步，发现B还没有构造，于是开始B流程的构造过程，构造的时候发现需要填充A，从第三层缓存singletonFactories中找到A(此时的A还没有完全构造完成，但是可以拿到A的一个引用)，B拿到A的引用后，完成B自己的填充属性工作，完成初始化工作，把自己放到第一层缓存singletonObjects中。这时回到A的这边，在拿到B对象后，完成自己的填充属性工作。\n\n源码                      级别     描述\nsingletonObjects        一级缓存   用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用\nearlySingletonObjects   二级缓存   存放原始的 bean 对象（尚未填充属性），用于解决循环依赖\nsingletonFactories      三级缓存   存放 bean 工厂对象，用于解决循环依赖·如果是构造器依赖属性 会报循环依赖异常\n\n·如果对象都是多例对象 会报循环依赖异常\n\n·如果设置allowCircularReferences为false 会报循环依赖异常\n\nprotected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n   if (this.allowBeanDefinitionOverriding != null) {\n      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   if (this.allowCircularReferences != null) {\n      beanFactory.setAllowCircularReferences(this.allowCircularReferences);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 扩展: bean的覆盖问题\n\n默认情况:\n\n同一个配置文件中出现id相同的bean会报错，不同的配置文件出现id相同的bean后加，载的bean会将先加载的bean覆盖掉称为bean的覆盖，bean的覆盖不会报错，但可能影响我们的项目，可以通过属性设置不允许bean的覆盖，allowBeanDefinitionOverriding设置为false。',normalizedContent:'spring源码晦涩难懂怎么办呢? 自己手动实现一个mini ioc容器吧，实现后再回头看spring源码事半功倍哦，就算直接和面试官讲也完全可以哦，类名完全按照源码设计，话不多说直接开干~!\n\n\n\n * 需要实现的ioc功能\n * 实现简易ioc设计的类\n * 类之间关系模型\n\n\n\n\n# 需要实现的ioc功能\n\n * 可以通过xml配置bean信息\n * 可以通过容器getbean获取对象\n * 能够根据bean的依赖属性实现依赖注入\n * 可以配置bean的单例多例\n\n\n# 实现简易ioc设计的类\n\n类/接口                         说明\nbeanfactory                  ioc容器的基础接口，提供ioc容器的基本功能\ndefaultlistablebeanfactory   ioc容器的核心实现类，提供多个map集合用来存储bean的定义对象，提供getbean方法的核心实现\nxmlbeanfactory               ioc容器的实现类，基于xml构建bean信息\nxmlbeandefinitionreader      用于解析xml信息，并提供解析document文档的方法，并将解析到的beandefinition对象注册到核心容器中\nbeandefinition               封装bean的定义对象，如: bean的id class,scope ..等等\nproperty                     封装bean所关联依赖的属性\n\n\n# 类之间关系模型\n\n\n\n# 前期准备\n\n创建maven项目引入依赖\n\n<dependencies>\n    \x3c!-- 解析xml --\x3e\n    <dependency>\n        <groupid>dom4j</groupid>\n        <artifactid>dom4j</artifactid>\n        <version>1.1</version>\n    </dependency>\n    \x3c!-- beanutils    --\x3e\n    <dependency>\n        <groupid>commons-beanutils</groupid>\n        <artifactid>commons-beanutils</artifactid>\n        <version>1.9.3</version>\n    </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n准备3个bean的实体类\n\n/**\n * 学生类  \n * 学生类依赖班级对象\n * 并提供 sayhello() 方法\n **/\npublic class student {\n    private string name;\n    private tclass tclass;\n    public void sayhello(){\n        system.out.println("大家好,我是" +this.name+" 我的班级是==>"+tclass.getcname() + " 我的老师是"+tclass.getteacher().gettname());\n    }\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n    public tclass gettclass() {\n        return tclass;\n    }\n    public void settclass(tclass tclass) {\n        this.tclass = tclass;\n    }\n}\n/**\n * 班级类\n * 班级类依赖教师对象\n **/\npublic class tclass {\n    private string cname;// 班级名称\n    private teacher teacher; // 老师\n    public string getcname() {\n        return cname;\n    }\n    public void setcname(string cname) {\n        this.cname = cname;\n    }\n    public com.itcast.ioc.bean.teacher getteacher() {\n        return teacher;\n    }\n    public void setteacher(com.itcast.ioc.bean.teacher teacher) {\n        this.teacher = teacher;\n    }\n}\n/**\n * 教师类\n **/\npublic class teacher {\n    private string tname;// 老师名称\n    public string gettname() {\n        return tname;\n    }\n    public void settname(string tname) {\n        this.tname = tname;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\nxml配置对象\n\n配置学生对象: 小明\n\n依赖班级对象: 3年2班\n\n依赖教师对象: 陈老师\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans>\n    \x3c!-- 配置ioc容器要管理的对象   bean作用域: 单例  原型 --\x3e\n    <bean id="student" class="com.itcast.ioc.bean.student" scope="singleton"\n          lazy-init="true">\n        \x3c!-- 依赖注入:   属性注入    构造器注入   注解注入--\x3e\n        <property name="name" value="小明"></property>\n        <property name="tclass" ref="tclass"></property>\n    </bean>\n    <bean id="tclass" class="com.itcast.ioc.bean.tclass">\n        <property name="cname" value="3年2班"></property>\n        <property name="teacher" ref="teacher"></property>\n    </bean>\n    <bean id="teacher" class="com.itcast.ioc.bean.teacher">\n        <property name="tname" value="陈老师"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# mini-ioc容器-定义类\n\n定义beanfactory\n\n/**\n * 容器的基础接口\n * 提供容器最基本的功能\n */\npublic interface beanfactory {\n    // 核心方法 获取对象\n    object getbean(string beanname);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n定义defaultlistablebeanfactory\n\npackage com.itcast.ioc.core;\n\nimport java.util.map;\nimport java.util.concurrent.concurrenthashmap;\n\n/**\n * 基础容器的核心实现\n * 提供 beandefinitionmap 存储bean的定义\n * 提供 singletonobjects 存储bean的对象实例\n **/\npublic class defaultlistablebeanfactory implements beanfactory {\n    // 提供 beandefinitionmap 存储bean的定义\n    private map<string,beandefinition> beandefinitionmap = new concurrenthashmap<>();\n    // 提供 singletonobjects 存储bean的对象实例 (scope为singleton的)\n    private map<string,object> singletonobjects = new concurrenthashmap<>();\n    /**\n     * 实现getbean方法\n     * @param beanname\n     * @return\n     */\n    @override\n    public object getbean(string beanname) {\n        return null;\n    }\n    /**\n     * 将bean注册到容器中\n     * @param beandefinition\n     */\n    public void registerbeandefinition(beandefinition beandefinition){\n        beandefinitionmap.put(beandefinition.getbeanname(),beandefinition);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n定义beandefnition\n\n/**\n * 用于描述bean的定义\n **/\npublic class beandefinition {\n    private string beanname; // bean标签的id 作为bean的唯一标识\n    private string classname; // bean的所属class\n    private string scope = "singleton";  // bean的scope作用域\n    private list<property> propertylist = new arraylist<>();\n    public string getbeanname() {\n        return beanname;\n    }\n    public void setbeanname(string beanname) {\n        this.beanname = beanname;\n    }\n    public string getclassname() {\n        return classname;\n    }\n    public void setclassname(string classname) {\n        this.classname = classname;\n    }\n    public string getscope() {\n        return scope;\n    }\n    public void setscope(string scope) {\n        this.scope = scope;\n    }\n    public list<property> getpropertylist() {\n        return propertylist;\n    }\n    public void setpropertylist(list<property> propertylist) {\n        this.propertylist = propertylist;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n定义property\n\n/**\n * 用于封装一个property标签\n * 属性数据\n **/\npublic class property {\n    private string name; // 属性名称\n    private string value; // 属性的值\n    private string ref; // 属性的引用\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n    public string getvalue() {\n        return value;\n    }\n    public void setvalue(string value) {\n        this.value = value;\n    }\n    public string getref() {\n        return ref;\n    }\n    public void setref(string ref) {\n        this.ref = ref;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n定义xmlbeanfactory\n\n/**\n * 继承核心实现类\n * 基于xml配置bean的实现类\n **/\npublic class xmlbeanfactory extends defaultlistablebeanfactory {\n    /**\n     * 将解析配置文件 注册bean的所有工作交给reader对象\n     */\n    final xmlbeandefinitionreader xmlbeandefinitionreader = new xmlbeandefinitionreader(this);\n    /**\n     * 构造器需要传入xml配置文件\n     * @param configpath\n     */\n    public xmlbeanfactory(string configpath) {\n        // 使用reader对象 解析配置  注册bean\n        this.xmlbeandefinitionreader.loadbeandefinitions(configpath);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n定义xmlbeandefinitionreader\n\n/**\n * 解析配置\n * 注册到容器中\n **/\npublic class xmlbeandefinitionreader {\n    // 核心beanfactory对象 用于将解析后的bean注册到beanfactory中\n    final defaultlistablebeanfactory beanfactory;\n    public xmlbeandefinitionreader(defaultlistablebeanfactory beanfactory) {\n        this.beanfactory = beanfactory;\n    }\n    /**\n     * 根据传递的配置文件\n     * 解析配置\n     * 注册bean\n     * @param configpath\n     */\n    void loadbeandefinitions(string configpath){\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# mini-ioc容器--解析注册\n\n实现步骤\n\n 1. 通过dom4j解析xml得到document文档\n\n 2. 遍历文档所有bean标签\n\n 3. 解析每一个bean标签 封装一个beandefinition对象\n\n 4. 解析每一个bean标签下的所有property标签 封装一个property对象\n\n 5. 将beandefinition和property对象注册到容器\n\n实现xml解析及bean注册\n\n/**\n * 解析配置\n * 注册到容器中\n **/\npublic class xmlbeandefinitionreader {\n    // 核心beanfactory对象 用于将解析后的bean注册到beanfactory中\n    final defaultlistablebeanfactory beanfactory;\n    public xmlbeandefinitionreader(defaultlistablebeanfactory beanfactory) {\n        this.beanfactory = beanfactory;\n    }\n    /**\n     * 根据传递的配置文件\n     * 解析配置\n     * 注册bean\n     * @param configpath\n     */\n    void loadbeandefinitions(string configpath){\n        // 1. 通过dom4j解析xml得到document文档\n        document document = doloaddocument(configpath);\n        // 2. 遍历文档所有bean标签\n        element rootelement = document.getrootelement();\n        list<element> list = rootelement.selectnodes("//bean");\n        for (element element : list) {\n            // 3. 解析每一个bean标签 封装一个beandefinition对象\n            beandefinition beandefinition = parsebeandefinition(element);\n            // 5. 将beandefinition和property对象注册到容器\n            beanfactory.registerbeandefinition(beandefinition);\n        }\n    }\n    /**\n     * 3. 解析每一个bean标签 封装一个beandefinition对象\n     * 4. 解析每一个bean标签下的所有property标签 封装一个property对象\n     */\n    beandefinition parsebeandefinition(element element){\n        beandefinition beandefinition = new beandefinition();\n        string beanname = element.attributevalue("id");\n        string classname = element.attributevalue("class");\n        string scope = element.attributevalue("scope");\n        beandefinition.setbeanname(beanname);\n        beandefinition.setclassname(classname);\n        if(scope!=null&&!"".equals(scope)){\n            beandefinition.setscope(scope);\n        }\n        list<element> propertylist = element.elements("property");\n        for (element propertyele : propertylist) {\n            property property = new property();\n            property.setname(propertyele.attributevalue("name"));\n            property.setvalue(propertyele.attributevalue("value"));\n            property.setref(propertyele.attributevalue("ref"));\n            beandefinition.getpropertylist().add(property);\n        }\n        return beandefinition;\n    }\n    /**\n     * 解析document文档\n     * @param configpath\n     * @return\n     */\n    document doloaddocument(string configpath){\n        inputstream inputstream = this.getclass().getclassloader().getresourceasstream(configpath);\n        saxreader saxreader = new saxreader();\n        try {\n            return saxreader.read(inputstream);\n        } catch (documentexception e) {\n            e.printstacktrace();\n            system.out.println("解析xml出现异常==>"+e.getmessage());\n            throw new runtimeexception(e.getmessage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n准备测试类\n\n/**\n * 测试类\n **/\npublic class ioctest {\n    public static void main(string[] args) {\n        // 创建ioc容器\n        beanfactory beanfactory = new xmlbeanfactory("applicationcontext.xml");\n        // 通过容器获取对象\n        student student = (student)beanfactory.getbean("student");\n        // 调用对象sayhello方法\n        student.sayhello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n断点查看注册情况\n\n可以看到我们配置的xml内容 已经解析成了beandefinition对象，注册到了核心容器的map中\n\n\n\n\n# mini-ioc容器-getbean\n\n实现步骤\n\n 1. 先从单例的map集合中获取 是否有指定beanname的对象\n\n·有直接返回\n\n·没有下一步\n\n 2. 从注册集合中获取bean的定义对象\n\n·有下一步\n\n·没有抛异常nosuchbeandefinition\n\n 3. 判断bean的scope作用域\n\nsingleton单例\n\n· createbean对象\n\n·存入单例集合\n\n·返回对象\n\nprototype多例\n\n·createbean对象\n\n·返回对象\n\n 4. createbean方法\n\n获取beandefinition中的classname\n\n通过反射api得到class对象\n\n通过反射api得到bean实例\n\n获取beandefinition中依赖的属性列表\n\n实现属性的依赖注入\n\n实现getbean及createbean方法\n\n/**\n * 基础容器的核心实现\n * 提供 beandefinitionmap 存储bean的定义\n * 提供 singletonobjects 存储bean的对象实例\n **/\npublic class defaultlistablebeanfactory implements beanfactory {\n    // 提供 beandefinitionmap 存储bean的定义\n    private map<string,beandefinition> beandefinitionmap = new concurrenthashmap<>();\n    // 提供 singletonobjects 存储bean的对象实例 (scope为singleton的)\n    private map<string,object> singletonobjects = new concurrenthashmap<>();\n    /**\n     * 实现getbean方法\n     * @param beanname\n     * @return\n     */\n    @override\n    public object getbean(string beanname) {\n//        1. 先从单例的map集合中获取 是否有指定beanname的对象\n        object singletonobj = singletonobjects.get(beanname);\n//                有直接返回\n        if(singletonobj!=null){\n            return singletonobj;\n        }\n//                没有下一步\n//        2. 从注册集合中获取bean的定义对象\n        beandefinition beandefinition = beandefinitionmap.get(beanname);\n//                有下一步\n//        没有抛异常nosuchbeandefinition\n        if(beandefinition==null){\n            throw new runtimeexception("nosuchbeandefinition : 你找的 "+beanname+" 对象 不存在");\n        }\n//        3. 判断bean的scope作用域\n        string scope = beandefinition.getscope();\n//                singleton单例\n        if("singleton".equals(scope)){\n//        createbean对象\n            object obj = createbean(beandefinition);\n//        存入单例集合\n            singletonobjects.put(beanname,obj);\n//        返回对象\n            return obj;\n        }else {\n//        prototype多例\n//        createbean对象\n            return createbean(beandefinition);\n//        返回对象\n        }\n    }\n    /**\n     * //4. createbean方法\n     * //获取beandefinition中的classname\n     * //通过反射api得到class对象\n     * //通过反射api得到bean实例\n     * //获取beandefinition中依赖的属性列表\n     * //实现属性的依赖注入\n     * 创建对象\n     * @param beandefinition\n     * @return\n     */\n    object createbean(beandefinition beandefinition){\n        string classname = beandefinition.getclassname();\n        class<?> aclass;\n        try {\n            aclass = class.forname(classname);\n        } catch (classnotfoundexception e) {\n            e.printstacktrace();\n            throw new runtimeexception("类未找到"+e.getmessage());\n        }\n        // 创建对象:\n        object obj;\n        try {\n            obj = aclass.newinstance();\n        } catch (instantiationexception e) {\n            e.printstacktrace();\n            throw new runtimeexception("创建对象失败"+e.getmessage());\n        } catch (illegalaccessexception e) {\n            e.printstacktrace();\n            throw new runtimeexception("非法访问"+e.getmessage());\n        }\n        // 依赖注入\n        list<property> propertylist = beandefinition.getpropertylist();\n        for (property property : propertylist) {\n            string name = property.getname();\n            string value = property.getvalue();\n            string ref = property.getref();\n            // 属性名不为空 进行注入\n            if(name!=null&&!"".equals(name)){\n                // 如果配置的是value值 直接注入\n                if(value!=null&&!"".equals(value)){\n                    map<string,string> params = new hashmap<>();\n                    params.put(name,value);\n                    try {\n                        beanutils.populate(obj,params);\n                    } catch (illegalaccessexception e) {\n                        e.printstacktrace();\n                        throw new runtimeexception("非法访问"+e.getmessage());\n                    } catch (invocationtargetexception e) {\n                        e.printstacktrace();\n                        throw new runtimeexception("调用目标对象失败"+e.getmessage());\n                    }\n                }\n                // 如果配置的是ref需要获取其它对象注入\n                if(ref!=null&&!"".equals(ref)){\n                    try {\n                        beanutils.setproperty(obj,name,getbean(ref));\n                    } catch (illegalaccessexception e) {\n                        e.printstacktrace();\n                        throw new runtimeexception("非法访问"+e.getmessage());\n                    } catch (invocationtargetexception e) {\n                        e.printstacktrace();\n                        throw new runtimeexception("调用目标对象失败"+e.getmessage());\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n    /**\n     * 将bean注册到容器中\n     * @param beandefinition\n     */\n    public void registerbeandefinition(beandefinition beandefinition){\n        beandefinitionmap.put(beandefinition.getbeanname(),beandefinition);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n\n# mini-ioc容器-单例对象初始化\n\ndefaultlistablebeanfactory增加初始化方法\n\npublic void preinstanicesingletons(){\n        beandefinitionmap.foreach((beanname,beandefinition)->{\n            string scope = beandefinition.getscope();\n            // 判断单例  非抽象   不懒加载\n            if("singleton".equals(scope)){\n                this.getbean(beanname);\n            }\n        });\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nxmlbeanfactory增加单例对象初始化\n\npublic xmlbeanfactory(string configpath) {\n   // 使用reader对象 解析配置  注册bean\n   this.xmlbeandefinitionreader.loadbeandefinitions(configpath);\n   // 初始化单例对象\n   this.preinstanicesingletons();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# mini-ioc容器-测试和小结\n\n测试对象能否获取\n\npublic class ioctest {\n    public static void main(stiring[] args) {\n        beanfactory beanfactory = new xmlbeanfactory("applicationcontext.xml");\n        student student = (student) beanfactory.getbean("student");\n        student.sayhello();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n查看bean的注册及单例集合信息\n\n可以通过变更scope的值查看对应的变化\n\n\n\n\n# ioc容器源码及其它面试细节\n\n\n# 扩展: 容器如何创建对象\n\nioc容器在准备创建对象时， 会判断是否有配置 factory-method方法\n\n如果有配置 会调用factory-method所指向的方法构建对象.\n\n如果没配置，会检查是否有配置构造参数\n\n无构造参数: 调用默认构造器创建对象\n\n有构造参数: 根据参数情况匹配对应的构造器\n\n\n# 扩展: bean的生命周期\n\nspring 容器中的bean的完整生命周期一共分为十一步完成。\n\n1.bean对象的实例化\n\n2.封装属性，也就是设置properties中的属性值\n\n3.如果bean实现了beannameaware，则执行setbeanname方法,也就是bean中的id值\n\n4.如果实现beanfactoryaware或者applicationcontextaware ，需要设置setbeanfactory或者上下文对象setapplicationcontext\n\n5.如果存在类实现beanpostprocessor后处理bean，执行postprocessbeforeinitialization，可以在初始化之前执行一些方法\n\n6.如果bean实现了initializingbean，则执行afterpropertiesset，执行属性设置之后的操作\n\n7.调用执行指定的初始化方法\n\n8.如果存在类实现beanpostprocessor则执行postprocessafterinitialization，执行初始化之后的操作\n\n9.执行自身的业务方法\n\n10.如果bean实现了disposablebean，则执行spring的的销毁方法\n\n11.调用执行自定义的销毁方法。\n\n\n# 扩展: bean的循环依赖问题\n\na 依赖 b b 依赖 a 产生闭环，称为循环依赖\n\n·spring 默认允许单例对象的属性注入 所产生的循环依赖\n\n单例对象的循环依赖 spring通过3级缓存来解决\n\n比如一个类a中有一个属性是b类，b类中有一个属性是a类，这时看spring是怎么解决他们的相互依赖的。spring注入一个类的大体步骤分为两部分，一是先完成对类的构造工作，二是会对类的属性进行设置和填充。首先spring构造a类，通过abstractautowirecapablebeanfactory的docreatebean方法中调用addsingletonfactory方法将a类曝光到singletonfactories中。这时完成a的构造后，需要填充b属性，继续第二步，发现b还没有构造，于是开始b流程的构造过程，构造的时候发现需要填充a，从第三层缓存singletonfactories中找到a(此时的a还没有完全构造完成，但是可以拿到a的一个引用)，b拿到a的引用后，完成b自己的填充属性工作，完成初始化工作，把自己放到第一层缓存singletonobjects中。这时回到a的这边，在拿到b对象后，完成自己的填充属性工作。\n\n源码                      级别     描述\nsingletonobjects        一级缓存   用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用\nearlysingletonobjects   二级缓存   存放原始的 bean 对象（尚未填充属性），用于解决循环依赖\nsingletonfactories      三级缓存   存放 bean 工厂对象，用于解决循环依赖·如果是构造器依赖属性 会报循环依赖异常\n\n·如果对象都是多例对象 会报循环依赖异常\n\n·如果设置allowcircularreferences为false 会报循环依赖异常\n\nprotected void customizebeanfactory(defaultlistablebeanfactory beanfactory) {\n   if (this.allowbeandefinitionoverriding != null) {\n      beanfactory.setallowbeandefinitionoverriding(this.allowbeandefinitionoverriding);\n   }\n   if (this.allowcircularreferences != null) {\n      beanfactory.setallowcircularreferences(this.allowcircularreferences);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 扩展: bean的覆盖问题\n\n默认情况:\n\n同一个配置文件中出现id相同的bean会报错，不同的配置文件出现id相同的bean后加，载的bean会将先加载的bean覆盖掉称为bean的覆盖，bean的覆盖不会报错，但可能影响我们的项目，可以通过属性设置不允许bean的覆盖，allowbeandefinitionoverriding设置为false。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"POI 多线程多Sheet导出Excel,Csv",frontmatter:{title:"POI 多线程多Sheet导出Excel,Csv",date:"2018-08-20T00:00:00.000Z",tags:["Java","poi","多线程"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/poi.html",relativePath:"views/backend/poi.md",key:"v-42002a52",path:"/views/backend/poi.html",headers:[{level:2,title:"概要",slug:"概要",normalizedTitle:"概要",charIndex:74},{level:2,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:80},{level:2,title:"解决办法：",slug:"解决办法",normalizedTitle:"解决办法：",charIndex:88},{level:3,title:"1. 调整jvm/tomcat大小",slug:"_1-调整jvm-tomcat大小",normalizedTitle:"1. 调整jvm/tomcat大小",charIndex:99},{level:3,title:"2. 通过新版的SXSSFWorkbook来解决",slug:"_2-通过新版的sxssfworkbook来解决",normalizedTitle:"2. 通过新版的sxssfworkbook来解决",charIndex:122},{level:3,title:"3. 转csv导出",slug:"_3-转csv导出",normalizedTitle:"3. 转csv导出",charIndex:152},{level:3,title:"4. 本地90万数据：输入输出流+poi多线程多sheet导出Excel",slug:"_4-本地90万数据-输入输出流-poi多线程多sheet导出excel",normalizedTitle:"4. 本地90万数据：输入输出流+poi多线程多sheet导出excel",charIndex:167},{level:3,title:"5. 浏览器：多线程多sheet页下载",slug:"_5-浏览器-多线程多sheet页下载",normalizedTitle:"5. 浏览器：多线程多sheet页下载",charIndex:209}],excerpt:"<Boxx/>\n<p>因项目特殊，最近遇到了<code>Excel导出大数据量</code>的问题，所以就趁着解决这个问题的机会，把poi导出Excel再整理一遍，方便自己日后总结。</p>\n",headersStr:"概要 问题原因 解决办法： 1. 调整jvm/tomcat大小 2. 通过新版的SXSSFWorkbook来解决 3. 转csv导出 4. 本地90万数据：输入输出流+poi多线程多sheet导出Excel 5. 浏览器：多线程多sheet页下载",content:'因项目特殊，最近遇到了Excel导出大数据量的问题，所以就趁着解决这个问题的机会，把poi导出Excel再整理一遍，方便自己日后总结。\n\n\n\n * 概要\n * 问题原因\n * 解决办法：\n   * 1. 调整jvm/tomcat大小\n   * 2. 通过新版的SXSSFWorkbook来解决\n   * 3. 转csv导出\n   * 4. 本地90万数据：输入输出流+poi多线程多sheet导出Excel\n   * 5. 浏览器：多线程多sheet页下载\n\n\n\n\n# 概要\n\nExcel：POI 多线程多sheet导出数据\n\n * Excel2003版最大行数是65536，Excel2007最大行数是1048576\n * Excel2003版最大列数是256，Excel2007最大列数是16384\n\n\n# 问题原因\n\n 1. 导出大数据量，可能遇到的第一个问题就是后台报：java.lang.OutOfMemoryError: Java heap space 内存溢出这个问题\n    \n    > 分析：poi导出时，会先把内容写到内存中，最后浏览器从内存中下载，但是数据量太大，会导致内存溢出\n\n\n# 解决办法：\n\n\n# 1. 调整jvm/tomcat大小\n\n * 设置jvm：-Xms64m -Xmx512m（依据你物理内存的大小调整）\n   \n   > 祥见：https://www.cnblogs.com/jhcelue/p/6900881.html\n\n\n# 2. 通过新版的SXSSFWorkbook来解决\n\n * 自poi3.8以后，可通过新版的SXSSFWorkbook来解决，可通过其构造函数指定在内存中缓存的行数，内存中指定行数满足时会自动缓存在硬盘的临时目录上然后循环下一次，同时，并不会存在页面卡顿的情况；\n   \n   > JAVA使用POI如何导出百万级别数据：\n   > \n   > https://www.cnblogs.com/520playboy/p/6275170.html\n   > \n   > https://fanshuyao.iteye.com/blog/2426095\n\n\n# 3. 转csv导出\n\n * CSV是一种通用的、相对简单的文件格式，其文件以纯文本形式存储表格数据（数字和文本）。\n * Excel和CSV格式文件的不同之处 => 传送门\n\n> 手写一个 csv，可先直接运行main()查看结果\n\npackage com.zpj.electric.utils;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.alibaba.druid.util.StringUtils;\n\n/**\n * @className: CSVUtils\n * @date: 2018/7/16\n * @version: 1.0\n */\n\npublic class CSVUtils {\n\n\n    /**\n     * 功能说明：获取UTF-8编码文本文件开头的BOM签名。\n     * BOM(Byte Order Mark)，是UTF编码方案里用于标识编码的标准标记。例：接收者收到以EF BB BF开头的字节流，就知道是UTF-8编码。\n     * @return UTF-8编码文本文件开头的BOM签名\n     */\n    public static String getBOM() {\n\n        byte b[] = {(byte)0xEF, (byte)0xBB, (byte)0xBF};\n        return new String(b);\n    }\n\n    /**\n     * 生成CVS文件\n     * @param exportData\n     *       源数据List\n     * @param map\n     *       csv文件的列表头map\n     * @param outPutPath\n     *       文件路径\n     * @param fileName\n     *       文件名称\n     * @return\n     */\n    @SuppressWarnings("rawtypes")\n    public static File createCSVFile(List exportData, LinkedHashMap map, String outPutPath,\n                                     String fileName) {\n        File csvFile = null;\n        BufferedWriter csvFileOutputStream = null;\n        try {\n            File file = new File(outPutPath);\n            if (!file.exists()) {\n                file.mkdirs();\n            }\n            //定义文件名格式并创建\n            csvFile =new File(outPutPath+fileName+".csv");\n            file.createNewFile();\n            // UTF-8使正确读取分隔符","\n            //如果生产文件乱码，windows下用gbk，linux用UTF-8\n            csvFileOutputStream = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\n                    csvFile), "UTF-8"), 1024);\n\n            //写入前段字节流，防止乱码\n            csvFileOutputStream.write(getBOM());\n            // 写入文件头部\n            for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator.hasNext();) {\n                java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator.next();\n                csvFileOutputStream.write((String) propertyEntry.getValue() != null ? (String) propertyEntry.getValue() : "" );\n                if (propertyIterator.hasNext()) {\n                    csvFileOutputStream.write(",");\n                }\n            }\n            csvFileOutputStream.newLine();\n            // 写入文件内容\n            for (Iterator iterator = exportData.iterator(); iterator.hasNext();) {\n                Object row = (Object) iterator.next();\n                for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator\n                        .hasNext();) {\n                    java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator\n                            .next();\n                    String str=row!=null?((String)((Map)row).get( propertyEntry.getKey())):"";\n\n                    if(StringUtils.isEmpty(str)){\n                        str="";\n                    }else{\n                        str=str.replaceAll("\\"","\\"\\"");\n                        if(str.indexOf(",")>=0){\n                            str="\\""+str+"\\"";\n                        }\n                    }\n                    csvFileOutputStream.write(str);\n                    if (propertyIterator.hasNext()) {\n                        csvFileOutputStream.write(",");\n                    }\n                }\n                if (iterator.hasNext()) {\n                    csvFileOutputStream.newLine();\n                }\n            }\n            csvFileOutputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                csvFileOutputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return csvFile;\n    }\n\n    /**\n     *     生成并下载csv文件\n     * @param response\n     * @param exportData\n     * @param map\n     * @param outPutPath\n     * @param fileName\n     * @throws IOException\n     */\n    @SuppressWarnings("rawtypes")\n    public static void exportDataFile(HttpServletResponse response,List exportData, LinkedHashMap map, String outPutPath,String fileName) throws IOException{\n        File csvFile = null;\n        BufferedWriter csvFileOutputStream = null;\n        try {\n            File file = new File(outPutPath);\n            if (!file.exists()) {\n                file.mkdirs();\n            }\n            //定义文件名格式并创建\n            csvFile =new File(outPutPath+fileName+".csv");\n            if(csvFile.exists()){\n                csvFile.delete();\n            }\n            csvFile.createNewFile();\n            // UTF-8使正确读取分隔符","\n            //如果生产文件乱码，windows下用gbk，linux用UTF-8\n            csvFileOutputStream = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csvFile), "UTF-8"), 1024);\n            //写入前段字节流，防止乱码\n            csvFileOutputStream.write(getBOM());\n            // 写入文件头部\n            for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator.hasNext();) {\n                java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator.next();\n                csvFileOutputStream.write((String) propertyEntry.getValue() != null ? (String) propertyEntry.getValue() : "" );\n                if (propertyIterator.hasNext()) {\n                    csvFileOutputStream.write(",");\n                }\n            }\n            csvFileOutputStream.newLine();\n            // 写入文件内容\n            for (Iterator iterator = exportData.iterator(); iterator.hasNext();) {\n                Object row = (Object) iterator.next();\n                for (Iterator propertyIterator = map.entrySet().iterator(); propertyIterator\n                        .hasNext();) {\n                    java.util.Map.Entry propertyEntry = (java.util.Map.Entry) propertyIterator\n                            .next();\n                    String str=row!=null?((String)((Map)row).get( propertyEntry.getKey())):"";\n                    if(StringUtils.isEmpty(str)){\n                        str="";\n                    }else{\n                        str=str.replaceAll("\\"","\\"\\"");\n                        if(str.indexOf(",")>=0){\n                            str="\\""+str+"\\"";\n                        }\n                    }\n                    csvFileOutputStream.write(str);\n                    if (propertyIterator.hasNext()) {\n                        csvFileOutputStream.write(",");\n                    }\n                }\n                if (iterator.hasNext()) {\n                    csvFileOutputStream.newLine();\n                }\n            }\n            csvFileOutputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                csvFileOutputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n\n\n\n        InputStream in = null;\n        try {\n            in = new FileInputStream(outPutPath+fileName+".csv");\n            int len = 0;\n            byte[] buffer = new byte[1024];\n\n            OutputStream out = response.getOutputStream();\n            response.reset();\n\n            response.setContentType("application/csv;charset=UTF-8");\n            response.setHeader("Content-Disposition","attachment; filename=" + URLEncoder.encode(fileName+".csv", "UTF-8"));\n            response.setCharacterEncoding("UTF-8");\n            while ((len = in.read(buffer)) > 0) {\n                out.write(new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF });\n                out.write(buffer, 0, len);\n            }\n            out.close();\n        } catch (FileNotFoundException e) {\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n    }\n\n    /**\n     * 删除该目录filePath下的所有文件\n     * @param filePath\n     *      文件目录路径\n     */\n    public static void deleteFiles(String filePath) {\n        File file = new File(filePath);\n        if (file.exists()) {\n            File[] files = file.listFiles();\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].isFile()) {\n                    files[i].delete();\n                }\n            }\n        }\n    }\n\n    /**\n     * 删除单个文件\n     * @param filePath\n     *     文件目录路径\n     * @param fileName\n     *     文件名称\n     */\n    public static void deleteFile(String filePath, String fileName) {\n        File file = new File(filePath);\n        if (file.exists()) {\n            File[] files = file.listFiles();\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].isFile()) {\n                    if (files[i].getName().equals(fileName)) {\n                        files[i].delete();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 测试数据\n     * @param args\n     */\n    @SuppressWarnings({ "rawtypes", "unchecked" })\n    public static void main(String[] args) {\n        List exportData = new ArrayList<Map>();\n        Map row1 = new LinkedHashMap<String, String>();\n        row1.put("1", "11");\n        row1.put("2", "12");\n        row1.put("3", "13");\n        row1.put("4", "14");\n        exportData.add(row1);\n        row1 = new LinkedHashMap<String, String>();\n        row1.put("1", "21");\n        row1.put("2", "22");\n        row1.put("3", "23");\n        row1.put("4", "24");\n        exportData.add(row1);\n        LinkedHashMap map = new LinkedHashMap();\n\n        //设置列名\n        map.put("1", "第一列名称");\n        map.put("2", "第二列名称");\n        map.put("3", "第三列名称");\n        map.put("4", "第四列名称");\n        //这个文件上传到路径，可以配置在数据库从数据库读取，这样方便一些！\n        String path = "E:/";\n\n        //文件名=生产的文件名称+时间戳\n        String fileName = "文件导出";\n        File file = CSVUtils.createCSVFile(exportData, map, path, fileName);\n        String fileName2 = file.getName();\n        System.out.println("文件名称：" + fileName2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n\n\n\n# 4. 本地90万数据：输入输出流+poi多线程多sheet导出Excel\n\n> 可直接运行main()查看导出结果，注意poi版本3.7+\n\npackage com.zpj.electric.util.excel;\n\nimport com.zpj.electric.po.Student;\nimport org.apache.commons.beanutils.PropertyUtilsBean;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.usermodel.Sheet;\nimport org.apache.poi.ss.usermodel.Workbook;\nimport org.apache.poi.xssf.streaming.SXSSFWorkbook;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadExcelUtils {\n\n    /**\n     * 定义没个 sheet 最多数量\n     */\n    public static final Integer EXCEL_MAX_CNT = 50000;\n\n    private Workbook wb;\n\n    private String fileName;\n\n    private String filePath;\n\n    private String[] hearders;\n\n    private String[] fields;\n\n    public Workbook getWb() {\n        return wb;\n    }\n\n    public String getFileName() {\n        return fileName;\n    }\n\n    public String getFilePath() {\n        return filePath;\n    }\n\n    public String[] getHearders() {\n        return hearders;\n    }\n\n    public String[] getFields() {\n        return fields;\n    }\n\n    /**\n     * @param fileName 文件名称\n     * @param filePath 文件路径\n     * @param hearders 文件头\n     * @param fields   字段属性\n     * @Author maochuang.li\n     * @Date Create in 13:54 2017/12/28 0028\n     */\n    public ThreadExcelUtils(String fileName, String filePath, String[] hearders, String[] fields) {\n        this.wb = new SXSSFWorkbook(10000);\n        this.fileName = fileName;\n        this.filePath = filePath;\n        this.hearders = hearders;\n        this.fields = fields;\n    }\n\n    public static void main(String[] args) throws Exception {\n        String[] header = {"姓名", "年龄"};\n        String[] fileNames = {"name", "age"};\n        ThreadExcelUtils utils = new ThreadExcelUtils("测试Excel1", "D:\\\\exceltext\\\\wer\\\\sd", header, fileNames);\n        List list = new ArrayList<>();\n        System.out.println("开始造数据.......");\n        for (int i = 0; i < 900000; i++) {\n            Student student = new Student();\n            student.setName("name->" + i);\n            student.setAge(i);\n            list.add(student);\n        }\n        System.out.println(getDate(new Date()) + "开始写入文件.......");\n        long startTime = System.currentTimeMillis();\n        utils.exportExcelToFilePath(list);\n        long endTime = System.currentTimeMillis();\n        System.out.println("耗时：" + (endTime - startTime));\n        //耗时：29230\n        //耗时：25226\n\n    }\n\n    /**\n     * @param list 数据\n     * @Author maochuang.li\n     * @Date Create in 10:52 2017/12/28 0028\n     */\n    public void exportExcelToFilePath(List<Object> list) throws Exception {\n        int excelSize = EXCEL_MAX_CNT;    //每个Excel文件条数\n        int totalCount = list.size();    //查询结果总条数\n        int pageCount = 0;//总sheet页个数\n        int numPage = totalCount % excelSize;    //是否整页数\n        if (numPage > 0)\n            pageCount = totalCount / excelSize + 1;\n        else\n            pageCount = totalCount / excelSize;\n        //创建线程池 多sheet多线程写入 线程数 为sheet页的 1/4\n        Integer threadNumber = pageCount / 4;\n        if (threadNumber == 0)\n            threadNumber = 1;\n//        ExecutorService threadPool = Executors.newFixedThreadPool(threadNumber);\n        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(threadNumber, threadNumber, 0L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(50));\n        //创建栅栏 等待任务完成\n        CountDownLatch countDownLatch = new CountDownLatch(pageCount);\n        //循环遍历投递任务\n        for (int i = 1; i <= pageCount; i++) {\n            ThraedExcel thraedExcel = new ThraedExcel(list, i, pageCount, numPage, this);\n            thraedExcel.setCountDownLatch(countDownLatch);\n            threadPool.submit(thraedExcel);\n        }\n        countDownLatch.await(10L,TimeUnit.SECONDS);\n        System.err.println("超时拉=====================================");\n        Workbook wb = getWb();\n        File file = new File(filePath);\n        if (!file.exists() && !file.isDirectory()) {\n            file.mkdirs();\n        }\n        FileOutputStream fout = new FileOutputStream(new File(file, fileName + ".xls"));\n        try {\n            wb.write(fout);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println("文件写入完成");\n        //立即销毁线程池\n        threadPool.shutdownNow();\n    }\n\n\n    private static String getDate(Date date) {\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");\n        String format = simpleDateFormat.format(date);\n        return format;\n    }\n\n    /**\n     * JavaBean转Map\n     *\n     * @param obj\n     * @return\n     */\n    public static Map<String, Object> beanToMap(Object obj) {\n        Map<String, Object> params = new HashMap<String, Object>(0);\n        try {\n            PropertyUtilsBean propertyUtilsBean = new PropertyUtilsBean();\n            PropertyDescriptor[] descriptors = propertyUtilsBean.getPropertyDescriptors(obj);\n            int length = descriptors.length;\n            for (int i = 0; i < length; i++) {\n                String name = descriptors[i].getName();\n                if (!StringUtils.equals(name, "class")) {\n                    params.put(name, propertyUtilsBean.getNestedProperty(obj, name));\n                }\n            }\n        } catch (Exception e) {\n            System.err.println("bean 转Map出错");\n            e.printStackTrace();\n        }\n        return params;\n    }\n\n    /***\n     * 线程写入sheet\n     */\n    private static class ThraedExcel implements Runnable {\n\n        private List<Object> list;//数据\n\n        private Integer sheetNumber;//当前sheet页\n\n        private Integer totalSheetCount;//总数据\n\n        private int numPage;    //是否整页数\n\n        private Integer excelSize;\n\n        private ThreadExcelUtils threadExcelUtils;\n        //栅栏对象\n        private CountDownLatch countDownLatch;\n\n        /**\n         * @param list            总数据\n         * @param sheetNumber     当前sheet页\n         * @param totalSheetCount 总sheet页\n         * @param numPage         是否整数\n         * @Author maochuang.li\n         * @Date Create in 11:12 2017/12/28 0028\n         */\n        public ThraedExcel(List<Object> list, Integer sheetNumber, Integer totalSheetCount, Integer numPage, ThreadExcelUtils threadExcelUtils) {\n            this.list = list;//总数据\n            this.sheetNumber = sheetNumber;//当前sheet页\n            this.totalSheetCount = totalSheetCount;//总sheet页\n            this.numPage = numPage;//是否整除\n            this.excelSize = ThreadExcelUtils.EXCEL_MAX_CNT;//没个sheet最大数量\n            this.threadExcelUtils = threadExcelUtils;//当前线程对象\n        }\n\n        public void setCountDownLatch(CountDownLatch countDownLatch) {\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            System.out.println("第"+sheetNumber+"个sheet开始");\n            List<Object> sheetList = null;\n            if (totalSheetCount > 1) {\n                if (numPage == 0) {\n                    sheetList = list.subList((sheetNumber - 1) * excelSize, excelSize * sheetNumber);\n                } else {\n                    if (sheetNumber == totalSheetCount) {\n                        sheetList = list.subList((sheetNumber - 1) * excelSize, list.size());\n                    } else {\n                        sheetList = list.subList((sheetNumber - 1) * excelSize, excelSize * (sheetNumber));\n                    }\n                }\n            } else\n                sheetList = list;\n            //开始写入数据\n            createWorkBook(sheetList);\n            if (this.countDownLatch != null)\n                this.countDownLatch.countDown();\n            System.out.println("第"+sheetNumber+"个sheet  结束");\n        }\n\n        /***\n         * 写出数据\n         */\n        private void createWorkBook(List<Object> sheetList) {\n            Sheet sheet = null;\n            Row row = null;\n            synchronized (ThreadExcelUtils.class) {\n                String fileName = threadExcelUtils.getFileName();\n                Workbook wb = threadExcelUtils.getWb();\n                sheet = wb.createSheet(fileName + "_" + this.sheetNumber);\n                row = sheet.createRow(0);\n            }\n            String[] header = threadExcelUtils.getHearders();\n            String[] fields = threadExcelUtils.getFields();\n            //设置标题\n            for (int i = 0; i < header.length; i++) {\n                row.createCell(i).setCellValue(header[i]);\n            }\n            //开始写入数据\n            if (sheetList != null && sheetList.size() > 0) {\n                int dataLength = sheetList.size();\n                for (int i = 0; i < dataLength; i++) {\n                    Row row1 = sheet.createRow(i + 1);\n                    Object obj = sheetList.get(i);\n                    Map<String, Object> map = (obj instanceof Map) ? (Map<String, Object>) obj : beanToMap(obj);\n                    int length = fields.length;\n                    for (int j = 0; j < length; j++) {\n                        String key = fields[j];\n                        Object value = map.get(key);\n//                        if ((StringUtil.isNotBlank(value))) {\n                        if (!(org.springframework.util.StringUtils.isEmpty(value))) {\n                            //不晓得 此处为啥有线程安全问题\n                            synchronized (ThreadExcelUtils.class) {\n                                if (value instanceof Date) {\n                                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");\n                                    String format = sdf.format(value);\n                                    row1.createCell(j).setCellValue(format);\n                                } else {\n                                    try {\n                                        row1.createCell(j).setCellValue(value.toString());\n                                    } catch (Exception e) {\n                                        e.printStackTrace();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n\n\n\n# 5. 浏览器：多线程多sheet页下载\n\n * 先引入依赖\n\n\x3c!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\x3e\n        <dependency>\n            <groupId>org.apache.poi</groupId>\n            <artifactId>poi-ooxml</artifactId>\n            <version>3.9</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\x3e\n        <dependency>\n            <groupId>org.apache.poi</groupId>\n            <artifactId>poi</artifactId>\n            <version>3.9</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/commons-io/commons-io --\x3e\n        <dependency>\n            <groupId>commons-io</groupId>\n            <artifactId>commons-io</artifactId>\n            <version>2.4</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/log4j/log4j --\x3e\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 创建下载工具类（我写的太low，可以自己优化）\n\npackage com.zpj.electric.util;\n\nimport java.io.OutputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.log4j.Logger;\nimport org.apache.poi.hssf.usermodel.HSSFCell;\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\nimport org.apache.poi.hssf.usermodel.HSSFClientAnchor;\nimport org.apache.poi.hssf.usermodel.HSSFFont;\nimport org.apache.poi.hssf.usermodel.HSSFPatriarch;\nimport org.apache.poi.hssf.usermodel.HSSFRichTextString;\nimport org.apache.poi.hssf.usermodel.HSSFRow;\nimport org.apache.poi.hssf.usermodel.HSSFSheet;\nimport org.apache.poi.hssf.usermodel.HSSFWorkbook;\nimport org.apache.poi.ss.usermodel.IndexedColors;\nimport org.apache.poi.ss.util.CellRangeAddress;\nimport org.apache.poi.xssf.usermodel.XSSFCell;\nimport org.apache.poi.xssf.usermodel.XSSFCellStyle;\nimport org.apache.poi.xssf.usermodel.XSSFFont;\nimport org.apache.poi.xssf.usermodel.XSSFRichTextString;\nimport org.apache.poi.xssf.usermodel.XSSFRow;\nimport org.apache.poi.xssf.usermodel.XSSFSheet;\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook;\n\npublic class ExcelUtil {\n\n\tprivate static Logger log = Logger.getLogger(ExcelUtil.class);\n\n\tprivate static SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");\n\tprivate final static String EXCE_VERSION_03 = "03";\n\tprivate final static String EXCE_VERSION_07 = "07";\n\n\t/**\n\t * @param resp\n\t * @param fileName\n\t *            文件名，一级表头\n\t * @param useFirstTitle\n\t *            是否需要一级表头，true：是，false：否\n\t * @param version\n\t *            导出版本，可选值为 07，统一用07版\n\t * @param titles\n\t *            excel列名\n\t * @param data\n\t *            需要导出的数据集合\n\t */\n\tpublic static void exportExcel(HttpServletResponse resp, String fileName,\n\t\t\tboolean useFirstTitle, String version, String[] titles,\n\t\t\tList<Object[]> data) {\n\t\t// 如果传入的文件名为空，则使用当前时间作为文件名\n\t\tString excelFileName = "";\n\t\tif ("".equals(fileName) || fileName == null) {\n\t\t\texcelFileName = sdf.format(new Date());\n\t\t}\n\t\t// (data.size() >= 0) 当列表中没有数据时，导出的excel加上标题等。\n\t\tif (titles.length >= 0) {\n\t\t\ttry {\n\t\t\t\tif (EXCE_VERSION_03.equals(version)) {\n\t\t\t\t\texcelFileName = fileName + ".xls";\n\t\t\t\t} else if (EXCE_VERSION_07.equals(version)) {\n\t\t\t\t\texcelFileName = fileName + ".xlsx";\n\t\t\t\t}\n\n\t\t\t\tresp.setContentType("application/x-msdownload");\n\t\t\t\texcelFileName = new String(excelFileName.getBytes("gb2312"), "iso8859-1");\n\t\t\t\tresp.addHeader("Content-Disposition", "attachment;filename="\n\t\t\t\t\t\t+ excelFileName);\n\t\t\t\tOutputStream out = resp.getOutputStream();\n\t\t\t\tif (EXCE_VERSION_03.equals(version)) {\n\t\t\t\t\texprotExcel_03(fileName, titles, useFirstTitle, data, out);\n\t\t\t\t} else if (EXCE_VERSION_07.equals(version)) {\n\t\t\t\t\texprotExcel_07_plus(excelFileName, titles, useFirstTitle, data, out);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error("", e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void exprotExcel_07_plus(String fileName, String[] titles,\n\t\t\tboolean useFirstTitle, List<Object[]> data, OutputStream out) {\n\t\tXSSFWorkbook wb = new XSSFWorkbook();\n\n\t\t//把要下载的数据分为多个sheet下载\n\t\tList<List<Object[]>> dataList = createList(data, 50000);\n\t\tLong start = System.currentTimeMillis();\n\t\tSystem.out.println("下载开始时间：" + start);\n\n\t\t//使用多线程下载\n\t\tExecutorService es = Executors.newFixedThreadPool(dataList.size());\n\t\t//使用计步器\n\t\t// final CountDownLatch doneSignal = new CountDownLatch(dataList.size());\n\t\tCountDownLatch doneSignal = new CountDownLatch(dataList.size());\n\n\t\ttry {\n\n\t\tfor(int x = 0;x<dataList.size();x++){\n\t\t\tPoiWriter poiWriter = new PoiWriter(x, wb, fileName, titles, data, dataList, useFirstTitle, doneSignal);\n\t\t\tFuture future = es.submit(poiWriter);\n\t\t\t /*try {\n\t\t\t\t \t//如果Future.get()返回null，任务完成\n\t\t            if(future.get()==null){\n\t\t                System.out.println("第"+(x+1)+"个sheet页，任务完成");\n\t\t            }\n\t\t        } catch (InterruptedException e) {\n\t\t        } catch (ExecutionException e) {\n\t\t            //失败\n\t\t            System.out.println("第"+(x+1)+"个sheet页，任务失败："+e.getCause().getMessage());\n\t\t        }*/\n\t\t\t//new PoiWriter(x, wb, fileName, titles, data, dataList, useFirstTitle, null).run();\n\t\t}\n\t\tdoneSignal.await();//阻塞，直到计数器的值为0，才让主线程往下执行\n\t    es.shutdown();//关闭线程池\n\t\tLong end = System.currentTimeMillis();\n\t\tSystem.out.println("总计下载时间：" + ((end-start)/1000) + "s");\n\t\t\twb.write(out);\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\tlog.error("", e);\n\t\t} finally {\n\t\t\tIOUtils.closeQuietly(out);\n\t\t}\n\n\t}\n\n\n\t public static List<List<Object[]>>  createList(List<Object[]> targe,int size) {\n\t\t        List<List<Object[]>> listArr = new ArrayList<List<Object[]>>();\n\t\t        //获取被拆分的数组个数\n\t\t        int arrSize = targe.size()%size==0?targe.size()/size:targe.size()/size+1;\n\t\t        for(int i=0;i<arrSize;i++) {\n\t\t            List<Object[]>  sub = new ArrayList<Object[]>();\n\t\t            //把指定索引数据放入到list中\n\t\t            for(int j=i*size;j<=size*(i+1)-1;j++) {\n\t\t                if(j<=targe.size()-1) {\n\t\t                \t//得到拆分后的集合\n\t\t                    sub.add(targe.get(j));\n\t\t                }\n\t\t            }\n\t\t            //拆分的集合可以做点什么\n\t\t            //sub.dosomething();\n\t\t            //将拆分后的集合综合为一个集合\n\t\t            listArr.add(sub);\n\t\t        }\n\t\t        return listArr;\n\t }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n\n * 线程类\n\npackage com.zpj.electric.util;\n\nimport org.apache.poi.hssf.usermodel.HSSFCellStyle;\nimport org.apache.poi.ss.usermodel.IndexedColors;\nimport org.apache.poi.ss.util.CellRangeAddress;\nimport org.apache.poi.xssf.usermodel.*;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class PoiWriter implements Runnable {\n\n\tpublic int x;//第几个sheet页\n\tpublic XSSFWorkbook wb;//poi Workbook\n\tpublic String fileName;//要导出的文件名字(含后缀)\n\tpublic String[] titles;//标题\n\tpublic List<Object[]> data;//全部数据\n\tpublic List<List<Object[]>> dataList;//包含了各个sheet页的数据\n\tpublic boolean useFirstTitle;//是否需要表头\n\tpublic  CountDownLatch doneSignal;//多线程栅栏计步器\n\n\n\tpublic PoiWriter(int x, XSSFWorkbook wb, String fileName, String[] titles,\n\t\t\tList<Object[]> data, List<List<Object[]>> dataList,\n\t\t\tboolean useFirstTitle, CountDownLatch doneSignal) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.wb = wb;\n\t\tthis.fileName = fileName;\n\t\tthis.titles = titles;\n\t\tthis.data = data;\n\t\tthis.dataList = dataList;\n\t\tthis.useFirstTitle = useFirstTitle;\n\t\tthis.doneSignal = doneSignal;\n\t}\n\n\tpublic PoiWriter() {\n\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tLong start1 = System.currentTimeMillis();\n\t\tSystem.out.println(fileName+"：第"+(x+1)+"个sheet开始时间：" + start1);\n\t\t// 创建一sheet页\n\t\tXSSFSheet sheet = wb.createSheet("sheet"+x);\n\t\t// 设置格式 在单元格中右排放\n\t\tXSSFCellStyle style = wb.createCellStyle();\n\t\tstyle.setAlignment(XSSFCellStyle.ALIGN_RIGHT);\n\n\t\tint firstRow = 0;\n\t\tif (useFirstTitle) {\n\t\t\tXSSFRow fr = sheet.createRow(firstRow);\n\t\t\tXSSFFont font = wb.createFont();\n\t\t\tfont.setFontName("宋体");\n\t\t\tfont.setFontHeightInPoints((short) 16);\n\t\t\tXSSFCellStyle cs = wb.createCellStyle();\n\t\t\tcs.setAlignment(XSSFCellStyle.ALIGN_CENTER);\n\t\t\tcs.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);\n\t\t\tcs.setFont(font);\n\t\t\tfr.setHeight((short) 700);\n\t\t\tfr.setHeight((short) 700);\n\t\t\t//excel大标题和并列多了一列，当列表中数据为空时，导出的excel中加上标题等信息\n\t\t\tsheet.addMergedRegion(new CellRangeAddress(0, 0, 0,\n\t\t\t\t\ttitles.length-1));\n\t\t\tfor (int i = 0; i < titles.length; i++) {\n\t\t\t\tfr.createCell(i);\n\t\t\t}\n\t\t\t/**\n\t\t\t * 自适应宽度\n\t\t\t */\n\t\t\tif(null!=data&&data.size()>0){\n\t\t\t\tObject[] obj=data.get(0);\n\t\t\t\tif(obj.length==titles.length){\n\t\t\t\t\tfor(int i=0;i<titles.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint contentLength=titles[i].length();\n\t\t\t\t\t\tif(null!=obj[i]&&obj[i].toString().length()>titles[i].length()){\n\t\t\t\t\t\t\tcontentLength=obj[i].toString().length();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//The maximum column width for an individual cell is 255 characters. 的解决方案\n\t\t\t\t\t\t\tif((short)50*(50+contentLength)/256>255){\n\t\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)254*256);  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)50*(50+contentLength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//The maximum column width for an individual cell is 255 characters. 的解决方案\n\t\t\t\t\t\t\tif((short)100*(55+contentLength)/256>255){\n\t\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)254*256);  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)100*(55+contentLength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i=0;i<titles.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint contentLength=titles[i].length();\n\t\t\t\t\t\tif(i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)50*(50+contentLength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tsheet.setColumnWidth(i, (short)100*(55+contentLength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//创建新的样式给列表的大标题加上背景色\n\t\t\t XSSFCellStyle alignStyle = (XSSFCellStyle)wb.createCellStyle();\n\t\t\t alignStyle.setAlignment(XSSFCellStyle.ALIGN_CENTER);\n\t\t\t alignStyle.setVerticalAlignment(XSSFCellStyle.VERTICAL_CENTER);\n\t\t\t alignStyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);\n\t\t\t alignStyle.setFillForegroundColor(IndexedColors.SKY_BLUE.getIndex());\n\t\t\t alignStyle.setFont(font);\n\t\t\tfr.getCell(0).setCellValue(new XSSFRichTextString(fileName));\n\t\t\tfr.getCell(0).setCellStyle(alignStyle);\n\t\t\tfirstRow += 1;\n\t\t}\n\n\t\tXSSFRow row = sheet.createRow(firstRow);\n\t\tfor (int i = 0; i < titles.length; i++) {\n\t\t\trow.createCell(i).setCellValue(new XSSFRichTextString(titles[i]));\n\t\t}\n\n\n\t\t\tfor (int i = 0; i < dataList.get(x).size(); i++) {\n\t\t\t\tXSSFRow r = sheet.createRow(i + firstRow + 1);\n\t\t\t\tObject[] obj = dataList.get(x).get(i);\n\t\t\t\tfor (int j = 0; j < obj.length; j++) {\n\t\t\t\t\t// 创建单元格\n\t\t\t\t\tXSSFCell cell = r.createCell(j);\n\t\t\t\t\tObject value = obj[j];\n\t\t\t\t\t// 判断值的类型后进行强制类型转换\n\t\t\t\t\tString textValue = null;\n\t\t\t\t\tif (value instanceof Date) {\n\t\t\t\t\t\tDate date = (Date) value;\n\t\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\n\t\t\t\t\t\t\t\t"yy-MM-dd HH:mm:ss");\n\t\t\t\t\t\ttextValue = sdf.format(date);\n\t\t\t\t\t} else if (value instanceof byte[]) {\n\t\t\t\t\t\t// 有图片时，设置行高为60px;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\t\t// 如果值为空，什么都不做\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// 其它数据类型都当作字符串简单处理\n\t\t\t\t\t\t\ttextValue = value.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 如果不是图片数据，就利用正则表达式判断textValue是否全部由数字组成\n\t\t\t\t\tif (textValue != null) {\n\t\t\t\t\t\tPattern p = Pattern.compile("^//d+(//.//d+)?$");\n\t\t\t\t\t\tMatcher matcher = p.matcher(textValue);\n\t\t\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\t\t\t// 是数字当作double处理\n\t\t\t\t\t\t\tcell.setCellValue(Double.parseDouble(textValue));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tXSSFRichTextString richString = new XSSFRichTextString(\n\t\t\t\t\t\t\t\t\ttextValue);\n\t\t\t\t\t\t\tcell.setCellValue(richString);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {// 若果是空值，单元格显示为空\n\t\t\t\t\t\tcell.setCellValue(new XSSFRichTextString(""));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLong end1 = System.currentTimeMillis();\n\t\t\tSystem.out.println("第"+(x+1)+"个sheet总计时间：" +((end1-start1)/1000) + "s");\n\t\t\tif(doneSignal!=null){\n\t\t\t\tdoneSignal.countDown(); // 线程计数-1\n\t\t\t\tSystem.out.println("第" + (x+1) + "个sheet创建完成，" + "计数器减1");\n\t\t\t}\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n',normalizedContent:'因项目特殊，最近遇到了excel导出大数据量的问题，所以就趁着解决这个问题的机会，把poi导出excel再整理一遍，方便自己日后总结。\n\n\n\n * 概要\n * 问题原因\n * 解决办法：\n   * 1. 调整jvm/tomcat大小\n   * 2. 通过新版的sxssfworkbook来解决\n   * 3. 转csv导出\n   * 4. 本地90万数据：输入输出流+poi多线程多sheet导出excel\n   * 5. 浏览器：多线程多sheet页下载\n\n\n\n\n# 概要\n\nexcel：poi 多线程多sheet导出数据\n\n * excel2003版最大行数是65536，excel2007最大行数是1048576\n * excel2003版最大列数是256，excel2007最大列数是16384\n\n\n# 问题原因\n\n 1. 导出大数据量，可能遇到的第一个问题就是后台报：java.lang.outofmemoryerror: java heap space 内存溢出这个问题\n    \n    > 分析：poi导出时，会先把内容写到内存中，最后浏览器从内存中下载，但是数据量太大，会导致内存溢出\n\n\n# 解决办法：\n\n\n# 1. 调整jvm/tomcat大小\n\n * 设置jvm：-xms64m -xmx512m（依据你物理内存的大小调整）\n   \n   > 祥见：https://www.cnblogs.com/jhcelue/p/6900881.html\n\n\n# 2. 通过新版的sxssfworkbook来解决\n\n * 自poi3.8以后，可通过新版的sxssfworkbook来解决，可通过其构造函数指定在内存中缓存的行数，内存中指定行数满足时会自动缓存在硬盘的临时目录上然后循环下一次，同时，并不会存在页面卡顿的情况；\n   \n   > java使用poi如何导出百万级别数据：\n   > \n   > https://www.cnblogs.com/520playboy/p/6275170.html\n   > \n   > https://fanshuyao.iteye.com/blog/2426095\n\n\n# 3. 转csv导出\n\n * csv是一种通用的、相对简单的文件格式，其文件以纯文本形式存储表格数据（数字和文本）。\n * excel和csv格式文件的不同之处 => 传送门\n\n> 手写一个 csv，可先直接运行main()查看结果\n\npackage com.zpj.electric.utils;\n\nimport java.io.bufferedwriter;\nimport java.io.file;\nimport java.io.fileinputstream;\nimport java.io.filenotfoundexception;\nimport java.io.fileoutputstream;\nimport java.io.ioexception;\nimport java.io.inputstream;\nimport java.io.outputstream;\nimport java.io.outputstreamwriter;\nimport java.net.urlencoder;\nimport java.util.arraylist;\nimport java.util.iterator;\nimport java.util.linkedhashmap;\nimport java.util.list;\nimport java.util.map;\n\nimport javax.servlet.http.httpservletresponse;\n\nimport com.alibaba.druid.util.stringutils;\n\n/**\n * @classname: csvutils\n * @date: 2018/7/16\n * @version: 1.0\n */\n\npublic class csvutils {\n\n\n    /**\n     * 功能说明：获取utf-8编码文本文件开头的bom签名。\n     * bom(byte order mark)，是utf编码方案里用于标识编码的标准标记。例：接收者收到以ef bb bf开头的字节流，就知道是utf-8编码。\n     * @return utf-8编码文本文件开头的bom签名\n     */\n    public static string getbom() {\n\n        byte b[] = {(byte)0xef, (byte)0xbb, (byte)0xbf};\n        return new string(b);\n    }\n\n    /**\n     * 生成cvs文件\n     * @param exportdata\n     *       源数据list\n     * @param map\n     *       csv文件的列表头map\n     * @param outputpath\n     *       文件路径\n     * @param filename\n     *       文件名称\n     * @return\n     */\n    @suppresswarnings("rawtypes")\n    public static file createcsvfile(list exportdata, linkedhashmap map, string outputpath,\n                                     string filename) {\n        file csvfile = null;\n        bufferedwriter csvfileoutputstream = null;\n        try {\n            file file = new file(outputpath);\n            if (!file.exists()) {\n                file.mkdirs();\n            }\n            //定义文件名格式并创建\n            csvfile =new file(outputpath+filename+".csv");\n            file.createnewfile();\n            // utf-8使正确读取分隔符","\n            //如果生产文件乱码，windows下用gbk，linux用utf-8\n            csvfileoutputstream = new bufferedwriter(new outputstreamwriter(new fileoutputstream(\n                    csvfile), "utf-8"), 1024);\n\n            //写入前段字节流，防止乱码\n            csvfileoutputstream.write(getbom());\n            // 写入文件头部\n            for (iterator propertyiterator = map.entryset().iterator(); propertyiterator.hasnext();) {\n                java.util.map.entry propertyentry = (java.util.map.entry) propertyiterator.next();\n                csvfileoutputstream.write((string) propertyentry.getvalue() != null ? (string) propertyentry.getvalue() : "" );\n                if (propertyiterator.hasnext()) {\n                    csvfileoutputstream.write(",");\n                }\n            }\n            csvfileoutputstream.newline();\n            // 写入文件内容\n            for (iterator iterator = exportdata.iterator(); iterator.hasnext();) {\n                object row = (object) iterator.next();\n                for (iterator propertyiterator = map.entryset().iterator(); propertyiterator\n                        .hasnext();) {\n                    java.util.map.entry propertyentry = (java.util.map.entry) propertyiterator\n                            .next();\n                    string str=row!=null?((string)((map)row).get( propertyentry.getkey())):"";\n\n                    if(stringutils.isempty(str)){\n                        str="";\n                    }else{\n                        str=str.replaceall("\\"","\\"\\"");\n                        if(str.indexof(",")>=0){\n                            str="\\""+str+"\\"";\n                        }\n                    }\n                    csvfileoutputstream.write(str);\n                    if (propertyiterator.hasnext()) {\n                        csvfileoutputstream.write(",");\n                    }\n                }\n                if (iterator.hasnext()) {\n                    csvfileoutputstream.newline();\n                }\n            }\n            csvfileoutputstream.flush();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            try {\n                csvfileoutputstream.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n        return csvfile;\n    }\n\n    /**\n     *     生成并下载csv文件\n     * @param response\n     * @param exportdata\n     * @param map\n     * @param outputpath\n     * @param filename\n     * @throws ioexception\n     */\n    @suppresswarnings("rawtypes")\n    public static void exportdatafile(httpservletresponse response,list exportdata, linkedhashmap map, string outputpath,string filename) throws ioexception{\n        file csvfile = null;\n        bufferedwriter csvfileoutputstream = null;\n        try {\n            file file = new file(outputpath);\n            if (!file.exists()) {\n                file.mkdirs();\n            }\n            //定义文件名格式并创建\n            csvfile =new file(outputpath+filename+".csv");\n            if(csvfile.exists()){\n                csvfile.delete();\n            }\n            csvfile.createnewfile();\n            // utf-8使正确读取分隔符","\n            //如果生产文件乱码，windows下用gbk，linux用utf-8\n            csvfileoutputstream = new bufferedwriter(new outputstreamwriter(new fileoutputstream(csvfile), "utf-8"), 1024);\n            //写入前段字节流，防止乱码\n            csvfileoutputstream.write(getbom());\n            // 写入文件头部\n            for (iterator propertyiterator = map.entryset().iterator(); propertyiterator.hasnext();) {\n                java.util.map.entry propertyentry = (java.util.map.entry) propertyiterator.next();\n                csvfileoutputstream.write((string) propertyentry.getvalue() != null ? (string) propertyentry.getvalue() : "" );\n                if (propertyiterator.hasnext()) {\n                    csvfileoutputstream.write(",");\n                }\n            }\n            csvfileoutputstream.newline();\n            // 写入文件内容\n            for (iterator iterator = exportdata.iterator(); iterator.hasnext();) {\n                object row = (object) iterator.next();\n                for (iterator propertyiterator = map.entryset().iterator(); propertyiterator\n                        .hasnext();) {\n                    java.util.map.entry propertyentry = (java.util.map.entry) propertyiterator\n                            .next();\n                    string str=row!=null?((string)((map)row).get( propertyentry.getkey())):"";\n                    if(stringutils.isempty(str)){\n                        str="";\n                    }else{\n                        str=str.replaceall("\\"","\\"\\"");\n                        if(str.indexof(",")>=0){\n                            str="\\""+str+"\\"";\n                        }\n                    }\n                    csvfileoutputstream.write(str);\n                    if (propertyiterator.hasnext()) {\n                        csvfileoutputstream.write(",");\n                    }\n                }\n                if (iterator.hasnext()) {\n                    csvfileoutputstream.newline();\n                }\n            }\n            csvfileoutputstream.flush();\n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            try {\n                csvfileoutputstream.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n\n\n\n\n        inputstream in = null;\n        try {\n            in = new fileinputstream(outputpath+filename+".csv");\n            int len = 0;\n            byte[] buffer = new byte[1024];\n\n            outputstream out = response.getoutputstream();\n            response.reset();\n\n            response.setcontenttype("application/csv;charset=utf-8");\n            response.setheader("content-disposition","attachment; filename=" + urlencoder.encode(filename+".csv", "utf-8"));\n            response.setcharacterencoding("utf-8");\n            while ((len = in.read(buffer)) > 0) {\n                out.write(new byte[] { (byte) 0xef, (byte) 0xbb, (byte) 0xbf });\n                out.write(buffer, 0, len);\n            }\n            out.close();\n        } catch (filenotfoundexception e) {\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (exception e) {\n                    throw new runtimeexception(e);\n                }\n            }\n        }\n\n    }\n\n    /**\n     * 删除该目录filepath下的所有文件\n     * @param filepath\n     *      文件目录路径\n     */\n    public static void deletefiles(string filepath) {\n        file file = new file(filepath);\n        if (file.exists()) {\n            file[] files = file.listfiles();\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].isfile()) {\n                    files[i].delete();\n                }\n            }\n        }\n    }\n\n    /**\n     * 删除单个文件\n     * @param filepath\n     *     文件目录路径\n     * @param filename\n     *     文件名称\n     */\n    public static void deletefile(string filepath, string filename) {\n        file file = new file(filepath);\n        if (file.exists()) {\n            file[] files = file.listfiles();\n            for (int i = 0; i < files.length; i++) {\n                if (files[i].isfile()) {\n                    if (files[i].getname().equals(filename)) {\n                        files[i].delete();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * 测试数据\n     * @param args\n     */\n    @suppresswarnings({ "rawtypes", "unchecked" })\n    public static void main(string[] args) {\n        list exportdata = new arraylist<map>();\n        map row1 = new linkedhashmap<string, string>();\n        row1.put("1", "11");\n        row1.put("2", "12");\n        row1.put("3", "13");\n        row1.put("4", "14");\n        exportdata.add(row1);\n        row1 = new linkedhashmap<string, string>();\n        row1.put("1", "21");\n        row1.put("2", "22");\n        row1.put("3", "23");\n        row1.put("4", "24");\n        exportdata.add(row1);\n        linkedhashmap map = new linkedhashmap();\n\n        //设置列名\n        map.put("1", "第一列名称");\n        map.put("2", "第二列名称");\n        map.put("3", "第三列名称");\n        map.put("4", "第四列名称");\n        //这个文件上传到路径，可以配置在数据库从数据库读取，这样方便一些！\n        string path = "e:/";\n\n        //文件名=生产的文件名称+时间戳\n        string filename = "文件导出";\n        file file = csvutils.createcsvfile(exportdata, map, path, filename);\n        string filename2 = file.getname();\n        system.out.println("文件名称：" + filename2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n\n\n\n# 4. 本地90万数据：输入输出流+poi多线程多sheet导出excel\n\n> 可直接运行main()查看导出结果，注意poi版本3.7+\n\npackage com.zpj.electric.util.excel;\n\nimport com.zpj.electric.po.student;\nimport org.apache.commons.beanutils.propertyutilsbean;\nimport org.apache.commons.lang3.stringutils;\nimport org.apache.poi.ss.usermodel.row;\nimport org.apache.poi.ss.usermodel.sheet;\nimport org.apache.poi.ss.usermodel.workbook;\nimport org.apache.poi.xssf.streaming.sxssfworkbook;\n\nimport java.beans.propertydescriptor;\nimport java.io.file;\nimport java.io.fileoutputstream;\nimport java.io.ioexception;\nimport java.text.simpledateformat;\nimport java.util.*;\nimport java.util.concurrent.countdownlatch;\nimport java.util.concurrent.linkedblockingqueue;\nimport java.util.concurrent.threadpoolexecutor;\nimport java.util.concurrent.timeunit;\n\npublic class threadexcelutils {\n\n    /**\n     * 定义没个 sheet 最多数量\n     */\n    public static final integer excel_max_cnt = 50000;\n\n    private workbook wb;\n\n    private string filename;\n\n    private string filepath;\n\n    private string[] hearders;\n\n    private string[] fields;\n\n    public workbook getwb() {\n        return wb;\n    }\n\n    public string getfilename() {\n        return filename;\n    }\n\n    public string getfilepath() {\n        return filepath;\n    }\n\n    public string[] gethearders() {\n        return hearders;\n    }\n\n    public string[] getfields() {\n        return fields;\n    }\n\n    /**\n     * @param filename 文件名称\n     * @param filepath 文件路径\n     * @param hearders 文件头\n     * @param fields   字段属性\n     * @author maochuang.li\n     * @date create in 13:54 2017/12/28 0028\n     */\n    public threadexcelutils(string filename, string filepath, string[] hearders, string[] fields) {\n        this.wb = new sxssfworkbook(10000);\n        this.filename = filename;\n        this.filepath = filepath;\n        this.hearders = hearders;\n        this.fields = fields;\n    }\n\n    public static void main(string[] args) throws exception {\n        string[] header = {"姓名", "年龄"};\n        string[] filenames = {"name", "age"};\n        threadexcelutils utils = new threadexcelutils("测试excel1", "d:\\\\exceltext\\\\wer\\\\sd", header, filenames);\n        list list = new arraylist<>();\n        system.out.println("开始造数据.......");\n        for (int i = 0; i < 900000; i++) {\n            student student = new student();\n            student.setname("name->" + i);\n            student.setage(i);\n            list.add(student);\n        }\n        system.out.println(getdate(new date()) + "开始写入文件.......");\n        long starttime = system.currenttimemillis();\n        utils.exportexceltofilepath(list);\n        long endtime = system.currenttimemillis();\n        system.out.println("耗时：" + (endtime - starttime));\n        //耗时：29230\n        //耗时：25226\n\n    }\n\n    /**\n     * @param list 数据\n     * @author maochuang.li\n     * @date create in 10:52 2017/12/28 0028\n     */\n    public void exportexceltofilepath(list<object> list) throws exception {\n        int excelsize = excel_max_cnt;    //每个excel文件条数\n        int totalcount = list.size();    //查询结果总条数\n        int pagecount = 0;//总sheet页个数\n        int numpage = totalcount % excelsize;    //是否整页数\n        if (numpage > 0)\n            pagecount = totalcount / excelsize + 1;\n        else\n            pagecount = totalcount / excelsize;\n        //创建线程池 多sheet多线程写入 线程数 为sheet页的 1/4\n        integer threadnumber = pagecount / 4;\n        if (threadnumber == 0)\n            threadnumber = 1;\n//        executorservice threadpool = executors.newfixedthreadpool(threadnumber);\n        threadpoolexecutor threadpool = new threadpoolexecutor(threadnumber, threadnumber, 0l, timeunit.seconds, new linkedblockingqueue<>(50));\n        //创建栅栏 等待任务完成\n        countdownlatch countdownlatch = new countdownlatch(pagecount);\n        //循环遍历投递任务\n        for (int i = 1; i <= pagecount; i++) {\n            thraedexcel thraedexcel = new thraedexcel(list, i, pagecount, numpage, this);\n            thraedexcel.setcountdownlatch(countdownlatch);\n            threadpool.submit(thraedexcel);\n        }\n        countdownlatch.await(10l,timeunit.seconds);\n        system.err.println("超时拉=====================================");\n        workbook wb = getwb();\n        file file = new file(filepath);\n        if (!file.exists() && !file.isdirectory()) {\n            file.mkdirs();\n        }\n        fileoutputstream fout = new fileoutputstream(new file(file, filename + ".xls"));\n        try {\n            wb.write(fout);\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        system.out.println("文件写入完成");\n        //立即销毁线程池\n        threadpool.shutdownnow();\n    }\n\n\n    private static string getdate(date date) {\n        simpledateformat simpledateformat = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n        string format = simpledateformat.format(date);\n        return format;\n    }\n\n    /**\n     * javabean转map\n     *\n     * @param obj\n     * @return\n     */\n    public static map<string, object> beantomap(object obj) {\n        map<string, object> params = new hashmap<string, object>(0);\n        try {\n            propertyutilsbean propertyutilsbean = new propertyutilsbean();\n            propertydescriptor[] descriptors = propertyutilsbean.getpropertydescriptors(obj);\n            int length = descriptors.length;\n            for (int i = 0; i < length; i++) {\n                string name = descriptors[i].getname();\n                if (!stringutils.equals(name, "class")) {\n                    params.put(name, propertyutilsbean.getnestedproperty(obj, name));\n                }\n            }\n        } catch (exception e) {\n            system.err.println("bean 转map出错");\n            e.printstacktrace();\n        }\n        return params;\n    }\n\n    /***\n     * 线程写入sheet\n     */\n    private static class thraedexcel implements runnable {\n\n        private list<object> list;//数据\n\n        private integer sheetnumber;//当前sheet页\n\n        private integer totalsheetcount;//总数据\n\n        private int numpage;    //是否整页数\n\n        private integer excelsize;\n\n        private threadexcelutils threadexcelutils;\n        //栅栏对象\n        private countdownlatch countdownlatch;\n\n        /**\n         * @param list            总数据\n         * @param sheetnumber     当前sheet页\n         * @param totalsheetcount 总sheet页\n         * @param numpage         是否整数\n         * @author maochuang.li\n         * @date create in 11:12 2017/12/28 0028\n         */\n        public thraedexcel(list<object> list, integer sheetnumber, integer totalsheetcount, integer numpage, threadexcelutils threadexcelutils) {\n            this.list = list;//总数据\n            this.sheetnumber = sheetnumber;//当前sheet页\n            this.totalsheetcount = totalsheetcount;//总sheet页\n            this.numpage = numpage;//是否整除\n            this.excelsize = threadexcelutils.excel_max_cnt;//没个sheet最大数量\n            this.threadexcelutils = threadexcelutils;//当前线程对象\n        }\n\n        public void setcountdownlatch(countdownlatch countdownlatch) {\n            this.countdownlatch = countdownlatch;\n        }\n\n        @override\n        public void run() {\n            system.out.println("第"+sheetnumber+"个sheet开始");\n            list<object> sheetlist = null;\n            if (totalsheetcount > 1) {\n                if (numpage == 0) {\n                    sheetlist = list.sublist((sheetnumber - 1) * excelsize, excelsize * sheetnumber);\n                } else {\n                    if (sheetnumber == totalsheetcount) {\n                        sheetlist = list.sublist((sheetnumber - 1) * excelsize, list.size());\n                    } else {\n                        sheetlist = list.sublist((sheetnumber - 1) * excelsize, excelsize * (sheetnumber));\n                    }\n                }\n            } else\n                sheetlist = list;\n            //开始写入数据\n            createworkbook(sheetlist);\n            if (this.countdownlatch != null)\n                this.countdownlatch.countdown();\n            system.out.println("第"+sheetnumber+"个sheet  结束");\n        }\n\n        /***\n         * 写出数据\n         */\n        private void createworkbook(list<object> sheetlist) {\n            sheet sheet = null;\n            row row = null;\n            synchronized (threadexcelutils.class) {\n                string filename = threadexcelutils.getfilename();\n                workbook wb = threadexcelutils.getwb();\n                sheet = wb.createsheet(filename + "_" + this.sheetnumber);\n                row = sheet.createrow(0);\n            }\n            string[] header = threadexcelutils.gethearders();\n            string[] fields = threadexcelutils.getfields();\n            //设置标题\n            for (int i = 0; i < header.length; i++) {\n                row.createcell(i).setcellvalue(header[i]);\n            }\n            //开始写入数据\n            if (sheetlist != null && sheetlist.size() > 0) {\n                int datalength = sheetlist.size();\n                for (int i = 0; i < datalength; i++) {\n                    row row1 = sheet.createrow(i + 1);\n                    object obj = sheetlist.get(i);\n                    map<string, object> map = (obj instanceof map) ? (map<string, object>) obj : beantomap(obj);\n                    int length = fields.length;\n                    for (int j = 0; j < length; j++) {\n                        string key = fields[j];\n                        object value = map.get(key);\n//                        if ((stringutil.isnotblank(value))) {\n                        if (!(org.springframework.util.stringutils.isempty(value))) {\n                            //不晓得 此处为啥有线程安全问题\n                            synchronized (threadexcelutils.class) {\n                                if (value instanceof date) {\n                                    simpledateformat sdf = new simpledateformat("yyyy-mm-dd");\n                                    string format = sdf.format(value);\n                                    row1.createcell(j).setcellvalue(format);\n                                } else {\n                                    try {\n                                        row1.createcell(j).setcellvalue(value.tostring());\n                                    } catch (exception e) {\n                                        e.printstacktrace();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n\n\n\n# 5. 浏览器：多线程多sheet页下载\n\n * 先引入依赖\n\n\x3c!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\x3e\n        <dependency>\n            <groupid>org.apache.poi</groupid>\n            <artifactid>poi-ooxml</artifactid>\n            <version>3.9</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\x3e\n        <dependency>\n            <groupid>org.apache.poi</groupid>\n            <artifactid>poi</artifactid>\n            <version>3.9</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/commons-io/commons-io --\x3e\n        <dependency>\n            <groupid>commons-io</groupid>\n            <artifactid>commons-io</artifactid>\n            <version>2.4</version>\n        </dependency>\n        \x3c!-- https://mvnrepository.com/artifact/log4j/log4j --\x3e\n        <dependency>\n            <groupid>log4j</groupid>\n            <artifactid>log4j</artifactid>\n            <version>1.2.17</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 创建下载工具类（我写的太low，可以自己优化）\n\npackage com.zpj.electric.util;\n\nimport java.io.outputstream;\nimport java.text.simpledateformat;\nimport java.util.arraylist;\nimport java.util.date;\nimport java.util.list;\nimport java.util.concurrent.countdownlatch;\nimport java.util.concurrent.executionexception;\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.executors;\nimport java.util.concurrent.future;\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\nimport javax.servlet.http.httpservletresponse;\n\nimport org.apache.commons.io.ioutils;\nimport org.apache.log4j.logger;\nimport org.apache.poi.hssf.usermodel.hssfcell;\nimport org.apache.poi.hssf.usermodel.hssfcellstyle;\nimport org.apache.poi.hssf.usermodel.hssfclientanchor;\nimport org.apache.poi.hssf.usermodel.hssffont;\nimport org.apache.poi.hssf.usermodel.hssfpatriarch;\nimport org.apache.poi.hssf.usermodel.hssfrichtextstring;\nimport org.apache.poi.hssf.usermodel.hssfrow;\nimport org.apache.poi.hssf.usermodel.hssfsheet;\nimport org.apache.poi.hssf.usermodel.hssfworkbook;\nimport org.apache.poi.ss.usermodel.indexedcolors;\nimport org.apache.poi.ss.util.cellrangeaddress;\nimport org.apache.poi.xssf.usermodel.xssfcell;\nimport org.apache.poi.xssf.usermodel.xssfcellstyle;\nimport org.apache.poi.xssf.usermodel.xssffont;\nimport org.apache.poi.xssf.usermodel.xssfrichtextstring;\nimport org.apache.poi.xssf.usermodel.xssfrow;\nimport org.apache.poi.xssf.usermodel.xssfsheet;\nimport org.apache.poi.xssf.usermodel.xssfworkbook;\n\npublic class excelutil {\n\n\tprivate static logger log = logger.getlogger(excelutil.class);\n\n\tprivate static simpledateformat sdf = new simpledateformat("yyyymmddhhmmss");\n\tprivate final static string exce_version_03 = "03";\n\tprivate final static string exce_version_07 = "07";\n\n\t/**\n\t * @param resp\n\t * @param filename\n\t *            文件名，一级表头\n\t * @param usefirsttitle\n\t *            是否需要一级表头，true：是，false：否\n\t * @param version\n\t *            导出版本，可选值为 07，统一用07版\n\t * @param titles\n\t *            excel列名\n\t * @param data\n\t *            需要导出的数据集合\n\t */\n\tpublic static void exportexcel(httpservletresponse resp, string filename,\n\t\t\tboolean usefirsttitle, string version, string[] titles,\n\t\t\tlist<object[]> data) {\n\t\t// 如果传入的文件名为空，则使用当前时间作为文件名\n\t\tstring excelfilename = "";\n\t\tif ("".equals(filename) || filename == null) {\n\t\t\texcelfilename = sdf.format(new date());\n\t\t}\n\t\t// (data.size() >= 0) 当列表中没有数据时，导出的excel加上标题等。\n\t\tif (titles.length >= 0) {\n\t\t\ttry {\n\t\t\t\tif (exce_version_03.equals(version)) {\n\t\t\t\t\texcelfilename = filename + ".xls";\n\t\t\t\t} else if (exce_version_07.equals(version)) {\n\t\t\t\t\texcelfilename = filename + ".xlsx";\n\t\t\t\t}\n\n\t\t\t\tresp.setcontenttype("application/x-msdownload");\n\t\t\t\texcelfilename = new string(excelfilename.getbytes("gb2312"), "iso8859-1");\n\t\t\t\tresp.addheader("content-disposition", "attachment;filename="\n\t\t\t\t\t\t+ excelfilename);\n\t\t\t\toutputstream out = resp.getoutputstream();\n\t\t\t\tif (exce_version_03.equals(version)) {\n\t\t\t\t\texprotexcel_03(filename, titles, usefirsttitle, data, out);\n\t\t\t\t} else if (exce_version_07.equals(version)) {\n\t\t\t\t\texprotexcel_07_plus(excelfilename, titles, usefirsttitle, data, out);\n\t\t\t\t}\n\t\t\t} catch (exception e) {\n\t\t\t\tlog.error("", e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void exprotexcel_07_plus(string filename, string[] titles,\n\t\t\tboolean usefirsttitle, list<object[]> data, outputstream out) {\n\t\txssfworkbook wb = new xssfworkbook();\n\n\t\t//把要下载的数据分为多个sheet下载\n\t\tlist<list<object[]>> datalist = createlist(data, 50000);\n\t\tlong start = system.currenttimemillis();\n\t\tsystem.out.println("下载开始时间：" + start);\n\n\t\t//使用多线程下载\n\t\texecutorservice es = executors.newfixedthreadpool(datalist.size());\n\t\t//使用计步器\n\t\t// final countdownlatch donesignal = new countdownlatch(datalist.size());\n\t\tcountdownlatch donesignal = new countdownlatch(datalist.size());\n\n\t\ttry {\n\n\t\tfor(int x = 0;x<datalist.size();x++){\n\t\t\tpoiwriter poiwriter = new poiwriter(x, wb, filename, titles, data, datalist, usefirsttitle, donesignal);\n\t\t\tfuture future = es.submit(poiwriter);\n\t\t\t /*try {\n\t\t\t\t \t//如果future.get()返回null，任务完成\n\t\t            if(future.get()==null){\n\t\t                system.out.println("第"+(x+1)+"个sheet页，任务完成");\n\t\t            }\n\t\t        } catch (interruptedexception e) {\n\t\t        } catch (executionexception e) {\n\t\t            //失败\n\t\t            system.out.println("第"+(x+1)+"个sheet页，任务失败："+e.getcause().getmessage());\n\t\t        }*/\n\t\t\t//new poiwriter(x, wb, filename, titles, data, datalist, usefirsttitle, null).run();\n\t\t}\n\t\tdonesignal.await();//阻塞，直到计数器的值为0，才让主线程往下执行\n\t    es.shutdown();//关闭线程池\n\t\tlong end = system.currenttimemillis();\n\t\tsystem.out.println("总计下载时间：" + ((end-start)/1000) + "s");\n\t\t\twb.write(out);\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t} catch (exception e) {\n\t\t\tlog.error("", e);\n\t\t} finally {\n\t\t\tioutils.closequietly(out);\n\t\t}\n\n\t}\n\n\n\t public static list<list<object[]>>  createlist(list<object[]> targe,int size) {\n\t\t        list<list<object[]>> listarr = new arraylist<list<object[]>>();\n\t\t        //获取被拆分的数组个数\n\t\t        int arrsize = targe.size()%size==0?targe.size()/size:targe.size()/size+1;\n\t\t        for(int i=0;i<arrsize;i++) {\n\t\t            list<object[]>  sub = new arraylist<object[]>();\n\t\t            //把指定索引数据放入到list中\n\t\t            for(int j=i*size;j<=size*(i+1)-1;j++) {\n\t\t                if(j<=targe.size()-1) {\n\t\t                \t//得到拆分后的集合\n\t\t                    sub.add(targe.get(j));\n\t\t                }\n\t\t            }\n\t\t            //拆分的集合可以做点什么\n\t\t            //sub.dosomething();\n\t\t            //将拆分后的集合综合为一个集合\n\t\t            listarr.add(sub);\n\t\t        }\n\t\t        return listarr;\n\t }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n\n * 线程类\n\npackage com.zpj.electric.util;\n\nimport org.apache.poi.hssf.usermodel.hssfcellstyle;\nimport org.apache.poi.ss.usermodel.indexedcolors;\nimport org.apache.poi.ss.util.cellrangeaddress;\nimport org.apache.poi.xssf.usermodel.*;\n\nimport java.text.simpledateformat;\nimport java.util.date;\nimport java.util.list;\nimport java.util.concurrent.countdownlatch;\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class poiwriter implements runnable {\n\n\tpublic int x;//第几个sheet页\n\tpublic xssfworkbook wb;//poi workbook\n\tpublic string filename;//要导出的文件名字(含后缀)\n\tpublic string[] titles;//标题\n\tpublic list<object[]> data;//全部数据\n\tpublic list<list<object[]>> datalist;//包含了各个sheet页的数据\n\tpublic boolean usefirsttitle;//是否需要表头\n\tpublic  countdownlatch donesignal;//多线程栅栏计步器\n\n\n\tpublic poiwriter(int x, xssfworkbook wb, string filename, string[] titles,\n\t\t\tlist<object[]> data, list<list<object[]>> datalist,\n\t\t\tboolean usefirsttitle, countdownlatch donesignal) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.wb = wb;\n\t\tthis.filename = filename;\n\t\tthis.titles = titles;\n\t\tthis.data = data;\n\t\tthis.datalist = datalist;\n\t\tthis.usefirsttitle = usefirsttitle;\n\t\tthis.donesignal = donesignal;\n\t}\n\n\tpublic poiwriter() {\n\n\t}\n\n\t@override\n\tpublic void run() {\n\t\tlong start1 = system.currenttimemillis();\n\t\tsystem.out.println(filename+"：第"+(x+1)+"个sheet开始时间：" + start1);\n\t\t// 创建一sheet页\n\t\txssfsheet sheet = wb.createsheet("sheet"+x);\n\t\t// 设置格式 在单元格中右排放\n\t\txssfcellstyle style = wb.createcellstyle();\n\t\tstyle.setalignment(xssfcellstyle.align_right);\n\n\t\tint firstrow = 0;\n\t\tif (usefirsttitle) {\n\t\t\txssfrow fr = sheet.createrow(firstrow);\n\t\t\txssffont font = wb.createfont();\n\t\t\tfont.setfontname("宋体");\n\t\t\tfont.setfontheightinpoints((short) 16);\n\t\t\txssfcellstyle cs = wb.createcellstyle();\n\t\t\tcs.setalignment(xssfcellstyle.align_center);\n\t\t\tcs.setverticalalignment(xssfcellstyle.vertical_center);\n\t\t\tcs.setfont(font);\n\t\t\tfr.setheight((short) 700);\n\t\t\tfr.setheight((short) 700);\n\t\t\t//excel大标题和并列多了一列，当列表中数据为空时，导出的excel中加上标题等信息\n\t\t\tsheet.addmergedregion(new cellrangeaddress(0, 0, 0,\n\t\t\t\t\ttitles.length-1));\n\t\t\tfor (int i = 0; i < titles.length; i++) {\n\t\t\t\tfr.createcell(i);\n\t\t\t}\n\t\t\t/**\n\t\t\t * 自适应宽度\n\t\t\t */\n\t\t\tif(null!=data&&data.size()>0){\n\t\t\t\tobject[] obj=data.get(0);\n\t\t\t\tif(obj.length==titles.length){\n\t\t\t\t\tfor(int i=0;i<titles.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint contentlength=titles[i].length();\n\t\t\t\t\t\tif(null!=obj[i]&&obj[i].tostring().length()>titles[i].length()){\n\t\t\t\t\t\t\tcontentlength=obj[i].tostring().length();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//the maximum column width for an individual cell is 255 characters. 的解决方案\n\t\t\t\t\t\t\tif((short)50*(50+contentlength)/256>255){\n\t\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)254*256);  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)50*(50+contentlength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t//the maximum column width for an individual cell is 255 characters. 的解决方案\n\t\t\t\t\t\t\tif((short)100*(55+contentlength)/256>255){\n\t\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)254*256);  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)100*(55+contentlength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i=0;i<titles.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint contentlength=titles[i].length();\n\t\t\t\t\t\tif(i==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)50*(50+contentlength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tsheet.setcolumnwidth(i, (short)100*(55+contentlength));  //初始列宽+自适应宽度\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//创建新的样式给列表的大标题加上背景色\n\t\t\t xssfcellstyle alignstyle = (xssfcellstyle)wb.createcellstyle();\n\t\t\t alignstyle.setalignment(xssfcellstyle.align_center);\n\t\t\t alignstyle.setverticalalignment(xssfcellstyle.vertical_center);\n\t\t\t alignstyle.setfillpattern(hssfcellstyle.solid_foreground);\n\t\t\t alignstyle.setfillforegroundcolor(indexedcolors.sky_blue.getindex());\n\t\t\t alignstyle.setfont(font);\n\t\t\tfr.getcell(0).setcellvalue(new xssfrichtextstring(filename));\n\t\t\tfr.getcell(0).setcellstyle(alignstyle);\n\t\t\tfirstrow += 1;\n\t\t}\n\n\t\txssfrow row = sheet.createrow(firstrow);\n\t\tfor (int i = 0; i < titles.length; i++) {\n\t\t\trow.createcell(i).setcellvalue(new xssfrichtextstring(titles[i]));\n\t\t}\n\n\n\t\t\tfor (int i = 0; i < datalist.get(x).size(); i++) {\n\t\t\t\txssfrow r = sheet.createrow(i + firstrow + 1);\n\t\t\t\tobject[] obj = datalist.get(x).get(i);\n\t\t\t\tfor (int j = 0; j < obj.length; j++) {\n\t\t\t\t\t// 创建单元格\n\t\t\t\t\txssfcell cell = r.createcell(j);\n\t\t\t\t\tobject value = obj[j];\n\t\t\t\t\t// 判断值的类型后进行强制类型转换\n\t\t\t\t\tstring textvalue = null;\n\t\t\t\t\tif (value instanceof date) {\n\t\t\t\t\t\tdate date = (date) value;\n\t\t\t\t\t\tsimpledateformat sdf = new simpledateformat(\n\t\t\t\t\t\t\t\t"yy-mm-dd hh:mm:ss");\n\t\t\t\t\t\ttextvalue = sdf.format(date);\n\t\t\t\t\t} else if (value instanceof byte[]) {\n\t\t\t\t\t\t// 有图片时，设置行高为60px;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\t\t// 如果值为空，什么都不做\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// 其它数据类型都当作字符串简单处理\n\t\t\t\t\t\t\ttextvalue = value.tostring();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// 如果不是图片数据，就利用正则表达式判断textvalue是否全部由数字组成\n\t\t\t\t\tif (textvalue != null) {\n\t\t\t\t\t\tpattern p = pattern.compile("^//d+(//.//d+)?$");\n\t\t\t\t\t\tmatcher matcher = p.matcher(textvalue);\n\t\t\t\t\t\tif (matcher.matches()) {\n\t\t\t\t\t\t\t// 是数字当作double处理\n\t\t\t\t\t\t\tcell.setcellvalue(double.parsedouble(textvalue));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\txssfrichtextstring richstring = new xssfrichtextstring(\n\t\t\t\t\t\t\t\t\ttextvalue);\n\t\t\t\t\t\t\tcell.setcellvalue(richstring);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {// 若果是空值，单元格显示为空\n\t\t\t\t\t\tcell.setcellvalue(new xssfrichtextstring(""));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong end1 = system.currenttimemillis();\n\t\t\tsystem.out.println("第"+(x+1)+"个sheet总计时间：" +((end1-start1)/1000) + "s");\n\t\t\tif(donesignal!=null){\n\t\t\t\tdonesignal.countdown(); // 线程计数-1\n\t\t\t\tsystem.out.println("第" + (x+1) + "个sheet创建完成，" + "计数器减1");\n\t\t\t}\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"RabbitMQ - 基础",frontmatter:{title:"RabbitMQ - 基础",date:"2019-08-17T00:00:00.000Z",tags:["RabbitMQ"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/rabbitmq001.html",relativePath:"views/backend/rabbitmq001.md",key:"v-f59ecb92",path:"/views/backend/rabbitmq001.html",headers:[{level:2,title:"AMQP",slug:"amqp",normalizedTitle:"amqp",charIndex:50},{level:2,title:"Message Queue",slug:"message-queue",normalizedTitle:"message queue",charIndex:58},{level:2,title:"RabbitMQ",slug:"rabbitmq",normalizedTitle:"rabbitmq",charIndex:0},{level:2,title:"RabbitMQ应用场景",slug:"rabbitmq应用场景",normalizedTitle:"rabbitmq应用场景",charIndex:87},{level:2,title:"RabbitMQ的安装（基于Docker）",slug:"rabbitmq的安装-基于docker",normalizedTitle:"rabbitmq的安装（基于docker）",charIndex:103},{level:3,title:"Docker环境安装",slug:"docker环境安装",normalizedTitle:"docker环境安装",charIndex:130},{level:3,title:"RabbitMQ安装",slug:"rabbitmq安装",normalizedTitle:"rabbitmq安装",charIndex:146},{level:2,title:"RabbitMQ的使用",slug:"rabbitmq的使用",normalizedTitle:"rabbitmq的使用",charIndex:160},{level:3,title:"九大核心要素",slug:"九大核心要素",normalizedTitle:"九大核心要素",charIndex:177},{level:3,title:"6种消息队列模型",slug:"_6种消息队列模型",normalizedTitle:"6种消息队列模型",charIndex:189},{level:4,title:"主题模型",slug:"主题模型",normalizedTitle:"主题模型",charIndex:2326},{level:2,title:"SpringBoot整合RabbitMQ",slug:"springboot整合rabbitmq",normalizedTitle:"springboot整合rabbitmq",charIndex:201},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:225}],excerpt:"<Boxx/>\n<p>RabbitMQ的5种主题模式、使用场景、在Spring、SpringBoot中的使用</p>\n",headersStr:"AMQP Message Queue RabbitMQ RabbitMQ应用场景 RabbitMQ的安装（基于Docker） Docker环境安装 RabbitMQ安装 RabbitMQ的使用 九大核心要素 6种消息队列模型 主题模型 SpringBoot整合RabbitMQ 其它",content:'RabbitMQ的5种主题模式、使用场景、在Spring、SpringBoot中的使用\n\n\n\n * AMQP\n * Message Queue\n * RabbitMQ\n * RabbitMQ应用场景\n * RabbitMQ的安装（基于Docker）\n   * Docker环境安装\n   * RabbitMQ安装\n * RabbitMQ的使用\n   * 九大核心要素\n   * 6种消息队列模型\n * SpringBoot整合RabbitMQ\n * 其它\n\n\n\n\n# AMQP\n\n * AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品、不同的开发语言等条件的限制。\n\n\n# Message Queue\n\n * Message queue，即消息队列，是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。\n\n\n# RabbitMQ\n\n * 官网：http://www.rabbitmq.com/\n\n * RabbitMQ是基于Erlang语言开发的实现了高级消息队列协议（AMQP)的开源消息代理中间件，支持多种语言，多个平台。\n   \n   \n\n\n# RabbitMQ应用场景\n\n 1. 异步处理\n 2. 应用解耦\n 3. 流量削峰 -- 传送门\n\n\n# RabbitMQ的安装（基于Docker）\n\n> 基于Windows的安装忽略（注意的就是提前安装对应版本的Erlang环境）\n\n\n# Docker环境安装\n\n 1. 安装yum-utils：\n\nyum install -y yum -utils device -mapper -persistent -data lvm2\n\n\n1\n\n 2. 为yum源添加docker仓库位置：\n\nyum -config -manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n\n 3. 安装docker：\n\nyum install docker-ce\n\n\n1\n\n 4. 启动docker：\n\nsystemctl start docker\n\n\n1\n\n\n\n# RabbitMQ安装\n\n 1. 下载rabbitmq3.7.15的docker镜像：\n\ndocker pull rabbitmq:3.7.15\n\n\n1\n\n 2. 使用docker命令启动：\n\ndocker run -d --name rabbitmq \\\n-p 5672:5672 -p 15672:15672 \\\nrabbitmq:3.7.15\n\n\n1\n2\n3\n\n 3. 进入容器并开启管理功能：\n\ndocker exec -it rabbitmq /bin/bash \nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n2\n\n 4. 开启防火墙：\n\nfirewall-cmd --zone=public --add-port=15672/tcp --permanent\nfirewall-cmd --reload\n\n\n1\n2\n\n 5. 访问地址查看是否安装成功：\n    * http://192.168.3.101:15672/\n    * 默认账号密码均为：guest\n\n\n# RabbitMQ的使用\n\n\n# 九大核心要素\n\n名称             释义\nConnection     获取rabbitmq连接，比如一个TCP连接\nChannel        不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP\n               都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接，AMQP 命令都是通过信道发出去的\nPublisher      生产者\nMessage        消息体\nExchange       交换器，Exchange有4种类型： direct(直接)， fanout(广播), topic(主题),\n               和headers，不同类型的Exchange转发消息的策略有所区别\nQueue          消息队列，用来保存消息直到消费者进行消费。\nBinding        绑定，用于消息队列和交换器之间的关联。Exchange 和Queue的绑定可以是多对多的关系\nConsumer       消费者\nVirtual Host   虚拟主机，表示一批交换器、消息队列和相关对象。RabbitMQ 默认的 vhost 是 /\n\n\n# 6种消息队列模型\n\n\n\n * 官网是真的真的真的是最好的学习路径：https://www.rabbitmq.com/getstarted.html\n * 官网实例源码rabbitmq-java-maven：https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/java-mvn\n\n# 主题模型\n\n> 这里挑最主要的topic（主题）模型，介绍一下\n\n\n\n举例：如上图的主题模式中，交换机类型设为topic， Q1绑定 *.orange.* 路由键，Q2绑定两个路由键，分别是 *.*.rabbit 以及 lazy.#\n\n 1. 如果生产者发送路由键为quick.orange.rabbit消息，C1和C2都可以接收到。\n 2. 如果为lazy.orange.elephant， C1和C2都可以接收到\n 3. 如果为quick.orange.fox， 只要C1可以接收到\n 4. 如果为lazy.brown.fox， 只有C2可以接收到\n 5. 如果为lazy.pink.rabbit， C1，C2都可以\n 6. 如果为quick.brown.fox， 都不会接收到\n\ntopic交换机，配置路由键的时候可以配置 *, # 来模糊匹配\n\n 1. * 号表示可以精确匹配一个单词\n 2. # 号可以匹配0个或者多个单词\n\n# 多个消费者公平分发\n\npackage com.zpj.electric.rabbitMq;\n\nimport java.io.IOException;\n\n/**\n * Created by admin on 2019/12/2.\n * 用的是：\n  \t\t<dependency>\n            <groupId>com.rabbitmq</groupId>\n            <artifactId>amqp-client</artifactId>\n            <version>3.0.4</version>\n        </dependency>\n */\npublic class TestConsumer {\n    public static void main(String[] args) throws IOException {\n        //测试公平分发\n        Consumer recv1 = new Consumer("A",500);\n        recv1.recv_2();\n\n        Consumer recv2_2 = new Consumer("B",2000);\n        recv2_2.recv_2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 生产者\n\npackage com.zpj.electric.rabbitMq;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.MessageProperties;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\npublic class Producter {\n\n    private static final String EXCHANGE_NAME = "test_exchange_topic";\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 获取连接\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("127.0.0.1");\n        factory.setUsername("guest");\n        factory.setPassword("guest");\n        factory.setPort(5672);\n        Connection connection = factory.newConnection();\n        // 从连接开一个通道\n        Channel channel = connection.createChannel();\n        // 声明一个topic路由交换机，交换机持久化\n//        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        channel.exchangeDeclare(EXCHANGE_NAME, "topic", true);\n\n        // 发送消息\n        String message = "hello, quick.orange.rabbit";\n        /*参数说明：\n            String exchange -- 交换机名称\n        \tString routingKey -- 路由关键字\n        \tBasicProperties props -- 消息的基本属性，例如路由头等\n        \tbyte[] body -- 消息体\n        */\n        for (int i = 0; i < 100; i++) {\n            message = "hello, quick.orange.rabbit" + "  -------  " + i;\n\n            //参数：交换机名，路由键，消息持久化的，消息体\n            channel.basicPublish(EXCHANGE_NAME, "quick.orange.rabbit", MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());\n            System.out.println(" [x] Sent message : \'" + message + "\'");\n        }\n\n        channel.close();\n        connection.close();\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n# 消费者\n\npackage com.zpj.electric.rabbitMq;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\n\npublic  class Consumer {\n\n    private static final String QUEUE_NAME = "test_queue_topic_1";\n    private static final String EXCHANGE_NAME = "test_exchange_topic";\n\n    //消费者名称\n    private String name;\n    //休眠时间\n    private int sleepTime;\n\n    public Consumer(String name, int sleepTime) {\n        this.name = name;\n        this.sleepTime = sleepTime;\n    }\n\n    public void recv_2() throws IOException {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("127.0.0.1");\n        factory.setUsername("guest");\n        factory.setPassword("guest");\n        factory.setPort(5672);\n        Connection connection = factory.newConnection();\n\n        // 打开通道\n        Channel channel = connection.createChannel();\n\n        //交换机\n        channel.exchangeDeclare(EXCHANGE_NAME, "topic", true);\n\n        // 申明要消费的队列\n        //创建一个持久化的 不排他的 非自动删除的队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n\n        // 绑定队列到交换机\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "*.orange.*");\n\n        // 这样RabbitMQ就会使得每个Consumer在同一个时间点最多处理一个Message。换句话说，在接收到该Consumer的ack前，他它不会将新的Message分发给它。\n        //mq的公平分发也用到这个\n        channel.basicQos(1);\n\n        // 创建一个回调的消费者处理类\n        com.rabbitmq.client.Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                // 接收到的消息\n                String message = new String(body);\n                System.out.println(name + " Received \'" + message + "\'");\n\n                try {\n                    Thread.sleep(sleepTime);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    System.out.println(name + " 完成： done ");\n                    // false：手动应答\n                    channel.basicAck(envelope.getDeliveryTag(), false);\n                }\n            }\n        };\n\n        // 消费消息 false：手动应答\n        channel.basicConsume(QUEUE_NAME, false, consumer);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# SpringBoot整合RabbitMQ\n\n> 还是以 topic 为例子\n\n 1. 导入maven依赖\n\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n2.修改SpringBoot配置文件application.yml\n\n rabbitmq:\n \thost: localhost # rabbitmq的连接地址\n \tport: 5672 # rabbitmq的连接端口号\n\tvirtual-host: /test # rabbitmq的虚拟host\n\tusername: guest # rabbitmq的用户名\n\tpassword: guest # rabbitmq的密码\n\tpublisher-confirms: true # 如果对异步消息需要回调必须设置为true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. 配置类\n\npackage com.example.rabbitmqdemo.config;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.amqp.core.TopicExchange;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:10\n **/\n@Configuration\npublic class TopicRabbitConfig {\n\n\n    final static String message = "topic.message";\n    final static String messages = "topic.messages";\n\n\n    //创建两个 Queue\n    @Bean\n    public Queue queueMessage(){\n        return new Queue(TopicRabbitConfig.message);\n    }\n\n    @Bean\n    public Queue queueMessages(){\n        return new Queue(TopicRabbitConfig.messages);\n    }\n\n    //配置 TopicExchange,指定名称为 topicExchange\n    @Bean\n    public TopicExchange exchange(){\n        return new TopicExchange("topicExchange");\n    }\n\n    //给队列绑定 exchange 和 routing_key\n\n    @Bean\n    public Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange){\n        return BindingBuilder.bind(queueMessage).to(exchange).with("topic.message");\n    }\n\n    @Bean\n    public Binding bingingExchangeMessages(Queue queueMessages,TopicExchange exchange){\n        return BindingBuilder.bind(queueMessages).to(exchange).with("topic.#");\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 4. 生产者\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:26\n **/\n@Component\npublic class TopicSender {\n\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    public void send1(){\n        String context = "hi, i am message 1";\n        System.out.println("Sender : " + context);\n        amqpTemplate.convertAndSend("topicExchange","topic.message",context);\n    }\n\n    public void send2() {\n        String context = "hi, i am messages 2";\n        System.out.println("Sender : " + context);\n        amqpTemplate.convertAndSend("topicExchange", "topic.messages", context);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 5. 2个消费者\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:34\n **/\n@Component\n@RabbitListener(queues = "topic.message")\npublic class TopicReceiver1 {\n\n    @RabbitHandler\n    public void process(String message){\n\n        System.out.println("Receiver topic.message :"+ message);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:34\n **/\n@Component\n@RabbitListener(queues = "topic.messages")\npublic class TopicReceiver2 {\n\n    @RabbitHandler\n    public void process(String message){\n\n        System.out.println("Receiver topic.messages: "+ message);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 其它\n\n * RabbitMQ教程\n * 主题模式\n * SpringBoot整合RabbitMQ\n * 整合RabbitMQ实现延迟消息',normalizedContent:'rabbitmq的5种主题模式、使用场景、在spring、springboot中的使用\n\n\n\n * amqp\n * message queue\n * rabbitmq\n * rabbitmq应用场景\n * rabbitmq的安装（基于docker）\n   * docker环境安装\n   * rabbitmq安装\n * rabbitmq的使用\n   * 九大核心要素\n   * 6种消息队列模型\n * springboot整合rabbitmq\n * 其它\n\n\n\n\n# amqp\n\n * amqp，即advanced message queuing protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品、不同的开发语言等条件的限制。\n\n\n# message queue\n\n * message queue，即消息队列，是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。\n\n\n# rabbitmq\n\n * 官网：http://www.rabbitmq.com/\n\n * rabbitmq是基于erlang语言开发的实现了高级消息队列协议（amqp)的开源消息代理中间件，支持多种语言，多个平台。\n   \n   \n\n\n# rabbitmq应用场景\n\n 1. 异步处理\n 2. 应用解耦\n 3. 流量削峰 -- 传送门\n\n\n# rabbitmq的安装（基于docker）\n\n> 基于windows的安装忽略（注意的就是提前安装对应版本的erlang环境）\n\n\n# docker环境安装\n\n 1. 安装yum-utils：\n\nyum install -y yum -utils device -mapper -persistent -data lvm2\n\n\n1\n\n 2. 为yum源添加docker仓库位置：\n\nyum -config -manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n\n1\n\n 3. 安装docker：\n\nyum install docker-ce\n\n\n1\n\n 4. 启动docker：\n\nsystemctl start docker\n\n\n1\n\n\n\n# rabbitmq安装\n\n 1. 下载rabbitmq3.7.15的docker镜像：\n\ndocker pull rabbitmq:3.7.15\n\n\n1\n\n 2. 使用docker命令启动：\n\ndocker run -d --name rabbitmq \\\n-p 5672:5672 -p 15672:15672 \\\nrabbitmq:3.7.15\n\n\n1\n2\n3\n\n 3. 进入容器并开启管理功能：\n\ndocker exec -it rabbitmq /bin/bash \nrabbitmq-plugins enable rabbitmq_management\n\n\n1\n2\n\n 4. 开启防火墙：\n\nfirewall-cmd --zone=public --add-port=15672/tcp --permanent\nfirewall-cmd --reload\n\n\n1\n2\n\n 5. 访问地址查看是否安装成功：\n    * http://192.168.3.101:15672/\n    * 默认账号密码均为：guest\n\n\n# rabbitmq的使用\n\n\n# 九大核心要素\n\n名称             释义\nconnection     获取rabbitmq连接，比如一个tcp连接\nchannel        不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 tcp\n               都是非常昂贵的开销，所以引入了信道的概念，以复用一条 tcp 连接，amqp 命令都是通过信道发出去的\npublisher      生产者\nmessage        消息体\nexchange       交换器，exchange有4种类型： direct(直接)， fanout(广播), topic(主题),\n               和headers，不同类型的exchange转发消息的策略有所区别\nqueue          消息队列，用来保存消息直到消费者进行消费。\nbinding        绑定，用于消息队列和交换器之间的关联。exchange 和queue的绑定可以是多对多的关系\nconsumer       消费者\nvirtual host   虚拟主机，表示一批交换器、消息队列和相关对象。rabbitmq 默认的 vhost 是 /\n\n\n# 6种消息队列模型\n\n\n\n * 官网是真的真的真的是最好的学习路径：https://www.rabbitmq.com/getstarted.html\n * 官网实例源码rabbitmq-java-maven：https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/java-mvn\n\n# 主题模型\n\n> 这里挑最主要的topic（主题）模型，介绍一下\n\n\n\n举例：如上图的主题模式中，交换机类型设为topic， q1绑定 *.orange.* 路由键，q2绑定两个路由键，分别是 *.*.rabbit 以及 lazy.#\n\n 1. 如果生产者发送路由键为quick.orange.rabbit消息，c1和c2都可以接收到。\n 2. 如果为lazy.orange.elephant， c1和c2都可以接收到\n 3. 如果为quick.orange.fox， 只要c1可以接收到\n 4. 如果为lazy.brown.fox， 只有c2可以接收到\n 5. 如果为lazy.pink.rabbit， c1，c2都可以\n 6. 如果为quick.brown.fox， 都不会接收到\n\ntopic交换机，配置路由键的时候可以配置 *, # 来模糊匹配\n\n 1. * 号表示可以精确匹配一个单词\n 2. # 号可以匹配0个或者多个单词\n\n# 多个消费者公平分发\n\npackage com.zpj.electric.rabbitmq;\n\nimport java.io.ioexception;\n\n/**\n * created by admin on 2019/12/2.\n * 用的是：\n  \t\t<dependency>\n            <groupid>com.rabbitmq</groupid>\n            <artifactid>amqp-client</artifactid>\n            <version>3.0.4</version>\n        </dependency>\n */\npublic class testconsumer {\n    public static void main(string[] args) throws ioexception {\n        //测试公平分发\n        consumer recv1 = new consumer("a",500);\n        recv1.recv_2();\n\n        consumer recv2_2 = new consumer("b",2000);\n        recv2_2.recv_2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 生产者\n\npackage com.zpj.electric.rabbitmq;\n\nimport com.rabbitmq.client.channel;\nimport com.rabbitmq.client.connection;\nimport com.rabbitmq.client.connectionfactory;\nimport com.rabbitmq.client.messageproperties;\n\nimport java.io.ioexception;\nimport java.util.concurrent.timeoutexception;\n\npublic class producter {\n\n    private static final string exchange_name = "test_exchange_topic";\n\n    public static void main(string[] args) throws ioexception, timeoutexception {\n        // 获取连接\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("127.0.0.1");\n        factory.setusername("guest");\n        factory.setpassword("guest");\n        factory.setport(5672);\n        connection connection = factory.newconnection();\n        // 从连接开一个通道\n        channel channel = connection.createchannel();\n        // 声明一个topic路由交换机，交换机持久化\n//        channel.exchangedeclare(exchange_name, builtinexchangetype.topic);\n        channel.exchangedeclare(exchange_name, "topic", true);\n\n        // 发送消息\n        string message = "hello, quick.orange.rabbit";\n        /*参数说明：\n            string exchange -- 交换机名称\n        \tstring routingkey -- 路由关键字\n        \tbasicproperties props -- 消息的基本属性，例如路由头等\n        \tbyte[] body -- 消息体\n        */\n        for (int i = 0; i < 100; i++) {\n            message = "hello, quick.orange.rabbit" + "  -------  " + i;\n\n            //参数：交换机名，路由键，消息持久化的，消息体\n            channel.basicpublish(exchange_name, "quick.orange.rabbit", messageproperties.persistent_text_plain, message.getbytes());\n            system.out.println(" [x] sent message : \'" + message + "\'");\n        }\n\n        channel.close();\n        connection.close();\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n# 消费者\n\npackage com.zpj.electric.rabbitmq;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.ioexception;\n\npublic  class consumer {\n\n    private static final string queue_name = "test_queue_topic_1";\n    private static final string exchange_name = "test_exchange_topic";\n\n    //消费者名称\n    private string name;\n    //休眠时间\n    private int sleeptime;\n\n    public consumer(string name, int sleeptime) {\n        this.name = name;\n        this.sleeptime = sleeptime;\n    }\n\n    public void recv_2() throws ioexception {\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("127.0.0.1");\n        factory.setusername("guest");\n        factory.setpassword("guest");\n        factory.setport(5672);\n        connection connection = factory.newconnection();\n\n        // 打开通道\n        channel channel = connection.createchannel();\n\n        //交换机\n        channel.exchangedeclare(exchange_name, "topic", true);\n\n        // 申明要消费的队列\n        //创建一个持久化的 不排他的 非自动删除的队列\n        channel.queuedeclare(queue_name, true, false, false, null);\n\n        // 绑定队列到交换机\n        channel.queuebind(queue_name, exchange_name, "*.orange.*");\n\n        // 这样rabbitmq就会使得每个consumer在同一个时间点最多处理一个message。换句话说，在接收到该consumer的ack前，他它不会将新的message分发给它。\n        //mq的公平分发也用到这个\n        channel.basicqos(1);\n\n        // 创建一个回调的消费者处理类\n        com.rabbitmq.client.consumer consumer = new defaultconsumer(channel) {\n            @override\n            public void handledelivery(string consumertag, envelope envelope, amqp.basicproperties properties, byte[] body) throws ioexception {\n                // 接收到的消息\n                string message = new string(body);\n                system.out.println(name + " received \'" + message + "\'");\n\n                try {\n                    thread.sleep(sleeptime);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                } finally {\n                    system.out.println(name + " 完成： done ");\n                    // false：手动应答\n                    channel.basicack(envelope.getdeliverytag(), false);\n                }\n            }\n        };\n\n        // 消费消息 false：手动应答\n        channel.basicconsume(queue_name, false, consumer);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# springboot整合rabbitmq\n\n> 还是以 topic 为例子\n\n 1. 导入maven依赖\n\n<dependency>\n\t<groupid>org.springframework.boot</groupid>\n\t<artifactid>spring-boot-starter-amqp</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n\n\n2.修改springboot配置文件application.yml\n\n rabbitmq:\n \thost: localhost # rabbitmq的连接地址\n \tport: 5672 # rabbitmq的连接端口号\n\tvirtual-host: /test # rabbitmq的虚拟host\n\tusername: guest # rabbitmq的用户名\n\tpassword: guest # rabbitmq的密码\n\tpublisher-confirms: true # 如果对异步消息需要回调必须设置为true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 3. 配置类\n\npackage com.example.rabbitmqdemo.config;\n\nimport org.springframework.amqp.core.binding;\nimport org.springframework.amqp.core.bindingbuilder;\nimport org.springframework.amqp.core.queue;\nimport org.springframework.amqp.core.topicexchange;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.context.annotation.configuration;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:10\n **/\n@configuration\npublic class topicrabbitconfig {\n\n\n    final static string message = "topic.message";\n    final static string messages = "topic.messages";\n\n\n    //创建两个 queue\n    @bean\n    public queue queuemessage(){\n        return new queue(topicrabbitconfig.message);\n    }\n\n    @bean\n    public queue queuemessages(){\n        return new queue(topicrabbitconfig.messages);\n    }\n\n    //配置 topicexchange,指定名称为 topicexchange\n    @bean\n    public topicexchange exchange(){\n        return new topicexchange("topicexchange");\n    }\n\n    //给队列绑定 exchange 和 routing_key\n\n    @bean\n    public binding bindingexchangemessage(queue queuemessage, topicexchange exchange){\n        return bindingbuilder.bind(queuemessage).to(exchange).with("topic.message");\n    }\n\n    @bean\n    public binding bingingexchangemessages(queue queuemessages,topicexchange exchange){\n        return bindingbuilder.bind(queuemessages).to(exchange).with("topic.#");\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n 4. 生产者\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.core.amqptemplate;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:26\n **/\n@component\npublic class topicsender {\n\n    @autowired\n    amqptemplate amqptemplate;\n\n    public void send1(){\n        string context = "hi, i am message 1";\n        system.out.println("sender : " + context);\n        amqptemplate.convertandsend("topicexchange","topic.message",context);\n    }\n\n    public void send2() {\n        string context = "hi, i am messages 2";\n        system.out.println("sender : " + context);\n        amqptemplate.convertandsend("topicexchange", "topic.messages", context);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 5. 2个消费者\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.rabbit.annotation.rabbithandler;\nimport org.springframework.amqp.rabbit.annotation.rabbitlistener;\nimport org.springframework.stereotype.component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:34\n **/\n@component\n@rabbitlistener(queues = "topic.message")\npublic class topicreceiver1 {\n\n    @rabbithandler\n    public void process(string message){\n\n        system.out.println("receiver topic.message :"+ message);\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\npackage com.example.rabbitmqdemo.topic;\n\nimport org.springframework.amqp.rabbit.annotation.rabbithandler;\nimport org.springframework.amqp.rabbit.annotation.rabbitlistener;\nimport org.springframework.stereotype.component;\n\n/**\n * @author itguang\n * @create 2018-04-21 16:34\n **/\n@component\n@rabbitlistener(queues = "topic.messages")\npublic class topicreceiver2 {\n\n    @rabbithandler\n    public void process(string message){\n\n        system.out.println("receiver topic.messages: "+ message);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 其它\n\n * rabbitmq教程\n * 主题模式\n * springboot整合rabbitmq\n * 整合rabbitmq实现延迟消息',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Quartz定时任务",frontmatter:{title:"Quartz定时任务",date:"2019-09-15T00:00:00.000Z",tags:["定时任务"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/quartz.html",relativePath:"views/backend/quartz.md",key:"v-77367395",path:"/views/backend/quartz.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:9},{level:2,title:"简要步骤",slug:"简要步骤",normalizedTitle:"简要步骤",charIndex:17},{level:2,title:"Cron表达式",slug:"cron表达式",normalizedTitle:"cron表达式",charIndex:25},{level:2,title:"Spring整合Quartz",slug:"spring整合quartz",normalizedTitle:"spring整合quartz",charIndex:36},{level:3,title:"applicationContext-quartz.xml配置",slug:"applicationcontext-quartz-xml配置",normalizedTitle:"applicationcontext-quartz.xml配置",charIndex:56},{level:3,title:"业务类",slug:"业务类",normalizedTitle:"业务类",charIndex:93},{level:2,title:"SpringBoot整合Quartz",slug:"springboot整合quartz",normalizedTitle:"springboot整合quartz",charIndex:100},{level:3,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:124},{level:2,title:"任务类",slug:"任务类",normalizedTitle:"任务类",charIndex:130},{level:2,title:"可能遇到的问题",slug:"可能遇到的问题",normalizedTitle:"可能遇到的问题",charIndex:137},{level:3,title:"在实现Job接口的业务类中无法注入其他bean",slug:"在实现job接口的业务类中无法注入其他bean",normalizedTitle:"在实现job接口的业务类中无法注入其他bean",charIndex:150},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:177}],headersStr:"简介 使用场景 简要步骤 Cron表达式 Spring整合Quartz applicationContext-quartz.xml配置 业务类 SpringBoot整合Quartz 依赖 任务类 可能遇到的问题 在实现Job接口的业务类中无法注入其他bean 其它",content:' * 简介\n * 使用场景\n * 简要步骤\n * Cron表达式\n * Spring整合Quartz\n   * applicationContext-quartz.xml配置\n   * 业务类\n * SpringBoot整合Quartz\n   * 依赖\n * 任务类\n * 可能遇到的问题\n   * 在实现Job接口的业务类中无法注入其他bean\n * 其它\n\n\n\n\n# 简介\n\n> Quartz快速入门指南：https://www.w3cschool.cn/quartz_doc/\n\n * Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。\n * 需要注意的是：Spring3.1+版本支持Quartz2.x，对Spring3.1-版本请使用Quartz1.x。（另外Quzrtz2.x版本升级比较大，相比较Quartz1.x配置时请把 CronTriggerBean 改为 CronTriggerFactoryBean）\n\n\n# 使用场景\n\n * 定时生成报表\n * 定时发送邮件\n * 定时发送短信 sms\n * 数据库(表)与数据库(表) 同步数据/备份数据\n * QQ会员到期\n\n\n# 简要步骤\n\n> 以下4步中：4依赖3 --\x3e 3依赖2 --\x3e 2依赖1\n\n 1. 业务【 Job 】：我们自己手写的业务类（可以有多个）\n 2. 任务【 JobDetail 】：我们要对哪个业务进行操作，或者具体对业务类里的哪个方法操作（可以有多个）\n 3. 触发器【 Trigger 】：即Cron表达式，什么时间触发这个任务（可以有多个）\n 4. 调度器【 Scheduler 】：当我们配置好上述参数时，由Quartz的Scheduler 容器调度（只能有一个，一个调度器可以注册多个JobDetail 和 Trigger）\n\n\n# Cron表达式\n\nCron表达式的时间字段除允许设置数值外，还可使用一些特殊的字符，提供列表、范围、通配符等功能，细说如下：\n\n名称       释义\n星号(*)：   可用在所有字段中，表示对应时间域的每一个时刻，例如，*在分钟字段时，表示“每分钟”；\n问号(?）：   该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；\n减号(-)：   表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；\n逗号(,)：   表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；\n斜杠(/)：   x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；\n\n名称   是否必须   允许值              允许的通配符\n秒    是      0-59             , - * /\n分    是      0-59             , - * /\n时    是      0-23             , - * /\n日    是      1-31             , - * / L W ?\n月    是      1-12 或 JAN-DEC   , - * /\n周    是      1-7 或 SUN-SAT    , - * / L # ?\n年    否      空 或 1970-2099    , - * /\n\n * 在线Corn表达式生成器：http://cron.qqe2.com\n\n\n# Spring整合Quartz\n\n\n# applicationContext-quartz.xml配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\txmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n\txmlns:context="http://www.springframework.org/schema/context"\n\txsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">\n\n\t\x3c!-- 1.业务 我们自己手写的类--\x3e\n\t<bean id="jobTask" class="com.etoak.task.Job" />\n\t\t\n\t\x3c!-- 2.任务   --\x3e\n\t<bean id="jobDetail"  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">\n\t\t\n\t\t\x3c!-- 任务调用业务目标对象 Job对象 --\x3e\n\t\t<property name="targetObject" ref="jobTask"></property>\n\t\t\x3c!-- 任务调用业务目标对象方法名称 job方法 --\x3e\n\t\t<property name="targetMethod" value="job"></property>\n\t\t\x3c!-- false防止并发执行 --\x3e\n\t\t<property name="concurrent" value="false"></property>\n\t\n\t</bean>\t\t\n\t\n\t\x3c!-- 3.触发器 --\x3e\n\t<bean id="cronTriggerBean" class="org.springframework.scheduling.quartz.CronTriggerBean">\n\t\t\x3c!-- 注入任务 --\x3e\n\t\t<property name="jobDetail" ref="jobDetail"></property>\n\t\t\x3c!-- \n\t\t\t执行触发时间 ，  一旦时间触发 调用任务 \t\n\t\t    cron表达式  使用日期和星期  必须有个为问号（？） 而且不能同时出现问号（？）\n\t\t--\x3e\n\t\t<property name="cronExpression" value="0 0/5 * * * ?"></property>\n\t</bean>\n\t\n\t\x3c!-- \n\t\t4.调度器   监听器 \n\t\t容器启动 触发调度器  处于监听\t\n\t--\x3e\n\t<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">\n\t\t\x3c!-- 监听触发器 --\x3e\n\t\t<property name="triggers">\n\t\t\t<list>\n\t\t\t\t<ref bean="cronTriggerBean" />\n\t\t\t</list>\n\t\t</property>\n\t</bean>\n\t\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 业务类\n\npackage com.zpj80231.task;\n\nimport com.zpj80231.bean.User;\nimport com.zpj80231.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.List;\n\n//1.业务\npublic class Job {\n\t\n\t@Autowired\n\tprivate UserMapper mapper;\n\t\n\t/**\n\t *  定时任务 自定义方法时\n\t * \t不需要加入返回值\n\t * \t方法不能加入参数\n\t * \n\t * \t不能接收请求\n\t * \t不能响应请求\n\t */\n\tpublic void job() {\n\t\tList<User> list = mapper.getAll();\n\t\tfor(User user:list) {\n\t\t\tSystem.out.println(user.getUsername());\n\t\t\tSystem.out.println("-----------------");\n\t\t}\t\n\t}\n\t\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# SpringBoot整合Quartz\n\n> 两个注解搞定\n\n * 启动类添加@EnableScheduling\n * 定时任务类的方法上添加@Scheduled\n\n\n# 依赖\n\n<dependency>  \n    <groupId>org.quartz-scheduler</groupId>  \n    <artifactId>quartz</artifactId>  \n    <version>2.2.3</version>  \n</dependency> \n<dependency>  \n    <groupId>org.quartz-scheduler</groupId>  \n    <artifactId>quartz-jobs</artifactId>  \n    <version>2.2.3</version>  \n</dependency>\n<dependency>\x3c!-- 该依赖必加，里面有sping对schedule的支持 --\x3e\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context-support</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 任务类\n\npackage com.zpj80231.task;\n\nimport java.util.Date;\n\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class JobAnno {\n\t\n    @Autowire\n    private XXXX xxxx;\n    \n\t/**\n\t * 定时任务 自定义方法时\n\t * \t不需要加入返回值\n\t * \t方法不能加入参数\n\t * \n\t * \t不能接收请求\n\t * \t不能响应请求\n\t */\n\t@Scheduled(cron="0/10 * * * * ?")\n\tpublic void jobAnno() {\n\t\tSystem.out.println("jobAnno:" + new Date() + xxxx.xxXX());\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 可能遇到的问题\n\n\n# 在实现Job接口的业务类中无法注入其他bean\n\n * 在job任务类的执行方法中通过ApplicationContext.getBean()来获得 -- 传送们\n\n\n# 其它\n\n * Springboot整合Quartz实现动态定时任务\n * 在Spring中的话通过 实现定时任务的几种方式 里的RAMQuartz实现ServletContextListener重写contextInitialized方法实现定时任务',normalizedContent:' * 简介\n * 使用场景\n * 简要步骤\n * cron表达式\n * spring整合quartz\n   * applicationcontext-quartz.xml配置\n   * 业务类\n * springboot整合quartz\n   * 依赖\n * 任务类\n * 可能遇到的问题\n   * 在实现job接口的业务类中无法注入其他bean\n * 其它\n\n\n\n\n# 简介\n\n> quartz快速入门指南：https://www.w3cschool.cn/quartz_doc/\n\n * quartz 是一个完全由 java 编写的开源作业调度框架，为在 java 应用程序中进行作业调度提供了简单却强大的机制。\n * 需要注意的是：spring3.1+版本支持quartz2.x，对spring3.1-版本请使用quartz1.x。（另外quzrtz2.x版本升级比较大，相比较quartz1.x配置时请把 crontriggerbean 改为 crontriggerfactorybean）\n\n\n# 使用场景\n\n * 定时生成报表\n * 定时发送邮件\n * 定时发送短信 sms\n * 数据库(表)与数据库(表) 同步数据/备份数据\n * qq会员到期\n\n\n# 简要步骤\n\n> 以下4步中：4依赖3 --\x3e 3依赖2 --\x3e 2依赖1\n\n 1. 业务【 job 】：我们自己手写的业务类（可以有多个）\n 2. 任务【 jobdetail 】：我们要对哪个业务进行操作，或者具体对业务类里的哪个方法操作（可以有多个）\n 3. 触发器【 trigger 】：即cron表达式，什么时间触发这个任务（可以有多个）\n 4. 调度器【 scheduler 】：当我们配置好上述参数时，由quartz的scheduler 容器调度（只能有一个，一个调度器可以注册多个jobdetail 和 trigger）\n\n\n# cron表达式\n\ncron表达式的时间字段除允许设置数值外，还可使用一些特殊的字符，提供列表、范围、通配符等功能，细说如下：\n\n名称       释义\n星号(*)：   可用在所有字段中，表示对应时间域的每一个时刻，例如，*在分钟字段时，表示“每分钟”；\n问号(?）：   该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；\n减号(-)：   表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；\n逗号(,)：   表达一个列表值，如在星期字段中使用“mon,wed,fri”，则表示星期一，星期三和星期五；\n斜杠(/)：   x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；\n\n名称   是否必须   允许值              允许的通配符\n秒    是      0-59             , - * /\n分    是      0-59             , - * /\n时    是      0-23             , - * /\n日    是      1-31             , - * / l w ?\n月    是      1-12 或 jan-dec   , - * /\n周    是      1-7 或 sun-sat    , - * / l # ?\n年    否      空 或 1970-2099    , - * /\n\n * 在线corn表达式生成器：http://cron.qqe2.com\n\n\n# spring整合quartz\n\n\n# applicationcontext-quartz.xml配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n\txmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n\txmlns:context="http://www.springframework.org/schema/context"\n\txsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">\n\n\t\x3c!-- 1.业务 我们自己手写的类--\x3e\n\t<bean id="jobtask" class="com.etoak.task.job" />\n\t\t\n\t\x3c!-- 2.任务   --\x3e\n\t<bean id="jobdetail"  class="org.springframework.scheduling.quartz.methodinvokingjobdetailfactorybean">\n\t\t\n\t\t\x3c!-- 任务调用业务目标对象 job对象 --\x3e\n\t\t<property name="targetobject" ref="jobtask"></property>\n\t\t\x3c!-- 任务调用业务目标对象方法名称 job方法 --\x3e\n\t\t<property name="targetmethod" value="job"></property>\n\t\t\x3c!-- false防止并发执行 --\x3e\n\t\t<property name="concurrent" value="false"></property>\n\t\n\t</bean>\t\t\n\t\n\t\x3c!-- 3.触发器 --\x3e\n\t<bean id="crontriggerbean" class="org.springframework.scheduling.quartz.crontriggerbean">\n\t\t\x3c!-- 注入任务 --\x3e\n\t\t<property name="jobdetail" ref="jobdetail"></property>\n\t\t\x3c!-- \n\t\t\t执行触发时间 ，  一旦时间触发 调用任务 \t\n\t\t    cron表达式  使用日期和星期  必须有个为问号（？） 而且不能同时出现问号（？）\n\t\t--\x3e\n\t\t<property name="cronexpression" value="0 0/5 * * * ?"></property>\n\t</bean>\n\t\n\t\x3c!-- \n\t\t4.调度器   监听器 \n\t\t容器启动 触发调度器  处于监听\t\n\t--\x3e\n\t<bean class="org.springframework.scheduling.quartz.schedulerfactorybean">\n\t\t\x3c!-- 监听触发器 --\x3e\n\t\t<property name="triggers">\n\t\t\t<list>\n\t\t\t\t<ref bean="crontriggerbean" />\n\t\t\t</list>\n\t\t</property>\n\t</bean>\n\t\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 业务类\n\npackage com.zpj80231.task;\n\nimport com.zpj80231.bean.user;\nimport com.zpj80231.mapper.usermapper;\nimport org.springframework.beans.factory.annotation.autowired;\n\nimport java.util.list;\n\n//1.业务\npublic class job {\n\t\n\t@autowired\n\tprivate usermapper mapper;\n\t\n\t/**\n\t *  定时任务 自定义方法时\n\t * \t不需要加入返回值\n\t * \t方法不能加入参数\n\t * \n\t * \t不能接收请求\n\t * \t不能响应请求\n\t */\n\tpublic void job() {\n\t\tlist<user> list = mapper.getall();\n\t\tfor(user user:list) {\n\t\t\tsystem.out.println(user.getusername());\n\t\t\tsystem.out.println("-----------------");\n\t\t}\t\n\t}\n\t\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# springboot整合quartz\n\n> 两个注解搞定\n\n * 启动类添加@enablescheduling\n * 定时任务类的方法上添加@scheduled\n\n\n# 依赖\n\n<dependency>  \n    <groupid>org.quartz-scheduler</groupid>  \n    <artifactid>quartz</artifactid>  \n    <version>2.2.3</version>  \n</dependency> \n<dependency>  \n    <groupid>org.quartz-scheduler</groupid>  \n    <artifactid>quartz-jobs</artifactid>  \n    <version>2.2.3</version>  \n</dependency>\n<dependency>\x3c!-- 该依赖必加，里面有sping对schedule的支持 --\x3e\n    <groupid>org.springframework</groupid>\n    <artifactid>spring-context-support</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 任务类\n\npackage com.zpj80231.task;\n\nimport java.util.date;\n\nimport org.springframework.scheduling.annotation.scheduled;\nimport org.springframework.stereotype.component;\n\n@component\npublic class jobanno {\n\t\n    @autowire\n    private xxxx xxxx;\n    \n\t/**\n\t * 定时任务 自定义方法时\n\t * \t不需要加入返回值\n\t * \t方法不能加入参数\n\t * \n\t * \t不能接收请求\n\t * \t不能响应请求\n\t */\n\t@scheduled(cron="0/10 * * * * ?")\n\tpublic void jobanno() {\n\t\tsystem.out.println("jobanno:" + new date() + xxxx.xxxx());\n\t}\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 可能遇到的问题\n\n\n# 在实现job接口的业务类中无法注入其他bean\n\n * 在job任务类的执行方法中通过applicationcontext.getbean()来获得 -- 传送们\n\n\n# 其它\n\n * springboot整合quartz实现动态定时任务\n * 在spring中的话通过 实现定时任务的几种方式 里的ramquartz实现servletcontextlistener重写contextinitialized方法实现定时任务',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"RabbitMQ - 进阶",frontmatter:{title:"RabbitMQ - 进阶",date:"2019-09-21T00:00:00.000Z",tags:["RabbitMQ"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/rabbitmq002.html",relativePath:"views/backend/rabbitmq002.md",key:"v-24839ad2",path:"/views/backend/rabbitmq002.html",headers:[{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:3},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:11},{level:3,title:"消息丢失（可靠性）",slug:"消息丢失-可靠性",normalizedTitle:"消息丢失（可靠性）",charIndex:19},{level:3,title:"顺序消费",slug:"顺序消费",normalizedTitle:"顺序消费",charIndex:34},{level:3,title:"重复消费",slug:"重复消费",normalizedTitle:"重复消费",charIndex:44},{level:3,title:"消息补偿机制",slug:"消息补偿机制",normalizedTitle:"消息补偿机制",charIndex:54},{level:3,title:"大量数据消费",slug:"大量数据消费",normalizedTitle:"大量数据消费",charIndex:66},{level:3,title:"如何保证高可用",slug:"如何保证高可用",normalizedTitle:"如何保证高可用",charIndex:78},{level:3,title:"大量消息积压",slug:"大量消息积压",normalizedTitle:"大量消息积压",charIndex:91},{level:2,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:101},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:110}],headersStr:"使用场景 问题 消息丢失（可靠性） 顺序消费 重复消费 消息补偿机制 大量数据消费 如何保证高可用 大量消息积压 分布式事务 案例",content:" * 使用场景\n * 问题\n   * 消息丢失（可靠性）\n   * 顺序消费\n   * 重复消费\n   * 消息补偿机制\n   * 大量数据消费\n   * 如何保证高可用\n   * 大量消息积压\n * 分布式事务\n * 案例\n\n\n\n\n# 使用场景\n\n异步、削峰、解耦\n\n\n# 问题\n\n\n# 消息丢失（可靠性）\n\n * 事前事中事后\n\n\n\n\n# 顺序消费\n\n * 一个topic下有多个队列，为了保证发送有序，RocketMQ提供了MessageQueueSelector队列选择机制，他有三种实现:\n\n * RocketMQ仅保证顺序发送，顺序消费由消费者业务保证！\n\n * 一个队列有序出去，一个消费者消费不就好了？ 消费者是多线程的，你消息是有序的给他的，你能保证他是有序的处理的？还是一个消费成功了再发下一个稳妥。\n\n * rabbimq\n   \n   * 每个 queue 一个 consumer\n\n\n# 重复消费\n\n * 原因\n   \n   * 发给多个系统【库存、积分、活动】时，其他都处理成功但有一个【积分】处理失败（网络抖动，开发人员代码Bug等），触发mq重试。\n\n * 解决方案\n   \n   * 接口幂等（可以用redis做） + 唯一索引。（如下图引用傲丙强校验代码）\n   \n   \n\n\n# 消息补偿机制\n\n为啥要消息补偿：\n\n> 生产者在准备发送MQ的时候，突然生产者宕机；\n> \n> 消息到达MQ后，正在准备持久化到硬盘的过程中MQ宕机了；\n\n * 采用 定时轮询 + db 组合来重试（补偿）消息\n   1. 数据库表里存一条消息的id，消费状态，重试次数，路由键，队列名，交换机名，消息体，生产时间，消费时间等字段。\n   2. 消息补偿服务定时扫库：定时扫出状态为待消费、重试次数小于5次、生产时间大于5分钟的消息，这些消息才会重试。\n   3. 生产者发送消息时先入库，状态为待消费；然后发送消息到MQ。\n   4. MQ中间件正常接受消息，持久化，转发给消费者。\n   5. 消费者收到消息后，判断消息的消费状态，消费后更新消息的消费状态。\n\n\n# 大量数据消费\n\n * 在rabbitMq中采用多个消费者，公平分发的模式去消费队列\n\n\n# 如何保证高可用\n\n * 定义\n   \n   * 镜像集群模式：跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。\n\n * 开启\n   \n   * 其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。\n\n * 缺点\n   \n   * 1: 性能开销大: 因为需要进行整个集群内部所有实例的数据同步 2:无法线性扩容: 因为每一个服务器中都包含整个集群服务节点中的所有数据, 这样如果一旦单个服务器节点的容量无法容纳了怎么办?.\n\n\n# 大量消息积压\n\n * 一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：\n\n 1. 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。\n 2. 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。\n 3. 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。\n 4. 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。\n 5. 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。\n\n\n# 分布式事务\n\n * 弊端\n   \n   * 长时间锁定数据库资源，导致系统的响应不快，并发上不去\n   * 网络抖动出现脑裂情况，导致事物参与者，不能很好地执行协调者的指令，导致数据不一致。\n   * 单点故障：例如事物协调者，在某一时刻宕机，虽然可以通过选举机制产生新的Leader，但是这过程中，必然出现问题，而TCC，只有强悍的技术团队，才能支持开发，成本太高。\n\n * 有多种类型\n   \n   * 2pc（两段式提交）\n     \n     * 2pc（两段式提交）可以说是分布式事务的最开始的样子了，像极了媒婆，就是通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。\n   \n   * 3pc（三段式提交）\n   \n   * TCC（Try、Confirm、Cancel）\n   \n   * 最大努力通知\n   \n   * XA\n   \n   * 本地消息表（ebay研发出的）\n   \n   * 半消息/最终一致性（RocketMQ）\n\n\n# 案例\n\n订单和支付等\n\n",normalizedContent:" * 使用场景\n * 问题\n   * 消息丢失（可靠性）\n   * 顺序消费\n   * 重复消费\n   * 消息补偿机制\n   * 大量数据消费\n   * 如何保证高可用\n   * 大量消息积压\n * 分布式事务\n * 案例\n\n\n\n\n# 使用场景\n\n异步、削峰、解耦\n\n\n# 问题\n\n\n# 消息丢失（可靠性）\n\n * 事前事中事后\n\n\n\n\n# 顺序消费\n\n * 一个topic下有多个队列，为了保证发送有序，rocketmq提供了messagequeueselector队列选择机制，他有三种实现:\n\n * rocketmq仅保证顺序发送，顺序消费由消费者业务保证！\n\n * 一个队列有序出去，一个消费者消费不就好了？ 消费者是多线程的，你消息是有序的给他的，你能保证他是有序的处理的？还是一个消费成功了再发下一个稳妥。\n\n * rabbimq\n   \n   * 每个 queue 一个 consumer\n\n\n# 重复消费\n\n * 原因\n   \n   * 发给多个系统【库存、积分、活动】时，其他都处理成功但有一个【积分】处理失败（网络抖动，开发人员代码bug等），触发mq重试。\n\n * 解决方案\n   \n   * 接口幂等（可以用redis做） + 唯一索引。（如下图引用傲丙强校验代码）\n   \n   \n\n\n# 消息补偿机制\n\n为啥要消息补偿：\n\n> 生产者在准备发送mq的时候，突然生产者宕机；\n> \n> 消息到达mq后，正在准备持久化到硬盘的过程中mq宕机了；\n\n * 采用 定时轮询 + db 组合来重试（补偿）消息\n   1. 数据库表里存一条消息的id，消费状态，重试次数，路由键，队列名，交换机名，消息体，生产时间，消费时间等字段。\n   2. 消息补偿服务定时扫库：定时扫出状态为待消费、重试次数小于5次、生产时间大于5分钟的消息，这些消息才会重试。\n   3. 生产者发送消息时先入库，状态为待消费；然后发送消息到mq。\n   4. mq中间件正常接受消息，持久化，转发给消费者。\n   5. 消费者收到消息后，判断消息的消费状态，消费后更新消息的消费状态。\n\n\n# 大量数据消费\n\n * 在rabbitmq中采用多个消费者，公平分发的模式去消费队列\n\n\n# 如何保证高可用\n\n * 定义\n   \n   * 镜像集群模式：跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 rabbitmq 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。\n\n * 开启\n   \n   * 其实很简单，rabbitmq 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。\n\n * 缺点\n   \n   * 1: 性能开销大: 因为需要进行整个集群内部所有实例的数据同步 2:无法线性扩容: 因为每一个服务器中都包含整个集群服务节点中的所有数据, 这样如果一旦单个服务器节点的容量无法容纳了怎么办?.\n\n\n# 大量消息积压\n\n * 一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：\n\n 1. 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。\n 2. 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。\n 3. 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。\n 4. 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。\n 5. 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。\n\n\n# 分布式事务\n\n * 弊端\n   \n   * 长时间锁定数据库资源，导致系统的响应不快，并发上不去\n   * 网络抖动出现脑裂情况，导致事物参与者，不能很好地执行协调者的指令，导致数据不一致。\n   * 单点故障：例如事物协调者，在某一时刻宕机，虽然可以通过选举机制产生新的leader，但是这过程中，必然出现问题，而tcc，只有强悍的技术团队，才能支持开发，成本太高。\n\n * 有多种类型\n   \n   * 2pc（两段式提交）\n     \n     * 2pc（两段式提交）可以说是分布式事务的最开始的样子了，像极了媒婆，就是通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。\n   \n   * 3pc（三段式提交）\n   \n   * tcc（try、confirm、cancel）\n   \n   * 最大努力通知\n   \n   * xa\n   \n   * 本地消息表（ebay研发出的）\n   \n   * 半消息/最终一致性（rocketmq）\n\n\n# 案例\n\n订单和支付等\n\n",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Redis - 基础",frontmatter:{title:"Redis - 基础",date:"2019-08-04T18:41:12.000Z",tags:["Redis"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/redis01.html",relativePath:"views/backend/redis01.md",key:"v-6dd97e97",path:"/views/backend/redis01.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:53},{level:2,title:"redis提供的5中数据类型",slug:"redis提供的5中数据类型",normalizedTitle:"redis提供的5中数据类型",charIndex:59},{level:2,title:"redis使用场景",slug:"redis使用场景",normalizedTitle:"redis使用场景",charIndex:77},{level:2,title:"redis常用命令:",slug:"redis常用命令",normalizedTitle:"redis常用命令:",charIndex:90},{level:3,title:"string:",slug:"string",normalizedTitle:"string:",charIndex:106},{level:3,title:"hash:(效率最高)",slug:"hash-效率最高",normalizedTitle:"hash:(效率最高)",charIndex:119},{level:3,title:"list:",slug:"list",normalizedTitle:"list:",charIndex:136},{level:3,title:"set:(一般用交集并集)",slug:"set-一般用交集并集",normalizedTitle:"set:(一般用交集并集)",charIndex:147},{level:3,title:"zset:",slug:"zset",normalizedTitle:"zset:",charIndex:166},{level:2,title:"事务：(不推荐使用)",slug:"事务-不推荐使用",normalizedTitle:"事务：(不推荐使用)",charIndex:175},{level:2,title:"简单 spring配置jedis(相当于jdbc):",slug:"简单-spring配置jedis-相当于jdbc",normalizedTitle:"简单 spring配置jedis(相当于jdbc):",charIndex:189},{level:2,title:"详细 在spring中使用redis",slug:"详细-在spring中使用redis",normalizedTitle:"详细 在spring中使用redis",charIndex:219},{level:2,title:"详细 在springboot中使用redis",slug:"详细-在springboot中使用redis",normalizedTitle:"详细 在springboot中使用redis",charIndex:241},{level:2,title:"redis缓存与数据库同步",slug:"redis缓存与数据库同步",normalizedTitle:"redis缓存与数据库同步",charIndex:267}],excerpt:"<Boxx/>\n<p>对Redis的总结：常用命令、使用场景、在Spring中使用、在SpringBoot中是使用</p>\n",headersStr:"简介 redis提供的5中数据类型 redis使用场景 redis常用命令: string: hash:(效率最高) list: set:(一般用交集并集) zset: 事务：(不推荐使用) 简单 spring配置jedis(相当于jdbc): 详细 在spring中使用redis 详细 在springboot中使用redis redis缓存与数据库同步",content:'对Redis的总结：常用命令、使用场景、在Spring中使用、在SpringBoot中是使用\n\n\n\n * 简介\n * redis提供的5中数据类型\n * redis使用场景\n * redis常用命令:\n   * string:\n   * hash:(效率最高)\n   * list:\n   * set:(一般用交集并集)\n   * zset:\n * 事务：(不推荐使用)\n * 简单 spring配置jedis(相当于jdbc):\n * 详细 在spring中使用redis\n * 详细 在springboot中使用redis\n * redis缓存与数据库同步\n\n\n\n\n# 简介\n\nRedis(非关系型数据库)： 先开启服务器端service,再打开客户端cil\n\nRedis和MongoDB是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性\n\n> redis 特点\n\n 1. 单线程,底层c语言开发,默认16个数据库(下表从0开始)\n 2. 支持事务(原子性)\n 3. redis持久化 -> 存储在磁盘中,占用内存\n 4. 99%都是部署在Linux系统上\n\n> redis 优缺点\n\n 1. 优点: (1) 读写性能优异\n    \n    (2)支持数据持久化，支持AOF和RDB两种持久化方式\n    \n    (3)支持主从复制，主机会自动将数据同步到从机，可以进行读写分离\n    \n    (4)数据结构丰富：除了支持string类型的value外还支持string、hash、set、sortedset、list等数据结构\n\n 2. 缺点: (1) 缺少结构化(没有表和字段的概念)，可读性查，不能使用where条件\n    \n    (2) 由于是内存数据库，费内存\n    \n    (3)不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复 --- 更多\n\n\n# redis提供的5中数据类型\n\n\n\n 1. string 最大存储长度为512M\n    \n    实战场景：\n    \n    1. 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。\n    2. 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。\n    3. session：常见方案spring session + redis实现session共享\n    4. 原子计数器\n\n 2. list (linkedlist)双向列表\n    \n    实战场景：刷微博的下拉分页\n\n 3. hash hashmap\n    \n    实战场景：无，一般用到很少。\n\n 4. set hashset 无序\n    \n    实战场景：\n    \n    1. 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。\n    2. 点赞，或点踩，收藏等，可以放到set中实现\n\n 5. zset treeset 有序\n    \n    实战场景：排行榜, 有序集合经典使用场景。\n\n\n# redis使用场景\n\n 1. 缓存 替数据库 MySQL Oracle 分担一部分压力\n 2. 分页 点赞 踩 统计用户访问量 在线人数\n 3. 分布式锁\n 4. 单点登录 spring session cookie session\n\n\n# redis常用命令:\n\n * flushdb 清空当前的数据库(慎用)\n * flushall 清空所有的数据库(根本就不要用)\n * select 15 切换到第16个数据库\n\n\n# string:\n\n命令                    释义\nset key value         设置key和value\nget key               通过key拿值\ndel key1,key2,..      删除一个或多个数据\nexpire key 10         设置消亡时间，10秒后这个key就删除\nkeys k                查询所有的包含k的key\nttl key               当设置消亡时间后,以秒为单位返回key的剩余时间 (-1代表没有设置,-2代表已被删除)\nmove key1 15          把key1移动到第16个数据库(从0开始)\nrename key1 key2      把key1重新命名为key2 （如果key2已存在那会覆盖 ）\nRENAMENX              当且仅当 newkey 不存在时，将 key 改名为 newkey\nappend key1 valueX    如果key1存在就把valueX追加到原先value的末尾,key1不存在就是set\nmset k1 v1 k2 v2 ..   批量新增\nmget k1 k2 k3 ...     批量拿值\nincr key              将 key 中储存的数字值自动增一\nincrby key 数字         将 key 所储存的值加上增量\ndecrby key 数字         将 key 所储存的值减上数字\nsetnx key value       将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则SETNX 不做任何动作。\nstrlen key            返回key所对应的value的长度\n\n\n# hash:(效率最高)\n\n命令                                  释义\nhset key(相当于表) field(字段) value(值)   建表和赋值 key必须唯一,不然会覆盖\nhget key field                      取值\nhkeys key                           获取key中所有的字段\nhvals key                           获取key中所有的值\n\n\n# list:\n\n命令                                   释义\nlpush key v1 v2 v3                   在key中依次插入3个值,每次插入都放在最左边\nlrange key start(起始下标) stop(结束下标)    取出key中从下标start到stop(包含)的值\nlrange list (当前页-1)rows pagerows-1   分页\n\n\n# set:(一般用交集并集)\n\n命令                     释义\nsadd key 元素1 元素2 ...   添加多个元素到集合中\nsmembers key           取出集合中的所有成员\n\n\n# zset:\n\n命令                                 释义\nzadd key score(值) member(字段)       score必须得是int/float\nzrange key start stop              获取所有的member\nzrange key start stop withscores   获取所有的member和score\n\n\n# 事务：(不推荐使用)\n\nmulti 开启事务 ...添加队列操作 exec 执行事务\n\nredis支持lua脚本： //key[]/argv[]可以有多个,2表示有两个key,后边是依次给key和argv赋值 eval "return {keys[1],key[2],argv[1],argv[2]}" 2 key1 key2 1 2\n\n> 注意：redis缓存操作和数据库操作若要成为一个事务,即当数据库操作添加失败时也不能进到缓存中 所以我们只能造一个异常出来,因为事务的异常只能抛 事务的底层有一个try cath ,会把我们自己try的捕获,当出问题时我们try会使事务失效\n\n\n# 简单 spring配置jedis(相当于jdbc):\n\n 0. 导入jar包\n 1. 在xml中配置数据源 JedisPoolConfig maxTotal 最大连接数 minIdle 最小空闲数 minIdle 最大空闲数 maxWaitMillis 超时时间\n 2. 客户端连接服务端操作(没有set方法,只能通过构造方法注入属性) JedisPool poolConfig 注入1连接池 host IP地址 port 端口号\n\n\n# 详细 在spring中使用redis\n\n 1. 配置xml applicationContext-redis.xml\n\n\t\x3c!-- redis单机版 --\x3e\n\t<bean id="jedisPool" class="redis.clients.jedis.JedisPool">\n\t\t<constructor-arg name="host" value="192.168.25.153"/>\t\n\t\t<constructor-arg name="port" value="6379"/>\t\n\t</bean>\n\t\x3c!-- 我们封装的jedis常用方法类 --\x3e\n\t<bean id="jedisClientPool" class="com.taotao.jedis.JedisClientPool"/>\n\n\t\x3c!-- redis集群 --\x3e\n\t\x3c!-- <bean id="jedisCluster" class="redis.clients.jedis.JedisCluster">\n\t\t<constructor-arg>\n\t\t\t<set>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7001"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7002"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7003"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7004"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7005"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.HostAndPort">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7006"/>\n\t\t\t\t</bean>\n\t\t\t</set>\n\t\t</constructor-arg>\n\t</bean>\n\t<bean id="jedisClientCluster" class="com.taotao.jedis.JedisClientCluster"/> --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n 2. 可配置的redis连接池\n\n// 池基本配置\nJedisPoolConfig config = new JedisPoolConfig();\n\n//是否启用后进先出, 默认true\nconfig.setLifo(true);\n//最大空闲连接数, 默认8个\nconfig.setMaxIdle(8);\n//最大连接数, 默认8个\nconfig.setMaxTotal(8);\n//获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1\nconfig.setMaxWaitMillis(-1);\n//逐出连接的最小空闲时间 默认1800000毫秒(30分钟)\nconfig.setMinEvictableIdleTimeMillis(1800000);\n//最小空闲连接数, 默认0\nconfig.setMinIdle(0);\n//每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3\nconfig.setNumTestsPerEvictionRun(3);\n//对象空闲多久后逐出, 当空闲时间>该值 且 空闲连接>最大空闲数 时直接逐出,不再根据MinEvictableIdleTimeMillis判断  (默认逐出策略)\nconfig.setSoftMinEvictableIdleTimeMillis(1800000);\n//在获取连接的时候检查有效性, 默认false\nconfig.setTestOnBorrow(false);\n//在空闲时检查有效性, 默认false\nconfig.setTestWhileIdle(false);\n\n// 使用配置创建连接池\njedisPool = new JedisPool(config, host, port);\nJedis jedis = pool.getResource();// 从连接池中获取单个连接\n//jedis.auth("password");// 如果需要密码\n\n//...各种jedis操作\n\n//jedis.close();//用完记得关闭连接\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n 3. 对redis单机版、连接池版、集群版的简单测试\n\npackage com.taotao.jedis;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.junit.Test;\n\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.JedisPool;\n\npublic class TestJedis {\n\n\t@Test\n\tpublic void testJedis() throws Exception {\n\t\t//创建一个jedis对象，需要指定服务的ip和端口号\n\t\tJedis jedis = new Jedis("192.168.25.153", 6379);\n\t\t//直接操作数据库\n\t\tjedis.set("jedis-key", "1234");\n\t\tString result = jedis.get("jedis-key");\n\t\tSystem.out.println(result);\n\t\t//关闭jedis\n\t\tjedis.close();\n\t}\n\t\n\t@Test\n\tpublic void testJedisPool() throws Exception {\n\t\t//创建一个数据库连接池对象（单例），需要指定服务的ip和端口号\n\t\tJedisPool jedisPool = new JedisPool("192.168.25.153", 6379);\n\t\t//从连接池中获得连接\n\t\tJedis jedis = jedisPool.getResource();\n\t\t//使用Jedis操作数据库（方法级别使用）\n\t\tString result = jedis.get("jedis-key");\n\t\tSystem.out.println(result);\n\t\t//一定要关闭Jedis连接\n\t\tjedis.close();\n\t\t//系统关闭前关闭连接池\n\t\tjedisPool.close();\n\t}\n\t\n\t@Test\n\tpublic void testJedisCluster() throws Exception {\n\t\t//创建一个JedisCluster对象，构造参数Set类型，集合中每个元素是HostAndPort类型\n\t\tSet<HostAndPort> nodes = new HashSet<>();\n\t\t//向集合中添加节点\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7001));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7002));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7003));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7004));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7005));\n\t\tnodes.add(new HostAndPort("192.168.25.153", 7006));\n\t\tJedisCluster jedisCluster = new JedisCluster(nodes);\n\t\t//直接使用JedisCluster操作redis，自带连接池。jedisCluster对象可以是单例 的。\n\t\tjedisCluster.set("cluster-test", "hello jedis cluster");\n\t\tString string = jedisCluster.get("cluster-test");\n\t\tSystem.out.println(string);\n\t\t//系统关闭前关闭JedisCluster\n\t\tjedisCluster.close();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 详细 在springboot中使用redis\n\n 1. 在SpringBoot中添加Redis依赖：\n\n\x3c!--redis依赖配置--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n 2. 在SpringBoot中配置application-dev.yml\n\n  redis:\n    host: localhost # Redis服务器地址\n    database: 0 # Redis数据库索引（默认为0）\n    port: 6379 # Redis服务器连接端口\n    password: # Redis服务器连接密码（默认为空）\n    jedis:\n      pool:\n        max-active: 8 # 连接池最大连接数（使用负值表示没有限制）\n        max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）\n        max-idle: 8 # 连接池中的最大空闲连接\n        min-idle: 0 # 连接池中的最小空闲连接\n    timeout: 3000ms # 连接超时时间（毫秒）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 3. 常用的redis操作\n\n> 通过springboot自动配置的StringRedisTemplate对象进行Redis的读写操作\n\npackage com.macro.mall.portal.service.impl;\n\nimport com.macro.mall.portal.service.RedisService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * redis操作Service的实现类\n */\n@Service\npublic class RedisServiceImpl implements RedisService {\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Override\n    public void set(String key, String value) {\n        stringRedisTemplate.opsForValue().set(key, value);\n    }\n\n    @Override\n    public String get(String key) {\n        return stringRedisTemplate.opsForValue().get(key);\n    }\n\n    @Override\n    public boolean expire(String key, long expire) {\n        return stringRedisTemplate.expire(key, expire, TimeUnit.SECONDS);\n    }\n\n    @Override\n    public void remove(String key) {\n        stringRedisTemplate.delete(key);\n    }\n\n    @Override\n    public Long increment(String key, long delta) {\n        return stringRedisTemplate.opsForValue().increment(key,delta);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n 4. redis的其他操作\n\n> 注意：使用redis存储对象的时候，一定要将对象序列化（实现Serializable接口或自己写序列化工具类）\n> \n> 其他操作（集合、hash等）详见：https://www.jianshu.com/p/56999f2b8e3b\n\n\n# redis缓存与数据库同步\n\n * 新增：数据库新增后，放到缓存中\n\n * 删除：删除数据库相应数据后删除缓存（或延时双删）\n\n * 查询：\n\n\n\n * 更新：一般是先跟新数据库，再删除缓存（或延时双删）\n\n',normalizedContent:'对redis的总结：常用命令、使用场景、在spring中使用、在springboot中是使用\n\n\n\n * 简介\n * redis提供的5中数据类型\n * redis使用场景\n * redis常用命令:\n   * string:\n   * hash:(效率最高)\n   * list:\n   * set:(一般用交集并集)\n   * zset:\n * 事务：(不推荐使用)\n * 简单 spring配置jedis(相当于jdbc):\n * 详细 在spring中使用redis\n * 详细 在springboot中使用redis\n * redis缓存与数据库同步\n\n\n\n\n# 简介\n\nredis(非关系型数据库)： 先开启服务器端service,再打开客户端cil\n\nredis和mongodb是当前使用最广泛的nosql，而就redis技术而言，它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性\n\n> redis 特点\n\n 1. 单线程,底层c语言开发,默认16个数据库(下表从0开始)\n 2. 支持事务(原子性)\n 3. redis持久化 -> 存储在磁盘中,占用内存\n 4. 99%都是部署在linux系统上\n\n> redis 优缺点\n\n 1. 优点: (1) 读写性能优异\n    \n    (2)支持数据持久化，支持aof和rdb两种持久化方式\n    \n    (3)支持主从复制，主机会自动将数据同步到从机，可以进行读写分离\n    \n    (4)数据结构丰富：除了支持string类型的value外还支持string、hash、set、sortedset、list等数据结构\n\n 2. 缺点: (1) 缺少结构化(没有表和字段的概念)，可读性查，不能使用where条件\n    \n    (2) 由于是内存数据库，费内存\n    \n    (3)不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的ip才能恢复 --- 更多\n\n\n# redis提供的5中数据类型\n\n\n\n 1. string 最大存储长度为512m\n    \n    实战场景：\n    \n    1. 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。\n    2. 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。\n    3. session：常见方案spring session + redis实现session共享\n    4. 原子计数器\n\n 2. list (linkedlist)双向列表\n    \n    实战场景：刷微博的下拉分页\n\n 3. hash hashmap\n    \n    实战场景：无，一般用到很少。\n\n 4. set hashset 无序\n    \n    实战场景：\n    \n    1. 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。\n    2. 点赞，或点踩，收藏等，可以放到set中实现\n\n 5. zset treeset 有序\n    \n    实战场景：排行榜, 有序集合经典使用场景。\n\n\n# redis使用场景\n\n 1. 缓存 替数据库 mysql oracle 分担一部分压力\n 2. 分页 点赞 踩 统计用户访问量 在线人数\n 3. 分布式锁\n 4. 单点登录 spring session cookie session\n\n\n# redis常用命令:\n\n * flushdb 清空当前的数据库(慎用)\n * flushall 清空所有的数据库(根本就不要用)\n * select 15 切换到第16个数据库\n\n\n# string:\n\n命令                    释义\nset key value         设置key和value\nget key               通过key拿值\ndel key1,key2,..      删除一个或多个数据\nexpire key 10         设置消亡时间，10秒后这个key就删除\nkeys k                查询所有的包含k的key\nttl key               当设置消亡时间后,以秒为单位返回key的剩余时间 (-1代表没有设置,-2代表已被删除)\nmove key1 15          把key1移动到第16个数据库(从0开始)\nrename key1 key2      把key1重新命名为key2 （如果key2已存在那会覆盖 ）\nrenamenx              当且仅当 newkey 不存在时，将 key 改名为 newkey\nappend key1 valuex    如果key1存在就把valuex追加到原先value的末尾,key1不存在就是set\nmset k1 v1 k2 v2 ..   批量新增\nmget k1 k2 k3 ...     批量拿值\nincr key              将 key 中储存的数字值自动增一\nincrby key 数字         将 key 所储存的值加上增量\ndecrby key 数字         将 key 所储存的值减上数字\nsetnx key value       将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则setnx 不做任何动作。\nstrlen key            返回key所对应的value的长度\n\n\n# hash:(效率最高)\n\n命令                                  释义\nhset key(相当于表) field(字段) value(值)   建表和赋值 key必须唯一,不然会覆盖\nhget key field                      取值\nhkeys key                           获取key中所有的字段\nhvals key                           获取key中所有的值\n\n\n# list:\n\n命令                                   释义\nlpush key v1 v2 v3                   在key中依次插入3个值,每次插入都放在最左边\nlrange key start(起始下标) stop(结束下标)    取出key中从下标start到stop(包含)的值\nlrange list (当前页-1)rows pagerows-1   分页\n\n\n# set:(一般用交集并集)\n\n命令                     释义\nsadd key 元素1 元素2 ...   添加多个元素到集合中\nsmembers key           取出集合中的所有成员\n\n\n# zset:\n\n命令                                 释义\nzadd key score(值) member(字段)       score必须得是int/float\nzrange key start stop              获取所有的member\nzrange key start stop withscores   获取所有的member和score\n\n\n# 事务：(不推荐使用)\n\nmulti 开启事务 ...添加队列操作 exec 执行事务\n\nredis支持lua脚本： //key[]/argv[]可以有多个,2表示有两个key,后边是依次给key和argv赋值 eval "return {keys[1],key[2],argv[1],argv[2]}" 2 key1 key2 1 2\n\n> 注意：redis缓存操作和数据库操作若要成为一个事务,即当数据库操作添加失败时也不能进到缓存中 所以我们只能造一个异常出来,因为事务的异常只能抛 事务的底层有一个try cath ,会把我们自己try的捕获,当出问题时我们try会使事务失效\n\n\n# 简单 spring配置jedis(相当于jdbc):\n\n 0. 导入jar包\n 1. 在xml中配置数据源 jedispoolconfig maxtotal 最大连接数 minidle 最小空闲数 minidle 最大空闲数 maxwaitmillis 超时时间\n 2. 客户端连接服务端操作(没有set方法,只能通过构造方法注入属性) jedispool poolconfig 注入1连接池 host ip地址 port 端口号\n\n\n# 详细 在spring中使用redis\n\n 1. 配置xml applicationcontext-redis.xml\n\n\t\x3c!-- redis单机版 --\x3e\n\t<bean id="jedispool" class="redis.clients.jedis.jedispool">\n\t\t<constructor-arg name="host" value="192.168.25.153"/>\t\n\t\t<constructor-arg name="port" value="6379"/>\t\n\t</bean>\n\t\x3c!-- 我们封装的jedis常用方法类 --\x3e\n\t<bean id="jedisclientpool" class="com.taotao.jedis.jedisclientpool"/>\n\n\t\x3c!-- redis集群 --\x3e\n\t\x3c!-- <bean id="jediscluster" class="redis.clients.jedis.jediscluster">\n\t\t<constructor-arg>\n\t\t\t<set>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7001"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7002"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7003"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7004"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7005"/>\n\t\t\t\t</bean>\n\t\t\t\t<bean class="redis.clients.jedis.hostandport">\n\t\t\t\t\t<constructor-arg name="host" value="192.168.25.153"/>\n\t\t\t\t\t<constructor-arg name="port" value="7006"/>\n\t\t\t\t</bean>\n\t\t\t</set>\n\t\t</constructor-arg>\n\t</bean>\n\t<bean id="jedisclientcluster" class="com.taotao.jedis.jedisclientcluster"/> --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n 2. 可配置的redis连接池\n\n// 池基本配置\njedispoolconfig config = new jedispoolconfig();\n\n//是否启用后进先出, 默认true\nconfig.setlifo(true);\n//最大空闲连接数, 默认8个\nconfig.setmaxidle(8);\n//最大连接数, 默认8个\nconfig.setmaxtotal(8);\n//获取连接时的最大等待毫秒数(如果设置为阻塞时blockwhenexhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1\nconfig.setmaxwaitmillis(-1);\n//逐出连接的最小空闲时间 默认1800000毫秒(30分钟)\nconfig.setminevictableidletimemillis(1800000);\n//最小空闲连接数, 默认0\nconfig.setminidle(0);\n//每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3\nconfig.setnumtestsperevictionrun(3);\n//对象空闲多久后逐出, 当空闲时间>该值 且 空闲连接>最大空闲数 时直接逐出,不再根据minevictableidletimemillis判断  (默认逐出策略)\nconfig.setsoftminevictableidletimemillis(1800000);\n//在获取连接的时候检查有效性, 默认false\nconfig.settestonborrow(false);\n//在空闲时检查有效性, 默认false\nconfig.settestwhileidle(false);\n\n// 使用配置创建连接池\njedispool = new jedispool(config, host, port);\njedis jedis = pool.getresource();// 从连接池中获取单个连接\n//jedis.auth("password");// 如果需要密码\n\n//...各种jedis操作\n\n//jedis.close();//用完记得关闭连接\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n 3. 对redis单机版、连接池版、集群版的简单测试\n\npackage com.taotao.jedis;\n\nimport java.util.hashset;\nimport java.util.set;\n\nimport org.junit.test;\n\nimport redis.clients.jedis.hostandport;\nimport redis.clients.jedis.jedis;\nimport redis.clients.jedis.jediscluster;\nimport redis.clients.jedis.jedispool;\n\npublic class testjedis {\n\n\t@test\n\tpublic void testjedis() throws exception {\n\t\t//创建一个jedis对象，需要指定服务的ip和端口号\n\t\tjedis jedis = new jedis("192.168.25.153", 6379);\n\t\t//直接操作数据库\n\t\tjedis.set("jedis-key", "1234");\n\t\tstring result = jedis.get("jedis-key");\n\t\tsystem.out.println(result);\n\t\t//关闭jedis\n\t\tjedis.close();\n\t}\n\t\n\t@test\n\tpublic void testjedispool() throws exception {\n\t\t//创建一个数据库连接池对象（单例），需要指定服务的ip和端口号\n\t\tjedispool jedispool = new jedispool("192.168.25.153", 6379);\n\t\t//从连接池中获得连接\n\t\tjedis jedis = jedispool.getresource();\n\t\t//使用jedis操作数据库（方法级别使用）\n\t\tstring result = jedis.get("jedis-key");\n\t\tsystem.out.println(result);\n\t\t//一定要关闭jedis连接\n\t\tjedis.close();\n\t\t//系统关闭前关闭连接池\n\t\tjedispool.close();\n\t}\n\t\n\t@test\n\tpublic void testjediscluster() throws exception {\n\t\t//创建一个jediscluster对象，构造参数set类型，集合中每个元素是hostandport类型\n\t\tset<hostandport> nodes = new hashset<>();\n\t\t//向集合中添加节点\n\t\tnodes.add(new hostandport("192.168.25.153", 7001));\n\t\tnodes.add(new hostandport("192.168.25.153", 7002));\n\t\tnodes.add(new hostandport("192.168.25.153", 7003));\n\t\tnodes.add(new hostandport("192.168.25.153", 7004));\n\t\tnodes.add(new hostandport("192.168.25.153", 7005));\n\t\tnodes.add(new hostandport("192.168.25.153", 7006));\n\t\tjediscluster jediscluster = new jediscluster(nodes);\n\t\t//直接使用jediscluster操作redis，自带连接池。jediscluster对象可以是单例 的。\n\t\tjediscluster.set("cluster-test", "hello jedis cluster");\n\t\tstring string = jediscluster.get("cluster-test");\n\t\tsystem.out.println(string);\n\t\t//系统关闭前关闭jediscluster\n\t\tjediscluster.close();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 详细 在springboot中使用redis\n\n 1. 在springboot中添加redis依赖：\n\n\x3c!--redis依赖配置--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n 2. 在springboot中配置application-dev.yml\n\n  redis:\n    host: localhost # redis服务器地址\n    database: 0 # redis数据库索引（默认为0）\n    port: 6379 # redis服务器连接端口\n    password: # redis服务器连接密码（默认为空）\n    jedis:\n      pool:\n        max-active: 8 # 连接池最大连接数（使用负值表示没有限制）\n        max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）\n        max-idle: 8 # 连接池中的最大空闲连接\n        min-idle: 0 # 连接池中的最小空闲连接\n    timeout: 3000ms # 连接超时时间（毫秒）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 3. 常用的redis操作\n\n> 通过springboot自动配置的stringredistemplate对象进行redis的读写操作\n\npackage com.macro.mall.portal.service.impl;\n\nimport com.macro.mall.portal.service.redisservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.data.redis.core.stringredistemplate;\nimport org.springframework.stereotype.service;\n\nimport java.util.concurrent.timeunit;\n\n/**\n * redis操作service的实现类\n */\n@service\npublic class redisserviceimpl implements redisservice {\n    @autowired\n    private stringredistemplate stringredistemplate;\n\n    @override\n    public void set(string key, string value) {\n        stringredistemplate.opsforvalue().set(key, value);\n    }\n\n    @override\n    public string get(string key) {\n        return stringredistemplate.opsforvalue().get(key);\n    }\n\n    @override\n    public boolean expire(string key, long expire) {\n        return stringredistemplate.expire(key, expire, timeunit.seconds);\n    }\n\n    @override\n    public void remove(string key) {\n        stringredistemplate.delete(key);\n    }\n\n    @override\n    public long increment(string key, long delta) {\n        return stringredistemplate.opsforvalue().increment(key,delta);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n 4. redis的其他操作\n\n> 注意：使用redis存储对象的时候，一定要将对象序列化（实现serializable接口或自己写序列化工具类）\n> \n> 其他操作（集合、hash等）详见：https://www.jianshu.com/p/56999f2b8e3b\n\n\n# redis缓存与数据库同步\n\n * 新增：数据库新增后，放到缓存中\n\n * 删除：删除数据库相应数据后删除缓存（或延时双删）\n\n * 查询：\n\n\n\n * 更新：一般是先跟新数据库，再删除缓存（或延时双删）\n\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Redis - 终结",frontmatter:{title:"Redis - 终结",date:"2019-10-10T00:00:00.000Z",tags:["Redis"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/redis02.html",relativePath:"views/backend/redis02.md",key:"v-f711c112",path:"/views/backend/redis02.html",headers:[{level:2,title:"Redis基础",slug:"redis基础",normalizedTitle:"redis基础",charIndex:47},{level:3,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:60},{level:3,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:70},{level:3,title:"基本数据结构",slug:"基本数据结构",normalizedTitle:"基本数据结构",charIndex:79},{level:3,title:"持久化",slug:"持久化",normalizedTitle:"持久化",charIndex:91},{level:2,title:"缓存击穿、雪崩、穿透",slug:"缓存击穿、雪崩、穿透",normalizedTitle:"缓存击穿、雪崩、穿透",charIndex:98},{level:3,title:"雪崩",slug:"雪崩",normalizedTitle:"雪崩",charIndex:103},{level:3,title:"击穿",slug:"击穿",normalizedTitle:"击穿",charIndex:100},{level:3,title:"穿透",slug:"穿透",normalizedTitle:"穿透",charIndex:106},{level:2,title:"redis集群",slug:"redis集群",normalizedTitle:"redis集群",charIndex:136},{level:3,title:"哨兵",slug:"哨兵",normalizedTitle:"哨兵",charIndex:149},{level:3,title:"主从同步",slug:"主从同步",normalizedTitle:"主从同步",charIndex:157},{level:3,title:"redis主从、集群、哨兵搭建",slug:"redis主从、集群、哨兵搭建",normalizedTitle:"redis主从、集群、哨兵搭建",charIndex:167},{level:2,title:"分布式锁（并发竞争、读写一致性）",slug:"分布式锁-并发竞争、读写一致性",normalizedTitle:"分布式锁（并发竞争、读写一致性）",charIndex:186},{level:2,title:"内存淘汰机制",slug:"内存淘汰机制",normalizedTitle:"内存淘汰机制",charIndex:206},{level:3,title:"redis过期策略",slug:"redis过期策略",normalizedTitle:"redis过期策略",charIndex:218},{level:3,title:"定期没删，我也没查询（惰性没删），那可咋整？",slug:"定期没删-我也没查询-惰性没删-那可咋整",normalizedTitle:"定期没删，我也没查询（惰性没删），那可咋整？",charIndex:233},{level:2,title:"redis解决",slug:"redis解决",normalizedTitle:"redis解决",charIndex:259},{level:3,title:"事前",slug:"事前",normalizedTitle:"事前",charIndex:272},{level:3,title:"事中",slug:"事中",normalizedTitle:"事中",charIndex:280},{level:3,title:"事后",slug:"事后",normalizedTitle:"事后",charIndex:288},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:294},{level:3,title:"秒杀",slug:"秒杀",normalizedTitle:"秒杀",charIndex:302}],headersStr:"Redis基础 使用场景 优缺点 基本数据结构 持久化 缓存击穿、雪崩、穿透 雪崩 击穿 穿透 redis集群 哨兵 主从同步 redis主从、集群、哨兵搭建 分布式锁（并发竞争、读写一致性） 内存淘汰机制 redis过期策略 定期没删，我也没查询（惰性没删），那可咋整？ redis解决 事前 事中 事后 案例 秒杀",content:'个人看完傲丙的redis系列最后做的总结，不得不说他redis系列写的确实不错。\n\n\n\n * Redis基础\n   * 使用场景\n   * 优缺点\n   * 基本数据结构\n   * 持久化\n * 缓存击穿、雪崩、穿透\n   * 雪崩\n   * 击穿\n   * 穿透\n * redis集群\n   * 哨兵\n   * 主从同步\n   * redis主从、集群、哨兵搭建\n * 分布式锁（并发竞争、读写一致性）\n * 内存淘汰机制\n   * redis过期策略\n   * 定期没删，我也没查询（惰性没删），那可咋整？\n * redis解决\n   * 事前\n   * 事中\n   * 事后\n * 案例\n   * 秒杀\n\n\n\n\n# Redis基础\n\n看我之前的这篇 - 传送门\n\n\n# 使用场景\n\n * 缓存 替数据库分担压力 微博那种不断下拉分页，点赞 单点登陆 分布式锁\n\n\n# 优缺点\n\n 1. 基于内存的单线程非关系型数据库，由于在内存中完成操作，所以速度非常快，每秒十万+\n 2. 支持持久化\n 3. 高可用\n\n\n# 基本数据结构\n\n * String\n   \n   * 缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。\n   * 计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存\n   * 共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。\n\n * Hash\n   \n   * 这个是类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。（用的少）\n\n * List\n   \n   * 比如可以通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。\n     \n     * lpush key v1 v2 v3 在key中依次插入3个值,每次插入都放在最左边\n     * lrange key start(起始下标) stop(结束下标) 取出key中从下标start到stop(包含)的值\n     * lrange list (当前页-1)rows pagerows-1 分页\n\n * Set\n   \n   * 基于 Set 玩儿交集、并集、差集的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。\n\n * SortedSet\n   \n   * 去重且排序\n     \n     * 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。\n     * 用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。\n\n\n# 持久化\n\n * RDB做镜像全量持久化，AOF做增量持久化。 因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。\n   \n   * RDB\n     \n     * fork和cow：fork是指redis通过创建子进程来进行RDB操作，采用二进制压缩存储。cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。\n     * 因为是子进程完成的，所以效率高一点，但是生成一次RDB快照文件需要花费的时间较长。\n   \n   * AOF\n     \n     * 效率稍慢，类似于我们用Java流写数据时往文件上不断追加redis操作命令，AOF的执行时间通过配置redis来实现，一般是1秒\n     * 效率稍慢，RDB五分钟一次生成快照，但是AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据。\n\n * 不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功；AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。\n\n\n# 缓存击穿、雪崩、穿透\n\n\n# 雪崩\n\n * 原因\n   \n   * 如果大量的key过期时间设置的过于集中，到过期的那个时间点，缓存失效，同时又有巨大访问量，没有缓存直接到DB肯定扛不住，这不就炸了吗，这就是缓存雪崩导致的 【大面积的缓存失效，打崩了DB】\n\n * 场景\n   \n   * 目前电商首页以及热点数据经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩\n\n * 解决方法\n   \n   * 1. 我们一般在过期时间上加一个随机值，使得过期时间分散一些（推荐）\n     * setRedis（Key，value，time + Math.random() * 10000）；\n   * 2. 如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题，\n   * 3. 或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。\n   * 4. 微服务中的降级、熔断\n\n\n# 击穿\n\n * 原因\n   \n   * 和缓存雪崩有点像，但又不大一样，缓存雪崩是大面积缓存失效导致的，而缓存击穿就像是一个key失效，但同时又面临着巨大的访问量，直接打到DB也挂了。 【并发量大的单个缓存失效，打崩DB】\n\n * 解决方法\n   \n   * 设置热点数据永远不过期\n   * redis分布式锁，正常查询是先查缓存，缓存没有再查数据库然后放入缓存中，\n     而我们在查缓存没有之后查数据库的时候加入redis分布式锁，锁中逻辑是这样的，也是先再查一遍缓存，缓存没有查数据库，然后再放入缓存中，最后释放锁。\n     这样当热点缓存失效时，就算你有100个请求同时访问，因为加锁了，所以其他99个请求会进入阻塞，当第一个请求访问成功后又加入了缓存中，所以其他并发请求再来的时候就不会查库嘞。\n\n\n# 穿透\n\n * 原因\n   \n   * 访问缓存和DB中都没有的数据，如id是 -1或者特别大的数据 的时候，攻击者并发高点就会使DB宕机的 【绕过缓存，打崩DB】\n\n * 解决方法\n   \n   * 从网管nignx开始配置，对同一ip每秒访问次数超过一定阈值的都拉黑\n   * 对访问参数做校验，规范key的命名，并且统一缓存查询和写入的入口。这样，在入口处，对key的规范进行检测。–这样保存恶意的key被拦截。\n   * 不管数据库中是否有数据，都在缓存中保存对应的key，值为空就行。–这样是为了避免数据库中没有这个数据，导致的平凡穿透缓存对数据库进行访问。（代码容易，但会浪费redis内存）\n   * 如果上面缓存的空值如果太多，也会导致内存耗尽。导致不必要的内存消耗。这样就要定期的清理空值的key。避免内存被恶意占满，导致正常的功能的使用。\n   * 使用布隆过滤器\n     * 创建一个布隆过滤器，我们只需要关注两个必选参数 大小和误差值 (采用hash算法可能存在误差) 这两个参数即可，至于hash算法可参考guava的布隆过滤器实现即可。查找我们订单表的所有订单编号，循环遍历加入过滤器中。\n     * 优点：布隆过滤器只有 put() 和 mightContain()，相当于一个ArrayList不能删除元素，只能添加和判断是否存在，底层用hash算法直接保存二进制位(0或1)效率高。\n     * 缺点：布隆过滤器需要手写【一般用 redis setbit(redis中set方法底层就是直接保存的二进制) 实现保证分布式高可用】，维护难，增加数据时往布隆过滤器中put()，删除元素的话需要走定时任务定时重新生成布隆过滤器。\n\n\n# redis集群\n\n我们用到了集群的部署方式也就是Redis cluster，并且是主从同步读写分离，类似Mysql的主从同步，Redis cluster 支撑 N 个 Redis master node，每个master node都可以挂载多个 slave node。\n\n主节点负责写，主从同步，从负责读\n\n这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。\n\n\n# 哨兵\n\n * 功能\n   \n   * 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。\n   * 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。\n   * 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。\n   * 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。\n\n * 原理\n   \n   * 一般最低是一主两从三哨兵，当主节点挂了时，哨兵投票选出一个（奇数个哨兵保证能选出一个）去执行故障转移\n   * 根据选主策略选出一个新的主节点，断开当前slave所有主从关系，启动时从从同步，升级为主节点，将剩余的从节点指向到新的主节点并通知客户端主节点已更换\n\n * 选主策略\n   \n   * slave 的 priority 设置的越低，优先级越高；\n   * 同等情况下，slave 复制的数据越多优先级越高；\n   * 相同的条件下 runid 越小越容易被选中。\n\n\n# 主从同步\n\n * redis同步机制\n   \n   * Redis可以使用主从同步，从从同步。\n\n 1. 启动一台slave 的时候，他会发送一个psync命令给master\n\n 2. 第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点。\n\n 3. 后续的buffer增量数据通过AOF日志同步即可，有点类似数据库的binlog\n    \n    * 1.编辑 vim /etc/redis/6379.conf\n    \n    slaveof 172.25.254.101 6379 #redis-master 的ip\n\n 4. 重启 /etc/init.d/redis_6379 restart\n\n\n# redis主从、集群、哨兵搭建\n\n * 传送门\n\n\n# 分布式锁（并发竞争、读写一致性）\n\n * 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 set指令有非常复杂的参数，一般是同时把setnx和expire合成一条指令来用的！\n\n * 代码\n\n/**\n * redis分布式锁\n */\npublic class RedisLockUtil {\n \n    private static final String LOCK_SUCCESS = "OK";\n    private static final String SET_IF_NOT_EXIST = "NX";\n    private static final String SET_WITH_EXPIRE_TIME = "PX";\n \n    /**\n     * 尝试获取分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @param expireTime 超期时间\n     * @return 是否获取成功\n       @description \n        我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：\n            第一个为key，我们使用key来当锁，因为key是唯一的。\n            第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。\n            第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；\n            第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。\n            第五个为time，与第四个参数相呼应，代表key的过期时间。\n        总的来说，执行set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。\n     */\n    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {\n \n        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);\n \n        if (LOCK_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n\n\n\n    /**\n     * 释放分布式锁\n     * @param jedis Redis客户端\n     * @param lockKey 锁\n     * @param requestId 请求标识\n     * @return 是否释放成功\n     */\n    private static final Long RELEASE_SUCCESS = 1L;\n    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {\n \n        String script = "if redis.call(\'get\', KEYS[1]) == ARGV[1] then return redis.call(\'del\', KEYS[1]) else return 0 end";\n        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));\n \n        if (RELEASE_SUCCESS.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 内存淘汰机制\n\n\n# redis过期策略\n\n * 定期删除\n   \n   * 定期好理解，默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。\n     \n     * 为啥不扫描全部设置了过期时间的key呢？\n       \n       假如Redis里面所有的key都有过期时间，都扫描一遍？那太恐怖了，而且我们线上基本上也都是会设置一定的过期时间的。全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100s一次，Redis累都累死了。\n\n * 惰性删除\n   \n   * 定期删除肯定删不干净。 惰性删除，见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。\n\n\n# 定期没删，我也没查询（惰性没删），那可咋整？\n\n内存淘汰机制\n\n * allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。\n * volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。\n * allkeys-random: 回收随机的键使得新添加的数据有空间存放。\n * volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。\n\n\n# redis解决\n\n\n# 事前\n\n * redis高可用，主从+哨兵，redis cluster，避免全盘崩溃\n\n\n# 事中\n\n * Hystrix限流+降级，避免数据库炸裂\n\n\n# 事后\n\n * redis持久化，一旦重启自动恢复数据\n\n\n# 案例\n\n\n# 秒杀\n\n查看\n\n',normalizedContent:'个人看完傲丙的redis系列最后做的总结，不得不说他redis系列写的确实不错。\n\n\n\n * redis基础\n   * 使用场景\n   * 优缺点\n   * 基本数据结构\n   * 持久化\n * 缓存击穿、雪崩、穿透\n   * 雪崩\n   * 击穿\n   * 穿透\n * redis集群\n   * 哨兵\n   * 主从同步\n   * redis主从、集群、哨兵搭建\n * 分布式锁（并发竞争、读写一致性）\n * 内存淘汰机制\n   * redis过期策略\n   * 定期没删，我也没查询（惰性没删），那可咋整？\n * redis解决\n   * 事前\n   * 事中\n   * 事后\n * 案例\n   * 秒杀\n\n\n\n\n# redis基础\n\n看我之前的这篇 - 传送门\n\n\n# 使用场景\n\n * 缓存 替数据库分担压力 微博那种不断下拉分页，点赞 单点登陆 分布式锁\n\n\n# 优缺点\n\n 1. 基于内存的单线程非关系型数据库，由于在内存中完成操作，所以速度非常快，每秒十万+\n 2. 支持持久化\n 3. 高可用\n\n\n# 基本数据结构\n\n * string\n   \n   * 缓存功能：string字符串是最常用的数据类型，不仅仅是redis，各个语言都是最基本类型，因此，利用redis作为缓存，配合其它数据库作为存储层，利用redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。\n   * 计数器：许多系统都会使用redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存\n   * 共享用户session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存cookie，但是可以利用redis将用户的session集中管理，在这种模式只需要保证redis的高可用，每次用户session的更新和获取都可以快速完成。大大提高效率。\n\n * hash\n   \n   * 这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 redis 里，然后每次读写缓存的时候，可以就操作 hash 里的某个字段。（用的少）\n\n * list\n   \n   * 比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。\n     \n     * lpush key v1 v2 v3 在key中依次插入3个值,每次插入都放在最左边\n     * lrange key start(起始下标) stop(结束下标) 取出key中从下标start到stop(包含)的值\n     * lrange list (当前页-1)rows pagerows-1 分页\n\n * set\n   \n   * 基于 set 玩儿交集、并集、差集的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。\n\n * sortedset\n   \n   * 去重且排序\n     \n     * 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。\n     * 用sorted sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。\n\n\n# 持久化\n\n * rdb做镜像全量持久化，aof做增量持久化。 因为rdb会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用rdb持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。\n   \n   * rdb\n     \n     * fork和cow：fork是指redis通过创建子进程来进行rdb操作，采用二进制压缩存储。cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。\n     * 因为是子进程完成的，所以效率高一点，但是生成一次rdb快照文件需要花费的时间较长。\n   \n   * aof\n     \n     * 效率稍慢，类似于我们用java流写数据时往文件上不断追加redis操作命令，aof的执行时间通过配置redis来实现，一般是1秒\n     * 效率稍慢，rdb五分钟一次生成快照，但是aof是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据。\n\n * 不过redis本身的机制是 aof持久化开启且存在aof文件时，优先加载aof文件；aof关闭或者aof文件不存在时，加载rdb文件；加载aof/rdb文件城后，redis启动成功；aof/rdb文件存在错误时，redis启动失败并打印错误信息。\n\n\n# 缓存击穿、雪崩、穿透\n\n\n# 雪崩\n\n * 原因\n   \n   * 如果大量的key过期时间设置的过于集中，到过期的那个时间点，缓存失效，同时又有巨大访问量，没有缓存直接到db肯定扛不住，这不就炸了吗，这就是缓存雪崩导致的 【大面积的缓存失效，打崩了db】\n\n * 场景\n   \n   * 目前电商首页以及热点数据经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩\n\n * 解决方法\n   \n   * 1. 我们一般在过期时间上加一个随机值，使得过期时间分散一些（推荐）\n     * setredis（key，value，time + math.random() * 10000）；\n   * 2. 如果redis是集群部署，将热点数据均匀分布在不同的redis库中也能避免全部失效的问题，\n   * 3. 或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。\n   * 4. 微服务中的降级、熔断\n\n\n# 击穿\n\n * 原因\n   \n   * 和缓存雪崩有点像，但又不大一样，缓存雪崩是大面积缓存失效导致的，而缓存击穿就像是一个key失效，但同时又面临着巨大的访问量，直接打到db也挂了。 【并发量大的单个缓存失效，打崩db】\n\n * 解决方法\n   \n   * 设置热点数据永远不过期\n   * redis分布式锁，正常查询是先查缓存，缓存没有再查数据库然后放入缓存中，\n     而我们在查缓存没有之后查数据库的时候加入redis分布式锁，锁中逻辑是这样的，也是先再查一遍缓存，缓存没有查数据库，然后再放入缓存中，最后释放锁。\n     这样当热点缓存失效时，就算你有100个请求同时访问，因为加锁了，所以其他99个请求会进入阻塞，当第一个请求访问成功后又加入了缓存中，所以其他并发请求再来的时候就不会查库嘞。\n\n\n# 穿透\n\n * 原因\n   \n   * 访问缓存和db中都没有的数据，如id是 -1或者特别大的数据 的时候，攻击者并发高点就会使db宕机的 【绕过缓存，打崩db】\n\n * 解决方法\n   \n   * 从网管nignx开始配置，对同一ip每秒访问次数超过一定阈值的都拉黑\n   * 对访问参数做校验，规范key的命名，并且统一缓存查询和写入的入口。这样，在入口处，对key的规范进行检测。–这样保存恶意的key被拦截。\n   * 不管数据库中是否有数据，都在缓存中保存对应的key，值为空就行。–这样是为了避免数据库中没有这个数据，导致的平凡穿透缓存对数据库进行访问。（代码容易，但会浪费redis内存）\n   * 如果上面缓存的空值如果太多，也会导致内存耗尽。导致不必要的内存消耗。这样就要定期的清理空值的key。避免内存被恶意占满，导致正常的功能的使用。\n   * 使用布隆过滤器\n     * 创建一个布隆过滤器，我们只需要关注两个必选参数 大小和误差值 (采用hash算法可能存在误差) 这两个参数即可，至于hash算法可参考guava的布隆过滤器实现即可。查找我们订单表的所有订单编号，循环遍历加入过滤器中。\n     * 优点：布隆过滤器只有 put() 和 mightcontain()，相当于一个arraylist不能删除元素，只能添加和判断是否存在，底层用hash算法直接保存二进制位(0或1)效率高。\n     * 缺点：布隆过滤器需要手写【一般用 redis setbit(redis中set方法底层就是直接保存的二进制) 实现保证分布式高可用】，维护难，增加数据时往布隆过滤器中put()，删除元素的话需要走定时任务定时重新生成布隆过滤器。\n\n\n# redis集群\n\n我们用到了集群的部署方式也就是redis cluster，并且是主从同步读写分离，类似mysql的主从同步，redis cluster 支撑 n 个 redis master node，每个master node都可以挂载多个 slave node。\n\n主节点负责写，主从同步，从负责读\n\n这样整个 redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。\n\n\n# 哨兵\n\n * 功能\n   \n   * 集群监控：负责监控 redis master 和 slave 进程是否正常工作。\n   * 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。\n   * 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。\n   * 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。\n\n * 原理\n   \n   * 一般最低是一主两从三哨兵，当主节点挂了时，哨兵投票选出一个（奇数个哨兵保证能选出一个）去执行故障转移\n   * 根据选主策略选出一个新的主节点，断开当前slave所有主从关系，启动时从从同步，升级为主节点，将剩余的从节点指向到新的主节点并通知客户端主节点已更换\n\n * 选主策略\n   \n   * slave 的 priority 设置的越低，优先级越高；\n   * 同等情况下，slave 复制的数据越多优先级越高；\n   * 相同的条件下 runid 越小越容易被选中。\n\n\n# 主从同步\n\n * redis同步机制\n   \n   * redis可以使用主从同步，从从同步。\n\n 1. 启动一台slave 的时候，他会发送一个psync命令给master\n\n 2. 第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点。\n\n 3. 后续的buffer增量数据通过aof日志同步即可，有点类似数据库的binlog\n    \n    * 1.编辑 vim /etc/redis/6379.conf\n    \n    slaveof 172.25.254.101 6379 #redis-master 的ip\n\n 4. 重启 /etc/init.d/redis_6379 restart\n\n\n# redis主从、集群、哨兵搭建\n\n * 传送门\n\n\n# 分布式锁（并发竞争、读写一致性）\n\n * 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 set指令有非常复杂的参数，一般是同时把setnx和expire合成一条指令来用的！\n\n * 代码\n\n/**\n * redis分布式锁\n */\npublic class redislockutil {\n \n    private static final string lock_success = "ok";\n    private static final string set_if_not_exist = "nx";\n    private static final string set_with_expire_time = "px";\n \n    /**\n     * 尝试获取分布式锁\n     * @param jedis redis客户端\n     * @param lockkey 锁\n     * @param requestid 请求标识\n     * @param expiretime 超期时间\n     * @return 是否获取成功\n       @description \n        我们加锁就一行代码：jedis.set(string key, string value, string nxxx, string expx, int time)，这个set()方法一共有五个形参：\n            第一个为key，我们使用key来当锁，因为key是唯一的。\n            第二个为value，我们传的是requestid，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestid，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestid可以使用uuid.randomuuid().tostring()方法生成。\n            第三个为nxxx，这个参数我们填的是nx，意思是set if not exist，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；\n            第四个为expx，这个参数我们传的是px，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。\n            第五个为time，与第四个参数相呼应，代表key的过期时间。\n        总的来说，执行set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。\n     */\n    public static boolean trygetdistributedlock(jedis jedis, string lockkey, string requestid, int expiretime) {\n \n        string result = jedis.set(lockkey, requestid, set_if_not_exist, set_with_expire_time, expiretime);\n \n        if (lock_success.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n\n\n\n    /**\n     * 释放分布式锁\n     * @param jedis redis客户端\n     * @param lockkey 锁\n     * @param requestid 请求标识\n     * @return 是否释放成功\n     */\n    private static final long release_success = 1l;\n    public static boolean releasedistributedlock(jedis jedis, string lockkey, string requestid) {\n \n        string script = "if redis.call(\'get\', keys[1]) == argv[1] then return redis.call(\'del\', keys[1]) else return 0 end";\n        object result = jedis.eval(script, collections.singletonlist(lockkey), collections.singletonlist(requestid));\n \n        if (release_success.equals(result)) {\n            return true;\n        }\n        return false;\n \n    }\n\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 内存淘汰机制\n\n\n# redis过期策略\n\n * 定期删除\n   \n   * 定期好理解，默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。\n     \n     * 为啥不扫描全部设置了过期时间的key呢？\n       \n       假如redis里面所有的key都有过期时间，都扫描一遍？那太恐怖了，而且我们线上基本上也都是会设置一定的过期时间的。全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100s一次，redis累都累死了。\n\n * 惰性删除\n   \n   * 定期删除肯定删不干净。 惰性删除，见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。\n\n\n# 定期没删，我也没查询（惰性没删），那可咋整？\n\n内存淘汰机制\n\n * allkeys-lru: 尝试回收最少使用的键（lru），使得新添加的数据有空间存放。\n * volatile-lru: 尝试回收最少使用的键（lru），但仅限于在过期集合的键,使得新添加的数据有空间存放。\n * allkeys-random: 回收随机的键使得新添加的数据有空间存放。\n * volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。\n\n\n# redis解决\n\n\n# 事前\n\n * redis高可用，主从+哨兵，redis cluster，避免全盘崩溃\n\n\n# 事中\n\n * hystrix限流+降级，避免数据库炸裂\n\n\n# 事后\n\n * redis持久化，一旦重启自动恢复数据\n\n\n# 案例\n\n\n# 秒杀\n\n查看\n\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Redis - 常见应用场景",frontmatter:{title:"Redis - 常见应用场景",date:"2021-07-15T00:00:00.000Z",tags:["Redis"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"views/backend/redis使用场景.md",key:"v-1e51bcb2",path:"/views/backend/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html",headers:[{level:2,title:"一、String 场景",slug:"一、string-场景",normalizedTitle:"一、string 场景",charIndex:3},{level:2,title:"二、Hash 场景",slug:"二、hash-场景",normalizedTitle:"二、hash 场景",charIndex:18},{level:2,title:"三、List 场景",slug:"三、list-场景",normalizedTitle:"三、list 场景",charIndex:31},{level:2,title:"四、Set 场景",slug:"四、set-场景",normalizedTitle:"四、set 场景",charIndex:44},{level:2,title:"五、zSet 场景",slug:"五、zset-场景",normalizedTitle:"五、zset 场景",charIndex:56},{level:2,title:"五、bitmap 场景",slug:"五、bitmap-场景",normalizedTitle:"五、bitmap 场景",charIndex:69}],headersStr:"一、String 场景 二、Hash 场景 三、List 场景 四、Set 场景 五、zSet 场景 五、bitmap 场景",content:" * 一、String 场景\n * 二、Hash 场景\n * 三、List 场景\n * 四、Set 场景\n * 五、zSet 场景\n * 五、bitmap 场景\n\n\n\nRedis是一个key-value存储系统，现在在各种系统中的使用越来越多，大部分情况下是因为其高性能的特性，被当做缓存使用，下面介绍下Redis经常遇到的使用场景。\n\n\n# 一、String 场景\n\n * 计数：例如掘金文章点击数量，阅读数量。\n * 缓存：MySQL 缓存。\n * session共享：集群环境下的 session 共享。\n * 限流：限制一个公共API下某个用户每秒只能调用100次。 set设置key为userId:api，value为次数，过期时间为1s。(1s内每次调用则value加1)\n\n\n# 二、Hash 场景\n\n各种 商城购物车 (淘宝，京东。。)\n\n设计思路：\n\n1.购物车绑定了 userId。\n\n2.商品id作为feild，商品数量作为value。\n\n模拟过程：\n\n// 初始化购物车数据\nhmset userId:1 prod:1 1 prod:2 3 prod:3 4\n\n// 增加商品 prod:1 购买数量为2件时\nhincrby userId:1 prod:1 1\n\n// 减少商品 prod:2 数量为1件时\nhincrby userId:1 prod:2 -2\n\n// 删除商品 prod:1 时\nhdel userId:1 prod:1\n\n// 统计商品数\nhlen userId:1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 三、List 场景\n\n微信公众号订阅消息，文章评论列表等等\n\n设计思路：\n\n公众号发布消息时，向订阅本公众号的用户(mess:1)推送(将订阅消息id通过lpush放入用户的list中)，模拟过程。\n\n模拟过程：\n\n// 推送消息\nlpush mess:1 999\nlpush mess:1 1000\nlpush mess:1 1010\n\n// 查看消息，返回结果1010 1000 999\nlrange mess:1 0 -1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 四、Set 场景\n\n限时抽奖活动：例如微信有个活动，活动id为2，如何基于Redis设计实现。\n\n设计思路：\n\n用户点击立即参与后，将用户id保存到活动id的集合中，利用Set集合的元素唯一性可查看参加用户、参加用户数量等等。\n\n模拟过程：\n\n// 用户user:1 user:2 user:3参加抽奖活动act:888\nsadd act:888 user:1 user:2 user:3\n\n// 模拟一次性随机抽奖1名【抽奖】\nsrandmember act:888\n\n// 模拟两次抽奖，两次抽奖不重复，使用spop命令，抽取中的用户会从set中移除\nspop act:888\nspop act:888\n    \n/* 好友关系：共同关注，我关注的人也关注了他，我可能认识的人\n    注： 如果数据量大的情况下使用大数据分析\n    设计思路：两个集合取交集\n    模拟过程：*/\n    \n// 三个用户关注的人\nsadd user:1 zhangsan lisi wangwu\nsadd user:2 zhangsan liliu wanger wangwu\nsadd user:3 list wangwu liliu\n\n// user:1和user:2共同关注的人，【取交集】\n// 返回zhangsan wangwu\nsinter user:1 user:2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 五、zSet 场景\n\n各种榜单：\n\n例如百度新闻排名\n\n设计思路：\n\n将新闻id作为member，点击次数设置为score，每点击一次score+1，当然，为了每日榜单，member在设计时可以加上后缀用于日期区分，例如news:20191216、news:20191217 。\n\n模拟过程：\n\n// 增加热点新闻\nzadd topic:20191216 100 new:1 200 new:2 150 new:3 500 new:4\n\n// new:1点击了120次，点击数变为220\nzincrby topic:20191216 120 new:1\n\n// 查看今日排行前3名，返回 new:4 500 new:1 220 new:2 200\nzrevrange topic:20191216 0 2 withscores\n\n// 1.新添加数据\nzadd topic:20191217 110 new:1 200 new:2 150 new:3 100 new:4\n\nzadd topic:20191218 110 new:5 200 new:2 150 new:6 100 new:7\n\n// 2.合并三日的数据\nzunionstore topic:3day 3 topic:20191216 topic:20191217 topic:201912168\n\n// 3.查看近三日排行榜前三名，返回new:4 600 new:2 600 new:1 330\nzrevrange topic:3day 0 2 withscores\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 五、bitmap 场景\n\n如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量？redis如何做亿级用户登录日活统计？\n\n利用redis的bitmap，value是一个二进制数据，每一位只能是0或者1。\n\n// setbit key offset value\n// 用户登录，用户id为整型\nsetbit login:20220505 uid 1\n        \n// 判断用户某日是否登录过\ngetbit login:20220505 uid\n        \n// 每日用户登录数量统计 bitcount key [start] [end]\nbitcount login:20220505\n\n// 活跃用户(连续三日登录)统计 bitop operation destkey key [key …]\n/* bitmap的bitop命令支持对bitmap进行AND(与)，(OR)或，XOR(亦或)，NOT(非)四种相关操作;\n    我们对近三日的bitmap做AND操作即可，操作之后会形成一个新的bitmap，\n    我们可以取名为login:top_count \n */\n/* 然后我们可以对login:top_count使用bitcount或者getbit命令，\n    用于统计活跃用户数量，或者查看某个用户是否为活跃用户\n */\nbitop and login:top_count login:20201005 login:20201004 login:20201003\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n以上就是了解Redis常见应用场景的详细内容。",normalizedContent:" * 一、string 场景\n * 二、hash 场景\n * 三、list 场景\n * 四、set 场景\n * 五、zset 场景\n * 五、bitmap 场景\n\n\n\nredis是一个key-value存储系统，现在在各种系统中的使用越来越多，大部分情况下是因为其高性能的特性，被当做缓存使用，下面介绍下redis经常遇到的使用场景。\n\n\n# 一、string 场景\n\n * 计数：例如掘金文章点击数量，阅读数量。\n * 缓存：mysql 缓存。\n * session共享：集群环境下的 session 共享。\n * 限流：限制一个公共api下某个用户每秒只能调用100次。 set设置key为userid:api，value为次数，过期时间为1s。(1s内每次调用则value加1)\n\n\n# 二、hash 场景\n\n各种 商城购物车 (淘宝，京东。。)\n\n设计思路：\n\n1.购物车绑定了 userid。\n\n2.商品id作为feild，商品数量作为value。\n\n模拟过程：\n\n// 初始化购物车数据\nhmset userid:1 prod:1 1 prod:2 3 prod:3 4\n\n// 增加商品 prod:1 购买数量为2件时\nhincrby userid:1 prod:1 1\n\n// 减少商品 prod:2 数量为1件时\nhincrby userid:1 prod:2 -2\n\n// 删除商品 prod:1 时\nhdel userid:1 prod:1\n\n// 统计商品数\nhlen userid:1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 三、list 场景\n\n微信公众号订阅消息，文章评论列表等等\n\n设计思路：\n\n公众号发布消息时，向订阅本公众号的用户(mess:1)推送(将订阅消息id通过lpush放入用户的list中)，模拟过程。\n\n模拟过程：\n\n// 推送消息\nlpush mess:1 999\nlpush mess:1 1000\nlpush mess:1 1010\n\n// 查看消息，返回结果1010 1000 999\nlrange mess:1 0 -1\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 四、set 场景\n\n限时抽奖活动：例如微信有个活动，活动id为2，如何基于redis设计实现。\n\n设计思路：\n\n用户点击立即参与后，将用户id保存到活动id的集合中，利用set集合的元素唯一性可查看参加用户、参加用户数量等等。\n\n模拟过程：\n\n// 用户user:1 user:2 user:3参加抽奖活动act:888\nsadd act:888 user:1 user:2 user:3\n\n// 模拟一次性随机抽奖1名【抽奖】\nsrandmember act:888\n\n// 模拟两次抽奖，两次抽奖不重复，使用spop命令，抽取中的用户会从set中移除\nspop act:888\nspop act:888\n    \n/* 好友关系：共同关注，我关注的人也关注了他，我可能认识的人\n    注： 如果数据量大的情况下使用大数据分析\n    设计思路：两个集合取交集\n    模拟过程：*/\n    \n// 三个用户关注的人\nsadd user:1 zhangsan lisi wangwu\nsadd user:2 zhangsan liliu wanger wangwu\nsadd user:3 list wangwu liliu\n\n// user:1和user:2共同关注的人，【取交集】\n// 返回zhangsan wangwu\nsinter user:1 user:2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 五、zset 场景\n\n各种榜单：\n\n例如百度新闻排名\n\n设计思路：\n\n将新闻id作为member，点击次数设置为score，每点击一次score+1，当然，为了每日榜单，member在设计时可以加上后缀用于日期区分，例如news:20191216、news:20191217 。\n\n模拟过程：\n\n// 增加热点新闻\nzadd topic:20191216 100 new:1 200 new:2 150 new:3 500 new:4\n\n// new:1点击了120次，点击数变为220\nzincrby topic:20191216 120 new:1\n\n// 查看今日排行前3名，返回 new:4 500 new:1 220 new:2 200\nzrevrange topic:20191216 0 2 withscores\n\n// 1.新添加数据\nzadd topic:20191217 110 new:1 200 new:2 150 new:3 100 new:4\n\nzadd topic:20191218 110 new:5 200 new:2 150 new:6 100 new:7\n\n// 2.合并三日的数据\nzunionstore topic:3day 3 topic:20191216 topic:20191217 topic:201912168\n\n// 3.查看近三日排行榜前三名，返回new:4 600 new:2 600 new:1 330\nzrevrange topic:3day 0 2 withscores\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 五、bitmap 场景\n\n如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量？redis如何做亿级用户登录日活统计？\n\n利用redis的bitmap，value是一个二进制数据，每一位只能是0或者1。\n\n// setbit key offset value\n// 用户登录，用户id为整型\nsetbit login:20220505 uid 1\n        \n// 判断用户某日是否登录过\ngetbit login:20220505 uid\n        \n// 每日用户登录数量统计 bitcount key [start] [end]\nbitcount login:20220505\n\n// 活跃用户(连续三日登录)统计 bitop operation destkey key [key …]\n/* bitmap的bitop命令支持对bitmap进行and(与)，(or)或，xor(亦或)，not(非)四种相关操作;\n    我们对近三日的bitmap做and操作即可，操作之后会形成一个新的bitmap，\n    我们可以取名为login:top_count \n */\n/* 然后我们可以对login:top_count使用bitcount或者getbit命令，\n    用于统计活跃用户数量，或者查看某个用户是否为活跃用户\n */\nbitop and login:top_count login:20201005 login:20201004 login:20201003\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n以上就是了解redis常见应用场景的详细内容。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Spring Security 初识",frontmatter:{title:"Spring Security 初识",date:"2021-09-16T00:00:00.000Z",tags:["分布式","Spring Security"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-security-01.html",relativePath:"views/backend/spring-security-01.md",key:"v-2b4237af",path:"/views/backend/spring-security-01.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:141},{level:2,title:"主流web安全框架",slug:"主流web安全框架",normalizedTitle:"主流web安全框架",charIndex:147},{level:2,title:"重要组件",slug:"重要组件",normalizedTitle:"重要组件",charIndex:160},{level:3,title:"UserDetailsService",slug:"userdetailsservice",normalizedTitle:"userdetailsservice",charIndex:170},{level:3,title:"UserDetails",slug:"userdetails",normalizedTitle:"userdetails",charIndex:170},{level:3,title:"PasswordEncoder",slug:"passwordencoder",normalizedTitle:"passwordencoder",charIndex:211},{level:3,title:"WebSecurityConfigurerAdapter",slug:"websecurityconfigureradapter",normalizedTitle:"websecurityconfigureradapter",charIndex:232},{level:3,title:"鉴权注解",slug:"鉴权注解",normalizedTitle:"鉴权注解",charIndex:266},{level:4,title:"@Secured",slug:"secured",normalizedTitle:"@secured",charIndex:3024},{level:4,title:"@PreAuthorize",slug:"preauthorize",normalizedTitle:"@preauthorize",charIndex:3304},{level:4,title:"@PostAuthorize",slug:"postauthorize",normalizedTitle:"@postauthorize",charIndex:3716},{level:4,title:"@PostFilter",slug:"postfilter",normalizedTitle:"@postfilter",charIndex:3833},{level:4,title:"@PreFilter",slug:"prefilter",normalizedTitle:"@prefilter",charIndex:4280},{level:3,title:"remember-me",slug:"remember-me",normalizedTitle:"remember-me",charIndex:276}],excerpt:"<Boxx/>\n<p>Spring Security或者说web安全最核心的两个部分即：<code>认证（Authentication）</code> 和 <code>授权（Authorization）。</code></p>\n<ul>\n<li>认证：用户是否能登录</li>\n<li>授权：用户是否有权限去做某些事情</li>\n</ul>\n<p>即不用的用户登录之后有不同的权限可以去做某些事情。</p>\n",headersStr:"简介 主流web安全框架 重要组件 UserDetailsService UserDetails PasswordEncoder WebSecurityConfigurerAdapter 鉴权注解 @Secured @PreAuthorize @PostAuthorize @PostFilter @PreFilter remember-me",content:'Spring Security或者说web安全最核心的两个部分即：认证（Authentication） 和 授权（Authorization）。\n\n * 认证：用户是否能登录\n * 授权：用户是否有权限去做某些事情\n\n即不用的用户登录之后有不同的权限可以去做某些事情。\n\n\n\n * 简介\n * 主流web安全框架\n * 重要组件\n   * UserDetailsService\n   * UserDetails\n   * PasswordEncoder\n   * WebSecurityConfigurerAdapter\n   * 鉴权注解\n   * remember-me\n\n\n\n\n# 简介\n\n官网是最好的答案：https://spring.io/projects/spring-security\n\n\n# 主流web安全框架\n\nspring-security：与spring无缝整合，可定制化程度高，权限控制较全面，缺点即重量级，配置繁琐（但springboot出来后就没简单了）。\n\nshiro：轻量级，简单，缺点即没有spring-security功能完善，在web一些特殊需求下需要二次开发。\n\n因此，一般组合如下：\n\n * SSM + Shiro\n * Spring Boot/Spring Cloud + Spring Security\n\n\n# 重要组件\n\n\n# UserDetailsService\n\n * 数据库查询用户，校验密码的过程写在这里\n\n当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。\n\n如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。\n\npublic interface UserDetailsService {\n    //数据库查询用户，校验密码的过程写在这里\n    UserDetails loadUserByUsername(String var1) \n        throws UsernameNotFoundException;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# UserDetails\n\n实现UserDetails接口，Spring默认实现是User，而我们自定义用户实体类（包含用户名、密码、权限），以后我们只需要使用自定义的 User 实体类即可。\n\n// 表示获取登录用户所有权限\nCollection<? extends GrantedAuthority> getAuthorities();\n// 表示获取密码\nString getPassword();\n// 表示获取用户名\nString getUsername();\n// 表示判断账户是否过期\nboolean isAccountNonExpired();\n// 表示判断账户是否被锁定\nboolean isAccountNonLocked();\n// 表示凭证{密码}是否过期\nboolean isCredentialsNonExpired();\n// 表示当前用户是否可用\nboolean isEnabled();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# PasswordEncoder\n\nPasswordEncoder是Spring Security密码加密的一个工具接口；\n\nBCryptPasswordEncoder 是最好的实现方式， Spring Security 官方推荐的密码解析器，项目中一般都是用这个工具。\n\nBCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认 10。\n\n\n# WebSecurityConfigurerAdapter\n\n详细解释见：WebSecurityConfigurerAdapter 解析\n\nSpring Security 的核心配置就是继承 WebSecurityConfigurerAdapter 并注解 @EnableWebSecurity 的配置。这个配置指明了用户名密码的处理方式、请求路径、登录登出控制等和安全相关的配置。\n\nWebSecurityConfigurerAdapter中创建了一个SecurityConfigurer类型的HttpSecurity实例来真正完成安全的装配，HttpSecurity也提供了很多方法来方便对各种安全机制的配置。\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\t//  注入 PasswordEncoder  类到 spring  容器中\n\t@Bean\n\tpublic PasswordEncoder passwordEncoder(){\n\t\treturn new BCryptPasswordEncoder();\n\t}\n    \n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //  配置认证\n        http.formLogin()\n            .loginPage("/index") //  配置哪个 url 为登录页面\n            .loginProcessingUrl("/login") //  设置哪个是登录的 url 。\n            .successForwardUrl("/success") //  登录成功之后跳转到哪个 url\n            .failureForwardUrl("/fail");//  登录失败之后跳转到哪个 url\n        http.authorizeRequests()\n            .antMatchers("/layui/**","/index") // 表示配置请求路径\n            .permitAll() //  指定 URL 无需保护。\n            .antMatchers("/system").hasAnyAuthority(\'menu:system\')//是否具有某个权限\n            .anyRequest() //  其他请求\n            .authenticated(); // 需要认证\n        //  关闭 csrf\n        http.csrf().disable();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 鉴权注解\n\n如上，可以在配置类里以http.antMatchers("/system").hasAnyAuthority(\'menu:system\')//是否具有某个权限配置，也可以使用相关注解\n\n# @Secured\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE_“。\n\n> 使用注解先要开启注解功能！ @EnableGlobalMethodSecurity(securedEnabled=true)\n\n使用：\n\n@RequestMapping("/testSecured")\n@ResponseBody\n@Secured({"ROLE_normal","ROLE_admin"})\npublic String helloUser() {\n    return "hello,user";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# @PreAuthorize\n\n一般作为进入方法前的权限验证使用，@PreAuthorize 可以将登录用户的 roles/permissions 参数传到方法中。\n\n> 先开启注解功能： @EnableGlobalMethodSecurity(prePostEnabled = true)\n\n使用：\n\n@RequestMapping("/testPreAuthorize")\n@ResponseBody\n//@PreAuthorize("hasRole(\'ROLE_ 管理员 \')")\n@PreAuthorize("hasAnyAuthority(\'menu:system\')")\npublic String preAuthorize(){\n    System.out.println("preAuthorize");\n    return "preAuthorize";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# @PostAuthorize\n\n使用并不多，在方法执行后再进行权限验证，适合验证带有返回值 的权限。\n\n> 先开启注解功能： @EnableGlobalMethodSecurity(prePostEnabled = true)\n\n# @PostFilter\n\n权限验证之后对数据进行过滤 留下用户名是 admin1 的数据\n\n@RequestMapping("getAll")\n@PreAuthorize("hasRole(\'ROLE_ 管理员\')")\n//表达式中的 filterObject 引用的是方法返回值 List 中的某一个元素\n@PostFilter("filterObject.username == \'admin1\'")\n@ResponseBody\npublic List<UserInfo> getAllUser(){\n    ArrayList<UserInfo> list = new ArrayList<>();\n    list.add(new UserInfo(1l,"admin1","6666"));\n    list.add(new UserInfo(2l,"admin2","888"));\n    return list;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# @PreFilter\n\n进入控制器之前对数据进行过滤\n\n@RequestMapping("getTestPreFilter")\n@PreAuthorize("hasRole(\'ROLE_ 管理员\')")\n@PreFilter(value = "filterObject.id%2==0")\n@ResponseBody\npublic  List<UserInfo>  getTestPreFilter(\n    \t\t\t@RequestBody  List<UserInfo> list){\n    list.forEach(t-> {\n        System.out.println(t.getId()+"\\t"+t.getUsername());\n    });\n    return list;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# remember-me\n\n基于数据库的记住我：\n\n 1. 添加数据库的配置文件\n    \n    spring:\n        datasource:\t\n            driver-class-name: com.mysql.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/test\n            username: root\n            password: root\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. 编写配置类\n    \n    @Configuration\n    public class RememberMeSecurityConfig {\n        @Autowired\n        private DataSource dataSource;\n        @Bean\n        public PersistentTokenRepository persistentTokenRepository(){\n            JdbcTokenRepositoryImpl  jdbcTokenRepository  =  new\n            JdbcTokenRepositoryImpl();\n            //  赋值数据源\n            jdbcTokenRepository.setDataSource(dataSource);\n            //  自动创建表 , 第一次执行会创建，以后要执行就要删除掉！\n            jdbcTokenRepository.setCreateTableOnStartup(true);\n            return jdbcTokenRepository;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 3. 修改WebSecurityConfigurerAdapter安全配置类\n    \n    @Autowired\n    private UsersServiceImpl usersService;\n    @Autowired\n    private PersistentTokenRepository tokenRepository;\n    \n    // 开启记住我功能\n    http.rememberMe()\n        \t.tokenValiditySeconds()// 设置有效期，秒\n            .tokenRepository(tokenRepository)\n            .userDetailsService(usersService);\n    // 注销\n    http.logout()\n        \t.logoutUrl("/logout")\n        \t.logoutSuccessUrl("/index")\n        \t.permitAll;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 4. 页面添加记住我复选框\n    \n    name 属性值必须位 remember-me，不能改为其他值\n    \n    记住我：<input type="checkbox"name="remember-me"title=" 记住密码"/><br/>\n    \n    \n    1\n    \n\n 5. 完毕，测试！\n\n这次先简单了解一下SpringSecurity，下次留时间整点高级用法~',normalizedContent:'spring security或者说web安全最核心的两个部分即：认证（authentication） 和 授权（authorization）。\n\n * 认证：用户是否能登录\n * 授权：用户是否有权限去做某些事情\n\n即不用的用户登录之后有不同的权限可以去做某些事情。\n\n\n\n * 简介\n * 主流web安全框架\n * 重要组件\n   * userdetailsservice\n   * userdetails\n   * passwordencoder\n   * websecurityconfigureradapter\n   * 鉴权注解\n   * remember-me\n\n\n\n\n# 简介\n\n官网是最好的答案：https://spring.io/projects/spring-security\n\n\n# 主流web安全框架\n\nspring-security：与spring无缝整合，可定制化程度高，权限控制较全面，缺点即重量级，配置繁琐（但springboot出来后就没简单了）。\n\nshiro：轻量级，简单，缺点即没有spring-security功能完善，在web一些特殊需求下需要二次开发。\n\n因此，一般组合如下：\n\n * ssm + shiro\n * spring boot/spring cloud + spring security\n\n\n# 重要组件\n\n\n# userdetailsservice\n\n * 数据库查询用户，校验密码的过程写在这里\n\n当什么也没有配置的时候，账号和密码是由 spring security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。\n\n如果需要自定义逻辑时，只需要实现 userdetailsservice 接口即可。\n\npublic interface userdetailsservice {\n    //数据库查询用户，校验密码的过程写在这里\n    userdetails loaduserbyusername(string var1) \n        throws usernamenotfoundexception;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# userdetails\n\n实现userdetails接口，spring默认实现是user，而我们自定义用户实体类（包含用户名、密码、权限），以后我们只需要使用自定义的 user 实体类即可。\n\n// 表示获取登录用户所有权限\ncollection<? extends grantedauthority> getauthorities();\n// 表示获取密码\nstring getpassword();\n// 表示获取用户名\nstring getusername();\n// 表示判断账户是否过期\nboolean isaccountnonexpired();\n// 表示判断账户是否被锁定\nboolean isaccountnonlocked();\n// 表示凭证{密码}是否过期\nboolean iscredentialsnonexpired();\n// 表示当前用户是否可用\nboolean isenabled();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# passwordencoder\n\npasswordencoder是spring security密码加密的一个工具接口；\n\nbcryptpasswordencoder 是最好的实现方式， spring security 官方推荐的密码解析器，项目中一般都是用这个工具。\n\nbcryptpasswordencoder 是对 bcrypt 强散列方法的具体实现。是基于 hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认 10。\n\n\n# websecurityconfigureradapter\n\n详细解释见：websecurityconfigureradapter 解析\n\nspring security 的核心配置就是继承 websecurityconfigureradapter 并注解 @enablewebsecurity 的配置。这个配置指明了用户名密码的处理方式、请求路径、登录登出控制等和安全相关的配置。\n\nwebsecurityconfigureradapter中创建了一个securityconfigurer类型的httpsecurity实例来真正完成安全的装配，httpsecurity也提供了很多方法来方便对各种安全机制的配置。\n\n@configuration\npublic class securityconfig extends websecurityconfigureradapter {\n\t//  注入 passwordencoder  类到 spring  容器中\n\t@bean\n\tpublic passwordencoder passwordencoder(){\n\t\treturn new bcryptpasswordencoder();\n\t}\n    \n    @override\n    protected void configure(httpsecurity http) throws exception {\n        //  配置认证\n        http.formlogin()\n            .loginpage("/index") //  配置哪个 url 为登录页面\n            .loginprocessingurl("/login") //  设置哪个是登录的 url 。\n            .successforwardurl("/success") //  登录成功之后跳转到哪个 url\n            .failureforwardurl("/fail");//  登录失败之后跳转到哪个 url\n        http.authorizerequests()\n            .antmatchers("/layui/**","/index") // 表示配置请求路径\n            .permitall() //  指定 url 无需保护。\n            .antmatchers("/system").hasanyauthority(\'menu:system\')//是否具有某个权限\n            .anyrequest() //  其他请求\n            .authenticated(); // 需要认证\n        //  关闭 csrf\n        http.csrf().disable();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 鉴权注解\n\n如上，可以在配置类里以http.antmatchers("/system").hasanyauthority(\'menu:system\')//是否具有某个权限配置，也可以使用相关注解\n\n# @secured\n\n判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“role_“。\n\n> 使用注解先要开启注解功能！ @enableglobalmethodsecurity(securedenabled=true)\n\n使用：\n\n@requestmapping("/testsecured")\n@responsebody\n@secured({"role_normal","role_admin"})\npublic string hellouser() {\n    return "hello,user";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# @preauthorize\n\n一般作为进入方法前的权限验证使用，@preauthorize 可以将登录用户的 roles/permissions 参数传到方法中。\n\n> 先开启注解功能： @enableglobalmethodsecurity(prepostenabled = true)\n\n使用：\n\n@requestmapping("/testpreauthorize")\n@responsebody\n//@preauthorize("hasrole(\'role_ 管理员 \')")\n@preauthorize("hasanyauthority(\'menu:system\')")\npublic string preauthorize(){\n    system.out.println("preauthorize");\n    return "preauthorize";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# @postauthorize\n\n使用并不多，在方法执行后再进行权限验证，适合验证带有返回值 的权限。\n\n> 先开启注解功能： @enableglobalmethodsecurity(prepostenabled = true)\n\n# @postfilter\n\n权限验证之后对数据进行过滤 留下用户名是 admin1 的数据\n\n@requestmapping("getall")\n@preauthorize("hasrole(\'role_ 管理员\')")\n//表达式中的 filterobject 引用的是方法返回值 list 中的某一个元素\n@postfilter("filterobject.username == \'admin1\'")\n@responsebody\npublic list<userinfo> getalluser(){\n    arraylist<userinfo> list = new arraylist<>();\n    list.add(new userinfo(1l,"admin1","6666"));\n    list.add(new userinfo(2l,"admin2","888"));\n    return list;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# @prefilter\n\n进入控制器之前对数据进行过滤\n\n@requestmapping("gettestprefilter")\n@preauthorize("hasrole(\'role_ 管理员\')")\n@prefilter(value = "filterobject.id%2==0")\n@responsebody\npublic  list<userinfo>  gettestprefilter(\n    \t\t\t@requestbody  list<userinfo> list){\n    list.foreach(t-> {\n        system.out.println(t.getid()+"\\t"+t.getusername());\n    });\n    return list;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# remember-me\n\n基于数据库的记住我：\n\n 1. 添加数据库的配置文件\n    \n    spring:\n        datasource:\t\n            driver-class-name: com.mysql.jdbc.driver\n            url: jdbc:mysql://localhost:3306/test\n            username: root\n            password: root\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 2. 编写配置类\n    \n    @configuration\n    public class remembermesecurityconfig {\n        @autowired\n        private datasource datasource;\n        @bean\n        public persistenttokenrepository persistenttokenrepository(){\n            jdbctokenrepositoryimpl  jdbctokenrepository  =  new\n            jdbctokenrepositoryimpl();\n            //  赋值数据源\n            jdbctokenrepository.setdatasource(datasource);\n            //  自动创建表 , 第一次执行会创建，以后要执行就要删除掉！\n            jdbctokenrepository.setcreatetableonstartup(true);\n            return jdbctokenrepository;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 3. 修改websecurityconfigureradapter安全配置类\n    \n    @autowired\n    private usersserviceimpl usersservice;\n    @autowired\n    private persistenttokenrepository tokenrepository;\n    \n    // 开启记住我功能\n    http.rememberme()\n        \t.tokenvalidityseconds()// 设置有效期，秒\n            .tokenrepository(tokenrepository)\n            .userdetailsservice(usersservice);\n    // 注销\n    http.logout()\n        \t.logouturl("/logout")\n        \t.logoutsuccessurl("/index")\n        \t.permitall;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 4. 页面添加记住我复选框\n    \n    name 属性值必须位 remember-me，不能改为其他值\n    \n    记住我：<input type="checkbox"name="remember-me"title=" 记住密码"/><br/>\n    \n    \n    1\n    \n\n 5. 完毕，测试！\n\n这次先简单了解一下springsecurity，下次留时间整点高级用法~',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Spring Security 认证授权",frontmatter:{title:"Spring Security 认证授权",date:"2022-12-19T00:00:00.000Z",tags:["分布式","Spring Security"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-security-02.html",relativePath:"views/backend/spring-security-02.md",key:"v-345c456d",path:"/views/backend/spring-security-02.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3},{level:2,title:"认证",slug:"认证",normalizedTitle:"认证",charIndex:9},{level:2,title:"授权",slug:"授权",normalizedTitle:"授权",charIndex:15},{level:3,title:"基于注解的鉴权",slug:"基于注解的鉴权",normalizedTitle:"基于注解的鉴权",charIndex:23},{level:3,title:"基于url的动态鉴权",slug:"基于url的动态鉴权",normalizedTitle:"基于url的动态鉴权",charIndex:36},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:50}],excerpt:"<Boxx/>\n",headersStr:"简介 认证 授权 基于注解的鉴权 基于url的动态鉴权 参考",content:' * 简介\n * 认证\n * 授权\n   * 基于注解的鉴权\n   * 基于url的动态鉴权\n * 参考\n\n\n\n\n# 简介\n\n在 Spring Boot 风靡的今天，一款强大的安全管理框架必不可少，作为 Spring Boot 项目首选的默认安全技术选型，对 Spring Security 的学习必不可少，其实主要包括 认证 和 授权 两部分。\n\n而 Spring Security 的底层原理其实也就是一个 过滤器链，通过一个过滤器链中的不同过滤器组件实现不同的安全功能。\n\n\n\n过滤器链中的前三个部分都是可配置的，我们也可以在指定过滤器之前或之后添加我们自定义的过滤器。而 ExceptionTranslationFilter 和 FilterSecurityInterceptor 是一定会执行的。\n\nSpring Security 默认的过滤器：\n\n序号   过滤器                                       描述\n1    SecurityContextPersistenceFilter          首当其冲的一个过滤器，非常重要，主要是使用SecurityContextRepository在session中保存或更新一个SecurityContext，并将SecurityContext给以后的过滤器使用，来为后续filter建立所需的上下文，SecurityContext中存储了当前用户的认证和权限信息。\n2    WebAsyncManagerIntegrationFilter          此过滤器用于继承SecurityContext到Spring异步执行机制中的WebAsyncManager，和spring整合必须的。\n3    HeaderWriterFilter                        向请求的header中添加响应的信息，可以在http标签内部使用 security:headers 来控制。\n4    CsrfFilter                                Csrf又称跨域请求伪造，SpringSecurity会对所有post请求验证是否包含系统生成的csrf的token信息，如果不包含则报错，起到防止csrf攻击的效果。\n5    LogoutFilter                              匹配URL为/logout的请求，实现用户退出，清楚认证信息。\n6    UsernamePasswordAuthenticationFilter      认证操作全靠这个过滤器，默认匹配URL为/login且必须为POST请求。\n7    DefaultLoginPageGeneratingFilter          如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认的认证界面。\n8    DefaultLogoutPageGeneratingFilter         由此过滤器生成一个默认的退出登录页面。\n9    BasicAuthenticationFilter                 此过滤器会自动解析HTTP请求中头部名字为Authentication，且以Basic开头的头部信息。\n10   RequestCacheAwareFilter                   通过HttpSessionRequestCache内部维护一个RequestCache，用于缓存HttpServletRequest。\n11   SecurityContextHolderAwareRequestFilter   针对ServletRequest进行一次包装，使得request具有更加丰富的API。\n12   AnonymousAuthenticationFilter             当SecurityContextHolder中认证信息为空，则会创建一个匿名用户存储到SecurityContextHolder中，SpringSecurity为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。\n13   SessionManagementFilter                   SecurityContextRepository限制同一个用户开启多个会话的数量。\n14   ExceptionTranslationFilter                异常转换过滤器位于整个SpringSecurityFilterChain的后方，用来转换整个链路中出现的异常。\n15   FilterSecurityInterceptor                 获取所有配置资源的访问授权信息，根据SecurityContextHolder中存储的用户信息来决定其是否有权限。\n\nSpring 虽提供了拦截器，但 Spring Security 使用过滤器实现的主要原因是因为：过滤器是 servlet 层面的，而拦截器是 spring 层面的。一个请求进来的时候会依次经过：Filter -> Servlet -> Inteceptor -> Controller，若用 Inteceptor（拦截器）实现的话，可能一些请求已经被 Filter（过滤器） 过滤掉了导致Inteceptor（拦截器）无法处理。所以 Filter（过滤器）作为请求的入口，安全框架应该从 Filter（过滤器） 入手。\n\n\n# 认证\n\n认证流程：\n\n 1. 请求进来后先经过 用户名密码认证过滤器（这个在使用JWT的情况下会被我们自己实现的 JwtAuthenticationTokenFilter 代替），只要用户的请求满足该过滤器的条件，即认证成功（这些都是我们后续在代码中自己实现）。如果不满足则放行给下一个；\n\n 2. 请求继续向后，经过 BasicAutenticationFilter 继续进行认证，直到最后 FilterSecurityInterceptor 拦截器，它是API的最后一环，由它来决定请求是否能到达具体的API。简单来说，就是负责权限校验（利用 SecurityContextHolder 来获取用户的权限相关信息）;\n    \n    1. 它会根据我们配置的一些要求，来进行判断，如果不通过则抛出异常\n    \n    2. 例如某API要求请求必须经过认证，则在最后一个拦截器处，请求如果没有进行认证，则抛出对应的异常\n    \n    3. 比如某API要求请求具有VIP的权限，则最后一个拦截器会判断该请求是否具有VIP权限\n\n 3. ExceptionTranslationFilter 的作用主要是捕获 FilterSecurityInterceptor 抛出的异常( AccessDeniedException 和 AuthenticationException )，并做响应的处理\n\n 4. 黄色的部分可以通过配置来决定是否存在于过滤器链上，即由我们来决定使用哪些认证方式\n\n\n\n\n# 授权\n\n\n# 基于注解的鉴权\n\n基于方法的权限管理主要是通过AOP来实现的，spring security 中通过 MethodSecurityInterceptor 来提供相关的实现。不同在于，FilterSecurityInterceptor 只是在请求之前进行前置处理，MethodSecurityInterceptor 在此基础上还可以进行后置处理。前置处理就是在请求之前判断是否具备相应的权限，后置处理则是对方法的执行结果进行二次过滤。\n\n 1. 通过@EnableGlobalMethodSecurity(prePostEnabled = true)注解开启权限注解的使用\n\n 2. @PreAuthorize\n    \n    @Service\n    public class HelloService {\n    \t// 执行该方法必须具备ADMIN角色才可以访问\n        @PreAuthorize("hasRole(\'ADMIN\')")\n        public String preAuthorizeTest01() {\n            return "Hello";\n        }\n        // 访问者名称必须是javaboy，而且还需要同事具备ADMIN角色才可以访问\n        @PreAuthorize("hasRole(\'ADMIN\') and authentication.name == \'javaboy\'")\n        public String preAuthorizeTest02() {\n            return "Hello";\n        }\n        // 通过#引用方法参数，并对其进行校验，表示请求者的用户名必须等于方法参数name的值，方法才可以被执行\n        @PreAuthorize("authentication.name == #name")\n        public String preAuthorizeTest03(String name) {\n            return "Hello: " + name;\n        }\n    }\n    \n    @SpringBootTest\n    class BasedOnMethodApplicationTests {\n    \t@Autowired\n        HelloService helloService;\n        @Test\n        // 通过该注解设定当前执行的用户角色是ADMIN\n        @WithMockUser(roles = "ADMIN")\n        void preAuthorizeTest01() {\n            String hello = helloService.preAuthorizeTest01();\n            Assertions.assertNotNull(hello);\n            Assertions.assertEquals("Hello", hello);\n        }\n        @Test\n        @WithMockUser(roles = "ADMIN", username = "javaboy")\n        void preAuthorizeTest02() {\n            String hello = helloService.preAuthorizeTest02();\n            Assertions.assertNotNull(hello);\n            Assertions.assertEquals("Hello", hello);\n        }\n        @Test\n        @WithMockUser(username = "javaboy")\n        void preAuthorizeTest03() {\n            String hello = helloService.preAuthorizeTest03("javaboy");\n            Assertions.assertNotNull(hello);\n            Assertions.assertEquals("Hello: javaboy", hello);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    \n\n\n# 基于url的动态鉴权\n\n鉴权主要在 FilterSecurityInterceptor 这个类，如果默认的 FilterSecurityInterceptor 不满足要求，那我们就重写它就好了。\n\n 1. 实现 FilterInvocationSecurityMetadataSource.getAttributes 提供一个 url 对应的所需权限集合\n 2. 实现 AccessDecisionManager.decide 将当前登录用户的权限和 url 的所需权限比对，有则鉴权通过\n\n代码已经完成，实例可参考项目：https://github.com/zpj80231/imall admin 模块\n\n\n# 参考\n\n * Spring Security 认证与授权流程\n * Spring Security 基本认证，授权流程，原理方法\n * Spring Security 权限管理',normalizedContent:' * 简介\n * 认证\n * 授权\n   * 基于注解的鉴权\n   * 基于url的动态鉴权\n * 参考\n\n\n\n\n# 简介\n\n在 spring boot 风靡的今天，一款强大的安全管理框架必不可少，作为 spring boot 项目首选的默认安全技术选型，对 spring security 的学习必不可少，其实主要包括 认证 和 授权 两部分。\n\n而 spring security 的底层原理其实也就是一个 过滤器链，通过一个过滤器链中的不同过滤器组件实现不同的安全功能。\n\n\n\n过滤器链中的前三个部分都是可配置的，我们也可以在指定过滤器之前或之后添加我们自定义的过滤器。而 exceptiontranslationfilter 和 filtersecurityinterceptor 是一定会执行的。\n\nspring security 默认的过滤器：\n\n序号   过滤器                                       描述\n1    securitycontextpersistencefilter          首当其冲的一个过滤器，非常重要，主要是使用securitycontextrepository在session中保存或更新一个securitycontext，并将securitycontext给以后的过滤器使用，来为后续filter建立所需的上下文，securitycontext中存储了当前用户的认证和权限信息。\n2    webasyncmanagerintegrationfilter          此过滤器用于继承securitycontext到spring异步执行机制中的webasyncmanager，和spring整合必须的。\n3    headerwriterfilter                        向请求的header中添加响应的信息，可以在http标签内部使用 security:headers 来控制。\n4    csrffilter                                csrf又称跨域请求伪造，springsecurity会对所有post请求验证是否包含系统生成的csrf的token信息，如果不包含则报错，起到防止csrf攻击的效果。\n5    logoutfilter                              匹配url为/logout的请求，实现用户退出，清楚认证信息。\n6    usernamepasswordauthenticationfilter      认证操作全靠这个过滤器，默认匹配url为/login且必须为post请求。\n7    defaultloginpagegeneratingfilter          如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认的认证界面。\n8    defaultlogoutpagegeneratingfilter         由此过滤器生成一个默认的退出登录页面。\n9    basicauthenticationfilter                 此过滤器会自动解析http请求中头部名字为authentication，且以basic开头的头部信息。\n10   requestcacheawarefilter                   通过httpsessionrequestcache内部维护一个requestcache，用于缓存httpservletrequest。\n11   securitycontextholderawarerequestfilter   针对servletrequest进行一次包装，使得request具有更加丰富的api。\n12   anonymousauthenticationfilter             当securitycontextholder中认证信息为空，则会创建一个匿名用户存储到securitycontextholder中，springsecurity为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。\n13   sessionmanagementfilter                   securitycontextrepository限制同一个用户开启多个会话的数量。\n14   exceptiontranslationfilter                异常转换过滤器位于整个springsecurityfilterchain的后方，用来转换整个链路中出现的异常。\n15   filtersecurityinterceptor                 获取所有配置资源的访问授权信息，根据securitycontextholder中存储的用户信息来决定其是否有权限。\n\nspring 虽提供了拦截器，但 spring security 使用过滤器实现的主要原因是因为：过滤器是 servlet 层面的，而拦截器是 spring 层面的。一个请求进来的时候会依次经过：filter -> servlet -> inteceptor -> controller，若用 inteceptor（拦截器）实现的话，可能一些请求已经被 filter（过滤器） 过滤掉了导致inteceptor（拦截器）无法处理。所以 filter（过滤器）作为请求的入口，安全框架应该从 filter（过滤器） 入手。\n\n\n# 认证\n\n认证流程：\n\n 1. 请求进来后先经过 用户名密码认证过滤器（这个在使用jwt的情况下会被我们自己实现的 jwtauthenticationtokenfilter 代替），只要用户的请求满足该过滤器的条件，即认证成功（这些都是我们后续在代码中自己实现）。如果不满足则放行给下一个；\n\n 2. 请求继续向后，经过 basicautenticationfilter 继续进行认证，直到最后 filtersecurityinterceptor 拦截器，它是api的最后一环，由它来决定请求是否能到达具体的api。简单来说，就是负责权限校验（利用 securitycontextholder 来获取用户的权限相关信息）;\n    \n    1. 它会根据我们配置的一些要求，来进行判断，如果不通过则抛出异常\n    \n    2. 例如某api要求请求必须经过认证，则在最后一个拦截器处，请求如果没有进行认证，则抛出对应的异常\n    \n    3. 比如某api要求请求具有vip的权限，则最后一个拦截器会判断该请求是否具有vip权限\n\n 3. exceptiontranslationfilter 的作用主要是捕获 filtersecurityinterceptor 抛出的异常( accessdeniedexception 和 authenticationexception )，并做响应的处理\n\n 4. 黄色的部分可以通过配置来决定是否存在于过滤器链上，即由我们来决定使用哪些认证方式\n\n\n\n\n# 授权\n\n\n# 基于注解的鉴权\n\n基于方法的权限管理主要是通过aop来实现的，spring security 中通过 methodsecurityinterceptor 来提供相关的实现。不同在于，filtersecurityinterceptor 只是在请求之前进行前置处理，methodsecurityinterceptor 在此基础上还可以进行后置处理。前置处理就是在请求之前判断是否具备相应的权限，后置处理则是对方法的执行结果进行二次过滤。\n\n 1. 通过@enableglobalmethodsecurity(prepostenabled = true)注解开启权限注解的使用\n\n 2. @preauthorize\n    \n    @service\n    public class helloservice {\n    \t// 执行该方法必须具备admin角色才可以访问\n        @preauthorize("hasrole(\'admin\')")\n        public string preauthorizetest01() {\n            return "hello";\n        }\n        // 访问者名称必须是javaboy，而且还需要同事具备admin角色才可以访问\n        @preauthorize("hasrole(\'admin\') and authentication.name == \'javaboy\'")\n        public string preauthorizetest02() {\n            return "hello";\n        }\n        // 通过#引用方法参数，并对其进行校验，表示请求者的用户名必须等于方法参数name的值，方法才可以被执行\n        @preauthorize("authentication.name == #name")\n        public string preauthorizetest03(string name) {\n            return "hello: " + name;\n        }\n    }\n    \n    @springboottest\n    class basedonmethodapplicationtests {\n    \t@autowired\n        helloservice helloservice;\n        @test\n        // 通过该注解设定当前执行的用户角色是admin\n        @withmockuser(roles = "admin")\n        void preauthorizetest01() {\n            string hello = helloservice.preauthorizetest01();\n            assertions.assertnotnull(hello);\n            assertions.assertequals("hello", hello);\n        }\n        @test\n        @withmockuser(roles = "admin", username = "javaboy")\n        void preauthorizetest02() {\n            string hello = helloservice.preauthorizetest02();\n            assertions.assertnotnull(hello);\n            assertions.assertequals("hello", hello);\n        }\n        @test\n        @withmockuser(username = "javaboy")\n        void preauthorizetest03() {\n            string hello = helloservice.preauthorizetest03("javaboy");\n            assertions.assertnotnull(hello);\n            assertions.assertequals("hello: javaboy", hello);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    \n\n\n# 基于url的动态鉴权\n\n鉴权主要在 filtersecurityinterceptor 这个类，如果默认的 filtersecurityinterceptor 不满足要求，那我们就重写它就好了。\n\n 1. 实现 filterinvocationsecuritymetadatasource.getattributes 提供一个 url 对应的所需权限集合\n 2. 实现 accessdecisionmanager.decide 将当前登录用户的权限和 url 的所需权限比对，有则鉴权通过\n\n代码已经完成，实例可参考项目：https://github.com/zpj80231/imall admin 模块\n\n\n# 参考\n\n * spring security 认证与授权流程\n * spring security 基本认证，授权流程，原理方法\n * spring security 权限管理',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"手写 Spring 01 - 核心容器实现",frontmatter:{title:"手写 Spring 01 - 核心容器实现",date:"2023-02-17T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-01.html",relativePath:"views/backend/spring-source-01.md",key:"v-55af23a5",path:"/views/backend/spring-source-01.html",headers:[{level:2,title:"核心容器 DefaultListableBeanFactory",slug:"核心容器-defaultlistablebeanfactory",normalizedTitle:"核心容器 defaultlistablebeanfactory",charIndex:176},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:213},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:229},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:241},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:259},{level:2,title:"实例化",slug:"实例化",normalizedTitle:"实例化",charIndex:80},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:213},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:229},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:241},{level:3,title:"测试：",slug:"测试-2",normalizedTitle:"测试：",charIndex:259},{level:2,title:"属性填充",slug:"属性填充",normalizedTitle:"属性填充",charIndex:328},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-3",normalizedTitle:"定义一些职责和能力：",charIndex:213},{level:3,title:"具体的实现：",slug:"具体的实现-3",normalizedTitle:"具体的实现：",charIndex:229},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-3",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:241},{level:3,title:"测试：",slug:"测试-3",normalizedTitle:"测试：",charIndex:259}],excerpt:"<Boxx/>\n<p>Spring 的核心容器由两个部分组成：BeanFactory 和 ApplicationContext。BeanFactory 是 Spring 的基础，负责实例化、配置和管理应用程序中的对象。ApplicationContext 是 BeanFactory 的一个更高级别的实现，提供了额外的功能，如国际化、事件传播和Bean预处理。</p>\n",headersStr:"核心容器 DefaultListableBeanFactory 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 实例化 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 属性填充 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试：",content:'Spring 的核心容器由两个部分组成：BeanFactory 和 ApplicationContext。BeanFactory 是 Spring 的基础，负责实例化、配置和管理应用程序中的对象。ApplicationContext 是 BeanFactory 的一个更高级别的实现，提供了额外的功能，如国际化、事件传播和Bean预处理。\n\n\n\n * 核心容器 DefaultListableBeanFactory\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 实例化\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 属性填充\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n设计一个Spring容器需要考虑以下几个方面：\n\n 1. 容器初始化\n\nSpring 容器初始化过程中需要完成的任务包括：读取 XML 配置文件，解析 XML 配置信息，创建 Bean 对象，进行 Bean 之间的依赖注入等。因此，设计一个高效的初始化过程是非常重要的。可以考虑采用单例模式，使用懒加载机制来避免无用的资源浪费。\n\n 2. Bean 的实例化和管理\n\n在设计 Spring 容器时，需要考虑如何管理 Bean 的生命周期，包括 Bean 的实例化、初始化、销毁等。可以使用反射机制来实例化 Bean，使用依赖注入技术来完成 Bean 之间的依赖关系。对于 Bean 的生命周期管理，可以使用 BeanPostProcessor 和 BeanFactoryPostProcessor 等机制。\n\n 3. 依赖注入\n\n依赖注入是 Spring 的核心功能之一，它使得 Bean 之间的关系更加松散。设计一个高效的依赖注入机制是非常重要的。可以考虑使用自动装配机制，根据 Bean 之间的依赖关系自动完成依赖注入。同时，为了避免循环依赖问题，可以使用构造函数注入或者延迟依赖注入等机制。\n\n 4. AOP\n\n面向切面编程（AOP）是Spring的另一个核心功能。在设计 Spring 容器时，需要考虑如何支持 AOP。可以使用代理模式或者字节码增强技术来实现 AOP 功能。同时，为了方便用户使用，可以提供注解或者 XML 配置文件等方式来配置 AOP。\n\n 5. Web 支持\n\nSpring 也提供了 Web 支持，包括 MVC 架构和 RESTful 服务等。在设计 Spring 容器时，需要考虑如何支持 Web 功能。可以使用 Servlet 容器来支持 Web 功能，并提供注解或者 XML 配置文件等方式来配置 Web 功能。\n\n总的来说，设计一个高效、易用、灵活的 Spring 容器需要考虑多个方面，包括容器初始化、Bean 的实例化和管理、依赖注入、AOP 和 Web 支持等。需要根据具体需求来确定设计方案，并不断优化和改进。\n\n\n# 核心容器 DefaultListableBeanFactory\n\n对 Spring 中的核心类：DefaultListableBeanFactory 做一个简单初步的实现：\n\n\n# 定义一些职责和能力：\n\n 1. BeanFactory：提供获取 Bean 的能力；\n\n 2. BeanDefinition：Spring 可以通过 xml 或 注解 的方式加载一个 Bean，但为了更好的扩展，不管从何处加载的 Bean， 最好都统一转换为一个指定对象， 那么就需要定义一个统一的门面对象：BeanDefinition，只要有 BeanDefinition 我们就可以实例化一个 Bean；\n\n 3. SingletonBeanRegistry：提供获取一个 单例Bean 的能力（其实就是通过每个BeanDefinition定义的Class反射获得一个Bean，并缓存起来）；\n\n 4. BeanDefinitionRegistry：提供注册 BeanDefinition 的能力；\n\n\n# 具体的实现：\n\n 1. DefaultSingletonBeanRegistry： implements SingletonBeanRegistry， 实现了 单例Bean 的添加，获取；\n\n 2. AbstractBeanFactory：extends DefaultSingletonBeanRegistry implements BeanFactory， 实现了 getBean(String beanName) 而 getBean(String beanName) 的实现则主要是调用留给子类实现的空方法 createBean(beanName, beanDefinition)；\n\n 3. AbstractAutowireCapableBeanFactory：extends AbstractBeanFactory，实现createBean(beanName, beanDefinition)， 实现通过 BeanDefinition 创建 Bean 的能力；\n\n 4. ★ DefaultListableBeanFactory：extends AbstractAutowireCapableBeanFactory implements BeanDefinitionRegistry， 实现注册 BeanDefinition 的能力，获得一个 Bean 的能力；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic void testDefaultListableBeanFactory(){\n   // DefaultListableBeanFactory 的用法\n   DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();\n   // 1. 注册Bean的能力：将一个普通对象转换为 BeanDefinition，并注册进容器中\n   BeanDefinition beanDefinition=new BeanDefinition(Cat.class);\n   beanFactory.registerBeanDefinition("cat",beanDefinition);\n   // 2. 获取Bean的能力：从容器中获取指定 Bean，第一次获取会示例化并缓存\n   Cat cat=(Cat)beanFactory.getBean("cat");\n   cat.name();\n   // 3. 第二次会直接从单例缓存中获取\n   Cat cat_cache=(Cat)beanFactory.getBean("cat");\n   cat_cache.name();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 实例化\n\n上述方式只支持默认的无参构造实例化 Bean。\n\n\n# 定义一些职责和能力：\n\n 1. InstantiationStrategy：要想容器支持对 Bean的有参构造器 实例化的方式，需要定义一个实例化策略接口 InstantiationStrategy，当然，定义这个 InstantiationStrategy 策略接口也是为了支持不同实例化方式方便扩展。\n\n添加一个实例化方法：Object instantiatie(BeanDefinition beanDefinition, String beanName, Constructor constructor, Object[] args);\n\n一个 Bean 的实例化，需要的基本参数有：\n\n * BeanDefinition：主要保存了一个具体类的定义，主要就是实例化这个类\n * Constructor：通过哪个构造方法实例化\n * args：构造方法的参数\n\n\n# 具体的实现：\n\n * SimpleInstantiationStrategy：JDK 实例化策略\n\n * CglibSubclassingInstantiationStrategy：cglib 实例化策略\n\n\n# 将实现加入原有的逻辑中：\n\n 1. AbstractAutowireCapableBeanFactory：修改 createBean(String beanName, BeanDefinition beanDefinition) 实现，加入支持有参构造的实例化策略 createBeanInstance(beanDefinition, beanName, args);。\n\n\n# 测试：\n\n@Test\npublic void testDefaultListableBeanFactoryGetBeanWithConstructor(){\n   // DefaultListableBeanFactory 的用法\n   DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();\n   // 1. 注册Bean的能力：将一个普通对象转换为 BeanDefinition，并注册进容器中\n   BeanDefinition beanDefinition=new BeanDefinition(Cat.class);\n   beanFactory.registerBeanDefinition("cat",beanDefinition);\n   // 2. 获取Bean的能力：从容器中获取指定 Bean（通过有参构造），第一次获取会示例化并缓存\n   Cat cat=(Cat)beanFactory.getBean("cat","Cat -> Constructor");\n   cat.printName();\n   // 3. 第二次会直接从单例缓存中获取\n   Cat cat_cache=(Cat)beanFactory.getBean("cat");\n   cat_cache.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 属性填充\n\n完成 Bean 的实例化之后，进行 Bean 的属性填充。\n\n\n# 定义一些职责和能力：\n\n * 无\n\n\n# 具体的实现：\n\n 1. PropertyValue：将一个 Bean 本身的 字段名、字段值映射为一个 PropertyValue；\n 2. PropertyValues：当一个 Bean 有多个字段时，将 PropertyValue 保存为一个集合；\n 3. BeanReference：属性填充时可能遇到 Bean 的依赖，A 依赖 B, B 依赖 C, 循环调用实例化，主要解决 Bean依赖 问题的属性填充；\n\n\n# 将实现加入原有的逻辑中：\n\n 1. BeanDefinition：之前只保存了实例化的类型Class（实例化用），现在将 PropertyValues 也填充进去（属性填充用）；\n 2. AbstractAutowireCapableBeanFactory：修改 createBeanInstance(String beanName, BeanDefinition beanDefinition, Object[] args) 加入属性填充步骤 applyPropertyValues(beanName, bean, beanDefinition)；\n\n\n# 测试：\n\n @Test\npublic void testDefaultListableBeanFactoryGetBeanWithApplyPropertyValues(){\n   // DefaultListableBeanFactory 的用法\n   DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();\n   \n   // 1. 注册Bean的能力：将一个普通对象（和属性）转换为 BeanDefinition，并注册进容器中\n   // 注册一个 cat\n   PropertyValues catPropertyValues=new PropertyValues();\n   catPropertyValues.addPropertyValue(new PropertyValue("name","TomCat"));\n   BeanDefinition catBeanDefinition=new BeanDefinition(Cat.class,catPropertyValues);\n   beanFactory.registerBeanDefinition("cat",catBeanDefinition);\n   // 注册一个 dog，dog 依赖 cat\n   PropertyValues dogPropertyValues=new PropertyValues();\n   dogPropertyValues.addPropertyValue(new PropertyValue("name","JjDog"));\n   dogPropertyValues.addPropertyValue(new PropertyValue("cat",new BeanReference("cat")));\n   BeanDefinition dogBeanDefinition=new BeanDefinition(Dog.class,dogPropertyValues);\n   beanFactory.registerBeanDefinition("dog",dogBeanDefinition);\n   \n   // 2. 获取Bean的能力：从容器中获取指定 Bean，第一次获取会示例化并缓存\n   Dog dog=(Dog)beanFactory.getBean("dog");\n   dog.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',normalizedContent:'spring 的核心容器由两个部分组成：beanfactory 和 applicationcontext。beanfactory 是 spring 的基础，负责实例化、配置和管理应用程序中的对象。applicationcontext 是 beanfactory 的一个更高级别的实现，提供了额外的功能，如国际化、事件传播和bean预处理。\n\n\n\n * 核心容器 defaultlistablebeanfactory\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 实例化\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 属性填充\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n设计一个spring容器需要考虑以下几个方面：\n\n 1. 容器初始化\n\nspring 容器初始化过程中需要完成的任务包括：读取 xml 配置文件，解析 xml 配置信息，创建 bean 对象，进行 bean 之间的依赖注入等。因此，设计一个高效的初始化过程是非常重要的。可以考虑采用单例模式，使用懒加载机制来避免无用的资源浪费。\n\n 2. bean 的实例化和管理\n\n在设计 spring 容器时，需要考虑如何管理 bean 的生命周期，包括 bean 的实例化、初始化、销毁等。可以使用反射机制来实例化 bean，使用依赖注入技术来完成 bean 之间的依赖关系。对于 bean 的生命周期管理，可以使用 beanpostprocessor 和 beanfactorypostprocessor 等机制。\n\n 3. 依赖注入\n\n依赖注入是 spring 的核心功能之一，它使得 bean 之间的关系更加松散。设计一个高效的依赖注入机制是非常重要的。可以考虑使用自动装配机制，根据 bean 之间的依赖关系自动完成依赖注入。同时，为了避免循环依赖问题，可以使用构造函数注入或者延迟依赖注入等机制。\n\n 4. aop\n\n面向切面编程（aop）是spring的另一个核心功能。在设计 spring 容器时，需要考虑如何支持 aop。可以使用代理模式或者字节码增强技术来实现 aop 功能。同时，为了方便用户使用，可以提供注解或者 xml 配置文件等方式来配置 aop。\n\n 5. web 支持\n\nspring 也提供了 web 支持，包括 mvc 架构和 restful 服务等。在设计 spring 容器时，需要考虑如何支持 web 功能。可以使用 servlet 容器来支持 web 功能，并提供注解或者 xml 配置文件等方式来配置 web 功能。\n\n总的来说，设计一个高效、易用、灵活的 spring 容器需要考虑多个方面，包括容器初始化、bean 的实例化和管理、依赖注入、aop 和 web 支持等。需要根据具体需求来确定设计方案，并不断优化和改进。\n\n\n# 核心容器 defaultlistablebeanfactory\n\n对 spring 中的核心类：defaultlistablebeanfactory 做一个简单初步的实现：\n\n\n# 定义一些职责和能力：\n\n 1. beanfactory：提供获取 bean 的能力；\n\n 2. beandefinition：spring 可以通过 xml 或 注解 的方式加载一个 bean，但为了更好的扩展，不管从何处加载的 bean， 最好都统一转换为一个指定对象， 那么就需要定义一个统一的门面对象：beandefinition，只要有 beandefinition 我们就可以实例化一个 bean；\n\n 3. singletonbeanregistry：提供获取一个 单例bean 的能力（其实就是通过每个beandefinition定义的class反射获得一个bean，并缓存起来）；\n\n 4. beandefinitionregistry：提供注册 beandefinition 的能力；\n\n\n# 具体的实现：\n\n 1. defaultsingletonbeanregistry： implements singletonbeanregistry， 实现了 单例bean 的添加，获取；\n\n 2. abstractbeanfactory：extends defaultsingletonbeanregistry implements beanfactory， 实现了 getbean(string beanname) 而 getbean(string beanname) 的实现则主要是调用留给子类实现的空方法 createbean(beanname, beandefinition)；\n\n 3. abstractautowirecapablebeanfactory：extends abstractbeanfactory，实现createbean(beanname, beandefinition)， 实现通过 beandefinition 创建 bean 的能力；\n\n 4. ★ defaultlistablebeanfactory：extends abstractautowirecapablebeanfactory implements beandefinitionregistry， 实现注册 beandefinition 的能力，获得一个 bean 的能力；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic void testdefaultlistablebeanfactory(){\n   // defaultlistablebeanfactory 的用法\n   defaultlistablebeanfactory beanfactory=new defaultlistablebeanfactory();\n   // 1. 注册bean的能力：将一个普通对象转换为 beandefinition，并注册进容器中\n   beandefinition beandefinition=new beandefinition(cat.class);\n   beanfactory.registerbeandefinition("cat",beandefinition);\n   // 2. 获取bean的能力：从容器中获取指定 bean，第一次获取会示例化并缓存\n   cat cat=(cat)beanfactory.getbean("cat");\n   cat.name();\n   // 3. 第二次会直接从单例缓存中获取\n   cat cat_cache=(cat)beanfactory.getbean("cat");\n   cat_cache.name();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 实例化\n\n上述方式只支持默认的无参构造实例化 bean。\n\n\n# 定义一些职责和能力：\n\n 1. instantiationstrategy：要想容器支持对 bean的有参构造器 实例化的方式，需要定义一个实例化策略接口 instantiationstrategy，当然，定义这个 instantiationstrategy 策略接口也是为了支持不同实例化方式方便扩展。\n\n添加一个实例化方法：object instantiatie(beandefinition beandefinition, string beanname, constructor constructor, object[] args);\n\n一个 bean 的实例化，需要的基本参数有：\n\n * beandefinition：主要保存了一个具体类的定义，主要就是实例化这个类\n * constructor：通过哪个构造方法实例化\n * args：构造方法的参数\n\n\n# 具体的实现：\n\n * simpleinstantiationstrategy：jdk 实例化策略\n\n * cglibsubclassinginstantiationstrategy：cglib 实例化策略\n\n\n# 将实现加入原有的逻辑中：\n\n 1. abstractautowirecapablebeanfactory：修改 createbean(string beanname, beandefinition beandefinition) 实现，加入支持有参构造的实例化策略 createbeaninstance(beandefinition, beanname, args);。\n\n\n# 测试：\n\n@test\npublic void testdefaultlistablebeanfactorygetbeanwithconstructor(){\n   // defaultlistablebeanfactory 的用法\n   defaultlistablebeanfactory beanfactory=new defaultlistablebeanfactory();\n   // 1. 注册bean的能力：将一个普通对象转换为 beandefinition，并注册进容器中\n   beandefinition beandefinition=new beandefinition(cat.class);\n   beanfactory.registerbeandefinition("cat",beandefinition);\n   // 2. 获取bean的能力：从容器中获取指定 bean（通过有参构造），第一次获取会示例化并缓存\n   cat cat=(cat)beanfactory.getbean("cat","cat -> constructor");\n   cat.printname();\n   // 3. 第二次会直接从单例缓存中获取\n   cat cat_cache=(cat)beanfactory.getbean("cat");\n   cat_cache.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 属性填充\n\n完成 bean 的实例化之后，进行 bean 的属性填充。\n\n\n# 定义一些职责和能力：\n\n * 无\n\n\n# 具体的实现：\n\n 1. propertyvalue：将一个 bean 本身的 字段名、字段值映射为一个 propertyvalue；\n 2. propertyvalues：当一个 bean 有多个字段时，将 propertyvalue 保存为一个集合；\n 3. beanreference：属性填充时可能遇到 bean 的依赖，a 依赖 b, b 依赖 c, 循环调用实例化，主要解决 bean依赖 问题的属性填充；\n\n\n# 将实现加入原有的逻辑中：\n\n 1. beandefinition：之前只保存了实例化的类型class（实例化用），现在将 propertyvalues 也填充进去（属性填充用）；\n 2. abstractautowirecapablebeanfactory：修改 createbeaninstance(string beanname, beandefinition beandefinition, object[] args) 加入属性填充步骤 applypropertyvalues(beanname, bean, beandefinition)；\n\n\n# 测试：\n\n @test\npublic void testdefaultlistablebeanfactorygetbeanwithapplypropertyvalues(){\n   // defaultlistablebeanfactory 的用法\n   defaultlistablebeanfactory beanfactory=new defaultlistablebeanfactory();\n   \n   // 1. 注册bean的能力：将一个普通对象（和属性）转换为 beandefinition，并注册进容器中\n   // 注册一个 cat\n   propertyvalues catpropertyvalues=new propertyvalues();\n   catpropertyvalues.addpropertyvalue(new propertyvalue("name","tomcat"));\n   beandefinition catbeandefinition=new beandefinition(cat.class,catpropertyvalues);\n   beanfactory.registerbeandefinition("cat",catbeandefinition);\n   // 注册一个 dog，dog 依赖 cat\n   propertyvalues dogpropertyvalues=new propertyvalues();\n   dogpropertyvalues.addpropertyvalue(new propertyvalue("name","jjdog"));\n   dogpropertyvalues.addpropertyvalue(new propertyvalue("cat",new beanreference("cat")));\n   beandefinition dogbeandefinition=new beandefinition(dog.class,dogpropertyvalues);\n   beanfactory.registerbeandefinition("dog",dogbeandefinition);\n   \n   // 2. 获取bean的能力：从容器中获取指定 bean，第一次获取会示例化并缓存\n   dog dog=(dog)beanfactory.getbean("dog");\n   dog.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"手写 Spring 02 - 添加外部资源加载器以及和现有容器结合",frontmatter:{title:"手写 Spring 02 - 添加外部资源加载器以及和现有容器结合",date:"2023-02-28T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-02.html",relativePath:"views/backend/spring-source-02.md",key:"v-a2fc25ba",path:"/views/backend/spring-source-02.html",headers:[{level:2,title:"从外部资源加载 Bean",slug:"从外部资源加载-bean",normalizedTitle:"从外部资源加载 bean",charIndex:172},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:190},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:206},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:218},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:236},{level:2,title:"外部资源和现有容器整合",slug:"外部资源和现有容器整合",normalizedTitle:"外部资源和现有容器整合",charIndex:243},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:190},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:206},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:218},{level:3,title:"测试：",slug:"测试-2",normalizedTitle:"测试：",charIndex:236}],excerpt:"<Boxx/>\n<p>添加资源加载接口定义类：Resource，及核心实现：DefaultResourceLoader；</p>\n<p>添加加载Bean定义接口：BeanDefinitionReader，及核心实现xml解析：XmlBeanDefinitionReader</p>\n<p>与现有容器结合：通过构造参数的方式将容器注入到xml加载器中，将加载到资源解析给指定容器</p>\n",headersStr:"从外部资源加载 Bean 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 外部资源和现有容器整合 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试：",content:'添加资源加载接口定义类：Resource，及核心实现：DefaultResourceLoader；\n\n添加加载Bean定义接口：BeanDefinitionReader，及核心实现xml解析：XmlBeanDefinitionReader\n\n与现有容器结合：通过构造参数的方式将容器注入到xml加载器中，将加载到资源解析给指定容器\n\n\n\n * 从外部资源加载 Bean\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 外部资源和现有容器整合\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n\n# 从外部资源加载 Bean\n\n在 Bean 的实例化和属性填充完成后，我们已经可以通过在代码里手动 new 对象的方式实现一个简单的 Bean 容器。\n\n为了方便的从外部配置、加载 Bean，抽取一个工具类可以从不同位置获取 定义 Bean 的配置文件信息。\n\n\n# 定义一些职责和能力：\n\n 1. Resource：InputStream getInputStream() throws IOException; 定义资源接口；\n 2. ResourceLoader：Resource getResource(String location); 定义资源包装接口，根据入参自动匹配相应的资源（Resource）；\n\n\n# 具体的实现：\n\n 1. ClassPathResource：可以从类路径下读取资源；\n 2. FileSystemResource：可以从指定路径或指定文件读取资源；\n 3. UrlResource：可以从指定url读取资源；\n 4. DefaultResourceLoader：根据location自动匹配相应的资源；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic class DefaultResourceLoaderTest {\n\n   private ResourceLoader resourceLoader;\n\n   @Before\n   public void init() {\n      resourceLoader = new DefaultResourceLoader();\n   }\n\n   @Test\n   public void test_classpath() throws IOException {\n      Resource resource = resourceLoader.getResource("classpath:spring.xml");\n      InputStream inputStream = resource.getInputStream();\n      String content = IoUtil.readUtf8(inputStream);\n      System.out.println("===== classpath =====");\n      System.out.println(content);\n      System.out.println("===== classpath =====");\n   }\n\n   @Test\n   public void test_file() throws IOException {\n      Resource resource = resourceLoader.getResource("src/main/resources/spring.xml");\n      InputStream inputStream = resource.getInputStream();\n      String content = IoUtil.readUtf8(inputStream);\n      System.out.println("===== file =====");\n      System.out.println(content);\n      System.out.println("===== file =====");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 外部资源和现有容器整合\n\n从外部资源获取到 Bean 的配置信息后，需要解析配置信息与现有的 Bean 容器结合，增强容器的能力（省去了在代码中手动添加 Bean 的过程）。\n\n\n# 定义一些职责和能力：\n\n 1. BeanDefinitionReader：定义加载Bean定义接口，从各个资源加载为 BeanDefinition；\n\n\n# 具体的实现：\n\n 1. AbstractBeanDefinitionReader：一个抽线类默认实现，主要提供对 getRegistry()、getResourceLoader() 的默认实现，子类只需关心加载Bean定义即可；\n 2. XmlBeanDefinitionReader：从 xml 文件读取 bean，转换为 BeanDefinition，并注册到指定的 BeanDefinitionRegistry （DefaultListableBeanFactory 已经具备了这个能力）；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic class XmlBeanDefinitionReaderTest {\n\n   @Test\n   public void test_xml() {\n      // 核心容器\n      DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n      // 读取 xml 解析为 Bean\n      XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);\n      reader.loadBeanDefinitions("classpath:spring.xml");\n      // 获取指定 Bean\n      Dog dog = (Dog) beanFactory.getBean("dog");\n      dog.printName();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'添加资源加载接口定义类：resource，及核心实现：defaultresourceloader；\n\n添加加载bean定义接口：beandefinitionreader，及核心实现xml解析：xmlbeandefinitionreader\n\n与现有容器结合：通过构造参数的方式将容器注入到xml加载器中，将加载到资源解析给指定容器\n\n\n\n * 从外部资源加载 bean\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 外部资源和现有容器整合\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n\n# 从外部资源加载 bean\n\n在 bean 的实例化和属性填充完成后，我们已经可以通过在代码里手动 new 对象的方式实现一个简单的 bean 容器。\n\n为了方便的从外部配置、加载 bean，抽取一个工具类可以从不同位置获取 定义 bean 的配置文件信息。\n\n\n# 定义一些职责和能力：\n\n 1. resource：inputstream getinputstream() throws ioexception; 定义资源接口；\n 2. resourceloader：resource getresource(string location); 定义资源包装接口，根据入参自动匹配相应的资源（resource）；\n\n\n# 具体的实现：\n\n 1. classpathresource：可以从类路径下读取资源；\n 2. filesystemresource：可以从指定路径或指定文件读取资源；\n 3. urlresource：可以从指定url读取资源；\n 4. defaultresourceloader：根据location自动匹配相应的资源；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic class defaultresourceloadertest {\n\n   private resourceloader resourceloader;\n\n   @before\n   public void init() {\n      resourceloader = new defaultresourceloader();\n   }\n\n   @test\n   public void test_classpath() throws ioexception {\n      resource resource = resourceloader.getresource("classpath:spring.xml");\n      inputstream inputstream = resource.getinputstream();\n      string content = ioutil.readutf8(inputstream);\n      system.out.println("===== classpath =====");\n      system.out.println(content);\n      system.out.println("===== classpath =====");\n   }\n\n   @test\n   public void test_file() throws ioexception {\n      resource resource = resourceloader.getresource("src/main/resources/spring.xml");\n      inputstream inputstream = resource.getinputstream();\n      string content = ioutil.readutf8(inputstream);\n      system.out.println("===== file =====");\n      system.out.println(content);\n      system.out.println("===== file =====");\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 外部资源和现有容器整合\n\n从外部资源获取到 bean 的配置信息后，需要解析配置信息与现有的 bean 容器结合，增强容器的能力（省去了在代码中手动添加 bean 的过程）。\n\n\n# 定义一些职责和能力：\n\n 1. beandefinitionreader：定义加载bean定义接口，从各个资源加载为 beandefinition；\n\n\n# 具体的实现：\n\n 1. abstractbeandefinitionreader：一个抽线类默认实现，主要提供对 getregistry()、getresourceloader() 的默认实现，子类只需关心加载bean定义即可；\n 2. xmlbeandefinitionreader：从 xml 文件读取 bean，转换为 beandefinition，并注册到指定的 beandefinitionregistry （defaultlistablebeanfactory 已经具备了这个能力）；\n\n\n# 将实现加入原有的逻辑中：\n\n * 无\n\n\n# 测试：\n\npublic class xmlbeandefinitionreadertest {\n\n   @test\n   public void test_xml() {\n      // 核心容器\n      defaultlistablebeanfactory beanfactory = new defaultlistablebeanfactory();\n      // 读取 xml 解析为 bean\n      xmlbeandefinitionreader reader = new xmlbeandefinitionreader(beanfactory);\n      reader.loadbeandefinitions("classpath:spring.xml");\n      // 获取指定 bean\n      dog dog = (dog) beanfactory.getbean("dog");\n      dog.printname();\n   }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"手写 Spring 03 - 扩展 Bean 的生命周期",frontmatter:{title:"手写 Spring 03 - 扩展 Bean 的生命周期",date:"2023-03-07T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-03.html",relativePath:"views/backend/spring-source-03.md",key:"v-0754b6a1",path:"/views/backend/spring-source-03.html",headers:[{level:2,title:"在 Bean 的生命周期添加扩展点",slug:"在-bean-的生命周期添加扩展点",normalizedTitle:"在 bean 的生命周期添加扩展点",charIndex:3},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:26},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:42},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:54},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:72}],excerpt:"<Boxx/>\n",headersStr:"在 Bean 的生命周期添加扩展点 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试：",content:' * 在 Bean 的生命周期添加扩展点\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n\n# 在 Bean 的生命周期添加扩展点\n\n\n# 定义一些职责和能力：\n\n 1. BeanFactoryPostProcessor：用于修改 Spring 容器中 BeanDefinition 的扩展点。\n    \n    当 Spring 容器创建 BeanDefinition 之后，但在创建 Bean 实例之前，BeanFactoryPostProcessor 就可以通过实现 postProcessBeanFactory 方法来修改 BeanDefinition 的属性，如修改 Bean 的作用域、添加 Bean 的属性值等。BeanFactoryPostProcessor 的实现类在 Spring 容器启动时就会被调用。\n\n 2. BeanPostProcessor：用于修改 Bean 实例的扩展点。\n    \n    当 Spring 容器创建 Bean 实例之后，但在初始化 Bean 之前，BeanPostProcessor 就可以通过实现 postProcessBeforeInitialization 和 postProcessAfterInitialization 方法来修改 Bean 的属性或执行一些初始化操作。例如，可以为 Bean 添加代理对象、修改属性值、执行 AOP 操作等。BeanPostProcessor 的实现类在 Spring 容器启动时就会被调用，并且会对容器中的每个 Bean 实例都进行处理。\n\n 3. HierarchicalBeanFactory：扩展 BeanFactory 接口，支持父子容器，这里暂时无用。\n\n 4. DefaultSingletonBeanRegistry： implements SingletonBeanRegistry\n    \n    实现了添加和获取单例 Bean 的能力\n\n 5. ConfigurableBeanFactory：extends HierarchicalBeanFactory, SingletonBeanRegistry\n    \n    扩展 BeanFactory 接口，支持设置父级容器、自自定义作用域、添加 BeanPostProcessor 后置处理器、设置 bean 的初始化和销毁回调方法等。\n\n 6. AutowireCapableBeanFactory：扩展 BeanFactory 接口，支持自动装配 Bean 的能力，\n    \n    这里主要添加扩展点 Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName); 作为 初始化前 bean 的前置处理，Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName); 作为 初始化后 bean 的后置处理。\n\n\n# 具体的实现：\n\n 1. AbstractBeanFactory：[主要实现了doGetBean()，添加BeanPostProcessor]\n    \n    extends DefaultSingletonBeanRegistry（已经实现了添加和获取单例 Bean 的能力）\n    \n    implements ConfigurableBeanFactory（添加 BeanPostProcessor 后置处理器）\n    \n    实现：内置一个 List<BeanPostProcessor> 列表，实现了 添加 BeanPostProcessor 和 获取 BeanPostProcessor 的能力。\n\n 2. AbstractAutowireCapableBeanFactory：[真实的doGetBean()调用的createBean(beanName, beanDefinition, args);的过程在这个类里，所以将Bean的扩展点加入到创建Bean的过程中]\n    \n    extends AbstractBeanFactory （已经具备了添加BeanPostProcessor的能力）\n    \n    implements AutowireCapableBeanFactory（实现 bean 的实例化前后置回调）\n    \n    实现：在 createBean() 中，一个 Bean 实例化后进行属性填充，之后加入 Bean 的 init()，在 init() 前后加入 BeanPostProcessor 前后置方法的回调，这样在创建一个 Bean 的时候就加入了 Bean 的生命周期干预。\n\n 3. 对于 BeanFactoryPostProcessor，在测试的时候我们手写一个实现了，手动调用一下即可。（后续加入上下文的时候，在上下文里实现自动调用）\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 如上 AbstractBeanFactory 和 AbstractAutowireCapableBeanFactory\n\n\n# 测试：\n\n * BeanPostProcessor 准备\n\npublic class CatBeanPostProcessor implements BeanPostProcessor {\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        System.out.println("beanName：" + beanName + " 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization");\n        if ("cat".equals(beanName)) {\n            Cat cat = (Cat) bean;\n            return new Cat("postProcessBeforeInitialization name cat");\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        System.out.println("beanName：" + beanName + " 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization");\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * BeanFactoryPostProcessor 准备\n\npublic class DogBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n        System.out.println("进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory");\n        String beanName = "dog";\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n        PropertyValues propertyValues = beanDefinition.getPropertyValues();\n        PropertyValue propertyValue = propertyValues.getPropertyValue("name");\n        String oldValue = String.valueOf(propertyValue.getValue());\n        String updateValue = beanName + "-BeanDefinition-updated";\n        propertyValue.setValue(updateValue);\n        System.out.println("beanName：" + beanName + " 属性：name，原先值：" + oldValue + " 修改后值：" + updateValue);\n        System.out.println();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 外部资源 spring.xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catBEAN" class="com.snail.springframework.beans.factory.support.Cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.Dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.CatBeanPostProcessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.DogBeanFactoryPostProcessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\n@Test\npublic void test_beanFactoryAndPostProcessor() {\n    // 1. 初始化 Bean 工厂\n    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n    // 2. 使用加载器加载xml配置文件，初始化 BeanDefinition\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);\n    reader.loadBeanDefinitions("classpath:spring.xml");\n    \n\t// 3. 添加 BeanDefinition 扩展点，（这里的扩展点是手动调用的）\n    // 在 Bean 实例化前，BeanDefinition 初始化后\n    new DogBeanFactoryPostProcessor().postProcessBeanFactory(beanFactory);\n    // 4. 添加 Bean 扩展点\n    // Bean 初始化前后回调相应方法\n    CatBeanPostProcessor catBeanPostProcessor = new CatBeanPostProcessor();\n    beanFactory.addBeanPostProcessor(catBeanPostProcessor);\n    \n    // 5. 获取bean\n    Dog dog = (Dog) beanFactory.getBean("dog");\n    System.out.println();\n    dog.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 测试结果\n\n进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory\nbeanName：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-BeanDefinition-updated\n\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\n\ndog-BeanDefinition-updated\nCat{name=\'postProcessBeforeInitialization name cat\'}\n{inner-dog2=JerryDog, inner-dog1=TomDog}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:' * 在 bean 的生命周期添加扩展点\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n\n\n\n\n# 在 bean 的生命周期添加扩展点\n\n\n# 定义一些职责和能力：\n\n 1. beanfactorypostprocessor：用于修改 spring 容器中 beandefinition 的扩展点。\n    \n    当 spring 容器创建 beandefinition 之后，但在创建 bean 实例之前，beanfactorypostprocessor 就可以通过实现 postprocessbeanfactory 方法来修改 beandefinition 的属性，如修改 bean 的作用域、添加 bean 的属性值等。beanfactorypostprocessor 的实现类在 spring 容器启动时就会被调用。\n\n 2. beanpostprocessor：用于修改 bean 实例的扩展点。\n    \n    当 spring 容器创建 bean 实例之后，但在初始化 bean 之前，beanpostprocessor 就可以通过实现 postprocessbeforeinitialization 和 postprocessafterinitialization 方法来修改 bean 的属性或执行一些初始化操作。例如，可以为 bean 添加代理对象、修改属性值、执行 aop 操作等。beanpostprocessor 的实现类在 spring 容器启动时就会被调用，并且会对容器中的每个 bean 实例都进行处理。\n\n 3. hierarchicalbeanfactory：扩展 beanfactory 接口，支持父子容器，这里暂时无用。\n\n 4. defaultsingletonbeanregistry： implements singletonbeanregistry\n    \n    实现了添加和获取单例 bean 的能力\n\n 5. configurablebeanfactory：extends hierarchicalbeanfactory, singletonbeanregistry\n    \n    扩展 beanfactory 接口，支持设置父级容器、自自定义作用域、添加 beanpostprocessor 后置处理器、设置 bean 的初始化和销毁回调方法等。\n\n 6. autowirecapablebeanfactory：扩展 beanfactory 接口，支持自动装配 bean 的能力，\n    \n    这里主要添加扩展点 object applybeanpostprocessorsbeforeinitialization(object existingbean, string beanname); 作为 初始化前 bean 的前置处理，object applybeanpostprocessorsafterinitialization(object existingbean, string beanname); 作为 初始化后 bean 的后置处理。\n\n\n# 具体的实现：\n\n 1. abstractbeanfactory：[主要实现了dogetbean()，添加beanpostprocessor]\n    \n    extends defaultsingletonbeanregistry（已经实现了添加和获取单例 bean 的能力）\n    \n    implements configurablebeanfactory（添加 beanpostprocessor 后置处理器）\n    \n    实现：内置一个 list<beanpostprocessor> 列表，实现了 添加 beanpostprocessor 和 获取 beanpostprocessor 的能力。\n\n 2. abstractautowirecapablebeanfactory：[真实的dogetbean()调用的createbean(beanname, beandefinition, args);的过程在这个类里，所以将bean的扩展点加入到创建bean的过程中]\n    \n    extends abstractbeanfactory （已经具备了添加beanpostprocessor的能力）\n    \n    implements autowirecapablebeanfactory（实现 bean 的实例化前后置回调）\n    \n    实现：在 createbean() 中，一个 bean 实例化后进行属性填充，之后加入 bean 的 init()，在 init() 前后加入 beanpostprocessor 前后置方法的回调，这样在创建一个 bean 的时候就加入了 bean 的生命周期干预。\n\n 3. 对于 beanfactorypostprocessor，在测试的时候我们手写一个实现了，手动调用一下即可。（后续加入上下文的时候，在上下文里实现自动调用）\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 如上 abstractbeanfactory 和 abstractautowirecapablebeanfactory\n\n\n# 测试：\n\n * beanpostprocessor 准备\n\npublic class catbeanpostprocessor implements beanpostprocessor {\n\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) {\n        system.out.println("beanname：" + beanname + " 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization");\n        if ("cat".equals(beanname)) {\n            cat cat = (cat) bean;\n            return new cat("postprocessbeforeinitialization name cat");\n        }\n        return bean;\n    }\n\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) {\n        system.out.println("beanname：" + beanname + " 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization");\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * beanfactorypostprocessor 准备\n\npublic class dogbeanfactorypostprocessor implements beanfactorypostprocessor {\n\n    @override\n    public void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) {\n        system.out.println("进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory");\n        string beanname = "dog";\n        beandefinition beandefinition = beanfactory.getbeandefinition(beanname);\n        propertyvalues propertyvalues = beandefinition.getpropertyvalues();\n        propertyvalue propertyvalue = propertyvalues.getpropertyvalue("name");\n        string oldvalue = string.valueof(propertyvalue.getvalue());\n        string updatevalue = beanname + "-beandefinition-updated";\n        propertyvalue.setvalue(updatevalue);\n        system.out.println("beanname：" + beanname + " 属性：name，原先值：" + oldvalue + " 修改后值：" + updatevalue);\n        system.out.println();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 外部资源 spring.xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catbean" class="com.snail.springframework.beans.factory.support.cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.catbeanpostprocessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.dogbeanfactorypostprocessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\n@test\npublic void test_beanfactoryandpostprocessor() {\n    // 1. 初始化 bean 工厂\n    defaultlistablebeanfactory beanfactory = new defaultlistablebeanfactory();\n    // 2. 使用加载器加载xml配置文件，初始化 beandefinition\n    xmlbeandefinitionreader reader = new xmlbeandefinitionreader(beanfactory);\n    reader.loadbeandefinitions("classpath:spring.xml");\n    \n\t// 3. 添加 beandefinition 扩展点，（这里的扩展点是手动调用的）\n    // 在 bean 实例化前，beandefinition 初始化后\n    new dogbeanfactorypostprocessor().postprocessbeanfactory(beanfactory);\n    // 4. 添加 bean 扩展点\n    // bean 初始化前后回调相应方法\n    catbeanpostprocessor catbeanpostprocessor = new catbeanpostprocessor();\n    beanfactory.addbeanpostprocessor(catbeanpostprocessor);\n    \n    // 5. 获取bean\n    dog dog = (dog) beanfactory.getbean("dog");\n    system.out.println();\n    dog.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 测试结果\n\n进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory\nbeanname：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-beandefinition-updated\n\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\n\ndog-beandefinition-updated\ncat{name=\'postprocessbeforeinitialization name cat\'}\n{inner-dog2=jerrydog, inner-dog1=tomdog}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"手写 Spring 05 - 完善Bean生命周期，加入Bean的初始化和销毁",frontmatter:{title:"手写 Spring 05 - 完善Bean生命周期，加入Bean的初始化和销毁",date:"2023-03-27T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-05.html",relativePath:"views/backend/spring-source-05.md",key:"v-8e0b6cc6",path:"/views/backend/spring-source-05.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:639},{level:2,title:"初始化方法实现",slug:"初始化方法实现",normalizedTitle:"初始化方法实现",charIndex:645},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:658},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:674},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:686},{level:2,title:"销毁方法实现",slug:"销毁方法实现",normalizedTitle:"销毁方法实现",charIndex:702},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:658},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:674},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:686},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:760},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:767}],excerpt:"<Boxx/>\n<p>在 Spring 中，Bean 的生命周期由容器管理。当容器启动时，它会读取配置文件并创建 Bean 定义，然后通过这些定义来实例化 Bean。在 Bean 实例化的过程中，会按照一定的顺序调用一些特定的方法来完成 Bean 的初始化和销毁。</p>\n<p>Bean 初始化的方法：</p>\n<ol>\n<li>\n<p>构造方法：在实例化 Bean 时，容器会调用 Bean 的构造方法创建 Bean 的实例。</p>\n</li>\n<li>\n<p>实现 InitializingBean 接口：如果 Bean 实现了 InitializingBean 接口，容器会在 Bean 实例化之后调用它的 afterPropertiesSet() 方法。</p>\n</li>\n<li>\n<p>配置 init-method 属性：在 Bean 配置文件中，可以通过设置 init-method 属性来指定 Bean 初始化时要调用的方法。</p>\n</li>\n</ol>\n<p>Bean 销毁的方法：</p>\n<ol>\n<li>\n<p>实现 DisposableBean 接口：如果 Bean 实现了 DisposableBean 接口，容器在销毁 Bean 之前会调用它的 destroy() 方法。</p>\n</li>\n<li>\n<p>配置 destroy-method 属性：在 Bean 配置文件中，可以通过设置 destroy-method 属性来指定 Bean 销毁时要调用的方法。</p>\n</li>\n</ol>\n<p>需要注意的是，只有在容器正常关闭时，才会触发 Bean 的销毁方法。如果是容器发生异常或者是通过代码强制关闭容器，那么就不会触发 Bean 的销毁方法。</p>\n",headersStr:"解析 初始化方法实现 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 销毁方法实现 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 总结",content:'在 Spring 中，Bean 的生命周期由容器管理。当容器启动时，它会读取配置文件并创建 Bean 定义，然后通过这些定义来实例化 Bean。在 Bean 实例化的过程中，会按照一定的顺序调用一些特定的方法来完成 Bean 的初始化和销毁。\n\nBean 初始化的方法：\n\n 1. 构造方法：在实例化 Bean 时，容器会调用 Bean 的构造方法创建 Bean 的实例。\n\n 2. 实现 InitializingBean 接口：如果 Bean 实现了 InitializingBean 接口，容器会在 Bean 实例化之后调用它的 afterPropertiesSet() 方法。\n\n 3. 配置 init-method 属性：在 Bean 配置文件中，可以通过设置 init-method 属性来指定 Bean 初始化时要调用的方法。\n\nBean 销毁的方法：\n\n 1. 实现 DisposableBean 接口：如果 Bean 实现了 DisposableBean 接口，容器在销毁 Bean 之前会调用它的 destroy() 方法。\n\n 2. 配置 destroy-method 属性：在 Bean 配置文件中，可以通过设置 destroy-method 属性来指定 Bean 销毁时要调用的方法。\n\n需要注意的是，只有在容器正常关闭时，才会触发 Bean 的销毁方法。如果是容器发生异常或者是通过代码强制关闭容器，那么就不会触发 Bean 的销毁方法。\n\n\n\n * 解析\n * 初始化方法实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 销毁方法实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 解析\n\n这里我们对于 xml 方式实现，主要是在配置一个 Bean 的时候指定 init-method 和 destroy-method 两个属性值即可。\n\n在通过加载器扫描 xml，解析为 Bean 定义的时候，将这 2 个值带上。然在 AbstractAutowireCapableBeanFactory.createdBean() 的时候，调用 Bean 的初始化和销毁方法即可。\n\n而销毁方法的调用需向虚拟机注册一个钩子函数，使虚拟机在执行关闭之前回调。\n\n\n# 初始化方法实现\n\n要加入 Bean 生命周期的初始化，我们知道肯定得再创建 Bean 的时候修改加入初始化的逻辑。\n\n无非就是先在 xml 中配置 init-method 方法，然后加载到 Bean 定义中（所以肯定要修改 BeanDefinition），然后在 AbstractAutowireCapableBeanFactory.createBean(String beanName, BeanDefinition beanDefinition, Object[] args) 的时候，在 Bean 进行实例化及属性填充后，读取 BeanDefinition 加载这个初始化方法。\n\n销毁方法的调用比较特殊，得在容器关闭的时候调用，我们稍后再分析。\n\n\n# 定义一些职责和能力：\n\n 1. 修改 BeanDefinition ：加入两个属性，用来保存具体是初始化和销毁的哪个方法名。\n\nprivate String initMethodName;\nprivate String destroyMethodName;\n\n\n1\n2\n\n\n\n# 具体的实现：\n\n 1. 修改 xml 加载器：XmlBeanDefinitionReader，使之解析新加的标签属性 init-method 和 destroy-method，并将解析后的值设置到 BeanDefinition 中。\n    \n    <bean id="cat" name="catBEAN" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.support.Cat">\n    \n    \n    1\n    2\n    \n    \n    修改 XmlBeanDefinitionReader 的 doLoadBeanDefinitions(InputStream inputStream)\n    \n    // 新加关键行代码\n    String initMethod = bean.getAttribute("init-method");\n    String destroyMethod = bean.getAttribute("destroy-method");\n    beanDefinition.setInitMethodName(initMethod);\n    beanDefinition.setDestroyMethodName(destroyMethod);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. AbstractAutowireCapableBeanFactory\n    \n    private void invokeInitMethods(String beanName, Object bean, BeanDefinition beanDefinition) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {\n        String initMethodName = beanDefinition.getInitMethodName();\n        if (StrUtil.isNotBlank(initMethodName)) {\n            Method initMethod = beanDefinition.getBeanClass().getMethod(initMethodName);\n            if (initMethod == null) {\n                throw new BeansException("Could not found an init method name: " + initMethodName);\n            }\n            initMethod.invoke(bean);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    主要实现了 invokeInitMethods() 这个核心方法。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 AbstractAutowireCapableBeanFactory，在 Bean 实例化及属性填充后，加入初始化方法的调用：\n    \n    /**\n     * 创建 Bean\n     */\n    @Override\n    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n        Object bean = null;\n        try {\n            // 实例化\n            bean = createBeanInstance(beanName, beanDefinition, args);\n            // 属性填充\n            applyPropertyValues(beanName, bean, beanDefinition);\n            // 添加 Bean 的初始化扩展\n            bean = initializeBean(beanName, bean, beanDefinition);\n        } catch (Exception e) {\n            throw new BeansException("Failed to bean instance", e);\n        }\n        addSingleton(beanName, bean);\n        return bean;\n    }\n    \n    private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) {\n        // 前置处理\n        Object wrappedBean = applyBeanPostProcessorsBeforeInitialization(bean, beanName);\n        // ** 在这个一步，调用上面实现的初始化方法 **\n        try {\n            invokeInitMethods(beanName, wrappedBean, beanDefinition);\n        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {\n            throw new BeansException("Failed to bean init", e);\n        }\n        // 后置处理\n        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n        return wrappedBean;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    \n    \n    这样就把初始化加入到了 Bean 的创建中。\n\n\n# 销毁方法实现\n\n销毁方法的调用比较特殊，在 Spring 容器关闭时，会触发销毁所有 bean 的过程。\n\n销毁方法的配置方式：\n\n 1. 跟初始化方法一样，可以在 xml 中配置 destroy-method 方法。\n 2. 为了更好的扩展，我们可以定义接口，只要一个 Bean 实现了相应的初始化或销毁接口，就可以在容器中自动调用相应的实现方法。\n 3. 注解方式，我们现在赞不讨论。\n\n\n# 定义一些职责和能力：\n\n 1. InitializingBean ：如果 bean 实现了 InitializingBean 接口，容器会调用它的 afterPropertiesSet() 方法，完成 bean 的初始化。如果 bean 没有实现 InitializingBean 接口，容器会调用配置文件中指定的初始化方法（如果有）。\n\n 2. DisposableBean：如果 bean 实现了 DisposableBean 接口，容器会调用它的 destroy() 方法，完成 bean 的销毁。如果 bean 没有实现 DisposableBean 接口，容器会调用配置文件中指定的销毁方法（如果有）。\n\n 3. SingletonBeanRegistry：之前已经提供过获取一个单例 Bean 的能力。这里再加上\n    \n    注册待销毁的单例对象的能力：void registerDisposableBean(String beanName, DisposableBean bean);\n    \n    销毁所有单例 Bean 的能力：void destroySingletons();。\n\n 4. ConfigurableApplicationContext\n    \n    extendsApplicationContext\n    \n    ConfigurableApplicationContext是Spring框架中ApplicationContext接口的一个扩展接口，它提供了一些额外的方法，例如refresh()：刷新容器，registerShutdownHook()：注册关闭钩子函数，和close()：关闭函数，用于配置和管理应用程序上下文的生命周期和属性。\n\n\n# 具体的实现：\n\n 1. DisposableBeanAdapter：实现了 DisposableBean 接口，并将其委托给一个实际的bean实例来执行销毁操作。这个适配类的出现主要是为了解决在虚拟机关闭的时候不想关注到底是哪种（xml或接口或注解）方式的销毁，由此出现这个适配类。\n    \n    public class DispoableBeanAdapter implements DisposableBean {\n    \n        private final Object bean;\n        private final String beanName;\n        private final String destroyMethodName;\n    \n        public DispoableBeanAdapter(Object bean, String beanName, BeanDefinition beanDefinition) {\n            this.bean = bean;\n            this.beanName = beanName;\n            this.destroyMethodName = beanDefinition.getDestroyMethodName();\n        }\n    \n        @Override\n        public void destroy() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n            // 1. 实现接口的方式调用\n            if (bean instanceof DisposableBean) {\n                ((DisposableBean) bean).destroy();\n            }\n            // 2. xml 方式反射调用初始化方法\n            if (StrUtil.isNotBlank(destroyMethodName) && !(bean instanceof DisposableBean)) {\n                Method destroyMethod = bean.getClass().getMethod(destroyMethodName);\n                if (destroyMethod == null) {\n                    throw new BeansException("Could not found an init method name: " + destroyMethodName);\n                }\n                destroyMethod.invoke(bean);\n            }\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 2. DefaultSingletonBeanRegistry\n    \n    implements SingletonBeanRegistry\n    \n    主要实现 registerDisposableBean(String beanName, DisposableBean bean); 和 void destroySingletons();\n    \n    public class DefaultSingletonBeanRegistry implements SingletonBeanRegistry {\n    \n        private final Map<String, Object> singletonObjects = new HashMap<>();\n    \n        private final Map<String, DisposableBean> disposableBeans = new HashMap<>();\n    \n        @Override\n        public Object getSingleton(String beanName) {\n            return singletonObjects.get(beanName);\n        }\n    \n        protected void addSingleton(String beanName, Object singletonObject) {\n            singletonObjects.put(beanName, singletonObject);\n        }\n    \n        @Override\n        public void registerDisposableBean(String beanName, DisposableBean bean) {\n            disposableBeans.put(beanName, bean);\n        }\n    \n        @Override\n        public void destroySingletons() {\n            Set<String> keySet = disposableBeans.keySet();\n            Object[] disposableBeanNames = keySet.toArray();\n            for (int i = disposableBeanNames.length - 1; i >= 0; i--) {\n                Object beanName = disposableBeanNames[i];\n                DisposableBean disposableBean = disposableBeans.remove(beanName);\n                try {\n                    disposableBean.destroy();\n                } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n                    throw new BeansException("Failed to bean:[" + beanName + "] destroy", e);\n                }\n            }\n    \n        }\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n\n 3. 在 AbstractAutowireCapableBeanFactory\n    \n    extends AbstractBeanFactory （它又 extends DefaultSingletonBeanRegistry，已经具备了注册待销毁的Bean的能力）\n    \n    implements AutowireCapableBeanFactory\n    \n    Bean实例化、属性填充、初始化（Bean的前后置处理）之后，注册所有实现了 DisposableBean 接口的 Bean 对象，留待容器停止的时候调用。\n    \n        protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException {\n            Object bean = null;\n            try {\n                // 实例化\n                bean = createBeanInstance(beanName, beanDefinition, args);\n                // 属性填充\n                applyPropertyValues(beanName, bean, beanDefinition);\n                // 添加 Bean 的初始化扩展\n                bean = initializeBean(beanName, bean, beanDefinition);\n            } catch (Exception e) {\n                throw new BeansException("Failed to bean instance", e);\n            }\n            // 注册所有实现了 DisposableBean 接口的 Bean 对象，留待容器停止的时候调用。\n            registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);\n            // 添加单例 Bean 缓存\n            addSingleton(beanName, bean);\n            return bean;\n        }\n    \n        protected void registerDisposableBeanIfNecessary(String beanName, Object bean, BeanDefinition beanDefinition) {\n            if (bean instanceof DisposableBean || StrUtil.isNotBlank(beanDefinition.getDestroyMethodName())) {\n                registerDisposableBean(beanName, new DispoableBeanAdapter(bean, beanName, beanDefinition));\n            }\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    主要实现了 registerDisposableBeanIfNecessary() 这个方法。\n\n 4. AbstractApplicationContext\n    \n    extends DefaultResourceLoader\n    \n    implements ConfigurableApplicationContext （需要实现注册虚拟机关闭钩子函数和关闭容器的方法）\n    \n        /** refresh()在之前已经实现 */\n    \t@Override\n        public void refresh() {\n            // 1. 创建 Bean 工厂，加载 BeanDefinition\n            refreshBeanFactory();\n    \n            // 2. 获得 Bean 工厂\n            ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    \n            // 3. BeanDefinition 扩展点：\n            // Spring 容器中 BeanDefinition 的扩展点。\n            // 创建 BeanDefinition 之后，但在创建 Bean 实例之前。\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 4. Bean 扩展点：\n            // 提前注册所有的 BeanPostProcessor，在 Bean 创建后，初始化时扩展\n            // （见 AbstractAutowireCapableBeanFactory.createBean ）。\n            registerBeanPostProcessors(beanFactory);\n    \n            // 5. 提前实例化所有的单例 Bean\n            beanFactory.preInstantiateSingletons();\n        }\n    \n        @Override\n        public void registerShutdownHook() {\n            Runtime.getRuntime().addShutdownHook(new Thread(this::close));\n        }\n    \n        @Override\n        public void close() {\n            getBeanFactory().destroySingletons();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n\n# 将实现加入原有的逻辑中：\n\n 1. 总结就是先定义了两个接口 InitializingBean 和 DisposableBean，实现他们就具备了相应的能力。\n 2. 在 创建 Bean 的时候调用所有初始化方法。\n 3. 因为虚拟机关闭时不想关系具体销毁的实现，所有加了个 DisposableBean 包装所有的销毁方式。\n 4. Bean 工厂得具备销毁的能力，所以得有注册和销毁的方法。在 SingletonBeanRegistry 定义：注册所有的待销毁实例+销毁所有可销毁的Bean（就是看有没有实现DisposableBean接口或xml指定销毁方法，有就提前存起来），而 DefaultSingletonBeanRegistry 就是对这两个能力的实现。\n 5. 容器得具备销毁的能力（实际就是调用 Bean 工厂的销毁），在 ConfigurableApplicationContext 定义了 refresh()：刷新容器，registerShutdownHook()：注册关闭钩子函数，和close()：关闭函数。而 AbstractApplicationContext 就是对它的实现（调用 Bean 工厂的销毁方法）。\n\n\n# 测试：\n\n * xml 准备，这里 cat 采用 xml 的方式实现 init 和 destroy。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catBEAN" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.support.Cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.Dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.CatBeanPostProcessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.DogBeanFactoryPostProcessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * Dog 准备，实现接口的方式\n\npublic class Dog implements InitializingBean, DisposableBean {\n\n    private String name;\n\n    private Cat cat;\n\n    private static Map<String, Object> initMap = new HashMap<>();\n\n    static {\n        initMap.put("inner-dog1", "TomDog");\n        initMap.put("inner-dog2", "JerryDog");\n    }\n\n    @Override\n    public void afterPropertiedSet() {\n        System.out.println("-- Dog afterPropertiedSet method by xml --");\n    }\n\n    @Override\n    public void destroy() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        System.out.println("-- Dog destroy method by xml --");\n    }\n\n    public void printName() {\n        System.out.println(this.name);\n        System.out.println(this.cat);\n        System.out.println(initMap);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Cat getCat() {\n        return cat;\n    }\n\n    public void setCat(Cat cat) {\n        this.cat = cat;\n    }\n\n    @Override\n    public String toString() {\n        return "Dog{" +\n                "name=\'" + name + \'\\\'\' +\n                ", cat=" + cat +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n * 测试类\n\n    @Test\n    public void test_xml_context_close() {\n        // 1. 利用 xml上下文 加载Bean\n        // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring.xml");\n        // * 可以提前注册 JVM 关闭钩子，用来确保 Spring 容器在 JVM 关闭之前正确地关闭并释放所有资源。\n        applicationContext.registerShutdownHook();\n        // 2. 获取bean\n        Dog dog = (Dog) applicationContext.getBean("dog");\n\n        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();\n        System.out.println();\n        System.out.println(JSONUtil.toJsonStr(beanDefinitionNames));\n        System.out.println();\n        dog.printName();\n        // * close 和 registerShutdownHook 比，比较暴力，直接手动调用关闭\n        // applicationContext.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 测试结果\n\n进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory\nbeanName：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-BeanDefinition-updated\n\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\n-- Cat init method by xml --\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\n-- Dog afterPropertiedSet method by interface --\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\n\n["cat","catBeanPostProcessor","dog","dogBeanFactoryPostProcessor"]\n\ndog-BeanDefinition-updated\nCat{name=\'postProcessBeforeInitialization name cat\'}\n{inner-dog2=JerryDog, inner-dog1=TomDog}\n-- Dog destroy method by interface --\n-- Cat destroy method by xml --\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\nSpring Bean 的初始化和销毁是指在 Spring 容器管理下的 Bean 对象在被实例化和使用前、以及在容器关闭时，分别会执行一些特定的方法，以完成一些必要的操作。下面是关于 Spring Bean 初始化和销毁的总结：\n\n 1. 初始化方法：\n\n在 Spring 容器创建 Bean 时，可以通过指定一些特定的初始化方法来对 Bean 进行初始化。Spring 提供了以下三种方式：\n\n * 通过实现 InitializingBean 接口来自定义初始化方法；\n * 通过在Bean配置文件中定义 init-method 属性来指定初始化方法；\n * 通过 @PostConstruct 注解来定义初始化方法。\n\n 1. 销毁方法：\n\n在 Spring 容器关闭时，需要对一些资源进行清理或释放，这时可以通过指定一些特定的销毁方法来完成。Spring 提供了以下两种方式：\n\n * 通过实现 DisposableBean 接口来自定义销毁方法；\n * 通过在Bean配置文件中定义 destroy-method 属性来指定销毁方法。\n\n需要注意的是，只有当 Bean 被 Spring 容器管理时，才能够执行初始化和销毁方法。如果 Bean 不是由 Spring 容器管理，则不会执行初始化和销毁方法。\n\n此外，Spring 还提供了一种通过 Java 注解来管理 Bean 的生命周期的方式，即通过 @PreDestroy 注解来定义Bean的作用域和销毁方法。\n\n总之，Spring Bean 的初始化和销毁方法可以通过实现特定接口、指定特定属性或使用注解来实现。在实际应用中，需要根据具体的业务需求和场景来选择合适的方式来管理Bean的生命周期。',normalizedContent:'在 spring 中，bean 的生命周期由容器管理。当容器启动时，它会读取配置文件并创建 bean 定义，然后通过这些定义来实例化 bean。在 bean 实例化的过程中，会按照一定的顺序调用一些特定的方法来完成 bean 的初始化和销毁。\n\nbean 初始化的方法：\n\n 1. 构造方法：在实例化 bean 时，容器会调用 bean 的构造方法创建 bean 的实例。\n\n 2. 实现 initializingbean 接口：如果 bean 实现了 initializingbean 接口，容器会在 bean 实例化之后调用它的 afterpropertiesset() 方法。\n\n 3. 配置 init-method 属性：在 bean 配置文件中，可以通过设置 init-method 属性来指定 bean 初始化时要调用的方法。\n\nbean 销毁的方法：\n\n 1. 实现 disposablebean 接口：如果 bean 实现了 disposablebean 接口，容器在销毁 bean 之前会调用它的 destroy() 方法。\n\n 2. 配置 destroy-method 属性：在 bean 配置文件中，可以通过设置 destroy-method 属性来指定 bean 销毁时要调用的方法。\n\n需要注意的是，只有在容器正常关闭时，才会触发 bean 的销毁方法。如果是容器发生异常或者是通过代码强制关闭容器，那么就不会触发 bean 的销毁方法。\n\n\n\n * 解析\n * 初始化方法实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 销毁方法实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 解析\n\n这里我们对于 xml 方式实现，主要是在配置一个 bean 的时候指定 init-method 和 destroy-method 两个属性值即可。\n\n在通过加载器扫描 xml，解析为 bean 定义的时候，将这 2 个值带上。然在 abstractautowirecapablebeanfactory.createdbean() 的时候，调用 bean 的初始化和销毁方法即可。\n\n而销毁方法的调用需向虚拟机注册一个钩子函数，使虚拟机在执行关闭之前回调。\n\n\n# 初始化方法实现\n\n要加入 bean 生命周期的初始化，我们知道肯定得再创建 bean 的时候修改加入初始化的逻辑。\n\n无非就是先在 xml 中配置 init-method 方法，然后加载到 bean 定义中（所以肯定要修改 beandefinition），然后在 abstractautowirecapablebeanfactory.createbean(string beanname, beandefinition beandefinition, object[] args) 的时候，在 bean 进行实例化及属性填充后，读取 beandefinition 加载这个初始化方法。\n\n销毁方法的调用比较特殊，得在容器关闭的时候调用，我们稍后再分析。\n\n\n# 定义一些职责和能力：\n\n 1. 修改 beandefinition ：加入两个属性，用来保存具体是初始化和销毁的哪个方法名。\n\nprivate string initmethodname;\nprivate string destroymethodname;\n\n\n1\n2\n\n\n\n# 具体的实现：\n\n 1. 修改 xml 加载器：xmlbeandefinitionreader，使之解析新加的标签属性 init-method 和 destroy-method，并将解析后的值设置到 beandefinition 中。\n    \n    <bean id="cat" name="catbean" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.support.cat">\n    \n    \n    1\n    2\n    \n    \n    修改 xmlbeandefinitionreader 的 doloadbeandefinitions(inputstream inputstream)\n    \n    // 新加关键行代码\n    string initmethod = bean.getattribute("init-method");\n    string destroymethod = bean.getattribute("destroy-method");\n    beandefinition.setinitmethodname(initmethod);\n    beandefinition.setdestroymethodname(destroymethod);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. abstractautowirecapablebeanfactory\n    \n    private void invokeinitmethods(string beanname, object bean, beandefinition beandefinition) throws invocationtargetexception, illegalaccessexception, nosuchmethodexception {\n        string initmethodname = beandefinition.getinitmethodname();\n        if (strutil.isnotblank(initmethodname)) {\n            method initmethod = beandefinition.getbeanclass().getmethod(initmethodname);\n            if (initmethod == null) {\n                throw new beansexception("could not found an init method name: " + initmethodname);\n            }\n            initmethod.invoke(bean);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    主要实现了 invokeinitmethods() 这个核心方法。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 abstractautowirecapablebeanfactory，在 bean 实例化及属性填充后，加入初始化方法的调用：\n    \n    /**\n     * 创建 bean\n     */\n    @override\n    protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n        object bean = null;\n        try {\n            // 实例化\n            bean = createbeaninstance(beanname, beandefinition, args);\n            // 属性填充\n            applypropertyvalues(beanname, bean, beandefinition);\n            // 添加 bean 的初始化扩展\n            bean = initializebean(beanname, bean, beandefinition);\n        } catch (exception e) {\n            throw new beansexception("failed to bean instance", e);\n        }\n        addsingleton(beanname, bean);\n        return bean;\n    }\n    \n    private object initializebean(string beanname, object bean, beandefinition beandefinition) {\n        // 前置处理\n        object wrappedbean = applybeanpostprocessorsbeforeinitialization(bean, beanname);\n        // ** 在这个一步，调用上面实现的初始化方法 **\n        try {\n            invokeinitmethods(beanname, wrappedbean, beandefinition);\n        } catch (invocationtargetexception | illegalaccessexception | nosuchmethodexception e) {\n            throw new beansexception("failed to bean init", e);\n        }\n        // 后置处理\n        wrappedbean = applybeanpostprocessorsafterinitialization(wrappedbean, beanname);\n        return wrappedbean;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    \n    \n    这样就把初始化加入到了 bean 的创建中。\n\n\n# 销毁方法实现\n\n销毁方法的调用比较特殊，在 spring 容器关闭时，会触发销毁所有 bean 的过程。\n\n销毁方法的配置方式：\n\n 1. 跟初始化方法一样，可以在 xml 中配置 destroy-method 方法。\n 2. 为了更好的扩展，我们可以定义接口，只要一个 bean 实现了相应的初始化或销毁接口，就可以在容器中自动调用相应的实现方法。\n 3. 注解方式，我们现在赞不讨论。\n\n\n# 定义一些职责和能力：\n\n 1. initializingbean ：如果 bean 实现了 initializingbean 接口，容器会调用它的 afterpropertiesset() 方法，完成 bean 的初始化。如果 bean 没有实现 initializingbean 接口，容器会调用配置文件中指定的初始化方法（如果有）。\n\n 2. disposablebean：如果 bean 实现了 disposablebean 接口，容器会调用它的 destroy() 方法，完成 bean 的销毁。如果 bean 没有实现 disposablebean 接口，容器会调用配置文件中指定的销毁方法（如果有）。\n\n 3. singletonbeanregistry：之前已经提供过获取一个单例 bean 的能力。这里再加上\n    \n    注册待销毁的单例对象的能力：void registerdisposablebean(string beanname, disposablebean bean);\n    \n    销毁所有单例 bean 的能力：void destroysingletons();。\n\n 4. configurableapplicationcontext\n    \n    extendsapplicationcontext\n    \n    configurableapplicationcontext是spring框架中applicationcontext接口的一个扩展接口，它提供了一些额外的方法，例如refresh()：刷新容器，registershutdownhook()：注册关闭钩子函数，和close()：关闭函数，用于配置和管理应用程序上下文的生命周期和属性。\n\n\n# 具体的实现：\n\n 1. disposablebeanadapter：实现了 disposablebean 接口，并将其委托给一个实际的bean实例来执行销毁操作。这个适配类的出现主要是为了解决在虚拟机关闭的时候不想关注到底是哪种（xml或接口或注解）方式的销毁，由此出现这个适配类。\n    \n    public class dispoablebeanadapter implements disposablebean {\n    \n        private final object bean;\n        private final string beanname;\n        private final string destroymethodname;\n    \n        public dispoablebeanadapter(object bean, string beanname, beandefinition beandefinition) {\n            this.bean = bean;\n            this.beanname = beanname;\n            this.destroymethodname = beandefinition.getdestroymethodname();\n        }\n    \n        @override\n        public void destroy() throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n            // 1. 实现接口的方式调用\n            if (bean instanceof disposablebean) {\n                ((disposablebean) bean).destroy();\n            }\n            // 2. xml 方式反射调用初始化方法\n            if (strutil.isnotblank(destroymethodname) && !(bean instanceof disposablebean)) {\n                method destroymethod = bean.getclass().getmethod(destroymethodname);\n                if (destroymethod == null) {\n                    throw new beansexception("could not found an init method name: " + destroymethodname);\n                }\n                destroymethod.invoke(bean);\n            }\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 2. defaultsingletonbeanregistry\n    \n    implements singletonbeanregistry\n    \n    主要实现 registerdisposablebean(string beanname, disposablebean bean); 和 void destroysingletons();\n    \n    public class defaultsingletonbeanregistry implements singletonbeanregistry {\n    \n        private final map<string, object> singletonobjects = new hashmap<>();\n    \n        private final map<string, disposablebean> disposablebeans = new hashmap<>();\n    \n        @override\n        public object getsingleton(string beanname) {\n            return singletonobjects.get(beanname);\n        }\n    \n        protected void addsingleton(string beanname, object singletonobject) {\n            singletonobjects.put(beanname, singletonobject);\n        }\n    \n        @override\n        public void registerdisposablebean(string beanname, disposablebean bean) {\n            disposablebeans.put(beanname, bean);\n        }\n    \n        @override\n        public void destroysingletons() {\n            set<string> keyset = disposablebeans.keyset();\n            object[] disposablebeannames = keyset.toarray();\n            for (int i = disposablebeannames.length - 1; i >= 0; i--) {\n                object beanname = disposablebeannames[i];\n                disposablebean disposablebean = disposablebeans.remove(beanname);\n                try {\n                    disposablebean.destroy();\n                } catch (nosuchmethodexception | invocationtargetexception | illegalaccessexception e) {\n                    throw new beansexception("failed to bean:[" + beanname + "] destroy", e);\n                }\n            }\n    \n        }\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n\n 3. 在 abstractautowirecapablebeanfactory\n    \n    extends abstractbeanfactory （它又 extends defaultsingletonbeanregistry，已经具备了注册待销毁的bean的能力）\n    \n    implements autowirecapablebeanfactory\n    \n    bean实例化、属性填充、初始化（bean的前后置处理）之后，注册所有实现了 disposablebean 接口的 bean 对象，留待容器停止的时候调用。\n    \n        protected object createbean(string beanname, beandefinition beandefinition, object[] args) throws beansexception {\n            object bean = null;\n            try {\n                // 实例化\n                bean = createbeaninstance(beanname, beandefinition, args);\n                // 属性填充\n                applypropertyvalues(beanname, bean, beandefinition);\n                // 添加 bean 的初始化扩展\n                bean = initializebean(beanname, bean, beandefinition);\n            } catch (exception e) {\n                throw new beansexception("failed to bean instance", e);\n            }\n            // 注册所有实现了 disposablebean 接口的 bean 对象，留待容器停止的时候调用。\n            registerdisposablebeanifnecessary(beanname, bean, beandefinition);\n            // 添加单例 bean 缓存\n            addsingleton(beanname, bean);\n            return bean;\n        }\n    \n        protected void registerdisposablebeanifnecessary(string beanname, object bean, beandefinition beandefinition) {\n            if (bean instanceof disposablebean || strutil.isnotblank(beandefinition.getdestroymethodname())) {\n                registerdisposablebean(beanname, new dispoablebeanadapter(bean, beanname, beandefinition));\n            }\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    主要实现了 registerdisposablebeanifnecessary() 这个方法。\n\n 4. abstractapplicationcontext\n    \n    extends defaultresourceloader\n    \n    implements configurableapplicationcontext （需要实现注册虚拟机关闭钩子函数和关闭容器的方法）\n    \n        /** refresh()在之前已经实现 */\n    \t@override\n        public void refresh() {\n            // 1. 创建 bean 工厂，加载 beandefinition\n            refreshbeanfactory();\n    \n            // 2. 获得 bean 工厂\n            configurablelistablebeanfactory beanfactory = getbeanfactory();\n    \n            // 3. beandefinition 扩展点：\n            // spring 容器中 beandefinition 的扩展点。\n            // 创建 beandefinition 之后，但在创建 bean 实例之前。\n            invokebeanfactorypostprocessors(beanfactory);\n    \n            // 4. bean 扩展点：\n            // 提前注册所有的 beanpostprocessor，在 bean 创建后，初始化时扩展\n            // （见 abstractautowirecapablebeanfactory.createbean ）。\n            registerbeanpostprocessors(beanfactory);\n    \n            // 5. 提前实例化所有的单例 bean\n            beanfactory.preinstantiatesingletons();\n        }\n    \n        @override\n        public void registershutdownhook() {\n            runtime.getruntime().addshutdownhook(new thread(this::close));\n        }\n    \n        @override\n        public void close() {\n            getbeanfactory().destroysingletons();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n\n# 将实现加入原有的逻辑中：\n\n 1. 总结就是先定义了两个接口 initializingbean 和 disposablebean，实现他们就具备了相应的能力。\n 2. 在 创建 bean 的时候调用所有初始化方法。\n 3. 因为虚拟机关闭时不想关系具体销毁的实现，所有加了个 disposablebean 包装所有的销毁方式。\n 4. bean 工厂得具备销毁的能力，所以得有注册和销毁的方法。在 singletonbeanregistry 定义：注册所有的待销毁实例+销毁所有可销毁的bean（就是看有没有实现disposablebean接口或xml指定销毁方法，有就提前存起来），而 defaultsingletonbeanregistry 就是对这两个能力的实现。\n 5. 容器得具备销毁的能力（实际就是调用 bean 工厂的销毁），在 configurableapplicationcontext 定义了 refresh()：刷新容器，registershutdownhook()：注册关闭钩子函数，和close()：关闭函数。而 abstractapplicationcontext 就是对它的实现（调用 bean 工厂的销毁方法）。\n\n\n# 测试：\n\n * xml 准备，这里 cat 采用 xml 的方式实现 init 和 destroy。\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catbean" init-method="init" destroy-method="destroy"\n          class="com.snail.springframework.beans.factory.support.cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.catbeanpostprocessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.dogbeanfactorypostprocessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * dog 准备，实现接口的方式\n\npublic class dog implements initializingbean, disposablebean {\n\n    private string name;\n\n    private cat cat;\n\n    private static map<string, object> initmap = new hashmap<>();\n\n    static {\n        initmap.put("inner-dog1", "tomdog");\n        initmap.put("inner-dog2", "jerrydog");\n    }\n\n    @override\n    public void afterpropertiedset() {\n        system.out.println("-- dog afterpropertiedset method by xml --");\n    }\n\n    @override\n    public void destroy() throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n        system.out.println("-- dog destroy method by xml --");\n    }\n\n    public void printname() {\n        system.out.println(this.name);\n        system.out.println(this.cat);\n        system.out.println(initmap);\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public cat getcat() {\n        return cat;\n    }\n\n    public void setcat(cat cat) {\n        this.cat = cat;\n    }\n\n    @override\n    public string tostring() {\n        return "dog{" +\n                "name=\'" + name + \'\\\'\' +\n                ", cat=" + cat +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n * 测试类\n\n    @test\n    public void test_xml_context_close() {\n        // 1. 利用 xml上下文 加载bean\n        // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring.xml");\n        // * 可以提前注册 jvm 关闭钩子，用来确保 spring 容器在 jvm 关闭之前正确地关闭并释放所有资源。\n        applicationcontext.registershutdownhook();\n        // 2. 获取bean\n        dog dog = (dog) applicationcontext.getbean("dog");\n\n        string[] beandefinitionnames = applicationcontext.getbeandefinitionnames();\n        system.out.println();\n        system.out.println(jsonutil.tojsonstr(beandefinitionnames));\n        system.out.println();\n        dog.printname();\n        // * close 和 registershutdownhook 比，比较暴力，直接手动调用关闭\n        // applicationcontext.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 测试结果\n\n进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory\nbeanname：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-beandefinition-updated\n\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\n-- cat init method by xml --\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\n-- dog afterpropertiedset method by interface --\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\n\n["cat","catbeanpostprocessor","dog","dogbeanfactorypostprocessor"]\n\ndog-beandefinition-updated\ncat{name=\'postprocessbeforeinitialization name cat\'}\n{inner-dog2=jerrydog, inner-dog1=tomdog}\n-- dog destroy method by interface --\n-- cat destroy method by xml --\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\nspring bean 的初始化和销毁是指在 spring 容器管理下的 bean 对象在被实例化和使用前、以及在容器关闭时，分别会执行一些特定的方法，以完成一些必要的操作。下面是关于 spring bean 初始化和销毁的总结：\n\n 1. 初始化方法：\n\n在 spring 容器创建 bean 时，可以通过指定一些特定的初始化方法来对 bean 进行初始化。spring 提供了以下三种方式：\n\n * 通过实现 initializingbean 接口来自定义初始化方法；\n * 通过在bean配置文件中定义 init-method 属性来指定初始化方法；\n * 通过 @postconstruct 注解来定义初始化方法。\n\n 1. 销毁方法：\n\n在 spring 容器关闭时，需要对一些资源进行清理或释放，这时可以通过指定一些特定的销毁方法来完成。spring 提供了以下两种方式：\n\n * 通过实现 disposablebean 接口来自定义销毁方法；\n * 通过在bean配置文件中定义 destroy-method 属性来指定销毁方法。\n\n需要注意的是，只有当 bean 被 spring 容器管理时，才能够执行初始化和销毁方法。如果 bean 不是由 spring 容器管理，则不会执行初始化和销毁方法。\n\n此外，spring 还提供了一种通过 java 注解来管理 bean 的生命周期的方式，即通过 @predestroy 注解来定义bean的作用域和销毁方法。\n\n总之，spring bean 的初始化和销毁方法可以通过实现特定接口、指定特定属性或使用注解来实现。在实际应用中，需要根据具体的业务需求和场景来选择合适的方式来管理bean的生命周期。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"手写 Spring 04 - 加入上下文，预加载容器操作",frontmatter:{title:"手写 Spring 04 - 加入上下文，预加载容器操作",date:"2023-03-19T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-04.html",relativePath:"views/backend/spring-source-04.md",key:"v-6027801f",path:"/views/backend/spring-source-04.html",headers:[{level:2,title:"加入上下文",slug:"加入上下文",normalizedTitle:"加入上下文",charIndex:586},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:597},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:613},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:625},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:643},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:650}],excerpt:"<Boxx/>\n<p>Spring 上下文（Context）和 BeanFactory 是 Spring 框架中的两个重要概念，它们之间存在继承关系。</p>\n<p>BeanFactory 是 Spring 框架中最基本的容器，它是一个用于管理 Bean 实例的工厂。在 Spring 中，BeanFactory 提供了一些基本的功能，例如 Bean 的创建、配置、生命周期管理等。但是，BeanFactory 的功能相对较为简单，只有在使用时才会进行 Bean 的创建和初始化。</p>\n<p>Spring 上下文则是在 BeanFactory 的基础上扩展而来的，它提供了更多的高级功能，例如国际化、AOP、事件发布等。与 BeanFactory 不同，<strong>Spring 上下文在启动时会一次性创建并初始化所有的 Bean 实例</strong>，这样可以提高应用程序的启动速度和运行效率。同时，Spring 上下文还提供了更多的扩展点，使得可以在运行时动态地加载和卸载 Bean 定义、注册和取消注册 BeanFactory 后置处理器和应用程序监听器等。</p>\n<p>因此，Spring 上下文可以看作是 BeanFactory 的一个扩展，它在 BeanFactory 的基础上添加了更多的高级功能和扩展点。在实际应用中，通常使用 Spring 上下文来管理 Bean 实例和配置信息，而不是直接使用 BeanFactory。</p>\n",headersStr:"加入上下文 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 总结",content:'Spring 上下文（Context）和 BeanFactory 是 Spring 框架中的两个重要概念，它们之间存在继承关系。\n\nBeanFactory 是 Spring 框架中最基本的容器，它是一个用于管理 Bean 实例的工厂。在 Spring 中，BeanFactory 提供了一些基本的功能，例如 Bean 的创建、配置、生命周期管理等。但是，BeanFactory 的功能相对较为简单，只有在使用时才会进行 Bean 的创建和初始化。\n\nSpring 上下文则是在 BeanFactory 的基础上扩展而来的，它提供了更多的高级功能，例如国际化、AOP、事件发布等。与 BeanFactory 不同，Spring 上下文在启动时会一次性创建并初始化所有的 Bean 实例，这样可以提高应用程序的启动速度和运行效率。同时，Spring 上下文还提供了更多的扩展点，使得可以在运行时动态地加载和卸载 Bean 定义、注册和取消注册 BeanFactory 后置处理器和应用程序监听器等。\n\n因此，Spring 上下文可以看作是 BeanFactory 的一个扩展，它在 BeanFactory 的基础上添加了更多的高级功能和扩展点。在实际应用中，通常使用 Spring 上下文来管理 Bean 实例和配置信息，而不是直接使用 BeanFactory。\n\n\n\n * 加入上下文\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 加入上下文\n\n\n# 定义一些职责和能力：\n\n 1. ListableBeanFactory：扩展 BeanFactory 接口，支持获取多个 Bean 或者与获取多个 Bean 相关的能力。\n    \n    根据类型获取 Spring 容器中所有对应类型的 Bean 实例：<T> Map<String, T> getBeansOfType(Class<T> type);\n    \n    获取 Spring 容器中所有 BeanDefinition 的名称：String[] getBeanDefinitionNames();\n\n 2. ApplicationContext：\n    \n     extends ListableBeanFactory\n    \n    \n    1\n    \n    \n    容器顶层接口，与 BeanFactory 不同，ApplicationContext 在容器启动时会一次性创建并初始化所有的 Bean 实例，而不是在使用时再进行创建。这意味着，ApplicationContext 在应用程序启动时会更快地启动和准备好，同时也减少了在运行时创建 Bean 实例的开销。此外，ApplicationContext 还提供了更多的特性，例如事件发布、国际化、AOP 等。\n    \n    这里我们只定义，留空不做任何处理。\n\n 3. ConfigurableApplicationContext\n    \n     extends ApplicationContext\n    \n    \n    1\n    \n    \n    扩展了 ApplicationContext 的功能，在这里定义了大名鼎鼎的刷新 refresh() 功能，另外，ConfigurableApplicationContext 还提供了一些工具方法，例如获取系统环境变量、获取资源、获取 Bean 类型、启动和关闭容器等。\n\n 4. ConfigurableListableBeanFactory\n    \n     extends ListableBeanFactory,// 可获取多个 Bean \n            AutowireCapableBeanFactory, // BeanPostProcessor 的前后置处理\n            ConfigurableBeanFactory // 添加 BeanPostProcessor\n    \n    \n    1\n    2\n    3\n    \n    \n    这里我们主要定义了预实例化所有单例 bean 的能力：void preInstantiateSingletons();\n\n\n# 具体的实现：\n\n 1. AbstractApplicationContext\n    \n    extends DefaultResourceLoader // 获得了资源加载器的能力\n    implements ConfigurableApplicationContext {\n        @Override\n        public void refresh() {\n            // 1. 创建 Bean 工厂，加载 BeanDefinition\n            refreshBeanFactory();\n    \n            // 2. 获得 Bean 工厂\n            ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    \n            // 3. BeanDefinition 扩展点：\n            // Spring 容器中 BeanDefinition 的扩展点。\n            // 创建 BeanDefinition 之后，但在创建 Bean 实例之前。\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 4. Bean 扩展点：\n            // 提前注册所有的 BeanPostProcessor，在 Bean 创建后，初始化时扩展\n            //（见 AbstractAutowireCapableBeanFactory.createBean ）。\n            registerBeanPostProcessors(beanFactory);\n    \n            // 5. 提前实例化所有的单例 Bean\n            beanFactory.preInstantiateSingletons();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    主要实现了 refresh() 这个核心方法。\n\n 2. AbstractRefreshableApplicationiContext\n    \n     extends AbstractApplicationContext\n    \n    \n    1\n    \n    \n    主要实现了 refreshBeanFactory()，这个方法中创建了默认的容器 DefaultListableBeanFactory，同时在创建容器后向容器中加载Bean定义：loadBeanDefinitions(DefaultListableBeanFactory beanFactory)，留给子类实现。\n\n 3. AbstractXmlApplicationContext\n    \n     extends AbstractRefreshableApplicationiContext\n    \n    \n    1\n    \n    \n    主要实现了从指定资源位置加载 Bean 定义： loadBeanDefinitions(DefaultListableBeanFactory beanFactory)\n    \n    同时留作获取资源位置： getConfigLocations(); 给子类实现。\n\n 4. ClassPathXmlApplicationContext：\n    \n    extends AbstractXmlApplicationContext\n    \n    \n    1\n    \n    \n    ClassPathXmlApplicationContext 上下文是 Bean 工厂的高级实现，将复杂的 xml 的加载、解析，Bean 的注册、实例化、属性填充、生命周期扩展等进行融合，让我们对 Bean 的管理更加简单易用。\n    \n    实现通过构造参数的方式new ClassPathXmlApplicationContext("classpath:spring.xml");赋值给 getConfigLocations() 来实现资源位置的获取。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 可以看到，refresh() 默认创建的容器是 DefaultListableBeanFactory，而 refresh() 中弟 5 步：提前实例化所有的单例 Bean，这个是之前 DefaultListableBeanFactory 这个容器所不具备的能力。修改 DefaultListableBeanFactory：\n    \n    extends AbstractAutowireCapableBeanFactory // 具备真正创建bean实例化、属性填充、BeanPostProcessor前后置扩展的能力\n        implements BeanDefinitionRegistry, // 之前 DefaultListableBeanFactory 已经实现了 注册 BeanDefinition 相关的能力\n    \tConfigurableListableBeanFactory // 新添加 要实现的功能：预实例化所有单例 Bean\n    {\n    \tprivate final Map<String, BeanDefinition> beanDefinitionMap = new HashMap<>();\n        @Override\n        public void preInstantiateSingletons() {\n            beanDefinitionMap.keySet().forEach(this::getBean);\n        }\n        @Override\n        public <T> Map<String, T> getBeansOfType(Class<T> type) {\n            HashMap<String, T> result = new HashMap<>();\n            beanDefinitionMap.forEach((beanName, beanDefinition) -> {\n                Class<?> beanClass = beanDefinition.getBeanClass();\n                if (type.isAssignableFrom(beanClass)) {\n                    result.put(beanName, (T) getBean(beanName));\n                }\n            });\n            return result;\n        }\n        @Override\n        public String[] getBeanDefinitionNames() {\n            return beanDefinitionMap.keySet().toArray(new String[0]);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    因为在 XmlBeanDefinitionReader 资源加载的时候，会将所有的 BeanDefinition 注册到容器 DefaultListableBeanFactory，所以在这里只需将所有 BeanDefinition 遍历去构建 Bean 即可。\n\n\n# 测试：\n\n * BeanPostProcessor 准备\n\npublic class CatBeanPostProcessor implements BeanPostProcessor {\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) {\n        System.out.println("beanName：" + beanName + " 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization");\n        if ("cat".equals(beanName)) {\n            Cat cat = (Cat) bean;\n            return new Cat("postProcessBeforeInitialization name cat");\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) {\n        System.out.println("beanName：" + beanName + " 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization");\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * BeanFactoryPostProcessor 准备\n\npublic class DogBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n        System.out.println("进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory");\n        String beanName = "dog";\n        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n        PropertyValues propertyValues = beanDefinition.getPropertyValues();\n        PropertyValue propertyValue = propertyValues.getPropertyValue("name");\n        String oldValue = String.valueOf(propertyValue.getValue());\n        String updateValue = beanName + "-BeanDefinition-updated";\n        propertyValue.setValue(updateValue);\n        System.out.println("beanName：" + beanName + " 属性：name，原先值：" + oldValue + " 修改后值：" + updateValue);\n        System.out.println();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 外部资源 spring.xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catBEAN" class="com.snail.springframework.beans.factory.support.Cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.Dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.CatBeanPostProcessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.DogBeanFactoryPostProcessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\n之前使用容器的测试类：\n\n@Test\npublic void test_beanFactoryAndPostProcessor() {\n    // 1. 初始化 Bean 工厂\n    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();\n    // 2. 使用加载器加载xml配置文件，初始化 BeanDefinition\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);\n    reader.loadBeanDefinitions("classpath:spring.xml");\n    \n\t// 3. 添加 BeanDefinition 扩展点，（这里的扩展点是手动调用的）\n    // 在 Bean 实例化前，BeanDefinition 初始化后\n    new DogBeanFactoryPostProcessor().postProcessBeanFactory(beanFactory);\n    // 4. 添加 Bean 扩展点\n    // Bean 初始化前后回调相应方法\n    CatBeanPostProcessor catBeanPostProcessor = new CatBeanPostProcessor();\n    beanFactory.addBeanPostProcessor(catBeanPostProcessor);\n    \n    // 5. 获取bean\n    Dog dog = (Dog) beanFactory.getBean("dog");\n    System.out.println();\n    dog.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n使用上下文后的测试类，可以看到相比之前已经有了极大的便利性：\n\n@Test\npublic void test_xml_context() {\n    // 1. 利用 xml上下文 加载Bean\n    // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n    ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring.xml");\n    // 2. 获取bean\n    Dog dog = (Dog) applicationContext.getBean("dog");\n\n    String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();\n    System.out.println();\n    System.out.println(JSONUtil.toJsonStr(beanDefinitionNames));\n    System.out.println();\n    dog.printName();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 测试结果\n\n进入到 BeanDefinition 扩展点 BeanFactoryPostProcessor -> postProcessBeanFactory\nbeanName：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-BeanDefinition-updated\n\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\nbeanName：cat 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessBeforeInitialization\nbeanName：dog 进入到 Bean 扩展点 BeanPostProcessor -> postProcessAfterInitialization\n\n["cat","catBeanPostProcessor","dog","dogBeanFactoryPostProcessor"]\n\ndog-BeanDefinition-updated\nCat{name=\'postProcessBeforeInitialization name cat\'}\n{inner-dog2=JerryDog, inner-dog1=TomDog}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 总结\n\n总结，Spring 上下文（Context）相对于 BeanFactory 有以下优势：\n\n 1. 预加载：BeanFactory 在容器启动时并不会实例化所有的 Bean，而是在需要时才进行实例化。相反，Spring 上下文会在容器启动时一次性创建并初始化所有的 Bean 实例。这样可以加快应用程序的启动速度，减少应用程序的资源消耗。\n 2. 自动装配：Spring 上下文支持自动装配，可以根据类型或名称自动注入 Bean 实例，而 BeanFactory 需要手动配置依赖注入关系。\n 3. 高级特性：Spring 上下文提供了更多的高级特性，例如 AOP、事务、国际化、事件发布等。而 BeanFactory 只提供了基本的 Bean 创建和管理功能。\n 4. 扩展性：Spring 上下文是在 BeanFactory 的基础上扩展而来的，它提供了更多的扩展点，使得可以在运行时动态地加载和卸载 Bean 定义、注册和取消注册 BeanFactory 后置处理器和应用程序监听器等。\n 5. 代码简洁性：Spring 上下文可以将多个 BeanFactory 集成到一个上下文中，从而简化了代码的编写和维护。\n\n综上所述，相对于 BeanFactory，Spring 上下文提供了更多的高级特性和扩展点，同时也具有更高的预加载性能和自动装配能力。因此，在实际应用中，通常使用 Spring 上下文来管理 Bean 实例和配置信息。',normalizedContent:'spring 上下文（context）和 beanfactory 是 spring 框架中的两个重要概念，它们之间存在继承关系。\n\nbeanfactory 是 spring 框架中最基本的容器，它是一个用于管理 bean 实例的工厂。在 spring 中，beanfactory 提供了一些基本的功能，例如 bean 的创建、配置、生命周期管理等。但是，beanfactory 的功能相对较为简单，只有在使用时才会进行 bean 的创建和初始化。\n\nspring 上下文则是在 beanfactory 的基础上扩展而来的，它提供了更多的高级功能，例如国际化、aop、事件发布等。与 beanfactory 不同，spring 上下文在启动时会一次性创建并初始化所有的 bean 实例，这样可以提高应用程序的启动速度和运行效率。同时，spring 上下文还提供了更多的扩展点，使得可以在运行时动态地加载和卸载 bean 定义、注册和取消注册 beanfactory 后置处理器和应用程序监听器等。\n\n因此，spring 上下文可以看作是 beanfactory 的一个扩展，它在 beanfactory 的基础上添加了更多的高级功能和扩展点。在实际应用中，通常使用 spring 上下文来管理 bean 实例和配置信息，而不是直接使用 beanfactory。\n\n\n\n * 加入上下文\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\n\n# 加入上下文\n\n\n# 定义一些职责和能力：\n\n 1. listablebeanfactory：扩展 beanfactory 接口，支持获取多个 bean 或者与获取多个 bean 相关的能力。\n    \n    根据类型获取 spring 容器中所有对应类型的 bean 实例：<t> map<string, t> getbeansoftype(class<t> type);\n    \n    获取 spring 容器中所有 beandefinition 的名称：string[] getbeandefinitionnames();\n\n 2. applicationcontext：\n    \n     extends listablebeanfactory\n    \n    \n    1\n    \n    \n    容器顶层接口，与 beanfactory 不同，applicationcontext 在容器启动时会一次性创建并初始化所有的 bean 实例，而不是在使用时再进行创建。这意味着，applicationcontext 在应用程序启动时会更快地启动和准备好，同时也减少了在运行时创建 bean 实例的开销。此外，applicationcontext 还提供了更多的特性，例如事件发布、国际化、aop 等。\n    \n    这里我们只定义，留空不做任何处理。\n\n 3. configurableapplicationcontext\n    \n     extends applicationcontext\n    \n    \n    1\n    \n    \n    扩展了 applicationcontext 的功能，在这里定义了大名鼎鼎的刷新 refresh() 功能，另外，configurableapplicationcontext 还提供了一些工具方法，例如获取系统环境变量、获取资源、获取 bean 类型、启动和关闭容器等。\n\n 4. configurablelistablebeanfactory\n    \n     extends listablebeanfactory,// 可获取多个 bean \n            autowirecapablebeanfactory, // beanpostprocessor 的前后置处理\n            configurablebeanfactory // 添加 beanpostprocessor\n    \n    \n    1\n    2\n    3\n    \n    \n    这里我们主要定义了预实例化所有单例 bean 的能力：void preinstantiatesingletons();\n\n\n# 具体的实现：\n\n 1. abstractapplicationcontext\n    \n    extends defaultresourceloader // 获得了资源加载器的能力\n    implements configurableapplicationcontext {\n        @override\n        public void refresh() {\n            // 1. 创建 bean 工厂，加载 beandefinition\n            refreshbeanfactory();\n    \n            // 2. 获得 bean 工厂\n            configurablelistablebeanfactory beanfactory = getbeanfactory();\n    \n            // 3. beandefinition 扩展点：\n            // spring 容器中 beandefinition 的扩展点。\n            // 创建 beandefinition 之后，但在创建 bean 实例之前。\n            invokebeanfactorypostprocessors(beanfactory);\n    \n            // 4. bean 扩展点：\n            // 提前注册所有的 beanpostprocessor，在 bean 创建后，初始化时扩展\n            //（见 abstractautowirecapablebeanfactory.createbean ）。\n            registerbeanpostprocessors(beanfactory);\n    \n            // 5. 提前实例化所有的单例 bean\n            beanfactory.preinstantiatesingletons();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    主要实现了 refresh() 这个核心方法。\n\n 2. abstractrefreshableapplicationicontext\n    \n     extends abstractapplicationcontext\n    \n    \n    1\n    \n    \n    主要实现了 refreshbeanfactory()，这个方法中创建了默认的容器 defaultlistablebeanfactory，同时在创建容器后向容器中加载bean定义：loadbeandefinitions(defaultlistablebeanfactory beanfactory)，留给子类实现。\n\n 3. abstractxmlapplicationcontext\n    \n     extends abstractrefreshableapplicationicontext\n    \n    \n    1\n    \n    \n    主要实现了从指定资源位置加载 bean 定义： loadbeandefinitions(defaultlistablebeanfactory beanfactory)\n    \n    同时留作获取资源位置： getconfiglocations(); 给子类实现。\n\n 4. classpathxmlapplicationcontext：\n    \n    extends abstractxmlapplicationcontext\n    \n    \n    1\n    \n    \n    classpathxmlapplicationcontext 上下文是 bean 工厂的高级实现，将复杂的 xml 的加载、解析，bean 的注册、实例化、属性填充、生命周期扩展等进行融合，让我们对 bean 的管理更加简单易用。\n    \n    实现通过构造参数的方式new classpathxmlapplicationcontext("classpath:spring.xml");赋值给 getconfiglocations() 来实现资源位置的获取。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 可以看到，refresh() 默认创建的容器是 defaultlistablebeanfactory，而 refresh() 中弟 5 步：提前实例化所有的单例 bean，这个是之前 defaultlistablebeanfactory 这个容器所不具备的能力。修改 defaultlistablebeanfactory：\n    \n    extends abstractautowirecapablebeanfactory // 具备真正创建bean实例化、属性填充、beanpostprocessor前后置扩展的能力\n        implements beandefinitionregistry, // 之前 defaultlistablebeanfactory 已经实现了 注册 beandefinition 相关的能力\n    \tconfigurablelistablebeanfactory // 新添加 要实现的功能：预实例化所有单例 bean\n    {\n    \tprivate final map<string, beandefinition> beandefinitionmap = new hashmap<>();\n        @override\n        public void preinstantiatesingletons() {\n            beandefinitionmap.keyset().foreach(this::getbean);\n        }\n        @override\n        public <t> map<string, t> getbeansoftype(class<t> type) {\n            hashmap<string, t> result = new hashmap<>();\n            beandefinitionmap.foreach((beanname, beandefinition) -> {\n                class<?> beanclass = beandefinition.getbeanclass();\n                if (type.isassignablefrom(beanclass)) {\n                    result.put(beanname, (t) getbean(beanname));\n                }\n            });\n            return result;\n        }\n        @override\n        public string[] getbeandefinitionnames() {\n            return beandefinitionmap.keyset().toarray(new string[0]);\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    因为在 xmlbeandefinitionreader 资源加载的时候，会将所有的 beandefinition 注册到容器 defaultlistablebeanfactory，所以在这里只需将所有 beandefinition 遍历去构建 bean 即可。\n\n\n# 测试：\n\n * beanpostprocessor 准备\n\npublic class catbeanpostprocessor implements beanpostprocessor {\n\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) {\n        system.out.println("beanname：" + beanname + " 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization");\n        if ("cat".equals(beanname)) {\n            cat cat = (cat) bean;\n            return new cat("postprocessbeforeinitialization name cat");\n        }\n        return bean;\n    }\n\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) {\n        system.out.println("beanname：" + beanname + " 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization");\n        return bean;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * beanfactorypostprocessor 准备\n\npublic class dogbeanfactorypostprocessor implements beanfactorypostprocessor {\n\n    @override\n    public void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) {\n        system.out.println("进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory");\n        string beanname = "dog";\n        beandefinition beandefinition = beanfactory.getbeandefinition(beanname);\n        propertyvalues propertyvalues = beandefinition.getpropertyvalues();\n        propertyvalue propertyvalue = propertyvalues.getpropertyvalue("name");\n        string oldvalue = string.valueof(propertyvalue.getvalue());\n        string updatevalue = beanname + "-beandefinition-updated";\n        propertyvalue.setvalue(updatevalue);\n        system.out.println("beanname：" + beanname + " 属性：name，原先值：" + oldvalue + " 修改后值：" + updatevalue);\n        system.out.println();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 外部资源 spring.xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n\n<beans>\n    <bean id="cat" name="catbean" class="com.snail.springframework.beans.factory.support.cat">\n        <property name="name" value="cat-name-xml-init"></property>\n    </bean>\n    <bean id="dog" class="com.snail.springframework.beans.factory.support.dog">\n        <property name="name" value="dog-name-xml-init"></property>\n        <property name="cat" ref="cat"></property>\n    </bean>\n\n    \x3c!--  添加扩展点相关类  --\x3e\n    <bean class="com.snail.springframework.beans.factory.support.catbeanpostprocessor"/>\n    <bean class="com.snail.springframework.beans.factory.support.dogbeanfactorypostprocessor"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 测试类\n\n之前使用容器的测试类：\n\n@test\npublic void test_beanfactoryandpostprocessor() {\n    // 1. 初始化 bean 工厂\n    defaultlistablebeanfactory beanfactory = new defaultlistablebeanfactory();\n    // 2. 使用加载器加载xml配置文件，初始化 beandefinition\n    xmlbeandefinitionreader reader = new xmlbeandefinitionreader(beanfactory);\n    reader.loadbeandefinitions("classpath:spring.xml");\n    \n\t// 3. 添加 beandefinition 扩展点，（这里的扩展点是手动调用的）\n    // 在 bean 实例化前，beandefinition 初始化后\n    new dogbeanfactorypostprocessor().postprocessbeanfactory(beanfactory);\n    // 4. 添加 bean 扩展点\n    // bean 初始化前后回调相应方法\n    catbeanpostprocessor catbeanpostprocessor = new catbeanpostprocessor();\n    beanfactory.addbeanpostprocessor(catbeanpostprocessor);\n    \n    // 5. 获取bean\n    dog dog = (dog) beanfactory.getbean("dog");\n    system.out.println();\n    dog.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n使用上下文后的测试类，可以看到相比之前已经有了极大的便利性：\n\n@test\npublic void test_xml_context() {\n    // 1. 利用 xml上下文 加载bean\n    // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n    classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring.xml");\n    // 2. 获取bean\n    dog dog = (dog) applicationcontext.getbean("dog");\n\n    string[] beandefinitionnames = applicationcontext.getbeandefinitionnames();\n    system.out.println();\n    system.out.println(jsonutil.tojsonstr(beandefinitionnames));\n    system.out.println();\n    dog.printname();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 测试结果\n\n进入到 beandefinition 扩展点 beanfactorypostprocessor -> postprocessbeanfactory\nbeanname：dog 属性：name，原先值：dog-name-xml-init 修改后值：dog-beandefinition-updated\n\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\nbeanname：cat 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessbeforeinitialization\nbeanname：dog 进入到 bean 扩展点 beanpostprocessor -> postprocessafterinitialization\n\n["cat","catbeanpostprocessor","dog","dogbeanfactorypostprocessor"]\n\ndog-beandefinition-updated\ncat{name=\'postprocessbeforeinitialization name cat\'}\n{inner-dog2=jerrydog, inner-dog1=tomdog}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 总结\n\n总结，spring 上下文（context）相对于 beanfactory 有以下优势：\n\n 1. 预加载：beanfactory 在容器启动时并不会实例化所有的 bean，而是在需要时才进行实例化。相反，spring 上下文会在容器启动时一次性创建并初始化所有的 bean 实例。这样可以加快应用程序的启动速度，减少应用程序的资源消耗。\n 2. 自动装配：spring 上下文支持自动装配，可以根据类型或名称自动注入 bean 实例，而 beanfactory 需要手动配置依赖注入关系。\n 3. 高级特性：spring 上下文提供了更多的高级特性，例如 aop、事务、国际化、事件发布等。而 beanfactory 只提供了基本的 bean 创建和管理功能。\n 4. 扩展性：spring 上下文是在 beanfactory 的基础上扩展而来的，它提供了更多的扩展点，使得可以在运行时动态地加载和卸载 bean 定义、注册和取消注册 beanfactory 后置处理器和应用程序监听器等。\n 5. 代码简洁性：spring 上下文可以将多个 beanfactory 集成到一个上下文中，从而简化了代码的编写和维护。\n\n综上所述，相对于 beanfactory，spring 上下文提供了更多的高级特性和扩展点，同时也具有更高的预加载性能和自动装配能力。因此，在实际应用中，通常使用 spring 上下文来管理 bean 实例和配置信息。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"手写 Spring 06 - Aware扩展，感知容器各个组件",frontmatter:{title:"手写 Spring 06 - Aware扩展，感知容器各个组件",date:"2023-04-19T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring-source-06.html",relativePath:"views/backend/spring-source-06.md",key:"v-11cd131b",path:"/views/backend/spring-source-06.html",headers:[{level:2,title:"解析",slug:"解析",normalizedTitle:"解析",charIndex:338},{level:2,title:"容器 Aware 实现",slug:"容器-aware-实现",normalizedTitle:"容器 aware 实现",charIndex:344},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力",normalizedTitle:"定义一些职责和能力：",charIndex:361},{level:3,title:"具体的实现：",slug:"具体的实现",normalizedTitle:"具体的实现：",charIndex:377},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:389},{level:2,title:"上下文 Aware 实现",slug:"上下文-aware-实现",normalizedTitle:"上下文 aware 实现",charIndex:405},{level:3,title:"定义一些职责和能力：",slug:"定义一些职责和能力-2",normalizedTitle:"定义一些职责和能力：",charIndex:361},{level:3,title:"具体的实现：",slug:"具体的实现-2",normalizedTitle:"具体的实现：",charIndex:377},{level:3,title:"将实现加入原有的逻辑中：",slug:"将实现加入原有的逻辑中-2",normalizedTitle:"将实现加入原有的逻辑中：",charIndex:389},{level:3,title:"测试：",slug:"测试",normalizedTitle:"测试：",charIndex:469},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:476}],excerpt:"<Boxx/>\n<p>Spring Aware 接口是一个标记接口，实现该接口的 Bean 可以访问 Spring 的核心组件 ApplicationContext 或其他特定的 Spring 框架对象。</p>\n<p>这些组件包括 BeanFactory、ResourceLoader、ApplicationEventPublisher 等等。</p>\n<p>实现该接口的 bean 需要实现 setApplicationContext() 方法，并在该方法中将 ApplicationContext 或其他 Spring 框架对象注入到该 bean 中。通过实现 Spring Aware 接口，bean 可以获取 Spring 容器中的其他 bean 和资源，从而更好地利用 Spring 框架的功能。</p>\n",headersStr:"解析 容器 Aware 实现 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 上下文 Aware 实现 定义一些职责和能力： 具体的实现： 将实现加入原有的逻辑中： 测试： 总结",content:'Spring Aware 接口是一个标记接口，实现该接口的 Bean 可以访问 Spring 的核心组件 ApplicationContext 或其他特定的 Spring 框架对象。\n\n这些组件包括 BeanFactory、ResourceLoader、ApplicationEventPublisher 等等。\n\n实现该接口的 bean 需要实现 setApplicationContext() 方法，并在该方法中将 ApplicationContext 或其他 Spring 框架对象注入到该 bean 中。通过实现 Spring Aware 接口，bean 可以获取 Spring 容器中的其他 bean 和资源，从而更好地利用 Spring 框架的功能。\n\n\n\n * 解析\n * 容器 Aware 实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 上下文 Aware 实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\nSpring Aware 接口有多个子接口，分别对应不同的 Spring 框架对象和功能。比如：\n\n 1. BeanNameAware：实现该接口的 bean 可以获取自己在容器中的 Bean 名称。\n\n 2. BeanFactoryAware：实现该接口的 bean 可以获取 BeanFactory（即Spring容器）对象。\n\n 3. ApplicationContextAware：实现该接口的 bean 可以获取 ApplicationContext 对象，从而可以访问 Spring 容器中的其他 bean、资源和配置信息。\n\n 4. MessageSourceAware：实现该接口的 bean 可以获取 MessageSource 对象，用于国际化处理。\n\n 5. ApplicationEventPublisherAware：实现该接口的 bean 可以获取 ApplicationEventPublisher 对象，用于发布应用程序事件。\n\n 6. ResourceLoaderAware：实现该接口的 bean 可以获取 ResourceLoader 对象，用于加载外部资源文件。\n\n通过实现这些 Spring Aware 接口，bean 可以更加灵活地使用 Spring 框架提供的各种功能和资源，同时也增强了与 Spring 框架的集成能力。\n\n\n# 解析\n\nAware 是如何在 Spring 中实现的呢：在 Spring 中，Aware 接口的实现是通过 BeanPostProcessor 机制来实现的。\n\n当 Spring 容器创建一个 bean 时，会在 bean 的生命周期中调用 BeanPostProcessor 接口中的两个方法 postProcessBeforeInitialization() 和 postProcessAfterInitialization() 。如果一个 bean 实现了某个 Aware 接口， BeanPostProcessor 会检测到该 bean，并调用对应的 setXxx() 方法来注入相应的 Spring 组件。\n\n比如，实现 ApplicationContextAware 接口的 bean，在 postProcessBeforeInitialization() 方法中会调用其 setApplicationContext() 方法，并将 ApplicationContext 对象注入到该 bean 中。由于 Aware 接口是标记接口，因此在 Spring 容器中没有具体的实现类，而是通过 Java 反射机制在运行时动态地为 bean 生成代理类来实现注入操作。\n\n需要注意的是，Aware 接口的实现顺序是非常重要的。如果多个 bean 都实现了同一个 Aware 接口，Spring 会按照某种预定义的顺序依次调用它们的 setXxx() 方法。因此，如果存在顺序依赖关系，就需要设置合适的优先级，确保 bean 的注入顺序正确。可以使用 @Order 注解或实现 Ordered 接口来指定 Aware 接口的执行顺序。\n\n\n# 容器 Aware 实现\n\nSpring 中的 Aware 实现流程可以分为以下几步：\n\n 1. 定义 Aware 接口：在自定义的类中定义一个实现了某个 Aware 接口的方法，如 ApplicationContextAware 接口。\n\n 2. 注册 BeanPostProcessor：在 Spring 容器启动时注册 BeanPostProcessor 实现类，该实现类会对所有 Bean 进行处理，判断是否实现了指定的 Aware 接口。如果实现了，则调用相应的方法。\n\n 3. 查找并注入相关 Bean：当一个 Bean 实现了指定的 Aware 接口后，在其初始化过程中，Spring 会自动查找相应的 Bean，并将其注入到该 Bean 中。\n\n 4. 使用注入的 Bean：在 Bean 初始化完成后，可通过注入的 Bean 来获取相应的资源，如 ApplicationContext、BeanFactory 等。\n\n需要注意的是，具体实现方式会因为实现的 Aware 接口不同而有所差异，例如实现了 BeanNameAware 接口则可获得当前 Bean 的名称等。\n\n\n# 定义一些职责和能力：\n\n 1. Aware\n    \n    /**\n     * Spring Aware 接口是一个标记接口，实现该接口的 Bean 可以访问 Spring 的核心组件 ApplicationContext 或其他特定的 Spring 框架对象。\n     * 通过实现 Spring Aware 接口，bean 可以获取 Spring 容器中的其他 bean 和资源，从而更好地利用 Spring 框架的功能。\n     */\n    public interface Aware {\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 2. BeanNameAware\n    \n    /**\n     * 实现该接口的 bean 可以获取 所属 Bean 在容器中的名称。\n     */\n    public interface BeanNameAware extends Aware {\n    \n        /**\n         * 感知 bean 名称\n         *\n         * @param beanName bean名字\n         */\n        void setBeanName(String beanName);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 3. BeanFactoryAware\n    \n    /**\n     * 实现该接口的 bean 可以获取 BeanFactory（即Spring容器）对象。\n     */\n    public interface BeanFactoryAware extends Aware {\n    \n        /**\n         * 感知 BeanFactory（即Spring容器）对象\n         *\n         * @param beanFactory bean工厂\n         */\n        void setBeanFactory(BeanFactory beanFactory);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 4. BeanClassLoaderAware\n    \n    /**\n     * 实现该接口的 bean 可以获取 所属 ClassLoader 对象。\n     *\n     * @author zhangpengjun\n     * @date 2023/3/28\n     */\n    public interface BeanClassLoaderAware extends Aware {\n    \n        /**\n         * 感知 所属 ClassLoader 对象\n         *\n         * @param classLoader 类装入器\n         */\n        void setBeanClassLoader(ClassLoader classLoader);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 具体的实现：\n\n * 无\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 AbstractAutowireCapableBeanFactory，在 Bean 实例化及属性填充后，初始化方法的调用的过程中加入 Aware 感知的能力：\n    \n        private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) {\n            // 感知类型扩展 处理\n            if (bean instanceof Aware) {\n                if (bean instanceof BeanNameAware) {\n                    ((BeanNameAware) bean).setBeanName(beanName);\n                }\n                if (bean instanceof BeanClassLoaderAware) {\n                    ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n                }\n                if (bean instanceof BeanFactoryAware) {\n                    ((BeanFactoryAware) bean).setBeanFactory(this);\n                }\n            }\n            // BeanPostProcessor 前置处理，ApplicationContextAwareProcessor 也会在这里处理\n            Object wrappedBean = applyBeanPostProcessorsBeforeInitialization(bean, beanName);\n            // 调用初始化方法\n            try {\n                invokeInitMethods(beanName, wrappedBean, beanDefinition);\n            } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException e) {\n                throw new BeansException("Failed to bean init", e);\n            }\n            // BeanPostProcessor 后置处理\n            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n            return wrappedBean;\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    这样就把容器 Aware 能力加入到了 Bean 的创建中。\n\n\n# 上下文 Aware 实现\n\n我们在 Spring 中对 ApplicationContextAware 接口的实现可以概括为以下几个步骤：\n\n 1. Spring 容器创建 ApplicationContextAware 实例对象。\n\n 2. Spring 容器检测到该实例对象实现了 ApplicationContextAware 接口。\n\n 3. Spring 容器将当前容器的 ApplicationContext 对象注入到该实例对象的 setApplicationContext() 方法中。\n\n 4. 实现 ApplicationContextAware 接口的 bean 可以在 setApplicationContext() 方法中获取 ApplicationContext 对象，从而访问容器中的其他 bean。\n\n需要注意的是，实现原理是通过 BeanPostProcessor 来实现的，其中 ApplicationContextAwareProcessor 就是一个内置的 BeanPostProcessor，它会在初始化 bean 的过程中，检测是否实现了 ApplicationContextAware 接口，并在合适的时候（容器启动，在 Bean 创建时的前置处理器中）调用 setApplicationContext() 方法完成注入操作。因此，如果我们需要自定义 Aware 类型接口的注入逻辑，也可以通过实现自己的 BeanPostProcessor 来实现。\n\n\n# 定义一些职责和能力：\n\n 1. ApplicationContextAware：感知应用程序上下文\n    \n    /**\n     * 感知 应用程序上下文\n     *\n     * @author zhangpengjun\n     * @date 2023/3/28\n     */\n    public interface ApplicationContextAware extends Aware {\n    \n        /**\n         * 设置应用程序上下文\n         *\n         * @param applicationContext 应用程序上下文\n         */\n        void setApplicationContext(ApplicationContext applicationContext);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 具体的实现：\n\n 1. ApplicationContextAwareProcessor：是一个处理器（BeanPostProcessor），用于在 Spring 容器创建 bean 实例后，对实现了 ApplicationContextAware 接口的 bean 进行特殊处理。\n    \n    /**\n     * 应用程序上下文Aware比较特殊，因为在容器直接创建 Bean 的时候没有上下文的存在，\n     * 所以只能交由上下文refresh()的时候，将 ApplicationContextAware 包装作为一个 Bean 的后置处理器添加到容器中，\n     * 然后在Bean创建的时候，应用Bean前置处理，将上下文设置到Bean中取。\n     * <p>\n     * 所以：ApplicationContextAware 底层是 通过 BeanPostProcessor 实现的。\n     */\n    public class ApplicationContextAwareProcessor implements BeanPostProcessor {\n    \n        private final ApplicationContext applicationContext;\n    \n        public ApplicationContextAwareProcessor(ApplicationContext applicationContext) {\n            this.applicationContext = applicationContext;\n        }\n    \n        @Override\n        public Object postProcessBeforeInitialization(Object bean, String beanName) {\n            if (bean instanceof ApplicationContextAware) {\n                ((ApplicationContextAware) bean).setApplicationContext(applicationContext);\n            }\n            return bean;\n        }\n    \n        @Override\n        public Object postProcessAfterInitialization(Object bean, String beanName) {\n            return bean;\n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    \n\n具体来说，ApplicationContextAwareProcessor 会在以下两个时刻进行处理：\n\n 1. 在 bean 实例化后，但在初始化前：此时 ApplicationContextAwareProcessor 会查找所有实现了 ApplicationContextAware 接口的 bean，并调用它们的 setApplicationContext() 方法，将 ApplicationContext 注入进去。\n 2. 在 bean 初始化后：此时 ApplicationContextAwareProcessor 不会再对 ApplicationContextAware 类型的 bean 进行处理，而是继续对其他类型的 bean 进行后续的处理。\n\n该处理器会检查每个 bean 是否实现了 ApplicationContextAware 接口，如果实现了，则将 ApplicationContext 容器注入到该 bean 的 setApplicationContext() 方法中，从而使得该 bean 可以访问容器中的其他 bean。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改上下文 AbstractApplicationContext 的 refresh() 方法：\n    \n        @Override\n        public void refresh() {\n            // 1. 创建 Bean 工厂，加载 BeanDefinition\n            refreshBeanFactory();\n    \n            // 2. 获得 Bean 工厂\n            ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n            // 2.1 == 这里新加这一步 ==\n            // 添加 ApplicationContextAware 的后置处理器\n            // 使 Bean 创建时（BeanPostProcessor前置处理器）的时候可以感知到容器上下文\n            beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n    \n            // 3. BeanDefinition 扩展点：\n            // Spring 容器中 BeanDefinition 的扩展点。\n            // 创建 BeanDefinition 之后，但在创建 Bean 实例之前。\n            invokeBeanFactoryPostProcessors(beanFactory);\n    \n            // 4. Bean 扩展点：\n            // 提前注册所有的 BeanPostProcessor，在 Bean 创建后，初始化时扩展\n            // （见 AbstractAutowireCapableBeanFactory.createBean ）。\n            registerBeanPostProcessors(beanFactory);\n    \n            // 5. 提前实例化所有的单例 Bean\n            beanFactory.preInstantiateSingletons();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n\n\n# 测试：\n\n * xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    <bean id="mouse" class="com.snail.springframework.beans.factory.support.Mouse">\n        <property name="name" value="name-xml-init-jerry"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n * Mouse 类准备，实现各个 Aware 接口\n\npublic class Mouse implements BeanNameAware, BeanClassLoaderAware, BeanFactoryAware, ApplicationContextAware {\n\n    private ApplicationContext applicationContext;\n    private String name;\n\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        System.out.println("==> BeanClassLoaderAware classLoader: " + classLoader);\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n        System.out.println("==> BeanFactoryAware beanFactory: " + beanFactory);\n    }\n\n    @Override\n    public void setBeanName(String beanName) {\n        System.out.println("==> BeanNameAware beanName: " + beanName);\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) {\n        System.out.println("==> ApplicationContextAware applicationContext: " + applicationContext);\n        this.applicationContext = applicationContext;\n    }\n\n    public ApplicationContext getApplicationContext() {\n        return applicationContext;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return "Mouse{" +\n                "applicationContext=" + applicationContext +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 测试类\n\n    /**\n     * xml上下文中，加入 Bean 的 Aware（感知能力），测试\n     */\n    @Test\n    public void test_xml_context_aware() {\n        // 1. 利用 xml上下文 加载Bean\n        // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring-aware.xml");\n        // 可以在任何时段，提前注册 JVM 关闭钩子，用来确保 Spring 容器在 JVM 关闭之前正确地关闭并释放所有资源。\n        applicationContext.registerShutdownHook();\n        // 2. 获取bean\n        Mouse mouse = (Mouse) applicationContext.getBean("mouse");\n\n        System.out.println("\\n" + mouse);\n        // * close 和 registerShutdownHook 比，比较暴力，直接手动调用关闭\n        // applicationContext.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 测试结果\n\n==> BeanNameAware beanName: mouse\n==> BeanClassLoaderAware classLoader: sun.misc.Launcher$AppClassLoader@18b4aac2\n==> BeanFactoryAware beanFactory: com.snail.springframework.beans.factory.support.DefaultListableBeanFactory@6df97b55\n==> ApplicationContextAware applicationContext: com.snail.springframework.context.support.ClassPathXmlApplicationContext@3cbbc1e0\n\nMouse{applicationContext=com.snail.springframework.context.support.ClassPathXmlApplicationContext@3cbbc1e0, name=\'name-xml-init-jerry\'}\n\nProcess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 总结\n\n实现 Aware 接口的 bean 可以在特定的生命周期阶段中获取对应的资源或对象，并进行相应的操作。\n\n例如，在初始化阶段，可以通过 ApplicationContextAware 获取 ApplicationContext 容器，并使用其提供的方法获取其他 bean 实例；在销毁阶段，可以通过 DisposableBean 或 @PreDestroy 注解来实现 bean 的清理操作。\n\n需要注意的是，Spring 框架只会将实现了相应 Aware 接口的 bean 注入对应的资源或对象，而不是所有的 bean 都可以访问这些资源或对象。如果一个 bean 不需要访问任何外部资源或对象，则无需实现任何 Aware 接口。\n\n同时，Spring 还提供了内置的处理器（例如 ApplicationContextAwareProcessor）来处理实现 Aware 接口的 bean，在合适的时候将指定的资源或对象注入到 bean 中。如果需要自定义 Aware 类型接口的注入逻辑，则可以通过实现自己的 BeanPostProcessor 来实现。',normalizedContent:'spring aware 接口是一个标记接口，实现该接口的 bean 可以访问 spring 的核心组件 applicationcontext 或其他特定的 spring 框架对象。\n\n这些组件包括 beanfactory、resourceloader、applicationeventpublisher 等等。\n\n实现该接口的 bean 需要实现 setapplicationcontext() 方法，并在该方法中将 applicationcontext 或其他 spring 框架对象注入到该 bean 中。通过实现 spring aware 接口，bean 可以获取 spring 容器中的其他 bean 和资源，从而更好地利用 spring 框架的功能。\n\n\n\n * 解析\n * 容器 aware 实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n * 上下文 aware 实现\n   * 定义一些职责和能力：\n   * 具体的实现：\n   * 将实现加入原有的逻辑中：\n   * 测试：\n * 总结\n\n\n\nspring aware 接口有多个子接口，分别对应不同的 spring 框架对象和功能。比如：\n\n 1. beannameaware：实现该接口的 bean 可以获取自己在容器中的 bean 名称。\n\n 2. beanfactoryaware：实现该接口的 bean 可以获取 beanfactory（即spring容器）对象。\n\n 3. applicationcontextaware：实现该接口的 bean 可以获取 applicationcontext 对象，从而可以访问 spring 容器中的其他 bean、资源和配置信息。\n\n 4. messagesourceaware：实现该接口的 bean 可以获取 messagesource 对象，用于国际化处理。\n\n 5. applicationeventpublisheraware：实现该接口的 bean 可以获取 applicationeventpublisher 对象，用于发布应用程序事件。\n\n 6. resourceloaderaware：实现该接口的 bean 可以获取 resourceloader 对象，用于加载外部资源文件。\n\n通过实现这些 spring aware 接口，bean 可以更加灵活地使用 spring 框架提供的各种功能和资源，同时也增强了与 spring 框架的集成能力。\n\n\n# 解析\n\naware 是如何在 spring 中实现的呢：在 spring 中，aware 接口的实现是通过 beanpostprocessor 机制来实现的。\n\n当 spring 容器创建一个 bean 时，会在 bean 的生命周期中调用 beanpostprocessor 接口中的两个方法 postprocessbeforeinitialization() 和 postprocessafterinitialization() 。如果一个 bean 实现了某个 aware 接口， beanpostprocessor 会检测到该 bean，并调用对应的 setxxx() 方法来注入相应的 spring 组件。\n\n比如，实现 applicationcontextaware 接口的 bean，在 postprocessbeforeinitialization() 方法中会调用其 setapplicationcontext() 方法，并将 applicationcontext 对象注入到该 bean 中。由于 aware 接口是标记接口，因此在 spring 容器中没有具体的实现类，而是通过 java 反射机制在运行时动态地为 bean 生成代理类来实现注入操作。\n\n需要注意的是，aware 接口的实现顺序是非常重要的。如果多个 bean 都实现了同一个 aware 接口，spring 会按照某种预定义的顺序依次调用它们的 setxxx() 方法。因此，如果存在顺序依赖关系，就需要设置合适的优先级，确保 bean 的注入顺序正确。可以使用 @order 注解或实现 ordered 接口来指定 aware 接口的执行顺序。\n\n\n# 容器 aware 实现\n\nspring 中的 aware 实现流程可以分为以下几步：\n\n 1. 定义 aware 接口：在自定义的类中定义一个实现了某个 aware 接口的方法，如 applicationcontextaware 接口。\n\n 2. 注册 beanpostprocessor：在 spring 容器启动时注册 beanpostprocessor 实现类，该实现类会对所有 bean 进行处理，判断是否实现了指定的 aware 接口。如果实现了，则调用相应的方法。\n\n 3. 查找并注入相关 bean：当一个 bean 实现了指定的 aware 接口后，在其初始化过程中，spring 会自动查找相应的 bean，并将其注入到该 bean 中。\n\n 4. 使用注入的 bean：在 bean 初始化完成后，可通过注入的 bean 来获取相应的资源，如 applicationcontext、beanfactory 等。\n\n需要注意的是，具体实现方式会因为实现的 aware 接口不同而有所差异，例如实现了 beannameaware 接口则可获得当前 bean 的名称等。\n\n\n# 定义一些职责和能力：\n\n 1. aware\n    \n    /**\n     * spring aware 接口是一个标记接口，实现该接口的 bean 可以访问 spring 的核心组件 applicationcontext 或其他特定的 spring 框架对象。\n     * 通过实现 spring aware 接口，bean 可以获取 spring 容器中的其他 bean 和资源，从而更好地利用 spring 框架的功能。\n     */\n    public interface aware {\n        \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 2. beannameaware\n    \n    /**\n     * 实现该接口的 bean 可以获取 所属 bean 在容器中的名称。\n     */\n    public interface beannameaware extends aware {\n    \n        /**\n         * 感知 bean 名称\n         *\n         * @param beanname bean名字\n         */\n        void setbeanname(string beanname);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 3. beanfactoryaware\n    \n    /**\n     * 实现该接口的 bean 可以获取 beanfactory（即spring容器）对象。\n     */\n    public interface beanfactoryaware extends aware {\n    \n        /**\n         * 感知 beanfactory（即spring容器）对象\n         *\n         * @param beanfactory bean工厂\n         */\n        void setbeanfactory(beanfactory beanfactory);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 4. beanclassloaderaware\n    \n    /**\n     * 实现该接口的 bean 可以获取 所属 classloader 对象。\n     *\n     * @author zhangpengjun\n     * @date 2023/3/28\n     */\n    public interface beanclassloaderaware extends aware {\n    \n        /**\n         * 感知 所属 classloader 对象\n         *\n         * @param classloader 类装入器\n         */\n        void setbeanclassloader(classloader classloader);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 具体的实现：\n\n * 无\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改 abstractautowirecapablebeanfactory，在 bean 实例化及属性填充后，初始化方法的调用的过程中加入 aware 感知的能力：\n    \n        private object initializebean(string beanname, object bean, beandefinition beandefinition) {\n            // 感知类型扩展 处理\n            if (bean instanceof aware) {\n                if (bean instanceof beannameaware) {\n                    ((beannameaware) bean).setbeanname(beanname);\n                }\n                if (bean instanceof beanclassloaderaware) {\n                    ((beanclassloaderaware) bean).setbeanclassloader(getbeanclassloader());\n                }\n                if (bean instanceof beanfactoryaware) {\n                    ((beanfactoryaware) bean).setbeanfactory(this);\n                }\n            }\n            // beanpostprocessor 前置处理，applicationcontextawareprocessor 也会在这里处理\n            object wrappedbean = applybeanpostprocessorsbeforeinitialization(bean, beanname);\n            // 调用初始化方法\n            try {\n                invokeinitmethods(beanname, wrappedbean, beandefinition);\n            } catch (invocationtargetexception | illegalaccessexception | nosuchmethodexception e) {\n                throw new beansexception("failed to bean init", e);\n            }\n            // beanpostprocessor 后置处理\n            wrappedbean = applybeanpostprocessorsafterinitialization(wrappedbean, beanname);\n            return wrappedbean;\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n    \n    这样就把容器 aware 能力加入到了 bean 的创建中。\n\n\n# 上下文 aware 实现\n\n我们在 spring 中对 applicationcontextaware 接口的实现可以概括为以下几个步骤：\n\n 1. spring 容器创建 applicationcontextaware 实例对象。\n\n 2. spring 容器检测到该实例对象实现了 applicationcontextaware 接口。\n\n 3. spring 容器将当前容器的 applicationcontext 对象注入到该实例对象的 setapplicationcontext() 方法中。\n\n 4. 实现 applicationcontextaware 接口的 bean 可以在 setapplicationcontext() 方法中获取 applicationcontext 对象，从而访问容器中的其他 bean。\n\n需要注意的是，实现原理是通过 beanpostprocessor 来实现的，其中 applicationcontextawareprocessor 就是一个内置的 beanpostprocessor，它会在初始化 bean 的过程中，检测是否实现了 applicationcontextaware 接口，并在合适的时候（容器启动，在 bean 创建时的前置处理器中）调用 setapplicationcontext() 方法完成注入操作。因此，如果我们需要自定义 aware 类型接口的注入逻辑，也可以通过实现自己的 beanpostprocessor 来实现。\n\n\n# 定义一些职责和能力：\n\n 1. applicationcontextaware：感知应用程序上下文\n    \n    /**\n     * 感知 应用程序上下文\n     *\n     * @author zhangpengjun\n     * @date 2023/3/28\n     */\n    public interface applicationcontextaware extends aware {\n    \n        /**\n         * 设置应用程序上下文\n         *\n         * @param applicationcontext 应用程序上下文\n         */\n        void setapplicationcontext(applicationcontext applicationcontext);\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 具体的实现：\n\n 1. applicationcontextawareprocessor：是一个处理器（beanpostprocessor），用于在 spring 容器创建 bean 实例后，对实现了 applicationcontextaware 接口的 bean 进行特殊处理。\n    \n    /**\n     * 应用程序上下文aware比较特殊，因为在容器直接创建 bean 的时候没有上下文的存在，\n     * 所以只能交由上下文refresh()的时候，将 applicationcontextaware 包装作为一个 bean 的后置处理器添加到容器中，\n     * 然后在bean创建的时候，应用bean前置处理，将上下文设置到bean中取。\n     * <p>\n     * 所以：applicationcontextaware 底层是 通过 beanpostprocessor 实现的。\n     */\n    public class applicationcontextawareprocessor implements beanpostprocessor {\n    \n        private final applicationcontext applicationcontext;\n    \n        public applicationcontextawareprocessor(applicationcontext applicationcontext) {\n            this.applicationcontext = applicationcontext;\n        }\n    \n        @override\n        public object postprocessbeforeinitialization(object bean, string beanname) {\n            if (bean instanceof applicationcontextaware) {\n                ((applicationcontextaware) bean).setapplicationcontext(applicationcontext);\n            }\n            return bean;\n        }\n    \n        @override\n        public object postprocessafterinitialization(object bean, string beanname) {\n            return bean;\n        }\n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    \n\n具体来说，applicationcontextawareprocessor 会在以下两个时刻进行处理：\n\n 1. 在 bean 实例化后，但在初始化前：此时 applicationcontextawareprocessor 会查找所有实现了 applicationcontextaware 接口的 bean，并调用它们的 setapplicationcontext() 方法，将 applicationcontext 注入进去。\n 2. 在 bean 初始化后：此时 applicationcontextawareprocessor 不会再对 applicationcontextaware 类型的 bean 进行处理，而是继续对其他类型的 bean 进行后续的处理。\n\n该处理器会检查每个 bean 是否实现了 applicationcontextaware 接口，如果实现了，则将 applicationcontext 容器注入到该 bean 的 setapplicationcontext() 方法中，从而使得该 bean 可以访问容器中的其他 bean。\n\n\n# 将实现加入原有的逻辑中：\n\n 1. 修改上下文 abstractapplicationcontext 的 refresh() 方法：\n    \n        @override\n        public void refresh() {\n            // 1. 创建 bean 工厂，加载 beandefinition\n            refreshbeanfactory();\n    \n            // 2. 获得 bean 工厂\n            configurablelistablebeanfactory beanfactory = getbeanfactory();\n            // 2.1 == 这里新加这一步 ==\n            // 添加 applicationcontextaware 的后置处理器\n            // 使 bean 创建时（beanpostprocessor前置处理器）的时候可以感知到容器上下文\n            beanfactory.addbeanpostprocessor(new applicationcontextawareprocessor(this));\n    \n            // 3. beandefinition 扩展点：\n            // spring 容器中 beandefinition 的扩展点。\n            // 创建 beandefinition 之后，但在创建 bean 实例之前。\n            invokebeanfactorypostprocessors(beanfactory);\n    \n            // 4. bean 扩展点：\n            // 提前注册所有的 beanpostprocessor，在 bean 创建后，初始化时扩展\n            // （见 abstractautowirecapablebeanfactory.createbean ）。\n            registerbeanpostprocessors(beanfactory);\n    \n            // 5. 提前实例化所有的单例 bean\n            beanfactory.preinstantiatesingletons();\n        }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n\n\n# 测试：\n\n * xml 准备\n\n<?xml version="1.0" encoding="utf-8" ?>\n<beans>\n    <bean id="mouse" class="com.snail.springframework.beans.factory.support.mouse">\n        <property name="name" value="name-xml-init-jerry"></property>\n    </bean>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n * mouse 类准备，实现各个 aware 接口\n\npublic class mouse implements beannameaware, beanclassloaderaware, beanfactoryaware, applicationcontextaware {\n\n    private applicationcontext applicationcontext;\n    private string name;\n\n    @override\n    public void setbeanclassloader(classloader classloader) {\n        system.out.println("==> beanclassloaderaware classloader: " + classloader);\n    }\n\n    @override\n    public void setbeanfactory(beanfactory beanfactory) {\n        system.out.println("==> beanfactoryaware beanfactory: " + beanfactory);\n    }\n\n    @override\n    public void setbeanname(string beanname) {\n        system.out.println("==> beannameaware beanname: " + beanname);\n    }\n\n    @override\n    public void setapplicationcontext(applicationcontext applicationcontext) {\n        system.out.println("==> applicationcontextaware applicationcontext: " + applicationcontext);\n        this.applicationcontext = applicationcontext;\n    }\n\n    public applicationcontext getapplicationcontext() {\n        return applicationcontext;\n    }\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    @override\n    public string tostring() {\n        return "mouse{" +\n                "applicationcontext=" + applicationcontext +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 测试类\n\n    /**\n     * xml上下文中，加入 bean 的 aware（感知能力），测试\n     */\n    @test\n    public void test_xml_context_aware() {\n        // 1. 利用 xml上下文 加载bean\n        // 上下文的高级实现极大的简化了或融合了上述的 1-4 步操作\n        classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:spring-aware.xml");\n        // 可以在任何时段，提前注册 jvm 关闭钩子，用来确保 spring 容器在 jvm 关闭之前正确地关闭并释放所有资源。\n        applicationcontext.registershutdownhook();\n        // 2. 获取bean\n        mouse mouse = (mouse) applicationcontext.getbean("mouse");\n\n        system.out.println("\\n" + mouse);\n        // * close 和 registershutdownhook 比，比较暴力，直接手动调用关闭\n        // applicationcontext.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 测试结果\n\n==> beannameaware beanname: mouse\n==> beanclassloaderaware classloader: sun.misc.launcher$appclassloader@18b4aac2\n==> beanfactoryaware beanfactory: com.snail.springframework.beans.factory.support.defaultlistablebeanfactory@6df97b55\n==> applicationcontextaware applicationcontext: com.snail.springframework.context.support.classpathxmlapplicationcontext@3cbbc1e0\n\nmouse{applicationcontext=com.snail.springframework.context.support.classpathxmlapplicationcontext@3cbbc1e0, name=\'name-xml-init-jerry\'}\n\nprocess finished with exit code 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 总结\n\n实现 aware 接口的 bean 可以在特定的生命周期阶段中获取对应的资源或对象，并进行相应的操作。\n\n例如，在初始化阶段，可以通过 applicationcontextaware 获取 applicationcontext 容器，并使用其提供的方法获取其他 bean 实例；在销毁阶段，可以通过 disposablebean 或 @predestroy 注解来实现 bean 的清理操作。\n\n需要注意的是，spring 框架只会将实现了相应 aware 接口的 bean 注入对应的资源或对象，而不是所有的 bean 都可以访问这些资源或对象。如果一个 bean 不需要访问任何外部资源或对象，则无需实现任何 aware 接口。\n\n同时，spring 还提供了内置的处理器（例如 applicationcontextawareprocessor）来处理实现 aware 接口的 bean，在合适的时候将指定的资源或对象注入到 bean 中。如果需要自定义 aware 类型接口的注入逻辑，则可以通过实现自己的 beanpostprocessor 来实现。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Spring Boot 除 xml/yml 外，利用 SPI 支持对 json 配置文件的解析",frontmatter:{title:"Spring Boot 除 xml/yml 外，利用 SPI 支持对 json 配置文件的解析",date:"2022-02-17T00:00:00.000Z",tags:["SPI"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/spring_application_json.html",relativePath:"views/backend/spring_application_json.md",key:"v-65a6b7f7",path:"/views/backend/spring_application_json.html",headersStr:null,content:'继上一篇JDK/Dubbo/Spring 三种SPI机制解析之后，今天就在 Spring Boot 中，利用 SPI 支持对 json 配置文件的解析。\n\nSpringBoot 的配置文件内置支持 properties、xml、yml、yaml 几种格式，其中 properties 和 xml 对应的Loader类为 PropertiesPropertySourceLoader ，yml和yaml 对应的Loader类为 YamlPropertySourceLoader。\n\n了解了 Spring SPI 机制后，观察这2个类可以发现，都实现自接口 PropertySourceLoader 。所以我们要新增支持别的格式的配置文件，就可以通过实现接口 PropertySourceLoader 来实现了。\n\n参照 PropertiesPropertySourceLoader , 下面实现了一个 json 格式的配置文件 Loader类：\n\n/**\n * JSON格式配置文件加载器\n */\npublic class JsonPropertySourceLoader implements PropertySourceLoader {\n\n    public String[] getFileExtensions() {\n        // 配置文件格式（扩展名）\n        return new String[] { "json" };\n    }\n\n    public List<PropertySource<?>> load(String name, Resource resource) throws IOException {\n        if (resource == null || !resource.exists()) {\n            return Collections.emptyList();\n        }\n        Map<String, Object> map = JSON.parseObject(resource.getInputStream(), Map.class);\n        Map<String, Object> resutltMap = new HashMap<>();\n        // 将json转为键值对\n        parseMap("", resutltMap, map);\n        return Collections.singletonList(return new MapPropertySource(name, result));\n    }\n\n    private void parseMap(String prefix, Map<String, Object> result, Map<String, Object> map) {\n        if (prefix.length() > 0) {\n            prefix += ".";\n        }\n        for (Map.Entry<String, Object> entrySet : map.entrySet()) {\n            if (entrySet.getValue() instanceof Map) {\n                nestMap(prefix + entrySet.getKey(), result, (Map<String, Object>) entrySet.getValue());\n            } else {\n                result.put(prefix + entrySet.getKey().toString(), entrySet.getValue());\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n然后在 src/main/resources 中创建 META-INF/spring.factories 文件，内容为：\n\norg.springframework.boot.env.PropertySourceLoader=\\\ncom.shanhy.sboot.property.JsonPropertySourceLoader\n\n\n1\n2\n\n\n创建测试的配置文件 application.json\n\n{\n    "custom": {\n        "property": {\n            "message": "测试数据"\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建验证结果的 HelloController.java\n\n@RestController\npublic class HelloController {\n\n    @Value("${custom.property.message}")\n    private Object customProperty;\n\n    @RequestMapping("/test")\n    public Object test() {\n        return customProperty;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n启动工程服务，浏览器访问 http://localhost:8080/test 即可查看输出的结果为 “测试数据”；',normalizedContent:'继上一篇jdk/dubbo/spring 三种spi机制解析之后，今天就在 spring boot 中，利用 spi 支持对 json 配置文件的解析。\n\nspringboot 的配置文件内置支持 properties、xml、yml、yaml 几种格式，其中 properties 和 xml 对应的loader类为 propertiespropertysourceloader ，yml和yaml 对应的loader类为 yamlpropertysourceloader。\n\n了解了 spring spi 机制后，观察这2个类可以发现，都实现自接口 propertysourceloader 。所以我们要新增支持别的格式的配置文件，就可以通过实现接口 propertysourceloader 来实现了。\n\n参照 propertiespropertysourceloader , 下面实现了一个 json 格式的配置文件 loader类：\n\n/**\n * json格式配置文件加载器\n */\npublic class jsonpropertysourceloader implements propertysourceloader {\n\n    public string[] getfileextensions() {\n        // 配置文件格式（扩展名）\n        return new string[] { "json" };\n    }\n\n    public list<propertysource<?>> load(string name, resource resource) throws ioexception {\n        if (resource == null || !resource.exists()) {\n            return collections.emptylist();\n        }\n        map<string, object> map = json.parseobject(resource.getinputstream(), map.class);\n        map<string, object> resutltmap = new hashmap<>();\n        // 将json转为键值对\n        parsemap("", resutltmap, map);\n        return collections.singletonlist(return new mappropertysource(name, result));\n    }\n\n    private void parsemap(string prefix, map<string, object> result, map<string, object> map) {\n        if (prefix.length() > 0) {\n            prefix += ".";\n        }\n        for (map.entry<string, object> entryset : map.entryset()) {\n            if (entryset.getvalue() instanceof map) {\n                nestmap(prefix + entryset.getkey(), result, (map<string, object>) entryset.getvalue());\n            } else {\n                result.put(prefix + entryset.getkey().tostring(), entryset.getvalue());\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n然后在 src/main/resources 中创建 meta-inf/spring.factories 文件，内容为：\n\norg.springframework.boot.env.propertysourceloader=\\\ncom.shanhy.sboot.property.jsonpropertysourceloader\n\n\n1\n2\n\n\n创建测试的配置文件 application.json\n\n{\n    "custom": {\n        "property": {\n            "message": "测试数据"\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n创建验证结果的 hellocontroller.java\n\n@restcontroller\npublic class hellocontroller {\n\n    @value("${custom.property.message}")\n    private object customproperty;\n\n    @requestmapping("/test")\n    public object test() {\n        return customproperty;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n启动工程服务，浏览器访问 http://localhost:8080/test 即可查看输出的结果为 “测试数据”；',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Swagger2的基本了解和使用",frontmatter:{title:"Swagger2的基本了解和使用",date:"2019-08-11T19:29:56.000Z",tags:["Swagger2","分布式"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/swagger2.html",relativePath:"views/backend/swagger2.md",key:"v-24ae108a",path:"/views/backend/swagger2.html",headers:[{level:2,title:"入门",slug:"入门",normalizedTitle:"入门",charIndex:78},{level:2,title:"Swagger常用注解",slug:"swagger常用注解",normalizedTitle:"swagger常用注解",charIndex:84},{level:2,title:"简单在SpringBoot中搭建Swagger文档",slug:"简单在springboot中搭建swagger文档",normalizedTitle:"简单在springboot中搭建swagger文档",charIndex:99},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:130},{level:3,title:"在SpringBoot中添加Swagger2Config配置类",slug:"在springboot中添加swagger2config配置类",normalizedTitle:"在springboot中添加swagger2config配置类",charIndex:140},{level:3,title:"给Controller类添加Swagger注解",slug:"给controller类添加swagger注解",normalizedTitle:"给controller类添加swagger注解",charIndex:177},{level:3,title:"给model实体类添加Swagger注解",slug:"给model实体类添加swagger注解",normalizedTitle:"给model实体类添加swagger注解",charIndex:206}],excerpt:"<Boxx/>\n<p>Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能组件，随着现在许多公司实现了前后端分离，swagger越来越受欢迎了。</p>\n",headersStr:"入门 Swagger常用注解 简单在SpringBoot中搭建Swagger文档 添加依赖 在SpringBoot中添加Swagger2Config配置类 给Controller类添加Swagger注解 给model实体类添加Swagger注解",content:'Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能组件，随着现在许多公司实现了前后端分离，swagger越来越受欢迎了。\n\n\n\n * 入门\n * Swagger常用注解\n * 简单在SpringBoot中搭建Swagger文档\n   * 添加依赖\n   * 在SpringBoot中添加Swagger2Config配置类\n   * 给Controller类添加Swagger注解\n   * 给model实体类添加Swagger注解\n\n\n\n\n# 入门\n\n我是怎么学swagger的呢，经过我一步一步的经验，推荐以下三个网址去学习即可：\n\n * 基础篇：虽然是老外写的入门，但凭我这个英语垃圾的一批的渣渣都能看懂，相信大部分人一定可以读懂！另外作者的写作风格我很喜欢，欢迎大家去看看。传送们\n * 中极篇：一篇不错的文章，从基础到配置到实现写的很详细。传送们\n * 高级篇：mall作者，我从他这学到不少东西，非常感谢！传送们\n\n\n# Swagger常用注解\n\n注解                  说明\n@Api                用于修饰Controller类，生成Controller相关文档信息\n@ApiOperation       用于修饰Controller类中的方法，生成接口方法相关文档信息\n@ApiParam           用于修饰接口中的参数，生成接口参数相关文档信息\n@ApiModel           用于修饰Model实体类\n@ApiModelProperty   用于修饰Model实体类的属性，当实体类是请求参数或返回结果时，直接生成相关文档信息\n\n\n# 简单在SpringBoot中搭建Swagger文档\n\n * 配置完成后，通过访问http://localhost:8080/swagger-ui.html（自己的项目访问路径/swagger-ui.html）来访问接口文档就可以了。\n\n\n\n\n# 添加依赖\n\n\x3c!--Swagger-UI API文档依赖--\x3e\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger2</artifactId>\n    <version>2.9.2</version>\n</dependency>\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger-ui</artifactId>\n    <version>2.9.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 在SpringBoot中添加Swagger2Config配置类\n\n@Configuration //这是一个配置类\n@EnableSwagger2 //开启Swagger2的自动配置\npublic class Swagger2Config {\n\n    // 配置docket以配置Swagger具体参数\n    @Bean\n    public Docket docket() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                // 通过.select()方法，去配置扫描接口\n                .select()\n                // 为 指定的包下的所有controller 生成API文档\n                .apis(RequestHandlerSelectors.basePackage("com.example.swaggerexample.controller"))\n                // 配置如何通过 path过滤 即这里只扫描 请求以 /user开头的接口\n                .path(PathSelectors.any("/user/**"))\n                .build();\n    }\n    \n    //不是刚需，按需配置\n    private ApiInfo apiInfo() {\n        Contact contact = new Contact("联系人名字", "http://xxx.xxx.com/联系人访问链接", "联系人邮箱");\n        return new ApiInfo("Swagger学习", // 标题\n                "学习演示如何配置Swagger", // 描述\n                "v1.0", // 版本\n                "http://terms.service.url/组织链接", // 组织链接\n                contact, // 联系人信息\n                "Apach 2.0 许可", // 许可\n                "许可链接", // 许可连接\n                new ArrayList<>()); // 扩展\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 给Controller类添加Swagger注解\n\n@Controller\n@Api(tags = "OmsOrderSettingController", description = "订单设置管理")\n@RequestMapping("/orderSetting")\npublic class OmsOrderSettingController {\n    @Autowired\n    private OmsOrderSettingService orderSettingService;\n\n    @ApiOperation("获取指定订单设置")\n    @RequestMapping(value = "/{id}", method = RequestMethod.GET)\n    @ResponseBody\n    public CommonResult<OmsOrderSetting> getItem(@PathVariable Long id) {\n        OmsOrderSetting orderSetting = orderSettingService.getItem(id);\n        return CommonResult.success(orderSetting);\n    }\n\n    @ApiOperation("修改指定订单设置")\n    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)\n    @ResponseBody\n    public CommonResult update(@PathVariable Long id, @RequestBody OmsOrderSetting orderSetting) {\n        int count = orderSettingService.update(id,orderSetting);\n        if(count>0){\n            return CommonResult.success(count);\n        }\n        return CommonResult.failed();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 给model实体类添加Swagger注解\n\n@ApiModel("用户实体")\npublic class User {\n    @ApiModelProperty("用户名")\n    private String username;\n    @ApiModelProperty("密码")\n    private String password;\n\t// 省略getter/setter\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'swagger 是一款restful接口的文档在线自动生成+功能测试功能组件，随着现在许多公司实现了前后端分离，swagger越来越受欢迎了。\n\n\n\n * 入门\n * swagger常用注解\n * 简单在springboot中搭建swagger文档\n   * 添加依赖\n   * 在springboot中添加swagger2config配置类\n   * 给controller类添加swagger注解\n   * 给model实体类添加swagger注解\n\n\n\n\n# 入门\n\n我是怎么学swagger的呢，经过我一步一步的经验，推荐以下三个网址去学习即可：\n\n * 基础篇：虽然是老外写的入门，但凭我这个英语垃圾的一批的渣渣都能看懂，相信大部分人一定可以读懂！另外作者的写作风格我很喜欢，欢迎大家去看看。传送们\n * 中极篇：一篇不错的文章，从基础到配置到实现写的很详细。传送们\n * 高级篇：mall作者，我从他这学到不少东西，非常感谢！传送们\n\n\n# swagger常用注解\n\n注解                  说明\n@api                用于修饰controller类，生成controller相关文档信息\n@apioperation       用于修饰controller类中的方法，生成接口方法相关文档信息\n@apiparam           用于修饰接口中的参数，生成接口参数相关文档信息\n@apimodel           用于修饰model实体类\n@apimodelproperty   用于修饰model实体类的属性，当实体类是请求参数或返回结果时，直接生成相关文档信息\n\n\n# 简单在springboot中搭建swagger文档\n\n * 配置完成后，通过访问http://localhost:8080/swagger-ui.html（自己的项目访问路径/swagger-ui.html）来访问接口文档就可以了。\n\n\n\n\n# 添加依赖\n\n\x3c!--swagger-ui api文档依赖--\x3e\n<dependency>\n    <groupid>io.springfox</groupid>\n    <artifactid>springfox-swagger2</artifactid>\n    <version>2.9.2</version>\n</dependency>\n<dependency>\n    <groupid>io.springfox</groupid>\n    <artifactid>springfox-swagger-ui</artifactid>\n    <version>2.9.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 在springboot中添加swagger2config配置类\n\n@configuration //这是一个配置类\n@enableswagger2 //开启swagger2的自动配置\npublic class swagger2config {\n\n    // 配置docket以配置swagger具体参数\n    @bean\n    public docket docket() {\n        return new docket(documentationtype.swagger_2)\n                .apiinfo(apiinfo())\n                // 通过.select()方法，去配置扫描接口\n                .select()\n                // 为 指定的包下的所有controller 生成api文档\n                .apis(requesthandlerselectors.basepackage("com.example.swaggerexample.controller"))\n                // 配置如何通过 path过滤 即这里只扫描 请求以 /user开头的接口\n                .path(pathselectors.any("/user/**"))\n                .build();\n    }\n    \n    //不是刚需，按需配置\n    private apiinfo apiinfo() {\n        contact contact = new contact("联系人名字", "http://xxx.xxx.com/联系人访问链接", "联系人邮箱");\n        return new apiinfo("swagger学习", // 标题\n                "学习演示如何配置swagger", // 描述\n                "v1.0", // 版本\n                "http://terms.service.url/组织链接", // 组织链接\n                contact, // 联系人信息\n                "apach 2.0 许可", // 许可\n                "许可链接", // 许可连接\n                new arraylist<>()); // 扩展\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 给controller类添加swagger注解\n\n@controller\n@api(tags = "omsordersettingcontroller", description = "订单设置管理")\n@requestmapping("/ordersetting")\npublic class omsordersettingcontroller {\n    @autowired\n    private omsordersettingservice ordersettingservice;\n\n    @apioperation("获取指定订单设置")\n    @requestmapping(value = "/{id}", method = requestmethod.get)\n    @responsebody\n    public commonresult<omsordersetting> getitem(@pathvariable long id) {\n        omsordersetting ordersetting = ordersettingservice.getitem(id);\n        return commonresult.success(ordersetting);\n    }\n\n    @apioperation("修改指定订单设置")\n    @requestmapping(value = "/update/{id}", method = requestmethod.post)\n    @responsebody\n    public commonresult update(@pathvariable long id, @requestbody omsordersetting ordersetting) {\n        int count = ordersettingservice.update(id,ordersetting);\n        if(count>0){\n            return commonresult.success(count);\n        }\n        return commonresult.failed();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 给model实体类添加swagger注解\n\n@apimodel("用户实体")\npublic class user {\n    @apimodelproperty("用户名")\n    private string username;\n    @apimodelproperty("密码")\n    private string password;\n\t// 省略getter/setter\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Spring Boot 配置文件加载顺序",frontmatter:{title:"Spring Boot 配置文件加载顺序",date:"2022-04-28T00:00:00.000Z",tags:["Spring Boot"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html",relativePath:"views/backend/springboot配置文件加载顺序.md",key:"v-3456e51e",path:"/views/backend/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.html",headers:[{level:2,title:"配置文件所在的位置",slug:"配置文件所在的位置",normalizedTitle:"配置文件所在的位置",charIndex:3},{level:2,title:"配置文件的名字",slug:"配置文件的名字",normalizedTitle:"配置文件的名字",charIndex:16},{level:3,title:"1、springBoot何时加载配置文件？",slug:"_1、springboot何时加载配置文件",normalizedTitle:"1、springboot何时加载配置文件？",charIndex:29},{level:3,title:"2、springBoot加载配置文件时，不同位置及不同后缀的配置文件如何加载？",slug:"_2、springboot加载配置文件时-不同位置及不同后缀的配置文件如何加载",normalizedTitle:"2、springboot加载配置文件时，不同位置及不同后缀的配置文件如何加载？",charIndex:56},{level:3,title:"3、springBoot的{prifile}文件时是如何加载的？如:（application-dev.yml）",slug:"_3、springboot的-prifile-文件时是如何加载的-如-application-dev-yml",normalizedTitle:"3、springboot的{prifile}文件时是如何加载的？如:（application-dev.yml）",charIndex:101},{level:3,title:"4、不同位置的配置文件配置了相同的属性时 将如何加载？",slug:"_4、不同位置的配置文件配置了相同的属性时-将如何加载",normalizedTitle:"4、不同位置的配置文件配置了相同的属性时 将如何加载？",charIndex:162},{level:3,title:"5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？",slug:"_5、不同位置到配置文件-设置不同属性时-后加载的文件是否会生效",normalizedTitle:"5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？",charIndex:195}],excerpt:"<Boxx/>\n",headersStr:"配置文件所在的位置 配置文件的名字 1、springBoot何时加载配置文件？ 2、springBoot加载配置文件时，不同位置及不同后缀的配置文件如何加载？ 3、springBoot的{prifile}文件时是如何加载的？如:（application-dev.yml） 4、不同位置的配置文件配置了相同的属性时 将如何加载？ 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？",content:" * 配置文件所在的位置\n * 配置文件的名字\n   * 1、springBoot何时加载配置文件？\n   * 2、springBoot加载配置文件时，不同位置及不同后缀的配置文件如何加载？\n   * 3、springBoot的{prifile}文件时是如何加载的？如:（application-dev.yml）\n   * 4、不同位置的配置文件配置了相同的属性时 将如何加载？\n   * 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？\n\n\n\nSpringBoot 默认支持 properties 和 YAML 两种格式的配置文件，并且有 bootstrap 和 application 两种配置文件。\n\nbootstrap 配置文件先于 application 配置文件被加载，会先创建初始化 Bootstrap Context，再创建初始化 Application Context，应用于更早期的配置信息，可以理解为系统配置。\n\nbootstrap 和 application 共享同一个 Environment，默认情况下，bootstrap 的配置不会被覆盖，而 application 的配置项可以被覆盖。（比如被 application-dev 覆盖，或被 java 命令行覆盖）\n\n\n# 配置文件所在的位置\n\n默认值为：classpath:/, classpath:/config/, file:./, file:./config/ （优先级从低到高），最先加载file:./config/ 位置的配置文件；如果配置了spring.config.location属性则取这个属性的值。\n\n加载顺序如下：优先级由高到底，如果所有文件某个字段配置了一样的信息，高优先级的配置会覆盖低优先级的配置，但是加载的时候其他字段会进行互补配置；\n\n\n\n项目打包好以后，我们还可以使用命令行参数的形式，在启动项目的时候来指定配置文件的新位置；\n\n用指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；\n\n例如：java -jar spring-boot-config-demo.jar --spring.config.location=G:/application.properties\n\n还可以在 java 命令中覆盖配置项（这里指定了新的 port 和 profile）：\n\njava -jar spring-boot-config-demo.jar --spring.profiles.active=prod --server.port=8081\n\n\n# 配置文件的名字\n\n默认值为：application; 如果配置了spring.config.name属性则取改属性值。\n\n所有的扩展名：properties xml yml yaml\n\n加载顺序如下（优先级从低到高）： properties -> xml -> yml -> yaml\n\n加载时候到的拼接过程为 location + name + “.” +ext\n\nlocation : 指的就是上面提到配置文件所在的位置。 name： 指的就是配置文件的名称 默认就是appliction。 ext: 指的就是后缀名。 然后对拼接后的资源路径进行加载。\n\n小结： 上面加载的总体过程就是两层循环，外层控制加载配置文件位置的顺序，在相同位置时，内层就是控制后缀名不同时的加载顺序。\n\n理解了上面的原理，然后主要针对如下几个问题进行回答\n\n\n# 1、springBoot何时加载配置文件？\n\n在容器启动时，会有方法调用所有监听器的onApplicationEvent方法。然后与配置加载相关的ConfigFileApplicationListener的对应方法就会被加载，执行读取配置文件操作。\n\n\n# 2、springBoot加载配置文件时，不同位置及不同后缀的配置文件如何加载？\n\nclasspath:/, classpath:/config/, file:./, file:./config/ （优先级从低到高）\n\nproperties -> xml -> yml -> yaml（优先级从低到高）\n\n加载顺序如下：\n\n 1. config/application.properties（项目根目录中config目录下）\n 2. config/application.yml\n 3. application.properties（项目根目录下）\n 4. application.yml\n 5. resources/config/application.properties（项目resources目录中config目录下）\n 6. resources/config/application.yml\n 7. resources/application.properties（项目的resources目录下）\n 8. resources/application.yml\n\n注：\n\n 1. 如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。\n 2. 如果同一个配置属性，在多个不同名的配置文件中都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。\n 3. 创建SpringBoot项目时，一般配置文件都放置在“项目的resources目录下”\n\n\n# 3、springBoot的{prifile}文件时是如何加载的？如:（application-dev.yml）\n\n每次加载配置文件时都会先读取 spring.profiles.active属性，如果存在则将该配置文件装载到 加载队列的首位，然后在下次循环时进行寻找加载。\n\n\n# 4、不同位置的配置文件配置了相同的属性时 将如何加载？\n\n * 当无spring.profiles.active 时， 先读取到的属性会先生效。例如：file:./config/配置端口 8080 ；file:./配置端口8081；classpath:/config/配置端口8082 ；classpath:/配置的端口为8083 。根据上文的讲解最先读取到的时 file:./config/的8080，后面再次读取后该属性并不会生效。所以最终的配置端口为8080 (并不是后读取到到配置文件不加载，会加载；但是不生效)\n * 当有spring.profiles.active 时，配置了相同属性时是profiles上的配置生效。例如：file:./config/上的yml配置了端口 8080 但是存在 spring.profiles.active属性 dev;然后我们在dev上也配置来一个端口 8081.此时生效的为8081.\n\n\n# 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？\n\n会有效果。会是互补配置。即先加载先生效，后加载的不同配置产生互补效果。\n\n例如：file:./config/配置了端口8080；file:./配置了访问路径/path。最总二者的配置会达成并集的效果。即二者都生效。",normalizedContent:" * 配置文件所在的位置\n * 配置文件的名字\n   * 1、springboot何时加载配置文件？\n   * 2、springboot加载配置文件时，不同位置及不同后缀的配置文件如何加载？\n   * 3、springboot的{prifile}文件时是如何加载的？如:（application-dev.yml）\n   * 4、不同位置的配置文件配置了相同的属性时 将如何加载？\n   * 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？\n\n\n\nspringboot 默认支持 properties 和 yaml 两种格式的配置文件，并且有 bootstrap 和 application 两种配置文件。\n\nbootstrap 配置文件先于 application 配置文件被加载，会先创建初始化 bootstrap context，再创建初始化 application context，应用于更早期的配置信息，可以理解为系统配置。\n\nbootstrap 和 application 共享同一个 environment，默认情况下，bootstrap 的配置不会被覆盖，而 application 的配置项可以被覆盖。（比如被 application-dev 覆盖，或被 java 命令行覆盖）\n\n\n# 配置文件所在的位置\n\n默认值为：classpath:/, classpath:/config/, file:./, file:./config/ （优先级从低到高），最先加载file:./config/ 位置的配置文件；如果配置了spring.config.location属性则取这个属性的值。\n\n加载顺序如下：优先级由高到底，如果所有文件某个字段配置了一样的信息，高优先级的配置会覆盖低优先级的配置，但是加载的时候其他字段会进行互补配置；\n\n\n\n项目打包好以后，我们还可以使用命令行参数的形式，在启动项目的时候来指定配置文件的新位置；\n\n用指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；\n\n例如：java -jar spring-boot-config-demo.jar --spring.config.location=g:/application.properties\n\n还可以在 java 命令中覆盖配置项（这里指定了新的 port 和 profile）：\n\njava -jar spring-boot-config-demo.jar --spring.profiles.active=prod --server.port=8081\n\n\n# 配置文件的名字\n\n默认值为：application; 如果配置了spring.config.name属性则取改属性值。\n\n所有的扩展名：properties xml yml yaml\n\n加载顺序如下（优先级从低到高）： properties -> xml -> yml -> yaml\n\n加载时候到的拼接过程为 location + name + “.” +ext\n\nlocation : 指的就是上面提到配置文件所在的位置。 name： 指的就是配置文件的名称 默认就是appliction。 ext: 指的就是后缀名。 然后对拼接后的资源路径进行加载。\n\n小结： 上面加载的总体过程就是两层循环，外层控制加载配置文件位置的顺序，在相同位置时，内层就是控制后缀名不同时的加载顺序。\n\n理解了上面的原理，然后主要针对如下几个问题进行回答\n\n\n# 1、springboot何时加载配置文件？\n\n在容器启动时，会有方法调用所有监听器的onapplicationevent方法。然后与配置加载相关的configfileapplicationlistener的对应方法就会被加载，执行读取配置文件操作。\n\n\n# 2、springboot加载配置文件时，不同位置及不同后缀的配置文件如何加载？\n\nclasspath:/, classpath:/config/, file:./, file:./config/ （优先级从低到高）\n\nproperties -> xml -> yml -> yaml（优先级从低到高）\n\n加载顺序如下：\n\n 1. config/application.properties（项目根目录中config目录下）\n 2. config/application.yml\n 3. application.properties（项目根目录下）\n 4. application.yml\n 5. resources/config/application.properties（项目resources目录中config目录下）\n 6. resources/config/application.yml\n 7. resources/application.properties（项目的resources目录下）\n 8. resources/application.yml\n\n注：\n\n 1. 如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。\n 2. 如果同一个配置属性，在多个不同名的配置文件中都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。\n 3. 创建springboot项目时，一般配置文件都放置在“项目的resources目录下”\n\n\n# 3、springboot的{prifile}文件时是如何加载的？如:（application-dev.yml）\n\n每次加载配置文件时都会先读取 spring.profiles.active属性，如果存在则将该配置文件装载到 加载队列的首位，然后在下次循环时进行寻找加载。\n\n\n# 4、不同位置的配置文件配置了相同的属性时 将如何加载？\n\n * 当无spring.profiles.active 时， 先读取到的属性会先生效。例如：file:./config/配置端口 8080 ；file:./配置端口8081；classpath:/config/配置端口8082 ；classpath:/配置的端口为8083 。根据上文的讲解最先读取到的时 file:./config/的8080，后面再次读取后该属性并不会生效。所以最终的配置端口为8080 (并不是后读取到到配置文件不加载，会加载；但是不生效)\n * 当有spring.profiles.active 时，配置了相同属性时是profiles上的配置生效。例如：file:./config/上的yml配置了端口 8080 但是存在 spring.profiles.active属性 dev;然后我们在dev上也配置来一个端口 8081.此时生效的为8081.\n\n\n# 5、不同位置到配置文件，设置不同属性时，后加载的文件是否会生效？\n\n会有效果。会是互补配置。即先加载先生效，后加载的不同配置产生互补效果。\n\n例如：file:./config/配置了端口8080；file:./配置了访问路径/path。最总二者的配置会达成并集的效果。即二者都生效。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"zk如何保证一致性及如何选举",frontmatter:{title:"zk如何保证一致性及如何选举",date:"2022-03-08T00:00:00.000Z",tags:["分布式","ZooKeeper"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html",relativePath:"views/backend/zk选举和一致性.md",key:"v-d12af5d4",path:"/views/backend/zk%E9%80%89%E4%B8%BE%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7.html",headers:[{level:2,title:"Zookeeper如何保证数据一致性",slug:"zookeeper如何保证数据一致性",normalizedTitle:"zookeeper如何保证数据一致性",charIndex:3},{level:2,title:"ZAB的崩溃恢复机制",slug:"zab的崩溃恢复机制",normalizedTitle:"zab的崩溃恢复机制",charIndex:25},{level:2,title:"ZAB恢复中删除数据机制",slug:"zab恢复中删除数据机制",normalizedTitle:"zab恢复中删除数据机制",charIndex:39},{level:2,title:"ZK选主过程",slug:"zk选主过程",normalizedTitle:"zk选主过程",charIndex:55},{level:2,title:"FAQ",slug:"faq",normalizedTitle:"faq",charIndex:65}],excerpt:"<Boxx/>\n",headersStr:"Zookeeper如何保证数据一致性 ZAB的崩溃恢复机制 ZAB恢复中删除数据机制 ZK选主过程 FAQ",content:" * Zookeeper如何保证数据一致性\n * ZAB的崩溃恢复机制\n * ZAB恢复中删除数据机制\n * ZK选主过程\n * FAQ\n\n\n\n\n# Zookeeper如何保证数据一致性\n\nZooKeeper保证数据一致性用的是ZAB协议。通过这个协议来进行ZooKeeper集群间的数据同步，保证数据的一致性。\n\n\n\n两阶段提交+过半写机制：\n\n 1. ZooKeeper写数据的机制是客户端 把写请求发送到leader节点上（如果发送的是follower节点，follower节点会把写请求转发到leader节点）\n 2. leader节点会把数据通过proposal请求 发送到所有节点（包括自己）\n 3. 所有到节点接受到数据以后都 持久化 会写到自己到本地磁盘上面，写好了以后会发送一个 ack 请求给leader\n 4. leader只要接受到 过半的节点发送ack响应 回来，就会发送 commit 消息给各个节点，各个节点就会把消息放入到内存中（放内存是为了保证高性能），该消息就会用户可见了。\n\n那么这个时候，如果ZooKeeper要想保证数据一致性，就需要考虑如下两个情况：\n\n * 情况一：leader执行commit了，还没来得及给follower发送commit的时候，leader宕机了，这个时候如何保证消息一致性？\n * 情况二：客户端把消息写到leader了，但是leader还没发送proposal消息给其他节点，这个时候leader宕机了，leader宕机后恢复的时候此消息又该如何处理？\n\n\n# ZAB的崩溃恢复机制\n\n针对情况一，当leader宕机以后，ZooKeeper会选举出来新的leader，新的leader启动以后要到磁盘上面去检查是否存在没有commit的消息。\n\n如果存在，就继续检查看其他follower有没有对这条消息进行了commit，如果有过半节点对这条消息进行了ack，但是没有commit，那么新leader通知follower要完成commit的操作。\n\n\n# ZAB恢复中删除数据机制\n\n针对情况二，客户端把消息写到leader了，但是leader还没发送portal消息给其他节点，这个时候leader宕机了，这个时候对于用户来说，这条消息是写失败的。\n\n假设过了一段时间以后leader节点又恢复了，不过这个时候角色就变为了follower了，它在检查自己磁盘的时候会发现自己有一条消息没有进行commit，此时就会检测消息的编号。\n\n消息是有编号的，由高32位和低32位组成，高32位是用来体现是否发生过leader切换的，低32位就是展示消息的顺序的。这个时候当前的节点就会根据高32位知道目前leader已经切换过了，所以就把当前的消息删除，然后从新的leader同步数据，这样保证了数据一致性。\n\n\n# ZK选主过程\n\n规则：\n\n 1. 初始阶段，都会给自己投票。\n\n 2. 当接收到来自其他服务器的投票时，都需要将别人的投票和自己的投票进行pk，规则如下：\n    \n    优先检查zxid。zxid比较大的服务器优先作为leader。如果zxid相同的话，就比较sid，sid比较大的服务器作为leader。\n\n举例：\n\n假设当前集群中有5台机器组成。\n\nsid（用来标识该机器在集群中的机器序号）分别为1，2，3，4，5。\n\nzxid（即zookeeper事务id号。ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid）分别为9，9，9，8，8。\n\n并且此时sid为2的机器是leader。\n\n某一时刻，1和2的服务器挂掉了，集群开始进行选主。\n\n * 在第一次投票中，由于无法检测到集群中其他机器的状态信息，因此每台机器都将自己作为被推举的对象来进行投票。于是sid为3，4，5的机器，投票情况分别为（3，9），（4，8），（5，8）\n * 每台机器把投票发出后，同时也会接收到来自另外两台机器的投票。\n * 对于server3来说，接收到（4，8），（5，8）的投票，对比后由于自己的zxid要大于收到的另外两个投票，因此不需要做任何变更。\n * 对于server4来说，接收到（3，9），（5，8）的投票，对比后由于（3，9）这个投票的zxid大于自己，因此需要变更投票为（3，9），然后继续将这个投票发送给另外两台机器。\n * 对于server5来说，接收到（3，9），（4，8）的投票，对比后由于（3，9）这个投票的zxid大于自己，因此需要变更投票为（3，9），然后继续将这个投票发送给另外两台机器。\n * 经过第二轮投票后，集群中的每台机器都会再次受到其他机器的投票，然后开始统计投票。判断是否有过半的机器收到相同的投票信息，如果有，那么该投票的sid会成为新的leader。\n * 机器总数为5台，server3，4，5都收到投票（3，9）。因此server3成为leader。\n\n\n# FAQ\n\nQ:\n\n * 1.同一个客户端，先发出写请求，leader将写请求事务广播给follow，如果半数follow成功，但是发出请求的follow没有成功，按照半数即成功的原理，leader会返回写操作成功，此时该客户端再读取数据，导致读取到的是旧的值，不符合同一个session写后读的保证，此时该怎么办？\n\n * 2.leader对于一个事务在本地提交了，但是还没广播就down机了，那么从其余follow中选出的leader如何保证这个事务也被提交？\n   \n   zab在崩溃选择时，根据什么决定proposal该被抛弃或者该被提交？比如最开始有5台server, leader把日志复制到了另外2台，leader在本地提交日志（或者还没来得及提交），然后立即挂了。剩下4台server, 有2台有这个日志，有2台没有，那么这个日志要不要保留？\n\nA:\n\n * 1.zookeeper不保证读一致性，是弱一致性，如果要保证读到的数据是最新的，读取之前要使用sync方法\n\n * 2.旧leader commit完就挂掉了，因为写入的follower肯定超过一半，新leader具有最大zxid，因此新leader就拥有commit的proposal，这时候只要提交该proposal并进行同步即可。如果旧leader只同步了一个follower就挂掉，该follower就是新leader，新leader同步该proposal然后同步即可。如果旧leader还没来得及同步就挂掉，该proposal在新集群中也不会存在，也不会成功，因此当旧leader恢复时就会被rollback。\n   \n   只要数据被写进新leader的log了，均不会丢失，zk只要选出了leader，数据就是从leader这里为准了。leader的选举规则可以额外看看，总之就是zxid最大的当选。那么什么数据会被同步呢？只要被记录到log中的事务都不会丢失。那么可能你会疑问，如果事务没提交呢？ leader在做restore的时候，会将日志中的proposal重新广播。",normalizedContent:" * zookeeper如何保证数据一致性\n * zab的崩溃恢复机制\n * zab恢复中删除数据机制\n * zk选主过程\n * faq\n\n\n\n\n# zookeeper如何保证数据一致性\n\nzookeeper保证数据一致性用的是zab协议。通过这个协议来进行zookeeper集群间的数据同步，保证数据的一致性。\n\n\n\n两阶段提交+过半写机制：\n\n 1. zookeeper写数据的机制是客户端 把写请求发送到leader节点上（如果发送的是follower节点，follower节点会把写请求转发到leader节点）\n 2. leader节点会把数据通过proposal请求 发送到所有节点（包括自己）\n 3. 所有到节点接受到数据以后都 持久化 会写到自己到本地磁盘上面，写好了以后会发送一个 ack 请求给leader\n 4. leader只要接受到 过半的节点发送ack响应 回来，就会发送 commit 消息给各个节点，各个节点就会把消息放入到内存中（放内存是为了保证高性能），该消息就会用户可见了。\n\n那么这个时候，如果zookeeper要想保证数据一致性，就需要考虑如下两个情况：\n\n * 情况一：leader执行commit了，还没来得及给follower发送commit的时候，leader宕机了，这个时候如何保证消息一致性？\n * 情况二：客户端把消息写到leader了，但是leader还没发送proposal消息给其他节点，这个时候leader宕机了，leader宕机后恢复的时候此消息又该如何处理？\n\n\n# zab的崩溃恢复机制\n\n针对情况一，当leader宕机以后，zookeeper会选举出来新的leader，新的leader启动以后要到磁盘上面去检查是否存在没有commit的消息。\n\n如果存在，就继续检查看其他follower有没有对这条消息进行了commit，如果有过半节点对这条消息进行了ack，但是没有commit，那么新leader通知follower要完成commit的操作。\n\n\n# zab恢复中删除数据机制\n\n针对情况二，客户端把消息写到leader了，但是leader还没发送portal消息给其他节点，这个时候leader宕机了，这个时候对于用户来说，这条消息是写失败的。\n\n假设过了一段时间以后leader节点又恢复了，不过这个时候角色就变为了follower了，它在检查自己磁盘的时候会发现自己有一条消息没有进行commit，此时就会检测消息的编号。\n\n消息是有编号的，由高32位和低32位组成，高32位是用来体现是否发生过leader切换的，低32位就是展示消息的顺序的。这个时候当前的节点就会根据高32位知道目前leader已经切换过了，所以就把当前的消息删除，然后从新的leader同步数据，这样保证了数据一致性。\n\n\n# zk选主过程\n\n规则：\n\n 1. 初始阶段，都会给自己投票。\n\n 2. 当接收到来自其他服务器的投票时，都需要将别人的投票和自己的投票进行pk，规则如下：\n    \n    优先检查zxid。zxid比较大的服务器优先作为leader。如果zxid相同的话，就比较sid，sid比较大的服务器作为leader。\n\n举例：\n\n假设当前集群中有5台机器组成。\n\nsid（用来标识该机器在集群中的机器序号）分别为1，2，3，4，5。\n\nzxid（即zookeeper事务id号。zookeeper状态的每一次改变, 都对应着一个递增的transaction id, 该id称为zxid）分别为9，9，9，8，8。\n\n并且此时sid为2的机器是leader。\n\n某一时刻，1和2的服务器挂掉了，集群开始进行选主。\n\n * 在第一次投票中，由于无法检测到集群中其他机器的状态信息，因此每台机器都将自己作为被推举的对象来进行投票。于是sid为3，4，5的机器，投票情况分别为（3，9），（4，8），（5，8）\n * 每台机器把投票发出后，同时也会接收到来自另外两台机器的投票。\n * 对于server3来说，接收到（4，8），（5，8）的投票，对比后由于自己的zxid要大于收到的另外两个投票，因此不需要做任何变更。\n * 对于server4来说，接收到（3，9），（5，8）的投票，对比后由于（3，9）这个投票的zxid大于自己，因此需要变更投票为（3，9），然后继续将这个投票发送给另外两台机器。\n * 对于server5来说，接收到（3，9），（4，8）的投票，对比后由于（3，9）这个投票的zxid大于自己，因此需要变更投票为（3，9），然后继续将这个投票发送给另外两台机器。\n * 经过第二轮投票后，集群中的每台机器都会再次受到其他机器的投票，然后开始统计投票。判断是否有过半的机器收到相同的投票信息，如果有，那么该投票的sid会成为新的leader。\n * 机器总数为5台，server3，4，5都收到投票（3，9）。因此server3成为leader。\n\n\n# faq\n\nq:\n\n * 1.同一个客户端，先发出写请求，leader将写请求事务广播给follow，如果半数follow成功，但是发出请求的follow没有成功，按照半数即成功的原理，leader会返回写操作成功，此时该客户端再读取数据，导致读取到的是旧的值，不符合同一个session写后读的保证，此时该怎么办？\n\n * 2.leader对于一个事务在本地提交了，但是还没广播就down机了，那么从其余follow中选出的leader如何保证这个事务也被提交？\n   \n   zab在崩溃选择时，根据什么决定proposal该被抛弃或者该被提交？比如最开始有5台server, leader把日志复制到了另外2台，leader在本地提交日志（或者还没来得及提交），然后立即挂了。剩下4台server, 有2台有这个日志，有2台没有，那么这个日志要不要保留？\n\na:\n\n * 1.zookeeper不保证读一致性，是弱一致性，如果要保证读到的数据是最新的，读取之前要使用sync方法\n\n * 2.旧leader commit完就挂掉了，因为写入的follower肯定超过一半，新leader具有最大zxid，因此新leader就拥有commit的proposal，这时候只要提交该proposal并进行同步即可。如果旧leader只同步了一个follower就挂掉，该follower就是新leader，新leader同步该proposal然后同步即可。如果旧leader还没来得及同步就挂掉，该proposal在新集群中也不会存在，也不会成功，因此当旧leader恢复时就会被rollback。\n   \n   只要数据被写进新leader的log了，均不会丢失，zk只要选出了leader，数据就是从leader这里为准了。leader的选举规则可以额外看看，总之就是zxid最大的当选。那么什么数据会被同步呢？只要被记录到log中的事务都不会丢失。那么可能你会疑问，如果事务没提交呢？ leader在做restore的时候，会将日志中的proposal重新广播。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"多线程和线程池基础",frontmatter:{title:"多线程和线程池基础",date:"2019-07-15T21:51:41.000Z",tags:["多线程","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/thread.html",relativePath:"views/backend/thread.md",key:"v-3c54cc77",path:"/views/backend/thread.html",headers:[{level:2,title:"多线程",slug:"多线程",normalizedTitle:"多线程",charIndex:3},{level:2,title:"多线程创建方式",slug:"多线程创建方式",normalizedTitle:"多线程创建方式",charIndex:10},{level:3,title:"继承 Thread 类",slug:"继承-thread-类",normalizedTitle:"继承 thread 类",charIndex:23},{level:3,title:"实现 Runable 接口",slug:"实现-runable-接口",normalizedTitle:"实现 runable 接口",charIndex:40},{level:3,title:"实现 Callable 接口",slug:"实现-callable-接口",normalizedTitle:"实现 callable 接口",charIndex:59},{level:2,title:"自己造一个并发实例",slug:"自己造一个并发实例",normalizedTitle:"自己造一个并发实例",charIndex:77},{level:2,title:"实现线程同步的几种方式",slug:"实现线程同步的几种方式",normalizedTitle:"实现线程同步的几种方式",charIndex:90},{level:2,title:"利用java工具查看死锁",slug:"利用java工具查看死锁",normalizedTitle:"利用java工具查看死锁",charIndex:105},{level:2,title:"创建线程池的几种方式",slug:"创建线程池的几种方式",normalizedTitle:"创建线程池的几种方式",charIndex:121},{level:2,title:"线程池的基本使用",slug:"线程池的基本使用",normalizedTitle:"线程池的基本使用",charIndex:135}],headersStr:"多线程 多线程创建方式 继承 Thread 类 实现 Runable 接口 实现 Callable 接口 自己造一个并发实例 实现线程同步的几种方式 利用java工具查看死锁 创建线程池的几种方式 线程池的基本使用",content:' * 多线程\n * 多线程创建方式\n   * 继承 Thread 类\n   * 实现 Runable 接口\n   * 实现 Callable 接口\n * 自己造一个并发实例\n * 实现线程同步的几种方式\n * 利用java工具查看死锁\n * 创建线程池的几种方式\n * 线程池的基本使用\n\n\n\n\n# 多线程\n\n * 这篇介绍了什么是多线程及多线程的实现方式和常用方法，写的很详细，特在此记录一下\n   \n   https://blog.csdn.net/vbirdbest/article/details/81282163\n\n\n# 多线程创建方式\n\n * 如看过上文地址，可跳过此节直接看下一节自己造一个并发实例，后面才是干货！\n\n\n# 继承 Thread 类\n\npublic class Main {\n    public static void main(String[] args) {\n        new MyThread().start();\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + "\\t" + Thread.currentThread().getId());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 实现 Runable 接口\n\n * 第一种方式是继承Thread类，因Java是单继承，如果一个类继承了Thread类，那么就没办法继承其它的类了，在继承上有一点受制，有一点不灵活，第二种方式就是为了解决第一种方式的单继承不灵活的问题，所以平常使用就使用第二种方式\n\npublic class Main {\n    public static void main(String[] args) {\n         // 将Runnable实现类作为Thread的构造参数传递到Thread类中，然后启动Thread类\n        MyRunnable runnable = new MyRunnable();\n        new Thread(runnable).start();\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + "\\t" + Thread.currentThread().getId());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 实现 Callable 接口\n\n * 重写call()方法，然后包装成java.util.concurrent.FutureTask, 再然后包装成Thread\n * Callable：有返回值并且能捕获异常，能取消线程，可以判断线程是否执行完毕\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n         // 将Callable包装成FutureTask，FutureTask也是一种Runnable\n        MyCallable callable = new MyCallable();\n        FutureTask<Integer> futureTask = new FutureTask<>(callable);\n        new Thread(futureTask).start();\n\n        // get方法会阻塞调用的线程\n        Integer sum = futureTask.get();\n        System.out.println(Thread.currentThread().getName() + Thread.currentThread().getId() + "=" + sum);\n    }\n}\n\nclass MyCallable implements Callable<Integer> {\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName() + "\\t" + Thread.currentThread().getId() + "\\t" + new Date() + " \\tstarting...");\n\n        int sum = 0;\n        for (int i = 0; i <= 100000; i++) {\n            sum += i;\n        }\n        Thread.sleep(5000);\n\n        System.out.println(Thread.currentThread().getName() + "\\t" + Thread.currentThread().getId() + "\\t" + new Date() + " \\tover...");\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 自己造一个并发实例\n\n * 有人可能对多线程及并发还不是很了解，那么就简单上手一个并发实例来体验一下吧！\n\n * 注意：下边的例子，自己多运行几次，看一下不同的结果\n   \n   >  1. 当对现场加锁的时候就不会并发：\n   >     * 打印结果：张曼玉：女士 / 梁朝伟：先生\n   >  2. 而如果对线程不加锁的话，就可能会造成并发：\n   >     * 打印结果：张曼玉：先生 / 梁朝伟：女士\n   >     * 打印结果：张曼玉：女士 / 梁朝伟：先生\n\n/**\n * @className: TestThreadPool\n * @descripe: 自己造一个并发的例子\n * @author: zpj\n * @date: 2019/7/8\n * @version: 1.0\n */\npublic class TestConcurrentError{\n\tpublic static void main(String[] args){\n\t\tStudent stu = new Student("张曼玉","女士");\n\t\tPrintThread pt = new PrintThread(stu);\n\t\tChangeThread ct = new ChangeThread(stu);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass Student{\n\tString name;\n\tString gender;\n\tpublic Student(String name,String gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n\nclass PrintThread extends Thread{\n\tStudent stu;\n\tpublic PrintThread(Student stu){\n\t\tthis.stu = stu;\n\t}\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\t//synchronized(stu){\n\t\t\t{\n\t\t\t\tSystem.out.println(stu.name + " : " + stu.gender);\n\t\t\t}\n\t\t}\n\t}\n}\nclass ChangeThread extends Thread{\n\tStudent stu;\n\tpublic ChangeThread(Student stu){\n\t\tthis.stu = stu;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tboolean isOkay = true;\n\t\twhile(true){\n\t\t\t//synchronized(stu){\n\t\t\t{\n\t\t\t\tif(isOkay){\n\t\t\t\t\tstu.name = "梁朝伟";//梁朝伟 女士\n\t\t\t\t\tstu.gender = "先生";//梁朝伟 先生\n\t\t\t\t}else{\n\t\t\t\t\tstu.name = "张曼玉";//张曼玉 先生\n\t\t\t\t\tstu.gender = "女士";//张曼玉 女士\n\t\t\t\t}\n\t\t\t\tisOkay = !isOkay;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# 实现线程同步的几种方式\n\n通过上面的实例我们知道了并发是怎么产生的，那我们如何解决呢？那就是使线程同步或给线程加锁呗！\n\n * 实现线程同步的几种方式：\n\n 1. 使用synchronized关键字\n    \n    synchronized既可以修饰方法也可以修饰代码块，用synchronized 关键字时一定要注意用于保护共享数据，防止造成资源浪费（synchronized 本来效率就不高）\n\n 2. wait()和notify() => 相当于引入等待池\n    \n    wait()：Object类的方法，使一个线程处于等待状态，并且释放所持有的对象的lock。\n    \n    sleep(1000)：Thread类的方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。 Allnotity()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。\n    \n    **注意：**wait、notify和notifyAll方法只能在同步方法或者同步代码块中使用，而sleep方法可以在任何地方使用。\n\n 3. 使用java.util.concurrent.ReentrantLock重入锁实现线程同步\n    \n    \tprivate int account = 100;\n    \t//获得锁对象\n    \tprivate ReentrantLock lock = new ReentrantLock();\n    \tpublic int getAccount() {\n    \t\treturn account;\n    \t}\n    \t//同步方法\n    \tpublic  void save(int money) {\n    \t\tlock.lock();//加锁\n    \t\ttry {\n    \t\t\taccount+=money;\n    \t\t} finally {\n    \t\t\tlock.unlock();//解锁\n    \t\t}\n    \t\t\n    \t}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 利用java工具查看死锁\n\n 1. 图形界面：jconsole.exe\n\n 2. 命令行：jps 和 jstack\n\n\n# 创建线程池的几种方式\n\n * 既然都了解到线程并发了，那怎么能不了解了解线程池呢！😄\n * java.util.concurrent.Executors类，这个类是用来创建线程池的：\n\n 1. newFixedThreadPool()\n    \n    创建固定大小的线程池 线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程\n\n 2. newCachedThreadPool()\n    \n    创建一个可缓存的线程池，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60s不执行任务)的线程，当任务数量增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于系统（JVM）能够创建的最大线程大小\n\n 3. newSingleThreadExecutor()\n    \n    创建一个单线程的线程池。这个线程池只有线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行\n\n 4. newScheduledThreadPool()\n    \n    创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求\n\n 5. newSingleThreadScheduledExecutor()\n    \n    创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求\n\n\n# 线程池的基本使用\n\nimport java.text.SimpleDateFormat;\nimport java.util.concurrent.*;\n\n/**\n * @className: TestThreadPool\n * @descripe: 多线程的基本使用\n * @author: zpj\n * @date: 2019/7/8\n * @version: 1.0\n */\npublic class TestThreadPool {\n\n    /*  打印结果：多个线程同时开始\n        Thread:pool-1-thread-2 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <1>\n        Thread:pool-1-thread-1 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <0>\n        Thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:31\n        Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <2>\n        Thread:pool-1-thread-5 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <4>\n        Thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:31\n            ==  I\'m a cat!  ==     <5>\n        Thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:32\n            ==  I\'m a cat!  ==     <6>\n        Thread:pool-1-thread-5 开始执行时间：2019-07-08 22:14:32\n            ==  I\'m a cat!  ==     <7>\n        Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:32\n        Thread:pool-1-thread-1 开始执行时间：2019-07-08 22:14:32\n        Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:32\n            ==  I\'m a cat!  ==     <9>\n            ==  I\'m a cat!  ==     <10>\n\n     */\n    public static void main(String[] args) throws InterruptedException {\n\n        //要循环的次数\n        int x = 10;\n\n        //ExecutorService executorService = Executors.newFixedThreadPool(1);//单线程\n        ExecutorService executorService = Executors.newFixedThreadPool(5);//多线程\n\n        //线程计数器\n        CountDownLatch downLatch = new CountDownLatch(x);\n\n        System.out.println("多线程执行开始！");\n        for (int i = 0;i <= x;i++) {\n            Future<?> future = executorService.submit(new Cat(i, downLatch));\n            /*\n            //加上它就变同步了，不知道为啥（百度咯，因为这是个阻塞的方法，future.isDone();是个非阻塞方法）\n            try {\n                if(future.get()==null){\n                    System.out.println("第   "+i+"   个任务执行成功!\\n");\n                }\n            } catch (ExecutionException e) {\n                System.out.println("第   "+i+"   个任务执行失败!    " + e.getMessage() + "\\n");\n            }*/\n        }\n        System.out.println("这就证明：多线程是异步执行的！");\n        downLatch.await();\n        executorService.shutdown();\n    }\n\n   /* public static void main(String[] args) throws InterruptedException {\n\n        //要循环的次数\n        int x = 10;\n\n        //ExecutorService executorService = Executors.newFixedThreadPool(1);//单线程\n        ExecutorService executorService = Executors.newFixedThreadPool(5);//多线程\n\n        //线程计数器\n        CountDownLatch downLatch = new CountDownLatch(x);\n\n        for (int i = 0;i <= x;i++) {\n            executorService.execute(new Cat(i, downLatch));\n        }\n        *//*\n         *  打印结果：可以看到多个线程基本同时开始执行\n            Exception in thread "pool-1-thread-4" java.lang.ArithmeticException: / by zero\n                at Cat.run(TestThreadPool.java:141)\n                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n                at java.lang.Thread.run(Thread.java:745)\n            Thread:pool-1-thread-1 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <0>\n            Thread:pool-1-thread-2 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <1>\n            Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <2>\n            Thread:pool-1-thread-4 开始执行时间：2019-07-08 22:00:39\n            Thread:pool-1-thread-5 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <4>\n            Thread:pool-1-thread-6 开始执行时间：2019-07-08 22:00:39\n                ==  I\'m a cat!  ==     <5>\n            Exception in thread "pool-1-thread-3" java.lang.ArithmeticException: / by zero\n            Thread:pool-1-thread-1 开始执行时间：2019-07-08 22:00:40\n                at Cat.run(TestThreadPool.java:141)\n                ==  I\'m a cat!  ==     <6>\n                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n            Thread:pool-1-thread-2 开始执行时间：2019-07-08 22:00:40\n                at java.lang.Thread.run(Thread.java:745)\n                ==  I\'m a cat!  ==     <7>\n            Thread:pool-1-thread-3 开始执行时间：2019-07-08 22:00:40\n            Thread:pool-1-thread-6 开始执行时间：2019-07-08 22:00:40\n                ==  I\'m a cat!  ==     <10>\n            Thread:pool-1-thread-5 开始执行时间：2019-07-08 22:00:40\n                ==  I\'m a cat!  ==     <9>\n            *//*\n        downLatch.await();\n        executorService.shutdown();\n    }*/\n\n}\n\nclass Cat implements Runnable {\n\n    int i;\n    private CountDownLatch downLatch;\n\n    public Cat(int i,CountDownLatch downLatch) {\n        this.i = i;\n        this.downLatch = downLatch;\n    }\n\n    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");\n\n    @Override\n    public void run() {\n        System.out.println("Thread:"+Thread.currentThread().getName()+" 开始执行时间："+format.format(System.currentTimeMillis()));\n\n        if(i == 8 || i == 3)\n            i = i/0;\n            System.out.println("    ==  I\'m a cat!  ==     <" + i + ">");\n        //每执行完一个线程 计数器就减1\n        downLatch.countDown();\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n',normalizedContent:' * 多线程\n * 多线程创建方式\n   * 继承 thread 类\n   * 实现 runable 接口\n   * 实现 callable 接口\n * 自己造一个并发实例\n * 实现线程同步的几种方式\n * 利用java工具查看死锁\n * 创建线程池的几种方式\n * 线程池的基本使用\n\n\n\n\n# 多线程\n\n * 这篇介绍了什么是多线程及多线程的实现方式和常用方法，写的很详细，特在此记录一下\n   \n   https://blog.csdn.net/vbirdbest/article/details/81282163\n\n\n# 多线程创建方式\n\n * 如看过上文地址，可跳过此节直接看下一节自己造一个并发实例，后面才是干货！\n\n\n# 继承 thread 类\n\npublic class main {\n    public static void main(string[] args) {\n        new mythread().start();\n    }\n}\n\nclass mythread extends thread {\n    @override\n    public void run() {\n        system.out.println(thread.currentthread().getname() + "\\t" + thread.currentthread().getid());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 实现 runable 接口\n\n * 第一种方式是继承thread类，因java是单继承，如果一个类继承了thread类，那么就没办法继承其它的类了，在继承上有一点受制，有一点不灵活，第二种方式就是为了解决第一种方式的单继承不灵活的问题，所以平常使用就使用第二种方式\n\npublic class main {\n    public static void main(string[] args) {\n         // 将runnable实现类作为thread的构造参数传递到thread类中，然后启动thread类\n        myrunnable runnable = new myrunnable();\n        new thread(runnable).start();\n    }\n}\n\nclass myrunnable implements runnable {\n    @override\n    public void run() {\n        system.out.println(thread.currentthread().getname() + "\\t" + thread.currentthread().getid());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 实现 callable 接口\n\n * 重写call()方法，然后包装成java.util.concurrent.futuretask, 再然后包装成thread\n * callable：有返回值并且能捕获异常，能取消线程，可以判断线程是否执行完毕\n\npublic class main {\n    public static void main(string[] args) throws exception {\n         // 将callable包装成futuretask，futuretask也是一种runnable\n        mycallable callable = new mycallable();\n        futuretask<integer> futuretask = new futuretask<>(callable);\n        new thread(futuretask).start();\n\n        // get方法会阻塞调用的线程\n        integer sum = futuretask.get();\n        system.out.println(thread.currentthread().getname() + thread.currentthread().getid() + "=" + sum);\n    }\n}\n\nclass mycallable implements callable<integer> {\n    @override\n    public integer call() throws exception {\n        system.out.println(thread.currentthread().getname() + "\\t" + thread.currentthread().getid() + "\\t" + new date() + " \\tstarting...");\n\n        int sum = 0;\n        for (int i = 0; i <= 100000; i++) {\n            sum += i;\n        }\n        thread.sleep(5000);\n\n        system.out.println(thread.currentthread().getname() + "\\t" + thread.currentthread().getid() + "\\t" + new date() + " \\tover...");\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 自己造一个并发实例\n\n * 有人可能对多线程及并发还不是很了解，那么就简单上手一个并发实例来体验一下吧！\n\n * 注意：下边的例子，自己多运行几次，看一下不同的结果\n   \n   >  1. 当对现场加锁的时候就不会并发：\n   >     * 打印结果：张曼玉：女士 / 梁朝伟：先生\n   >  2. 而如果对线程不加锁的话，就可能会造成并发：\n   >     * 打印结果：张曼玉：先生 / 梁朝伟：女士\n   >     * 打印结果：张曼玉：女士 / 梁朝伟：先生\n\n/**\n * @classname: testthreadpool\n * @descripe: 自己造一个并发的例子\n * @author: zpj\n * @date: 2019/7/8\n * @version: 1.0\n */\npublic class testconcurrenterror{\n\tpublic static void main(string[] args){\n\t\tstudent stu = new student("张曼玉","女士");\n\t\tprintthread pt = new printthread(stu);\n\t\tchangethread ct = new changethread(stu);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass student{\n\tstring name;\n\tstring gender;\n\tpublic student(string name,string gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n\nclass printthread extends thread{\n\tstudent stu;\n\tpublic printthread(student stu){\n\t\tthis.stu = stu;\n\t}\n\t@override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\t//synchronized(stu){\n\t\t\t{\n\t\t\t\tsystem.out.println(stu.name + " : " + stu.gender);\n\t\t\t}\n\t\t}\n\t}\n}\nclass changethread extends thread{\n\tstudent stu;\n\tpublic changethread(student stu){\n\t\tthis.stu = stu;\n\t}\n\t@override\n\tpublic void run(){\n\t\tboolean isokay = true;\n\t\twhile(true){\n\t\t\t//synchronized(stu){\n\t\t\t{\n\t\t\t\tif(isokay){\n\t\t\t\t\tstu.name = "梁朝伟";//梁朝伟 女士\n\t\t\t\t\tstu.gender = "先生";//梁朝伟 先生\n\t\t\t\t}else{\n\t\t\t\t\tstu.name = "张曼玉";//张曼玉 先生\n\t\t\t\t\tstu.gender = "女士";//张曼玉 女士\n\t\t\t\t}\n\t\t\t\tisokay = !isokay;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# 实现线程同步的几种方式\n\n通过上面的实例我们知道了并发是怎么产生的，那我们如何解决呢？那就是使线程同步或给线程加锁呗！\n\n * 实现线程同步的几种方式：\n\n 1. 使用synchronized关键字\n    \n    synchronized既可以修饰方法也可以修饰代码块，用synchronized 关键字时一定要注意用于保护共享数据，防止造成资源浪费（synchronized 本来效率就不高）\n\n 2. wait()和notify() => 相当于引入等待池\n    \n    wait()：object类的方法，使一个线程处于等待状态，并且释放所持有的对象的lock。\n    \n    sleep(1000)：thread类的方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉interruptedexception异常。 notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由jvm确定唤醒哪个线程，而且不是按优先级。 allnotity()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。\n    \n    **注意：**wait、notify和notifyall方法只能在同步方法或者同步代码块中使用，而sleep方法可以在任何地方使用。\n\n 3. 使用java.util.concurrent.reentrantlock重入锁实现线程同步\n    \n    \tprivate int account = 100;\n    \t//获得锁对象\n    \tprivate reentrantlock lock = new reentrantlock();\n    \tpublic int getaccount() {\n    \t\treturn account;\n    \t}\n    \t//同步方法\n    \tpublic  void save(int money) {\n    \t\tlock.lock();//加锁\n    \t\ttry {\n    \t\t\taccount+=money;\n    \t\t} finally {\n    \t\t\tlock.unlock();//解锁\n    \t\t}\n    \t\t\n    \t}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n\n# 利用java工具查看死锁\n\n 1. 图形界面：jconsole.exe\n\n 2. 命令行：jps 和 jstack\n\n\n# 创建线程池的几种方式\n\n * 既然都了解到线程并发了，那怎么能不了解了解线程池呢！😄\n * java.util.concurrent.executors类，这个类是用来创建线程池的：\n\n 1. newfixedthreadpool()\n    \n    创建固定大小的线程池 线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程\n\n 2. newcachedthreadpool()\n    \n    创建一个可缓存的线程池，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60s不执行任务)的线程，当任务数量增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于系统（jvm）能够创建的最大线程大小\n\n 3. newsinglethreadexecutor()\n    \n    创建一个单线程的线程池。这个线程池只有线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行\n\n 4. newscheduledthreadpool()\n    \n    创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求\n\n 5. newsinglethreadscheduledexecutor()\n    \n    创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求\n\n\n# 线程池的基本使用\n\nimport java.text.simpledateformat;\nimport java.util.concurrent.*;\n\n/**\n * @classname: testthreadpool\n * @descripe: 多线程的基本使用\n * @author: zpj\n * @date: 2019/7/8\n * @version: 1.0\n */\npublic class testthreadpool {\n\n    /*  打印结果：多个线程同时开始\n        thread:pool-1-thread-2 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <1>\n        thread:pool-1-thread-1 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <0>\n        thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:31\n        thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <2>\n        thread:pool-1-thread-5 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <4>\n        thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:31\n            ==  i\'m a cat!  ==     <5>\n        thread:pool-1-thread-4 开始执行时间：2019-07-08 22:14:32\n            ==  i\'m a cat!  ==     <6>\n        thread:pool-1-thread-5 开始执行时间：2019-07-08 22:14:32\n            ==  i\'m a cat!  ==     <7>\n        thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:32\n        thread:pool-1-thread-1 开始执行时间：2019-07-08 22:14:32\n        thread:pool-1-thread-3 开始执行时间：2019-07-08 22:14:32\n            ==  i\'m a cat!  ==     <9>\n            ==  i\'m a cat!  ==     <10>\n\n     */\n    public static void main(string[] args) throws interruptedexception {\n\n        //要循环的次数\n        int x = 10;\n\n        //executorservice executorservice = executors.newfixedthreadpool(1);//单线程\n        executorservice executorservice = executors.newfixedthreadpool(5);//多线程\n\n        //线程计数器\n        countdownlatch downlatch = new countdownlatch(x);\n\n        system.out.println("多线程执行开始！");\n        for (int i = 0;i <= x;i++) {\n            future<?> future = executorservice.submit(new cat(i, downlatch));\n            /*\n            //加上它就变同步了，不知道为啥（百度咯，因为这是个阻塞的方法，future.isdone();是个非阻塞方法）\n            try {\n                if(future.get()==null){\n                    system.out.println("第   "+i+"   个任务执行成功!\\n");\n                }\n            } catch (executionexception e) {\n                system.out.println("第   "+i+"   个任务执行失败!    " + e.getmessage() + "\\n");\n            }*/\n        }\n        system.out.println("这就证明：多线程是异步执行的！");\n        downlatch.await();\n        executorservice.shutdown();\n    }\n\n   /* public static void main(string[] args) throws interruptedexception {\n\n        //要循环的次数\n        int x = 10;\n\n        //executorservice executorservice = executors.newfixedthreadpool(1);//单线程\n        executorservice executorservice = executors.newfixedthreadpool(5);//多线程\n\n        //线程计数器\n        countdownlatch downlatch = new countdownlatch(x);\n\n        for (int i = 0;i <= x;i++) {\n            executorservice.execute(new cat(i, downlatch));\n        }\n        *//*\n         *  打印结果：可以看到多个线程基本同时开始执行\n            exception in thread "pool-1-thread-4" java.lang.arithmeticexception: / by zero\n                at cat.run(testthreadpool.java:141)\n                at java.util.concurrent.threadpoolexecutor.runworker(threadpoolexecutor.java:1142)\n                at java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:617)\n                at java.lang.thread.run(thread.java:745)\n            thread:pool-1-thread-1 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <0>\n            thread:pool-1-thread-2 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <1>\n            thread:pool-1-thread-3 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <2>\n            thread:pool-1-thread-4 开始执行时间：2019-07-08 22:00:39\n            thread:pool-1-thread-5 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <4>\n            thread:pool-1-thread-6 开始执行时间：2019-07-08 22:00:39\n                ==  i\'m a cat!  ==     <5>\n            exception in thread "pool-1-thread-3" java.lang.arithmeticexception: / by zero\n            thread:pool-1-thread-1 开始执行时间：2019-07-08 22:00:40\n                at cat.run(testthreadpool.java:141)\n                ==  i\'m a cat!  ==     <6>\n                at java.util.concurrent.threadpoolexecutor.runworker(threadpoolexecutor.java:1142)\n                at java.util.concurrent.threadpoolexecutor$worker.run(threadpoolexecutor.java:617)\n            thread:pool-1-thread-2 开始执行时间：2019-07-08 22:00:40\n                at java.lang.thread.run(thread.java:745)\n                ==  i\'m a cat!  ==     <7>\n            thread:pool-1-thread-3 开始执行时间：2019-07-08 22:00:40\n            thread:pool-1-thread-6 开始执行时间：2019-07-08 22:00:40\n                ==  i\'m a cat!  ==     <10>\n            thread:pool-1-thread-5 开始执行时间：2019-07-08 22:00:40\n                ==  i\'m a cat!  ==     <9>\n            *//*\n        downlatch.await();\n        executorservice.shutdown();\n    }*/\n\n}\n\nclass cat implements runnable {\n\n    int i;\n    private countdownlatch downlatch;\n\n    public cat(int i,countdownlatch downlatch) {\n        this.i = i;\n        this.downlatch = downlatch;\n    }\n\n    simpledateformat format = new simpledateformat("yyyy-mm-dd hh:mm:ss");\n\n    @override\n    public void run() {\n        system.out.println("thread:"+thread.currentthread().getname()+" 开始执行时间："+format.format(system.currenttimemillis()));\n\n        if(i == 8 || i == 3)\n            i = i/0;\n            system.out.println("    ==  i\'m a cat!  ==     <" + i + ">");\n        //每执行完一个线程 计数器就减1\n        downlatch.countdown();\n\n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"分布式系统概述",frontmatter:{title:"分布式系统概述",date:"2021-05-17T00:00:00.000Z",tags:["分布式"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html",relativePath:"views/backend/分布式系统概述.md",key:"v-5cb8f20a",path:"/views/backend/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.html",excerpt:'<Boxx/>\n<p><div class="table-of-contents"><ul></ul></div></p>\n<p>随着互联网用户规模扩大，应用系统数量增加，业务逻辑越来越复杂。传统的单机模式已不能满足需求，今天就从单机到分布式聊聊近些年系统架构的转变。</p>\n',headersStr:null,content:'随着互联网用户规模扩大，应用系统数量增加，业务逻辑越来越复杂。传统的单机模式已不能满足需求，今天就从单机到分布式聊聊近些年系统架构的转变。\n\n * 一个单机式系统需要的架构：\n\n环境：单台服务器 + 集中式系统\n\n场景：常用在企业内网或用户量少的内管系统\n\n * 一个分布式系统需要的架构：\n\n环境：多台服务器 + 分布式系统集群\n\n场景：常用在用户量大或业务量繁杂的大型系统\n\n\n\n单机系统处理能力瓶颈主要在CPU、内存、硬盘等，当业务量上来之后只能通过垂直拓展的方式来提升性能，而量级达到一定程度后，单机的稳定性和可用性将受到极大的挑战。\n\n此外单机还存在系统程序级别问题，一旦程序中某段代码出现问题，将影响整个系统的稳定性。\n\n由此，行业由集中式系统慢慢演变为分布式系统架构。\n\n分布式系统常见解决方案主要有：配置中心、注册中心、分布式缓存、分布式唯一ID、分布式消息、分布式任务、分布式事务、链路追踪、监控告警、服务治理等等。\n\n----------------------------------------\n\n以阿波罗饭店的故事为例，上演分布式架构演变历程~\n\n一个遥远的故事：阿波罗饭店的演变历程\n\n\n\n在远古时期，有一家名为阿波罗的饭店，当客户来的时候，点单、配菜、炒菜都是阿波罗一个人完成。（单机模式）\n\n起初还好，客户量少于个位数的时候阿波罗一个人就忙过来了。\n\n就这样，又过了一年。\n\n阿波罗口碑传开了，客户量直逼上百，好嘛，阿波罗心想：这可不行啊，这我哪忙的过来呀。\n\n过了两天，憋出来一个办法：我一个人不行，我再多找两个跟我一样的，干一样的活。（于是集群模式就出现了）\n\n就这样，又过了一年。\n\n阿波罗口碑太好了，人传人都传疯了，客户量直逼上千，好嘛，阿波罗心想：这可不行啊，这就我们三哪忙的过来呀。\n\n过了两天，又憋出来一个办法：我把我们三个人的活分一下，A去点单，B去配菜，C去炒菜。然后A配10个人，B配10个人，C配10个人，这样哪怕其中一个人有事请假了，相同工作的其他人还能继续顶上。（于是分布式系统+集群模式就出现了）\n\n\n\n刚开始还好，饭店正常运行没啥问题。\n\n突然有一天，饭店乱锅了。。\n\n有一个客户急眼了说：为啥我点单了还没给我上菜呀😡！原来是A1和A8号点单员下单是同一个流水号，导致A8把A1的单覆盖了。（于是分布式序列唯一ID出现了）\n\n另一个客户急眼了说：为啥我点个单这么慢呀😡！原来是点单员A2，A3，A4，A5没来，同时对于每天火爆的菜品也没个记录每次都得问炒菜员。（于是注册中心，分布式缓存出现了）\n\n后来啊，饭店时不时出个问题，于是阿波罗找了一波专业团队从头到尾重新把饭店打造了一番。\n\n\n\n于是就引出了：\n\n * 注册中心：所有人上班、请假都得来我这打卡、申请，防止A偷偷没来B偷偷溜走。\n\n * 配置中心：所有人有啥事变动后，其他人都可以及时知道。比如配菜员B1说今天胡萝卜没了，然后B2~B10全都了解。\n\n * 分布式序列：防止点单员A1~A10出现下单重复的情况，并且支持自定义指定规则的订单号。\n\n * 服务治理：当炒菜员C1在炒一个菜还没出锅的时候，点单员A1、A4、A5一直在催催催，炒菜员就告诉他："正在出锅中，正在出锅中"，而不是告诉他：”老子不干了，老子不干了，老子不！干！了！“\n\n * 分布式缓存：点单时，对一些常点菜的介绍、配方等，自己脑子里已经有个影响或者拿个本本记下来，不用每次再问炒菜员了；配菜时，对一些常用的菜，提前也能备好。\n\n * 分布式事务：点单、配菜、炒菜三个步骤要成功都得成功，其中只要有一个步骤出错，那么回退这次单子。\n\n * 链路追踪：点单、配菜、炒菜，我得知道这次流程到哪个环节了，或者在某个环节出问题了，出的什么问题我得知道。\n\n\n\n后来阿波罗又开发了美团团、饿了么么，接入了配送员：\n\n * 分布式消息：客户在美团团点单并付款后直接返回成功，不用等这阿波罗做完菜交给配送员送到客户手上后再显示成功。\n\n * 分布式任务：客户在美团团下单后的指定时间内不一定付款，采用定时轮扫的方式将这些订单统统取消掉。\n\n * 监控告警：对阿波罗的实时的点点滴滴了解的一清二楚，哪个炒菜员有风险，啥时候点单量最大，在任何时间点，当阿波罗出现任何问题的时候，我得知道。\n\nOK，今天知道了分布式系统中各组件是干嘛的，下次有时间就来聊聊各组件用到的技术实现。',normalizedContent:'随着互联网用户规模扩大，应用系统数量增加，业务逻辑越来越复杂。传统的单机模式已不能满足需求，今天就从单机到分布式聊聊近些年系统架构的转变。\n\n * 一个单机式系统需要的架构：\n\n环境：单台服务器 + 集中式系统\n\n场景：常用在企业内网或用户量少的内管系统\n\n * 一个分布式系统需要的架构：\n\n环境：多台服务器 + 分布式系统集群\n\n场景：常用在用户量大或业务量繁杂的大型系统\n\n\n\n单机系统处理能力瓶颈主要在cpu、内存、硬盘等，当业务量上来之后只能通过垂直拓展的方式来提升性能，而量级达到一定程度后，单机的稳定性和可用性将受到极大的挑战。\n\n此外单机还存在系统程序级别问题，一旦程序中某段代码出现问题，将影响整个系统的稳定性。\n\n由此，行业由集中式系统慢慢演变为分布式系统架构。\n\n分布式系统常见解决方案主要有：配置中心、注册中心、分布式缓存、分布式唯一id、分布式消息、分布式任务、分布式事务、链路追踪、监控告警、服务治理等等。\n\n----------------------------------------\n\n以阿波罗饭店的故事为例，上演分布式架构演变历程~\n\n一个遥远的故事：阿波罗饭店的演变历程\n\n\n\n在远古时期，有一家名为阿波罗的饭店，当客户来的时候，点单、配菜、炒菜都是阿波罗一个人完成。（单机模式）\n\n起初还好，客户量少于个位数的时候阿波罗一个人就忙过来了。\n\n就这样，又过了一年。\n\n阿波罗口碑传开了，客户量直逼上百，好嘛，阿波罗心想：这可不行啊，这我哪忙的过来呀。\n\n过了两天，憋出来一个办法：我一个人不行，我再多找两个跟我一样的，干一样的活。（于是集群模式就出现了）\n\n就这样，又过了一年。\n\n阿波罗口碑太好了，人传人都传疯了，客户量直逼上千，好嘛，阿波罗心想：这可不行啊，这就我们三哪忙的过来呀。\n\n过了两天，又憋出来一个办法：我把我们三个人的活分一下，a去点单，b去配菜，c去炒菜。然后a配10个人，b配10个人，c配10个人，这样哪怕其中一个人有事请假了，相同工作的其他人还能继续顶上。（于是分布式系统+集群模式就出现了）\n\n\n\n刚开始还好，饭店正常运行没啥问题。\n\n突然有一天，饭店乱锅了。。\n\n有一个客户急眼了说：为啥我点单了还没给我上菜呀😡！原来是a1和a8号点单员下单是同一个流水号，导致a8把a1的单覆盖了。（于是分布式序列唯一id出现了）\n\n另一个客户急眼了说：为啥我点个单这么慢呀😡！原来是点单员a2，a3，a4，a5没来，同时对于每天火爆的菜品也没个记录每次都得问炒菜员。（于是注册中心，分布式缓存出现了）\n\n后来啊，饭店时不时出个问题，于是阿波罗找了一波专业团队从头到尾重新把饭店打造了一番。\n\n\n\n于是就引出了：\n\n * 注册中心：所有人上班、请假都得来我这打卡、申请，防止a偷偷没来b偷偷溜走。\n\n * 配置中心：所有人有啥事变动后，其他人都可以及时知道。比如配菜员b1说今天胡萝卜没了，然后b2~b10全都了解。\n\n * 分布式序列：防止点单员a1~a10出现下单重复的情况，并且支持自定义指定规则的订单号。\n\n * 服务治理：当炒菜员c1在炒一个菜还没出锅的时候，点单员a1、a4、a5一直在催催催，炒菜员就告诉他："正在出锅中，正在出锅中"，而不是告诉他：”老子不干了，老子不干了，老子不！干！了！“\n\n * 分布式缓存：点单时，对一些常点菜的介绍、配方等，自己脑子里已经有个影响或者拿个本本记下来，不用每次再问炒菜员了；配菜时，对一些常用的菜，提前也能备好。\n\n * 分布式事务：点单、配菜、炒菜三个步骤要成功都得成功，其中只要有一个步骤出错，那么回退这次单子。\n\n * 链路追踪：点单、配菜、炒菜，我得知道这次流程到哪个环节了，或者在某个环节出问题了，出的什么问题我得知道。\n\n\n\n后来阿波罗又开发了美团团、饿了么么，接入了配送员：\n\n * 分布式消息：客户在美团团点单并付款后直接返回成功，不用等这阿波罗做完菜交给配送员送到客户手上后再显示成功。\n\n * 分布式任务：客户在美团团下单后的指定时间内不一定付款，采用定时轮扫的方式将这些订单统统取消掉。\n\n * 监控告警：对阿波罗的实时的点点滴滴了解的一清二楚，哪个炒菜员有风险，啥时候点单量最大，在任何时间点，当阿波罗出现任何问题的时候，我得知道。\n\nok，今天知道了分布式系统中各组件是干嘛的，下次有时间就来聊聊各组件用到的技术实现。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"动态代理和静态代理区别",frontmatter:{title:"动态代理和静态代理区别",date:"2022-03-02T00:00:00.000Z",tags:["源码分析","Java"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html",relativePath:"views/backend/动态代理和静态代理区别.md",key:"v-1bebd69a",path:"/views/backend/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8C%BA%E5%88%AB.html",headers:[{level:2,title:"一、代理概念",slug:"一、代理概念",normalizedTitle:"一、代理概念",charIndex:3},{level:2,title:"二、静态代理",slug:"二、静态代理",normalizedTitle:"二、静态代理",charIndex:13},{level:2,title:"三、动态代理",slug:"三、动态代理",normalizedTitle:"三、动态代理",charIndex:23},{level:3,title:"1、先看看与动态代理紧密关联的Java API。",slug:"_1、先看看与动态代理紧密关联的java-api。",normalizedTitle:"1、先看看与动态代理紧密关联的java api。",charIndex:35},{level:3,title:"2、动态代理实现步骤",slug:"_2、动态代理实现步骤",normalizedTitle:"2、动态代理实现步骤",charIndex:65},{level:3,title:"3、动态代理实现示例",slug:"_3、动态代理实现示例",normalizedTitle:"3、动态代理实现示例",charIndex:81},{level:3,title:"4、动态代理机制特点",slug:"_4、动态代理机制特点",normalizedTitle:"4、动态代理机制特点",charIndex:97},{level:3,title:"5、动态代理的优点和美中不足",slug:"_5、动态代理的优点和美中不足",normalizedTitle:"5、动态代理的优点和美中不足",charIndex:113}],excerpt:"<Boxx/>\n",headersStr:"一、代理概念 二、静态代理 三、动态代理 1、先看看与动态代理紧密关联的Java API。 2、动态代理实现步骤 3、动态代理实现示例 4、动态代理机制特点 5、动态代理的优点和美中不足",content:' * 一、代理概念\n * 二、静态代理\n * 三、动态代理\n   * 1、先看看与动态代理紧密关联的Java API。\n   * 2、动态代理实现步骤\n   * 3、动态代理实现示例\n   * 4、动态代理机制特点\n   * 5、动态代理的优点和美中不足\n\n\n\n\n# 一、代理概念\n\n为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。\n\n\n\n从图中可以看出，代理接口（Subject）、代理类（ProxySubject）、委托类（RealSubject）形成一个“品”字结构。根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。\n\n下面以一个模拟需求说明静态代理和动态代理：委托类要处理一项耗时较长的任务，客户类需要打印出执行任务消耗的时间。解决这个问题需要记录任务执行前时间和任务执行后时间，两个时间差就是任务执行消耗的时间。\n\n\n# 二、静态代理\n\n由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。\n\n清单1：代理接口\n\n/**  \n * 代理接口。处理给定名字的任务。 \n */  \npublic interface Subject {  \n  /** \n   * 执行给定名字的任务。 \n    * @param taskName 任务名 \n   */  \n   public void dealTask(String taskName);   \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n清单2：委托类，具体处理业务。\n\n/** \n * 真正执行任务的类，实现了代理接口。 \n */  \npublic class RealSubject implements Subject {  \n\n /** \n  * 执行给定名字的任务。这里打印出任务名，并休眠500ms模拟任务执行了很长时间 \n  * @param taskName  \n  */  \n   @Override  \n   public void dealTask(String taskName) {  \n      System.out.println("正在执行任务："+taskName);  \n      try {  \n         Thread.sleep(500);  \n      } catch (InterruptedException e) {  \n         e.printStackTrace();  \n      }  \n   }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n清单3：静态代理类\n\n/** \n * 代理类，实现了代理接口。 \n */  \npublic class ProxySubject implements Subject {  \n //代理类持有一个委托类的对象引用  \n private Subject delegate;  \n\n public ProxySubject(Subject delegate) {  \n  this.delegate = delegate;  \n }  \n\n /** \n  * 将请求分派给委托类执行，记录任务执行前后的时间，时间差即为任务的处理时间 \n  *  \n  * @param taskName \n  */  \n @Override  \n public void dealTask(String taskName) {  \n  long stime = System.currentTimeMillis();   \n  //将请求分派给委托类处理  \n  delegate.dealTask(taskName);  \n  long ftime = System.currentTimeMillis();   \n  System.out.println("执行任务耗时"+(ftime - stime)+"毫秒");  \n\n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n清单4：生成静态代理类工厂\n\npublic class SubjectStaticFactory {  \n //客户类调用此工厂方法获得代理对象。  \n //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  \n public static Subject getInstance(){   \n  return new ProxySubject(new RealSubject());  \n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n清单5：客户类\n\npublic class Client1 {  \n\n public static void main(String[] args) {  \n  Subject proxy = SubjectStaticFactory.getInstance();  \n  proxy.dealTask("DBQueryTask");  \n }   \n\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n静态代理类优缺点\n\n优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。\n\n缺点：\n\n * 代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。\n * 如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n\n# 三、动态代理\n\n动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。\n\n\n# 1、先看看与动态代理紧密关联的Java API。\n\n1）java.lang.reflect.Proxy\n\n这是 Java 动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。\n\n清单6：Proxy类的静态方法\n\n// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器  \nstatic InvocationHandler getInvocationHandler(Object proxy)   \n\n// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象  \nstatic Class getProxyClass(ClassLoader loader, Class[] interfaces)   \n\n// 方法 3：该方法用于判断指定类对象是否是一个动态代理类  \nstatic boolean isProxyClass(Class cl)   \n\n// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例  \nstatic Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n2）java.lang.reflect.InvocationHandler\n\n这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。每次生成动态代理类对象时都要指定一个对应的调用处理器对象。\n\n清单7：InvocationHandler的核心方法\n\n// 该方法负责集中处理动态代理类上的所有方法调用。\n// 第一个参数既是代理类实例，\n// 第二个参数是被调用的方法对象，\n// 第三个方法是调用参数。\n// 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行  \nObject invoke(Object proxy, Method method, Object[] args)   \n\n\n1\n2\n3\n4\n5\n6\n\n\n3）java.lang.ClassLoader\n\n这是类装载器类，负责将类的字节码装载到 Java 虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。\n\n每次生成动态代理类对象时都需要指定一个类装载器对象。\n\n\n# 2、动态代理实现步骤\n\n具体步骤是：\n\n * 实现InvocationHandler接口创建自己的调用处理器\n * 给Proxy类提供ClassLoader和代理接口类型数组创建动态代理类\n * 以调用处理器类型为参数，利用反射机制得到动态代理类的构造函数\n * 以调用处理器对象为参数，利用动态代理类的构造函数创建动态代理类对象\n\n清单8：分步骤实现动态代理\n\n// InvocationHandlerImpl 实现了 InvocationHandler 接口，\n// 并能实现方法调用从代理类到委托类的分派转发，\n// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用  \nInvocationHandler handler = new InvocationHandlerImpl(..);   \n\n// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象  \nClass clazz = Proxy.getProxyClass(classLoader, new Class[] { Interface.class, ... });   \n\n// 通过反射从生成的类对象获得构造函数对象  \nConstructor constructor = clazz.getConstructor(new Class[] { InvocationHandler.class });   \n\n// 通过构造函数对象创建动态代理类实例  \nInterface Proxy = (Interface)constructor.newInstance(new Object[] { handler });   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nProxy类的静态方法newProxyInstance对上面具体步骤的后三步做了封装，简化了动态代理对象的获取过程。\n\n清单9：简化后的动态代理实现\n\n// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发  \nInvocationHandler handler = new InvocationHandlerImpl(..);   \n\n// 通过 Proxy 直接创建动态代理类实例  \nInterface proxy = (Interface)Proxy.newProxyInstance( classLoader,   \n     new Class[] { Interface.class },  handler );  \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、动态代理实现示例\n\n清单10：创建自己的调用处理器\n\n/** \n * 动态代理类对应的调用处理程序类 \n */  \npublic class SubjectInvocationHandler implements InvocationHandler {  \n\n //代理类持有一个委托类的对象引用  \n private Object delegate;  \n\n public SubjectInvocationHandler(Object delegate) {  \n  this.delegate = delegate;  \n }  \n\n @Override  \n public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  \n  long stime = System.currentTimeMillis();   \n  //利用反射机制将请求分派给委托类处理。Method的invoke返回Object对象作为方法执行结果。  \n  //因为示例程序没有返回值，所以这里忽略了返回值处理  \n  method.invoke(delegate, args);  \n  long ftime = System.currentTimeMillis();   \n  System.out.println("执行任务耗时"+(ftime - stime)+"毫秒");  \n\n  return null;  \n }  \n}   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n清单11：生成动态代理对象的工厂，工厂方法列出了如何生成动态代理类对象的步骤。\n\n/** \n * 生成动态代理对象的工厂. \n */  \npublic class DynProxyFactory {  \n //客户类调用此工厂方法获得代理对象。  \n //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  \n public static Subject getInstance(){   \n  Subject delegate = new RealSubject();  \n  InvocationHandler handler = new SubjectInvocationHandler(delegate);  \n  Subject proxy = null;  \n  proxy = (Subject)Proxy.newProxyInstance(  \n    delegate.getClass().getClassLoader(),   \n    delegate.getClass().getInterfaces(),   \n    handler);  \n  return proxy;  \n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n清单12：动态代理客户类\n\npublic class Client {  \n\n public static void main(String[] args) {  \n\n  Subject proxy = DynProxyFactory.getInstance();  \n  proxy.dealTask("DBQueryTask");  \n }   \n\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4、动态代理机制特点\n\n首先是动态生成的代理类本身的一些特点。\n\n1）包：如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect 或 private，所以除 public 之外就是默认的 package 访问级别），那么它将被定义在该接口所在包（假设代理了 com.ibm.developerworks 包中的某非 public 接口 A，那么新生成的代理类所在的包就是 com.ibm.developerworks），这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；\n\n2）类修饰符：该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承；\n\n3）类名：格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，值得注意的一点是，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。\n\n4）类继承关系：该类的继承关系如图：\n\n\n\n由图可见，Proxy 类是它的父类，这个规则适用于所有由 Proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。\n\n接下来让我们了解一下代理类实例的一些特点。每个实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行。\n\n此外，值得注意的是，代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖；二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口（或继承于该接口的某子接口）的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。\n\n接着来了解一下被代理的一组接口有哪些特点。首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非 public 的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过 65535，这是 JVM 设定的限制。\n\n最后再来了解一下异常处理方面的特点。从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于 Throwable 接口，但事实是否如此呢？\n\n答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛 Throwable 异常。那么如果在 invoke 方法中的确产生了接口方法声明中不支持的异常，那将如何呢？\n\n放心，Java 动态代理类已经为我们设计好了解决方法：它将会抛出 UndeclaredThrowableException 异常。这个异常是一个 RuntimeException 类型，所以不会引起编译错误。通过该异常的 getCause 方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。\n\n\n# 5、动态代理的优点和美中不足\n\n优点：\n\n动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似Spring AOP那样配置外围业务。\n\n美中不足：\n\n诚然，Proxy 已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 Proxy。Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，原因是多继承在 Java 中本质上就行不通。\n\n有很多条理由，人们可以否定对 class 代理的必要性，但是同样有一些理由，相信支持 class 动态代理会更美好。接口和类的划分，本就不是很明显，只是到了 Java 中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。',normalizedContent:' * 一、代理概念\n * 二、静态代理\n * 三、动态代理\n   * 1、先看看与动态代理紧密关联的java api。\n   * 2、动态代理实现步骤\n   * 3、动态代理实现示例\n   * 4、动态代理机制特点\n   * 5、动态代理的优点和美中不足\n\n\n\n\n# 一、代理概念\n\n为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。\n\n\n\n从图中可以看出，代理接口（subject）、代理类（proxysubject）、委托类（realsubject）形成一个“品”字结构。根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。\n\n下面以一个模拟需求说明静态代理和动态代理：委托类要处理一项耗时较长的任务，客户类需要打印出执行任务消耗的时间。解决这个问题需要记录任务执行前时间和任务执行后时间，两个时间差就是任务执行消耗的时间。\n\n\n# 二、静态代理\n\n由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。\n\n清单1：代理接口\n\n/**  \n * 代理接口。处理给定名字的任务。 \n */  \npublic interface subject {  \n  /** \n   * 执行给定名字的任务。 \n    * @param taskname 任务名 \n   */  \n   public void dealtask(string taskname);   \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n清单2：委托类，具体处理业务。\n\n/** \n * 真正执行任务的类，实现了代理接口。 \n */  \npublic class realsubject implements subject {  \n\n /** \n  * 执行给定名字的任务。这里打印出任务名，并休眠500ms模拟任务执行了很长时间 \n  * @param taskname  \n  */  \n   @override  \n   public void dealtask(string taskname) {  \n      system.out.println("正在执行任务："+taskname);  \n      try {  \n         thread.sleep(500);  \n      } catch (interruptedexception e) {  \n         e.printstacktrace();  \n      }  \n   }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n清单3：静态代理类\n\n/** \n * 代理类，实现了代理接口。 \n */  \npublic class proxysubject implements subject {  \n //代理类持有一个委托类的对象引用  \n private subject delegate;  \n\n public proxysubject(subject delegate) {  \n  this.delegate = delegate;  \n }  \n\n /** \n  * 将请求分派给委托类执行，记录任务执行前后的时间，时间差即为任务的处理时间 \n  *  \n  * @param taskname \n  */  \n @override  \n public void dealtask(string taskname) {  \n  long stime = system.currenttimemillis();   \n  //将请求分派给委托类处理  \n  delegate.dealtask(taskname);  \n  long ftime = system.currenttimemillis();   \n  system.out.println("执行任务耗时"+(ftime - stime)+"毫秒");  \n\n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n清单4：生成静态代理类工厂\n\npublic class subjectstaticfactory {  \n //客户类调用此工厂方法获得代理对象。  \n //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  \n public static subject getinstance(){   \n  return new proxysubject(new realsubject());  \n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n清单5：客户类\n\npublic class client1 {  \n\n public static void main(string[] args) {  \n  subject proxy = subjectstaticfactory.getinstance();  \n  proxy.dealtask("dbquerytask");  \n }   \n\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n静态代理类优缺点\n\n优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。\n\n缺点：\n\n * 代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。\n * 如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n\n# 三、动态代理\n\n动态代理类的源码是在程序运行期间由jvm根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。\n\n\n# 1、先看看与动态代理紧密关联的java api。\n\n1）java.lang.reflect.proxy\n\n这是 java 动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。\n\n清单6：proxy类的静态方法\n\n// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器  \nstatic invocationhandler getinvocationhandler(object proxy)   \n\n// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象  \nstatic class getproxyclass(classloader loader, class[] interfaces)   \n\n// 方法 3：该方法用于判断指定类对象是否是一个动态代理类  \nstatic boolean isproxyclass(class cl)   \n\n// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例  \nstatic object newproxyinstance(classloader loader, class[] interfaces, invocationhandler h)   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n2）java.lang.reflect.invocationhandler\n\n这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。每次生成动态代理类对象时都要指定一个对应的调用处理器对象。\n\n清单7：invocationhandler的核心方法\n\n// 该方法负责集中处理动态代理类上的所有方法调用。\n// 第一个参数既是代理类实例，\n// 第二个参数是被调用的方法对象，\n// 第三个方法是调用参数。\n// 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行  \nobject invoke(object proxy, method method, object[] args)   \n\n\n1\n2\n3\n4\n5\n6\n\n\n3）java.lang.classloader\n\n这是类装载器类，负责将类的字节码装载到 java 虚拟机（jvm）中并为其定义类对象，然后该类才能被使用。proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 jvm 在运行时动态生成的而非预存在于任何一个 .class 文件中。\n\n每次生成动态代理类对象时都需要指定一个类装载器对象。\n\n\n# 2、动态代理实现步骤\n\n具体步骤是：\n\n * 实现invocationhandler接口创建自己的调用处理器\n * 给proxy类提供classloader和代理接口类型数组创建动态代理类\n * 以调用处理器类型为参数，利用反射机制得到动态代理类的构造函数\n * 以调用处理器对象为参数，利用动态代理类的构造函数创建动态代理类对象\n\n清单8：分步骤实现动态代理\n\n// invocationhandlerimpl 实现了 invocationhandler 接口，\n// 并能实现方法调用从代理类到委托类的分派转发，\n// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用  \ninvocationhandler handler = new invocationhandlerimpl(..);   \n\n// 通过 proxy 为包括 interface 接口在内的一组接口动态创建代理类的类对象  \nclass clazz = proxy.getproxyclass(classloader, new class[] { interface.class, ... });   \n\n// 通过反射从生成的类对象获得构造函数对象  \nconstructor constructor = clazz.getconstructor(new class[] { invocationhandler.class });   \n\n// 通过构造函数对象创建动态代理类实例  \ninterface proxy = (interface)constructor.newinstance(new object[] { handler });   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nproxy类的静态方法newproxyinstance对上面具体步骤的后三步做了封装，简化了动态代理对象的获取过程。\n\n清单9：简化后的动态代理实现\n\n// invocationhandlerimpl 实现了 invocationhandler 接口，并能实现方法调用从代理类到委托类的分派转发  \ninvocationhandler handler = new invocationhandlerimpl(..);   \n\n// 通过 proxy 直接创建动态代理类实例  \ninterface proxy = (interface)proxy.newproxyinstance( classloader,   \n     new class[] { interface.class },  handler );  \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、动态代理实现示例\n\n清单10：创建自己的调用处理器\n\n/** \n * 动态代理类对应的调用处理程序类 \n */  \npublic class subjectinvocationhandler implements invocationhandler {  \n\n //代理类持有一个委托类的对象引用  \n private object delegate;  \n\n public subjectinvocationhandler(object delegate) {  \n  this.delegate = delegate;  \n }  \n\n @override  \n public object invoke(object proxy, method method, object[] args) throws throwable {  \n  long stime = system.currenttimemillis();   \n  //利用反射机制将请求分派给委托类处理。method的invoke返回object对象作为方法执行结果。  \n  //因为示例程序没有返回值，所以这里忽略了返回值处理  \n  method.invoke(delegate, args);  \n  long ftime = system.currenttimemillis();   \n  system.out.println("执行任务耗时"+(ftime - stime)+"毫秒");  \n\n  return null;  \n }  \n}   \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n清单11：生成动态代理对象的工厂，工厂方法列出了如何生成动态代理类对象的步骤。\n\n/** \n * 生成动态代理对象的工厂. \n */  \npublic class dynproxyfactory {  \n //客户类调用此工厂方法获得代理对象。  \n //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。  \n public static subject getinstance(){   \n  subject delegate = new realsubject();  \n  invocationhandler handler = new subjectinvocationhandler(delegate);  \n  subject proxy = null;  \n  proxy = (subject)proxy.newproxyinstance(  \n    delegate.getclass().getclassloader(),   \n    delegate.getclass().getinterfaces(),   \n    handler);  \n  return proxy;  \n }  \n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n清单12：动态代理客户类\n\npublic class client {  \n\n public static void main(string[] args) {  \n\n  subject proxy = dynproxyfactory.getinstance();  \n  proxy.dealtask("dbquerytask");  \n }   \n\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4、动态代理机制特点\n\n首先是动态生成的代理类本身的一些特点。\n\n1）包：如果所代理的接口都是 public 的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非 public 的接口（因为接口不能被定义为 protect 或 private，所以除 public 之外就是默认的 package 访问级别），那么它将被定义在该接口所在包（假设代理了 com.ibm.developerworks 包中的某非 public 接口 a，那么新生成的代理类所在的包就是 com.ibm.developerworks），这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；\n\n2）类修饰符：该代理类具有 final 和 public 修饰符，意味着它可以被所有的类访问，但是不能被再度继承；\n\n3）类名：格式是“$proxyn”，其中 n 是一个逐一递增的阿拉伯数字，代表 proxy 类第 n 次生成的动态代理类，值得注意的一点是，并不是每次调用 proxy 的静态方法创建动态代理类都会使得 n 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。\n\n4）类继承关系：该类的继承关系如图：\n\n\n\n由图可见，proxy 类是它的父类，这个规则适用于所有由 proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。\n\n接下来让我们了解一下代理类实例的一些特点。每个实例都会关联一个调用处理器对象，可以通过 proxy 提供的静态方法 getinvocationhandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行。\n\n此外，值得注意的是，代理类的根类 java.lang.object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashcode，equals 和 tostring，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖；二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口（或继承于该接口的某子接口）的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。\n\n接着来了解一下被代理的一组接口有哪些特点。首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非 public 的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过 65535，这是 jvm 设定的限制。\n\n最后再来了解一下异常处理方面的特点。从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于 throwable 接口，但事实是否如此呢？\n\n答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛 throwable 异常。那么如果在 invoke 方法中的确产生了接口方法声明中不支持的异常，那将如何呢？\n\n放心，java 动态代理类已经为我们设计好了解决方法：它将会抛出 undeclaredthrowableexception 异常。这个异常是一个 runtimeexception 类型，所以不会引起编译错误。通过该异常的 getcause 方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。\n\n\n# 5、动态代理的优点和美中不足\n\n优点：\n\n动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（invocationhandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似spring aop那样配置外围业务。\n\n美中不足：\n\n诚然，proxy 已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 proxy。java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，原因是多继承在 java 中本质上就行不通。\n\n有很多条理由，人们可以否定对 class 代理的必要性，但是同样有一些理由，相信支持 class 动态代理会更美好。接口和类的划分，本就不是很明显，只是到了 java 中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"单元测试：如何在jUnit4中应用两个@RunWith？",frontmatter:{title:"单元测试：如何在jUnit4中应用两个@RunWith？",date:"2021-08-11T00:00:00.000Z",tags:["单元测试","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html",relativePath:"views/backend/单元测试1.md",key:"v-0eb0312f",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%951.html",headers:[{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:282},{level:2,title:"知识扩展",slug:"知识扩展",normalizedTitle:"知识扩展",charIndex:290},{level:3,title:"@RunWith作用",slug:"runwith作用",normalizedTitle:"@runwith作用",charIndex:300},{level:3,title:"使用@RunWith 和@Parameters 进行参数化测试",slug:"使用-runwith-和-parameters-进行参数化测试",normalizedTitle:"使用@runwith 和@parameters 进行参数化测试",charIndex:316},{level:4,title:"什么是参数化",slug:"什么是参数化",normalizedTitle:"什么是参数化",charIndex:3792},{level:4,title:"@Parameters：用于JUnit的参数化功能，用来标记准备数据的方法。",slug:"parameters-用于junit的参数化功能-用来标记准备数据的方法。",normalizedTitle:"@parameters：用于junit的参数化功能，用来标记准备数据的方法。",charIndex:3991}],excerpt:"<Boxx/>\n<p>比如正在使用 spring boot starter test 来编写 JUnit 测试用例。但很想使用 JunitParamrunner，它有助于为参数化测试传递文件。</p>\n<p>基本上它从文件中逐行读取数据，并为每一行调用一个测试用例。</p>\n<p>问题是同时使用需要通过@RunWith 和 SpringJUnit4ClassRunner 以及 JUnitParamsRunner。</p>\n<p>那需要在junit中@RunWith(SpringJUnit4ClassRunner.class)和@RunWith(Parameterized. class)这个要怎么写呢？</p>\n",headersStr:"解决方案 知识扩展 @RunWith作用 使用@RunWith 和@Parameters 进行参数化测试 什么是参数化 @Parameters：用于JUnit的参数化功能，用来标记准备数据的方法。",content:'比如正在使用 spring boot starter test 来编写 JUnit 测试用例。但很想使用 JunitParamrunner，它有助于为参数化测试传递文件。\n\n基本上它从文件中逐行读取数据，并为每一行调用一个测试用例。\n\n问题是同时使用需要通过@RunWith 和 SpringJUnit4ClassRunner 以及 JUnitParamsRunner。\n\n那需要在junit中@RunWith(SpringJUnit4ClassRunner.class)和@RunWith(Parameterized. class)这个要怎么写呢？\n\n\n\n * 解决方案\n * 知识扩展\n   * @RunWith作用\n   * 使用@RunWith 和@Parameters 进行参数化测试\n\n\n\n\n# 解决方案\n\n其实对于@RunWith(SpringJUnit4ClassRunner.class)，无非就是让测试运行于Spring的测试环境。\n\n而我们可以在测试类的构造函数中初始化上下文TestContextManager就相当于集成了spring测试环境，也相当于代替了@RunWith(SpringJUnit4ClassRunner.class)注解。\n\n 1. 书写一个测试基类\n\n/**\n * 测试基类，所有测试类都要继承此类\n */\n@ContextConfiguration(locations="classpath: application-context.xml")\n// @RunWith(SpringJUnit4ClassRunner.class)\n// @SpringBootTest\n// @RunWith(SpringRunner.class)\n// @EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})\n// @ComponentScan(excludeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {XxlJobConfig.class})})\npublic class BaseTest {\n\n    // 排除一个bean，Spring将使用这个mock而不是真正的类，所以不会调用@PostConstruct方法去创建\n    @MockBean\n    private XxlJobSpringExecutor xxlJobSpringExecutor;\n\n    private TestContextManager testContextManager;\n\n    public ParametrizedTestWithSpring() throws Exception {\n        this.testContextManager = new TestContextManager(getClass());\n        this.testContextManager.prepareTestInstance(this);\n    }\n\n    @BeforeClass\n    public static void setUp() throws Exception {\n        URL url = BaseTest.class.getClassLoader().getResource("");\n        String path = url.getPath() = "../../../docker/config/";\n        System.setProperty("env.cfg", path);\n        System.setProperty("spring.profiles.active", "dev");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n 2. 编写测试类，添加第二个@RunWith(Parameterized. class)\n\n@RunWith(Parameterized.class )\npublic class Demo1ControllerTest extends BaseTest {\n    \n    private static final Logger logger = LoggerFactory.getLogger(Demo1ControllerTest.class);\n    // 测试参数\n    private String target;\n    // 预期返回结果\n    private String except;\n    @Autowired\n    private Demo1Controlle demo1Controller;\n\n    /**\n     * 测试案例集\n     */\n    @Parameters\n    public static Collection setParam() {\n       return Arrays.asList(new Object[][] { \n           { "emplee_info", "empleeInfo" }, // 测试正常情况\n           { null, null }, // 测试null时处理情况\n           { "", "" }, // 测试空字符串的情况\n           { "employee_info", "EmployeeInfo" }, // 测试当首字母大写时的情况\n           { "employee_info_a", "employeeInfoA" }, // 测试当尾字母为大写时的情况\n           { "employee_a_info", "employeeAInfo" } // 测试多个相连字母大写时的情况\n       });\n    }\n\n    /**\n     * 参数化测试必须的构造函数\n     *\n     * @param except 期望的测试结果 ，对应参数集中的第一个参数\n     * @param target 测试数据，对应结果集中的第二个参数\n     */\n    public TestDemoParamter(String target, String except) {\n       this.except = except;\n       this.target = target;\n    }\n\n    @Test(timeout = 1000)\n    public void testParam(){\n        logger.info("入参：{}", target);\n        String except = demo1Controller.testParam();\n        logger.info("反参：{}", except);\n        Assert.assertEquals(except, target);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 知识扩展\n\n\n# @RunWith作用\n\n@RunWith 就是一个运行器：\n\n * @RunWith(JUnit4.class) 就是指用JUnit4来运行\n\n * @RunWith(SpringJUnit4ClassRunner.class), 让测试运行于Spring测试环境\n   \n   此时需要搭配@ContextConfiguration 使用，Spring整合JUnit4测试时，使用注解引入多个配置文件\n\n * @RunWith(Suite.class) 的话就是一套测试集合\n\n@ContextConfiguration语法：\n\n * 单个文件\n   \n   @ContextConfiguration(locations=“classpath：applicationContext.xml”)\n   \n   @ContextConfiguration(classes = SimpleConfiguration.class)\n\n * 多个文件时，可用{}\n   \n   @ContextConfiguration(locations = { “classpath:spring1.xml”, “classpath:spring2.xml” })\n\n\n# 使用@RunWith 和@Parameters 进行参数化测试\n\n# 什么是参数化\n\n * 怎么测试多分支？\n   \n   如一个对考试分数进行评价的函数\n   \n   返回值分别为“优秀，良好，一般，及格，不及格”\n   \n   在编写测试的时候，如果编写 5 个测试方法，进而测试 5 种情况，是 一件很麻烦的事情。\n\n * 为了简化类似的测试，JUnit 提出了“参数化测试”的概念，只写一个测试函 数，把这若干种情况作为参数传递进去，一次性的完成测试。\n\n# @Parameters：用于JUnit的参数化功能，用来标记准备数据的方法。\n\n注意：该方法需要满足一定的要求：\n\n 1. 该方法必须为public static的\n\n 2. 该方法返回值必须为java.util.Collection类型\n\n 3. 该方法的名字不做要求\n\n 4. 该方法没有参数\n\n 5. 参数化测试必须有与之对应的构造函数\n\n具体demo实类如上的Demo1ControllerTest。',normalizedContent:'比如正在使用 spring boot starter test 来编写 junit 测试用例。但很想使用 junitparamrunner，它有助于为参数化测试传递文件。\n\n基本上它从文件中逐行读取数据，并为每一行调用一个测试用例。\n\n问题是同时使用需要通过@runwith 和 springjunit4classrunner 以及 junitparamsrunner。\n\n那需要在junit中@runwith(springjunit4classrunner.class)和@runwith(parameterized. class)这个要怎么写呢？\n\n\n\n * 解决方案\n * 知识扩展\n   * @runwith作用\n   * 使用@runwith 和@parameters 进行参数化测试\n\n\n\n\n# 解决方案\n\n其实对于@runwith(springjunit4classrunner.class)，无非就是让测试运行于spring的测试环境。\n\n而我们可以在测试类的构造函数中初始化上下文testcontextmanager就相当于集成了spring测试环境，也相当于代替了@runwith(springjunit4classrunner.class)注解。\n\n 1. 书写一个测试基类\n\n/**\n * 测试基类，所有测试类都要继承此类\n */\n@contextconfiguration(locations="classpath: application-context.xml")\n// @runwith(springjunit4classrunner.class)\n// @springboottest\n// @runwith(springrunner.class)\n// @enableautoconfiguration(exclude = {datasourceautoconfiguration.class})\n// @componentscan(excludefilters = {@componentscan.filter(type = filtertype.assignable_type, classes = {xxljobconfig.class})})\npublic class basetest {\n\n    // 排除一个bean，spring将使用这个mock而不是真正的类，所以不会调用@postconstruct方法去创建\n    @mockbean\n    private xxljobspringexecutor xxljobspringexecutor;\n\n    private testcontextmanager testcontextmanager;\n\n    public parametrizedtestwithspring() throws exception {\n        this.testcontextmanager = new testcontextmanager(getclass());\n        this.testcontextmanager.preparetestinstance(this);\n    }\n\n    @beforeclass\n    public static void setup() throws exception {\n        url url = basetest.class.getclassloader().getresource("");\n        string path = url.getpath() = "../../../docker/config/";\n        system.setproperty("env.cfg", path);\n        system.setproperty("spring.profiles.active", "dev");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n 2. 编写测试类，添加第二个@runwith(parameterized. class)\n\n@runwith(parameterized.class )\npublic class demo1controllertest extends basetest {\n    \n    private static final logger logger = loggerfactory.getlogger(demo1controllertest.class);\n    // 测试参数\n    private string target;\n    // 预期返回结果\n    private string except;\n    @autowired\n    private demo1controlle demo1controller;\n\n    /**\n     * 测试案例集\n     */\n    @parameters\n    public static collection setparam() {\n       return arrays.aslist(new object[][] { \n           { "emplee_info", "empleeinfo" }, // 测试正常情况\n           { null, null }, // 测试null时处理情况\n           { "", "" }, // 测试空字符串的情况\n           { "employee_info", "employeeinfo" }, // 测试当首字母大写时的情况\n           { "employee_info_a", "employeeinfoa" }, // 测试当尾字母为大写时的情况\n           { "employee_a_info", "employeeainfo" } // 测试多个相连字母大写时的情况\n       });\n    }\n\n    /**\n     * 参数化测试必须的构造函数\n     *\n     * @param except 期望的测试结果 ，对应参数集中的第一个参数\n     * @param target 测试数据，对应结果集中的第二个参数\n     */\n    public testdemoparamter(string target, string except) {\n       this.except = except;\n       this.target = target;\n    }\n\n    @test(timeout = 1000)\n    public void testparam(){\n        logger.info("入参：{}", target);\n        string except = demo1controller.testparam();\n        logger.info("反参：{}", except);\n        assert.assertequals(except, target);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 知识扩展\n\n\n# @runwith作用\n\n@runwith 就是一个运行器：\n\n * @runwith(junit4.class) 就是指用junit4来运行\n\n * @runwith(springjunit4classrunner.class), 让测试运行于spring测试环境\n   \n   此时需要搭配@contextconfiguration 使用，spring整合junit4测试时，使用注解引入多个配置文件\n\n * @runwith(suite.class) 的话就是一套测试集合\n\n@contextconfiguration语法：\n\n * 单个文件\n   \n   @contextconfiguration(locations=“classpath：applicationcontext.xml”)\n   \n   @contextconfiguration(classes = simpleconfiguration.class)\n\n * 多个文件时，可用{}\n   \n   @contextconfiguration(locations = { “classpath:spring1.xml”, “classpath:spring2.xml” })\n\n\n# 使用@runwith 和@parameters 进行参数化测试\n\n# 什么是参数化\n\n * 怎么测试多分支？\n   \n   如一个对考试分数进行评价的函数\n   \n   返回值分别为“优秀，良好，一般，及格，不及格”\n   \n   在编写测试的时候，如果编写 5 个测试方法，进而测试 5 种情况，是 一件很麻烦的事情。\n\n * 为了简化类似的测试，junit 提出了“参数化测试”的概念，只写一个测试函 数，把这若干种情况作为参数传递进去，一次性的完成测试。\n\n# @parameters：用于junit的参数化功能，用来标记准备数据的方法。\n\n注意：该方法需要满足一定的要求：\n\n 1. 该方法必须为public static的\n\n 2. 该方法返回值必须为java.util.collection类型\n\n 3. 该方法的名字不做要求\n\n 4. 该方法没有参数\n\n 5. 参数化测试必须有与之对应的构造函数\n\n具体demo实类如上的demo1controllertest。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Zookeeper 全解",frontmatter:{title:"Zookeeper 全解",date:"2020-12-26T00:00:00.000Z",tags:["分布式","ZooKeeper"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/zookeeper.html",relativePath:"views/backend/zookeeper.md",key:"v-1e6887d2",path:"/views/backend/zookeeper.html",headers:[{level:2,title:"简介/快速入门",slug:"简介-快速入门",normalizedTitle:"简介/快速入门",charIndex:149},{level:4,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:1431},{level:4,title:"Zookeeper的设计目标",slug:"zookeeper的设计目标",normalizedTitle:"zookeeper的设计目标",charIndex:2774},{level:4,title:"数据模型",slug:"数据模型",normalizedTitle:"数据模型",charIndex:3133},{level:4,title:"结点状态stat的属性",slug:"结点状态stat的属性",normalizedTitle:"结点状态stat的属性",charIndex:3647},{level:4,title:"单机安装",slug:"单机安装",normalizedTitle:"单机安装",charIndex:4608},{level:2,title:"常用shell命令",slug:"常用shell命令",normalizedTitle:"常用shell命令",charIndex:160},{level:2,title:"zookeeper的Acl权限控制",slug:"zookeeper的acl权限控制",normalizedTitle:"zookeeper的acl权限控制",charIndex:173},{level:4,title:"案例/远程登录",slug:"案例-远程登录",normalizedTitle:"案例/远程登录",charIndex:9212},{level:4,title:"acl 超级管理员",slug:"acl-超级管理员",normalizedTitle:"acl 超级管理员",charIndex:10747},{level:2,title:"zookeeper的 JavaAPI",slug:"zookeeper的-javaapi",normalizedTitle:"zookeeper的 javaapi",charIndex:194},{level:4,title:"连接到Zookeeper",slug:"连接到zookeeper",normalizedTitle:"连接到zookeeper",charIndex:13602},{level:4,title:"新增节点",slug:"新增节点",normalizedTitle:"新增节点",charIndex:14959},{level:4,title:"修改节点",slug:"修改节点",normalizedTitle:"修改节点",charIndex:18435},{level:4,title:"删除节点",slug:"删除节点",normalizedTitle:"删除节点",charIndex:19616},{level:4,title:"查看节点",slug:"查看节点",normalizedTitle:"查看节点",charIndex:20519},{level:4,title:"查看子节点",slug:"查看子节点",normalizedTitle:"查看子节点",charIndex:21978},{level:4,title:"检查节点是否存在",slug:"检查节点是否存在",normalizedTitle:"检查节点是否存在",charIndex:23504},{level:2,title:"事件监听机制",slug:"事件监听机制",normalizedTitle:"事件监听机制",charIndex:216},{level:4,title:"watcher架构",slug:"watcher架构",normalizedTitle:"watcher架构",charIndex:24955},{level:4,title:"watcher特性",slug:"watcher特性",normalizedTitle:"watcher特性",charIndex:25195},{level:2,title:"配置中心案例",slug:"配置中心案例",normalizedTitle:"配置中心案例",charIndex:226},{level:2,title:"分布式唯一id案例",slug:"分布式唯一id案例",normalizedTitle:"分布式唯一id案例",charIndex:236},{level:2,title:"分布式锁案例",slug:"分布式锁案例",normalizedTitle:"分布式锁案例",charIndex:249},{level:2,title:"集群搭建",slug:"集群搭建",normalizedTitle:"集群搭建",charIndex:259},{level:4,title:"一致性协议——zab协议",slug:"一致性协议-zab协议",normalizedTitle:"一致性协议——zab协议",charIndex:43460},{level:4,title:"leader选举",slug:"leader选举",normalizedTitle:"leader选举",charIndex:40850},{level:4,title:"observer角色及其配置",slug:"observer角色及其配置",normalizedTitle:"observer角色及其配置",charIndex:45968},{level:4,title:"API连接集群",slug:"api连接集群",normalizedTitle:"api连接集群",charIndex:47e3},{level:2,title:"curator介绍",slug:"curator介绍",normalizedTitle:"curator介绍",charIndex:267},{level:4,title:"基础用法",slug:"基础用法",normalizedTitle:"基础用法",charIndex:49163},{level:4,title:"创建",slug:"创建-2",normalizedTitle:"创建",charIndex:2727},{level:4,title:"修改",slug:"修改",normalizedTitle:"修改",charIndex:1675},{level:4,title:"删除",slug:"删除-2",normalizedTitle:"删除",charIndex:2766},{level:4,title:"读取节点",slug:"读取节点",normalizedTitle:"读取节点",charIndex:57797},{level:4,title:"读取子节点",slug:"读取子节点",normalizedTitle:"读取子节点",charIndex:59721},{level:4,title:"watcher",slug:"watcher",normalizedTitle:"watcher",charIndex:14243},{level:4,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:2891},{level:4,title:"分布式锁",slug:"分布式锁",normalizedTitle:"分布式锁",charIndex:249},{level:2,title:"四字监控命令/配置属性",slug:"四字监控命令-配置属性",normalizedTitle:"四字监控命令/配置属性",charIndex:280},{level:4,title:"conf",slug:"conf",normalizedTitle:"conf",charIndex:415},{level:4,title:"cons",slug:"cons",normalizedTitle:"cons",charIndex:69328},{level:4,title:"crst",slug:"crst",normalizedTitle:"crst",charIndex:69402},{level:4,title:"dump",slug:"dump",normalizedTitle:"dump",charIndex:69431},{level:4,title:"envi",slug:"envi",normalizedTitle:"envi",charIndex:69462},{level:4,title:"ruok",slug:"ruok",normalizedTitle:"ruok",charIndex:69484},{level:4,title:"stat",slug:"stat",normalizedTitle:"stat",charIndex:3607},{level:4,title:"srst",slug:"srst",normalizedTitle:"srst",charIndex:69593},{level:4,title:"wchs",slug:"wchs",normalizedTitle:"wchs",charIndex:69611},{level:4,title:"wchc",slug:"wchc",normalizedTitle:"wchc",charIndex:69665},{level:4,title:"wchp",slug:"wchp",normalizedTitle:"wchp",charIndex:72957},{level:4,title:"mntr",slug:"mntr",normalizedTitle:"mntr",charIndex:69760},{level:2,title:"ZooInspector图形化工具",slug:"zooinspector图形化工具",normalizedTitle:"zooinspector图形化工具",charIndex:295}],excerpt:"<Boxx/>\n<p>官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>\n<p>简单来说zookeeper=文件系统+监听通知机制。</p>\n",headersStr:"简介/快速入门 应用场景 Zookeeper的设计目标 数据模型 结点状态stat的属性 单机安装 常用shell命令 zookeeper的Acl权限控制 案例/远程登录 acl 超级管理员 zookeeper的 JavaAPI 连接到Zookeeper 新增节点 修改节点 删除节点 查看节点 查看子节点 检查节点是否存在 事件监听机制 watcher架构 watcher特性 配置中心案例 分布式唯一id案例 分布式锁案例 集群搭建 一致性协议——zab协议 leader选举 observer角色及其配置 API连接集群 curator介绍 基础用法 创建 修改 删除 读取节点 读取子节点 watcher 事务 分布式锁 四字监控命令/配置属性 conf cons crst dump envi ruok stat srst wchs wchc wchp mntr ZooInspector图形化工具",content:'官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。\n\n简单来说zookeeper=文件系统+监听通知机制。\n\n\n\n * 简介/快速入门\n * 常用shell命令\n * zookeeper的Acl权限控制\n * zookeeper的 JavaAPI\n * 事件监听机制\n * 配置中心案例\n * 分布式唯一id案例\n * 分布式锁案例\n * 集群搭建\n * curator介绍\n * 四字监控命令/配置属性\n * ZooInspector图形化工具\n\n\n\n\n# 简介/快速入门\n\n官网：https://zookeeper.apache.org/\n\n> ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.\n\nZooKeeper是一个集中的服务，用于维护配置信息、命名、提供分布式同步和提供组服务。所有这些类型的服务都以某种形式被分布式应用程序使用。每次它们被实现时，都会有大量的工作来修复不可避免的错误和竞争条件。由于实现这些服务的困难，应用程序最初通常会略过这些服务，这使得它们在出现更改时变得脆弱，并且难以管理。即使正确地执行了这些服务，在部署应用程序时，这些服务的不同实现也会导致管理复杂性\n\nzookeeper由雅虎研究院开发,是Google Chubby的开源实现,后来托管到 Apache,于2010年11月正式成为apache的顶级项目\n\n大数据生态系统里由很多组件的命名都是某些动物或者昆虫，比如hadoop大象，hive就是蜂巢，zookeeper即管理员，顾名思义就算管理大数据生态系统各组件的管理员，如下所示：\n\n\n\n# 应用场景\n\nzookeepepr是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用,且具有严格顺序访问控制能力的分布式协调存储服务。\n\n * 维护配置信息\n * 分布式锁服务\n * 集群管理\n * 生成分布式唯一ID\n\n 1. 维护配置信息\n    \n    * java编程经常会遇到配置项，比如数据库的url、 schema、user和 password等。通常这些配置项我们会放置在配置文件中，再将配置文件放置在服务器上当需要更改配置项时，需要去服务器上修改对应的配置文件。\n      \n      但是随着分布式系统的兴起,由于许多服务都需要使用到该配置文件,因此有必须保证该配置服务的高可用性(highavailability)和各台服务器上配置数据的一致性。\n      \n      通常会将配置文件部署在一个集群上，然而一个集群动辄上千台服务器，此时如果再一台台服务器逐个修改配置文件那将是非常繁琐且危险的的操作，因此就需要一种服务，能够高效快速且可靠地完成配置项的更改等操作，并能够保证各配置项在每台服务器上的数据一致性。\n      \n      zookeeper就可以提供这样一种服务，其使用Zab这种一致性协议来保证一致性。现在有很多开源项目使用zookeeper来维护配置，如在 hbase中，客户端就是连接一个 zookeeper，获得必要的 hbase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列 kafka中，也便用zookeeper来维护 brokers的信息。在 alibaba开源的soa框架dubbo中也广泛的使用zookeeper管理一些配置来实现服务治理。\n      \n      \n\n 2. 分布式锁服务\n    \n    * 一个集群是一个分布式系统，由多台服务器组成。为了提高并发度和可靠性，多台服务器上运行着同一种服务。当多个服务在运行时就需要协调各服务的进度，有时候需要保证当某个服务在进行某个操作时，其他的服务都不能进行该操作，即对该操作进行加锁，如果当前机器挂掉后，释放锁并 fail over到其他的机器继续执行该服务\n\n 3. 集群管理\n    \n    * 一个集群有时会因为各种软硬件故障或者网络故障，出现棊些服务器挂掉而被移除集群，而某些服务器加入到集群中的情况，zookeeper会将这些服务器加入/移出的情况通知给集群中的其他正常工作的服务器，以及时调整存储和计算等任务的分配和执行等。此外zookeeper还会对故障的服务器做出诊断并尝试修复。\n      \n      \n\n 4. 生产分布式唯一ID\n    \n    * 在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_ increment属性来自动为每条记录生成一个唯一的ID。但是分库分表后，就无法在依靠数据库的auto_ Increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一ID。\n      \n      做法如下:每次要生成一个新id时，创建一个持久顺序节点，创建操作返回的节点序号，即为新id，然后把比自己节点小的删除即可\n\n# Zookeeper的设计目标\n\nzooKeeper致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务\n\n 1. 高性能\n    * zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，尤其用于以读为主的应用场景\n 2. 高可用\n    * zookeeper一般以集群的方式对外提供服务，一般3~5台机器就可以组成一个可用的 Zookeeper集群了，每台机器都会在内存中维护当前的服务器状态，井且每台机器之间都相互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服务\n 3. 严格顺序访问\n    * 对于来自客户端的每个更新请求，Zookeeper都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序\n\n# 数据模型\n\nzookeeper的数据结点可以视为树状结构(或目录)，树中的各个结点被称为znode(即zookeeper node)，一个znode可以由多个子结点。zookeeper结点在结构上表现为树状；\n\n使用路径path来定位某个znode，比如/ns-1/itcast/mysqml/schemal1/table1，此处ns-1，itcast、mysql、schemal1、table1分别是根结点、2级结点、3级结点以及4级结点；其中ns-1是itcast的父结点，itcast是ns-1的子结点，itcast是mysql的父结点....以此类推\n\nznode，间距文件和目录两种特点，即像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分\n\n\n\n那么如何描述一个znode呢？一个znode大体上分为3个部分：\n\n * 结点的数据：即znode data(结点path，结点data)的关系就像是Java map中的 key value关系\n * 结点的子结点children\n * 结点的状态stat：用来描述当前结点的创建、修改记录，包括cZxid、ctime等\n\n# 结点状态stat的属性\n\n在zookeeper shell中使用 get命令查看指定路径结点的data、stat信息\n\n\n\n属性说明：\n\n结点的各个属性如下。其中重要的概念是Zxid(Zookeeper Transaction ID)，Zookeeper结点的每一次更改都具有唯一的Zxid，如果Zxid-1 小于Zxid-2 ，则Zxid-1 的更改发生在 Zxid-2更改之前\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_zkDataModel_znodes\n\n * cZxid数据结点创建时的事务ID——针对于zookeeper数据结点的管理：我们对结点数据的一些写操作都会导致zookeeper自动地为我们去开启一个事务，并且自动地去为每一个事务维护一个事务ID\n * ctime数据结点创建时的时间\n * mZxid数据结点最后一次更新时的事务ID\n * mtime数据结点最后一次更新时的时间\n * pZxid数据节点最后一次修改此znode子节点更改的zxid\n * cversion子结点的更改次数\n * dataVersion结点数据的更改次数\n * aclVersion结点的ACL更改次数——类似linux的权限列表，维护的是当前结点的权限列表被修改的次数\n * ephemeralOwner如果结点是临时结点，则表示创建该结点的会话的SessionID；如果是持久结点，该属性值为0\n * dataLength数据内容的长度\n * numChildren数据结点当前的子结点个数\n\n结点类型\n\nzookeeper中的结点有两种，分别为临时结点和永久结点。结点的类型在创建时被确定，并且不能改变\n\n * 临时节点：\n   * 该节点的生命周期依赖于创建它们的会话。一旦会话( Session）结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的 Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，Zookeeper的临时节点不允许拥有子节点\n * 持久化结点：\n   * 该结点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除\n\n# 单机安装\n\n测试系统环境centos7.3\n\nzookeeper:zookeeper-3.4.10.tar.gz\n\njdk:jdk-8u131-linux-x64.tar.gz\n\nhttp://archive.apache.org/dist/zookeeper/\n\n 1. 在centos中使用 root用户创建 zookeeper用户，用户名:zookeeper密码:zookeeper\n    \n    * useradd zookeeper\n      passwd zookeeper\n      su zookeeper\n      \n      \n      1\n      2\n      3\n      \n\n 2. zookeeper底层依赖于jdk，zookeeper用户登录后，根目录下先进行jdk 的安装，jdk使用 jdk-8u131-linux-x64.tar.gz\n    \n    * tar -zxf tar.gz\n      \n      \n      1\n      \n\n 3. 配置jdk 环境变量\n    \n    * vi /etc/profile\n      JAVA_HOME=/home/zookeeper/jdk1.8.0_131\n      export JAVA_HOME\n      \n      PATH=$JAVA_HOME/bin:$PATH\n      export PATH\n      \n      souce /etc/profile\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n\n 4. 检测jdk安装\n    \n    * java -version // 如果反馈了Java信息，则成功\n\n 5. zookeeper 上传解压\n    \n    * tar -zxf tar.gz\n\n 6. 为zookeeper准备配置文件\n    \n    * # 进入conf目录\n      cd /home/zookeeper/zookeeper-3.4.10/conf\n      # 复制配置文件\n      cp zoo_sampe.cfg zoo.cfg\n      # zookeeper 根目录下创建data目录\n      mkdir data\n      # vi 配置文件中的dataDir\n      # 此路径用于存储zookeeper中数据的内存快照、及事务日志文件，虽然zookeeper是使用内存的，但是需要持久化一些数据来保证数据的安全，和redis一样\n      dataDir=/home/zookeeper/zookeeper-3.4.10/data\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      \n\n 7. 启动zookeeper\n    \n    * # 进入zookeeper的bin目录\n      cd /home/zookeeper/zookeeper-3.4.10/bin\n      # 启动zookeeper\n      ./zkServer.sh start\n      \n      # 启动: zkServer.sh start\n      # 停止: zkServer.sh stop\n      # 查看状态：zkServer.sh status\n      \n      # 进入zookeeper 内部\n      ./zkCli.sh\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      \n\n\n# 常用shell命令\n\nzookeeper——getting started——https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_FileManagement\n\n# 查询\n\nget /hadoop 查看结点的数据和属性 stat /hadoop 查看结点的属性\n\n# 创建\n\n创建结点并写入数据：\n\ncreate [-s] [-e] path data # 其中 -s 为有序结点，-e 临时结点（默认是持久结点）\n\ncreate /hadoop "123456"  # 此时，如果quit退出后再./ZkCient.sh 登入\n                         # 再用输入 get /hadoop 获取，结点依然存在(永久结点)\n\t\t\t\t       \ncreate -s /a "a"         # 创建一个持久化有序结点，创建的时候可以观察到返回的数据带上了一个id       \ncreate -s /b "b"         # 返回的值，id递增了\n\ncreate -s -e /aa "aa"    # 依然还会返回自增的id，quit后再进来，继续创建，id依然是往后推的\n\ncreate /aa/xx            # 继续创建结点，可以看到pZxid变化了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 更新\n\n更新结点的命令是set，可以直接进行修改，如下：\n\nset path [version]\n\nset /hadoop "345"        # 修改结点值\n\nset /hadoop "hadoop-x" 1 # 也可以基于版本号进行更改，类似于乐观锁，当传入版本号(dataVersion)\n                         # 和当前结点的数据版本号不一致时，zookeeper会拒绝本次修改\n\n\n1\n2\n3\n4\n\n\n# 删除\n\n删除结点的语法如下：\n\ndelete path [version] 和 set 方法相似，也可以传入版本号\n\ndelete /hadoop           # 删除结点\ndelete /hadoop 1         # 乐观锁机制，与set 方法一致\n\n\n1\n2\n\n\n要想删除某个结点及其所有后代结点，可以使用递归删除，命令为 rmr path\n\n查看结点列表\n\nls /hadoop               # 可以查看结点的列表\nls2 /hadoop              # 可以查看结点的列表以及目标结点的信息\n\nls /                     # 根节点\n\n\n1\n2\n3\n4\n\n\n监听器get path [watch] | stat path [watch]\n\n使用get path [watch] 注册的监听器能够在结点内容发生改变的时候，向客户端发出通知。需要注意的是zookeeper的触发器是一次性的(One-time trigger)，即触发一次后就会立即失效\n\nget /hadoop watch        # get 的时候添加监听器，当值改变的时候，监听器返回消息\nset /hadoop 45678        # 测试\n\n\n1\n2\n\n\nls\\ls2 path [watch]\n\n使用 ls path [watch] 或 ls2 path [watch]注册的监听器能够监听该结点下所有子节点的增加和删除操作\n\nls /hadoop watch         # 添加监听器\nset /hadoop/node "node"\n\n\n1\n2\n\n\n\n# zookeeper的Acl权限控制\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_ZooKeeperAccessControl\n\nzookeeper类似文件系统，client可以创建结点、更新结点、删除结点，那么如何做到结点的权限控制呢？\n\nzookeeper的 access control list 访问控制列表可以做到这一点\n\nacl权限控制，使用scheme：id：permission来标识，主要涵盖3个方面：\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_BuiltinACLSchemes\n\n * 权限模式(scheme)：授权的策略\n * 授权对象(id)：授权的对象\n * 权限(permission)：授予的权限\n\n其特性如下：\n\n * zookeeper的权限控制是基于每个znode结点的，需要对每个结点设置权限\n\n * 每个znode支持多种权限控制方案和多个权限\n\n * 子结点不会继承父结点的权限，客户端无权访问某结点，但可能可以访问它的子结点：\n   \n   例如setAcl /test2 ip:192.168.133.133:crwda // 将结点权限设置为Ip：192.168.133.133 的客户端可以对节点进行 增删改查和管理权限\n\n权限模式\n\n * 采用何种方式授权\n\n * \n\n * 方案       描述\n   world    只有一个用户：anyone，代表登录zookeeper所有人(默认)\n   ip       对客户端使用IP地址认证\n   auth     使用已添加认证的用户认证\n   digest   使用"用户名：密码"方式认证\n\n授权对象\n\n * 给谁授予权限\n * 授权对象ID是指，权限赋予的实体，例如：IP地址或用户\n\n授权的权限\n\n * 授予什么权限\n\n * create、delete、read、writer、admin也就是 增、删、查、改、管理权限，这5种权限简写为 c d r w a，注意： 这五种权限中，有的权限并不是对结点自身操作的例如：delete是指对子结点的删除权限\n   \n   可以试图删除父结点，但是子结点必须删除干净，所以delete的权限也是很有用的\n\n * \n\n * 权限       ACL简写   描述\n   create   c       可以创建子结点\n   delete   d       可以删除子结点(仅下一级结点)\n   read     r       可以读取结点数据以及显示子结点列表\n   write    w       可以设置结点数据\n   admin    a       可以设置结点访问控制权限列表\n\n授权的相关命令\n\n * \n\n * 命令        使用方式      描述\n   getAcl    getAcl    读取ACL权限\n   setAcl    setAcl    设置ACL权限\n   addauth   addauth   添加认证用户\n\n# 案例/远程登录\n\n./zkServer.sh -server 192.168.133.133 可以远程登录\n\nworld权限模式\n\n * getAcl /node // 读取权限信息\n * setAcl /node world:anyone:drwa // 设置权限(禁用创建子结点的权限)\n\nip模式\n\n./zkServer.sh -server 192.168.133.133 可以远程登录\n\n * setAcl /hadoop ip:192.168.133.133:drwa\n * 如果在两台不同的虚拟机中，另一台用远程连接的模式，进行上面这条命令，那么只会有一台被授权\n * 需要两台虚拟机一起授权的话需要用逗号将授权列表隔开：setAcl /hadoop ip:192.168.133.133:cdrwa,ip:192.168.133.132:cdrwa\n\nauth认证用户模式\n\naddauth digest <user>:<password>\n\nsetAcl <path> auth:<user>:<acl>\n\n * create /hadoop "hadoop"           # 初始化测试用的结点\n   addauth digest itcast:123456      # 添加认证用户\n   setAcl /hadoop auth:itcast:cdrwa  # 设置认证用户\n   quit                              # 退出后再./zkCli.sh 进入\n   get /hadoop                       # 这个时候就没有权限了，需要再次认证\n   addauth digest itcast:123456      # 认证，密码错了的话 zookeeper 不会报错，但是不能认证\n   get /hadoop\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\nDigest授权模式\n\nsetAcl <path> digest:<user>:<password>:<acl>\n\n * 这里的密码是经过SHA1以及BASE64处理的密文，在shell 中可以通过以下命令计算：\n   \n   * echo -n <user>:<password> | openssl dgst -binary -sha1 | openssl base64\n     \n     \n     1\n     \n   \n   * # 计算密码\n     echo -n itcast:12345 | openssl dgst -binary -sha1 | openssl base64\n     # 获取密码，设置权限列表\n     setAcl /hadoop digest:itcast:qUFSHxJjItUW/93UHFXFVGlvryY=:cdrwa\n     # 现在想要get /hadoop 需要登录了\n     addauth digest itcast:12345\n     get /hadoop\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n多种授权模式\n\n仅需逗号隔开\n\n *  setAcl /hadoop ip:192.168.133.132:cdrwa,auth:hadoop:cdrwa,digest:itcast:673OfZhUE8JEFMcu0l64qI8e5ek=:cdrwa\n   \n   \n   1\n   \n\n# acl 超级管理员\n\n * zookeeper的权限管理模式有一种叫做super，该模式提供一个超管，可以方便的访问任何权限的节点\n   \n   假设这个超管是supper:admin，需要为超管生产密码的密文\n   \n   echo -n super:admin | openssl dgst -binary -sha1 | openssl base64\n   \n   \n   1\n   \n\n * 那么打开zookeeper目录下/bin/zkServer.sh服务器脚本文件，找到如下一行：\n   \n    /nohup # 快速查找，可以看到如下\n    nohup "$JAVA" "-Dzookeeper.log.dir=${ZOO_LOG_DIR}" "-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}"\n   \n   \n   1\n   2\n   \n\n * 这个就算脚本中启动zookeeper的命令，默认只有以上两个配置项，我们需要添加一个超管的配置项\n   \n   "-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="\n   \n   \n   1\n   \n\n * 修改后命令变成如下\n   \n   nohup "$JAVA" "-Dzookeeper.log.dir=${ZOO_LOG_DIR}" "-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}" "-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="\n   \n   \n   1\n   \n\n * # 重起后，现在随便对任意节点添加权限限制\n   setAcl /hadoop ip:192.168.1.1:cdrwa # 这个ip并非本机\n   # 现在当前用户没有权限了\n   getAcl /hadoop\n   # 登录超管\n   addauth digest super:admin\n   # 强行操作节点\n   get /hadoop\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# zookeeper的 JavaAPI\n\n<dependency>\n            <groupId>com.101tec</groupId>\n            <artifactId>zkclient</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>zookeeper</artifactId>\n                    <groupId>org.apache.zookeeper</groupId>\n                </exclusion>\n                <exclusion>\n                    <artifactId>log4j</artifactId>\n                    <groupId>log4j</groupId>\n                </exclusion>\n                <exclusion>\n                    <artifactId>slf4j-log4j12</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n                <exclusion>\n                    <artifactId>slf4j-api</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n            </exclusions>\n            <version>0.9</version>\n        </dependency>\n        <dependency>\n            <artifactId>zookeeper</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>log4j</artifactId>\n                    <groupId>log4j</groupId>\n                </exclusion>\n                <exclusion>\n                    <artifactId>slf4j-log4j12</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n            </exclusions>\n            <groupId>org.apache.zookeeper</groupId>\n            <version>3.4.10</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nzonde是 zookeeper集合的核心组件，zookeeper API 提供了一小组使用 zookeeper集群来操作znode的所有细节\n\n客户端应该遵循以下步骤，与zookeeper服务器进行清晰和干净的交互\n\n * 连接到zookeeper服务器。zookeeper服务器为客户端分配会话ID\n * 定期向服务器发送心跳。否则，zookeeper服务器将过期会话ID，客户端需要重新连接\n * 只要会话Id处于活动状态，就可以获取/设置znode\n * 所有任务完成后，断开与zookeeper服务器连接，如果客户端长时间不活动，则zookeeper服务器将自动断开客户端\n\n# 连接到Zookeeper\n\n这部分，官网的解释十分稀少https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_ConnectingToZooKeeper\n\n[zkshell: 0] help\nZooKeeper host:port cmd args\n    get path [watch]\n    ls path [watch]\n    set path data [version]\n    delquota [-n|-b] path\n    quit\n    printwatches on|off\n    create path data acl\n    stat path [watch]\n    listquota path\n    history\n    setAcl path acl\n    getAcl path\n    sync path\n    redo cmdno\n    addauth scheme auth\n    delete path [version]\n    deleteall path\n    setquota -n|-b val path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nZookeeper(String connectionString, int sessionTimeout, watcher watcher)\n\n\n1\n\n * connectionString - zookeeper主机\n * sessionTimeout- 会话超时\n * watcher - 实现"监听器" 对象。zookeeper集合通过监视器对象返回连接状态\n\npublic static void main(String[] args) throws IOException, InterruptedException {\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n\n        ZooKeeper zookeeper = new ZooKeeper("192.168.133.133:2181", 5000, (WatchedEvent x) -> {\n            if (x.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                System.out.println("连接成功");\n                countDownLatch.countDown();\n            }\n        });\n        countDownLatch.await();\n        System.out.println(zookeeper.getSessionId());\n        zookeeper.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 新增节点\n\n * // 同步\n   create(String path, byte[] data, List<ACL> acl, CreateMode createMode)\n   // 异步\n   create(String path, byte[] data, List<ACL> acl, CreateMode createMode,\n         AsynCallback.StringCallback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n * \n\n * 参数           解释\n   path         znode路径\n   data         数据\n   acl          要创建的节点的访问控制列表。zookeeper API提供了一个静态接口 ZooDefs.Ids\n                来获取一些基本的acl列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE返回打开znode的acl列表\n   createMode   节点的类型，这是一个枚举\n   callBack     异步回调接口\n   ctx          传递上下文参数\n\n示例：\n\n * // 枚举的方式\n       public static void createTest1() throws Exception{\n           String str = "node";\n           String s = zookeeper.create("/node", str.getBytes(),\n                   ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);\n           System.out.println(s);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * // 自定义的方式\n       public static void createTest2() throws Exception{\n           ArrayList<ACL> acls = new ArrayList<>();\n           Id id = new Id("ip","192.168.133.133");\n           acls.add(new ACL(ZooDefs.Perms.ALL,id));\n           zookeeper.create("/create/node4","node4".getBytes(),acls,CreateMode.PERSISTENT);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * // auth\n       public static void createTest3() throws  Exception{\n           zookeeper.addAuthInfo("digest","itcast:12345".getBytes());\n           zookeeper.create("/node5","node5".getBytes(),\n                   ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);\n       }\n   // 自定义的方式\n       public static void createTest3() throws  Exception{\n   //        zookeeper.addAuthInfo("digest","itcast:12345".getBytes());\n   //        zookeeper.create("/node5","node5".getBytes(),\n   //                ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);\n           zookeeper.addAuthInfo("digest","itcast:12345".getBytes());\n           List<ACL> acls = new ArrayList<>();\n           Id id = new Id("auth","itcast");\n           acls.add(new ACL(ZooDefs.Perms.READ,id));\n           zookeeper.create("/create/node6","node6".getBytes(),\n                   acls,CreateMode.PERSISTENT);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n * // digest \n   public static void createTest3() throws  Exception{\n       List<ACL> acls = new ArrayList<>();\n       Id id = new Id("digest","itcast:qUFSHxJjItUW/93UHFXFVGlvryY=");\n       acls.add(new ACL(ZooDefs.Perms.READ,id));\n       zookeeper.create("/create/node7","node7".getBytes(), \t\n                        acls,CreateMode.PERSISTENT);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * // 异步\n       public static void createTest4() throws  Exception{\n           zookeeper.create("/node12", "node12".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new AsyncCallback.StringCallback(){\n               /**\n                * @param rc 状态，0 则为成功，以下的所有示例都是如此\n                * @param path 路径\n                * @param ctx 上下文参数\n                * @param name 路径\n                */\n               public void processResult(int rc, String path, Object ctx, String name){\n                   System.out.println(rc + " " + path + " " + name +  " " + ctx);\n               }\n           }, "I am context");\n           TimeUnit.SECONDS.sleep(1);\n           System.out.println("结束");\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n# 修改节点\n\n同样也有两种修改方式(异步和同步)\n\n * // 同步\n   setData(String path, byte[] data, int version)\n   // 异步\n   setData(String path, byte[] data, int version, StatCallback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   \n * \n\n * 参数         解释\n   path       节点路径\n   data       数据\n   version    数据的版本号， -1代表不使用版本号，乐观锁机制\n   callBack   异步回调 AsyncCallback.StatCallback，和之前的回调方法参数不同，这个可以获取节点状态\n   ctx        传递上下文参数\n\n *     public static void setData1() throws Exception{\n       \t// arg1:节点的路径\n           // arg2:修改的数据\n           // arg3:数据的版本号 -1 代表版本号不参与更新\n           Stat stat = zookeeper.setData("/hadoop","hadoop-1".getBytes(),-1);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n *     public static void setData2() throws Exception{\n           zookeeper.setData("/hadoop", "hadoop-1".getBytes(), 3 ,new AsyncCallback.StatCallback(){\n               @Override\n               public void processResult(int rc, String path, Object ctx, Stat stat) {\n                   // 讲道理，要判空\n                   System.out.println(rc + " " + path + " " + stat.getVersion() +  " " + ctx);\n               }\n           }, "I am context");\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n# 删除节点\n\n异步、同步\n\n * // 同步\n   delete(String path, int version)\n   // 异步\n   delete(String path, int version, AsyncCallback.VoidCallback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   \n * \n\n * 参数         解释\n   path       节点路径\n   version    版本\n   callBack   数据的版本号， -1代表不使用版本号，乐观锁机制\n   ctx        传递上下文参数\n\n *     public static void deleteData1() throws Exception {\n           zookeeper.delete("/hadoop", 1);\n       }\n   \n       public static void deleteData2() throws Exception {\n           zookeeper.delete("/hadoop", 1, new AsyncCallback.VoidCallback() {\n               @Override\n               public void processResult(int rc, String path, Object ctx) {\n                   System.out.println(rc + " " + path + " " + ctx);\n               }\n           }, "I am context");\n           TimeUnit.SECONDS.sleep(1);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n# 查看节点\n\n同步、异步\n\n * // 同步\n   getData(String path, boolean watch, Stat stat)\n   getData(String path, Watcher watcher, Stat stat)\n   // 异步\n   getData(String path, boolean watch, DataCallback callBack, Object ctx)\n   getData(String path, Watcher watcher, DataCallback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    是否使用连接对象中注册的监听器\n   stat       元数据\n   callBack   异步回调接口，可以获得状态和数据\n   ctx        传递上下文参数\n\n *     public static void getData1() throws Exception {\n           Stat stat = new Stat();\n           byte[] data = zookeeper.getData("/hadoop", false, stat);\n           System.out.println(new String(data));\n           // 判空\n           System.out.println(stat.getCtime());\n       }\n   \n       public static void getData2() throws Exception {\n           zookeeper.getData("/hadoop", false, new AsyncCallback.DataCallback() {\n               @Override\n               public void processResult(int rc, String path, Object ctx, byte[] bytes, Stat stat) {\n                   // 判空\n                   System.out.println(rc + " " + path\n                                      + " " + ctx + " " + new String(bytes) + " " + \n                                      stat.getCzxid());\n               }\n           }, "I am context");\n           TimeUnit.SECONDS.sleep(3);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n# 查看子节点\n\n同步、异步\n\n * // 同步\n   getChildren(String path, boolean watch)\n   getChildren(String path, Watcher watcher)\n   getChildren(String path, boolean watch, Stat stat)    \n   getChildren(String path, Watcher watcher, Stat stat)\n   // 异步\n   getChildren(String path, boolean watch, ChildrenCallback callBack, Object ctx)    \n   getChildren(String path, Watcher watcher, ChildrenCallback callBack, Object ctx)\n   getChildren(String path, Watcher watcher, Children2Callback callBack, Object ctx)    \n   getChildren(String path, boolean watch, Children2Callback callBack, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    \n   callBack   异步回调，可以获取节点列表\n   ctx        传递上下文参数\n\n *     public static void getChildren_1() throws Exception{\n           List<String> hadoop = zookeeper.getChildren("/hadoop", false);\n           hadoop.forEach(System.out::println);\n       }\n   \n       public static void getChildren_2() throws Exception {\n           zookeeper.getChildren("/hadoop", false, new AsyncCallback.ChildrenCallback() {\n               @Override\n               public void processResult(int rc, String path, Object ctx, List<String> list) {\n                   list.forEach(System.out::println);\n                   System.out.println(rc + " " + path + " " + ctx);\n               }\n           }, "I am children");\n           TimeUnit.SECONDS.sleep(3);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n# 检查节点是否存在\n\n同步、异步\n\n * // 同步\n   exists(String path, boolean watch)\n   exists(String path, Watcher watcher)\n   // 异步\n   exists(String path, boolean watch, StatCallback cb, Object ctx)\n   exists(String path, Watcher watcher, StatCallback cb, Object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    \n   callBack   异步回调，可以获取节点列表\n   ctx        传递上下文参数\n\n * public static void exists1() throws Exception{\n       Stat exists = zookeeper.exists("/hadoopx", false);\n       // 判空\n       System.out.println(exists.getVersion() + "成功");\n   }\n   public static void exists2() throws Exception{\n       zookeeper.exists("/hadoopx", false, new AsyncCallback.StatCallback() {\n           @Override\n           public void processResult(int rc, String path, Object ctx, Stat stat) {\n               // 判空\n               System.out.println(rc + " " + path + " " + ctx +" " + stat.getVersion());\n           }\n       }, "I am children");\n       TimeUnit.SECONDS.sleep(1);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n\n# 事件监听机制\n\nwatcher概念\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_WatchRememberThese\n\n * zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时例如节点内容改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者\n * zookeeper采用了 Watcher机制实现数据的发布订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在 Watcher注册后轮询阻塞，从而减轻了客户端压力\n * watcher机制事件上与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式\n\n# watcher架构\n\nwatcher实现由三个部分组成\n\n * zookeeper服务端\n * zookeeper客户端\n * 客户端的ZKWatchManager对象\n\n客户端首先将 Watcher注册到服务端，同时将 Watcher对象保存到客户端的watch管理器中。当Zookeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端，接着客户端的 Watch管理器会**触发相关 Watcher**来回调相应处理逻辑，从而完成整体的数据 发布/订阅流程\n\n\n\n# watcher特性\n\n * \n\n * 特性        说明\n   一次性       watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册\n   客户端顺序回调   watcher回调是顺序串行执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行\n   轻量级       WatchEvent是最小的通信单位，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容\n   时效性       watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；\n\nwatcher接口设计\n\nWatcher是一个接口，任何实现了Watcher接口的类就算一个新的Watcher。Watcher内部包含了两个枚举类：KeeperState、EventType\n\n\n\n# Watcher通知状态(KeeperState)\n\nKeeperState是客户端与服务端连接状态发生变化时对应的通知类型。路径为org.apache.zookeeper.Watcher.EventKeeperState，是一个枚举类，其枚举属性如下：\n\n * \n\n * 枚举属性            说明\n   SyncConnected   客户端与服务器正常连接时\n   Disconnected    客户端与服务器断开连接时\n   Expired         会话session失效时\n   AuthFailed      身份认证失败时\n\n# Watcher事件类型(EventType)\n\nEventType是数据节点znode发生变化时对应的通知类型。EventType变化时KeeperState永远处于SyncConnected通知状态下；当keeperState发生变化时，EventType永远为None。其路径为org.apache.zookeeper.Watcher.Event.EventType，是一个枚举类，枚举属性如下：\n\n * \n\n * 枚举属性                  说明\n   None                  无\n   NodeCreated           Watcher监听的数据节点被创建时\n   NodeDeleted           Watcher监听的数据节点被删除时\n   NodeDataChanged       Watcher监听的数据节点内容发生更改时(无论数据是否真的变化)\n   NodeChildrenChanged   Watcher监听的数据节点的子节点列表发生变更时\n\n * 注意：客户端接收到的相关事件通知中只包含状态以及类型等信息，不包含节点变化前后的具体内容，变化前的数据需业务自身存储，变化后的数据需要调用get等方法重新获取\n\n# 捕获相应的事件\n\n上面讲到zookeeper客户端连接的状态和zookeeper对znode节点监听的事件类型，下面我们来讲解如何建立zookeeper的***watcher监听***。在zookeeper中采用zk.getChildren(path,watch)、zk.exists(path,watch)、zk.getData(path,watcher,stat)这样的方式来为某个znode注册监听 。\n\n下表以node-x节点为例，说明调用的注册方法和可用监听事件间的关系：\n\n注册方式                                CREATED   CHILDRENCHANGED   CHANGED   DELETED\nzk.exists("/node-x",watcher)        可监控                         可监控       可监控\nzk.getData("/node-x",watcher)                                   可监控       可监控\nzk.getChildren("/node-x",watcher)             可监控                         可监控\n\n注册watcher的方法\n\n# 客户端与服务器端的连接状态\n\n * KeeperState：通知状态\n\n * SyncConnected：客户端与服务器正常连接时\n\n * Disconnected：客户端与服务器断开连接时\n\n * Expired：会话session失效时\n\n * AuthFailed：身份认证失败时\n\n * 事件类型为：None\n   \n   * 案例\n   \n   * public class ZkConnectionWatcher implements Watcher {\n         @Override\n         public void process(WatchedEvent watchedEvent) {\n             Event.KeeperState state = watchedEvent.getState();\n             if(state == Event.KeeperState.SyncConnected){\n                 // 正常\n                 System.out.println("正常连接");\n             }else if (state == Event.KeeperState.Disconnected){\n                 // 可以用Windows断开虚拟机网卡的方式模拟\n                 // 当会话断开会出现，断开连接不代表不能重连，在会话超时时间内重连可以恢复正常\n                 System.out.println("断开连接");\n             }else if (state == Event.KeeperState.Expired){\n                 // 没有在会话超时时间内重新连接，而是当会话超时被移除的时候重连会走进这里\n                 System.out.println("连接过期");\n             }else if (state == Event.KeeperState.AuthFailed){\n                 // 在操作的时候权限不够会出现\n                 System.out.println("授权失败");\n             }\n             countDownLatch.countDown();\n         }\n         private static final String IP = "192.168.133.133:2181"\n     ;\n         private static CountDownLatch countDownLatch = new CountDownLatch(1);\n     \n         public static void main(String[] args) throws Exception {\n             // 5000为会话超时时间\n             ZooKeeper zooKeeper = new ZooKeeper(IP, 5000, new ZkConnectionWatcher());\n             countDownLatch.await();\n             // 模拟授权失败\n             zooKeeper.addAuthInfo("digest1","itcast1:123451".getBytes());\n             byte[] data = zooKeeper.getData("/hadoop", false, null);\n             System.out.println(new String(data));\n             TimeUnit.SECONDS.sleep(50);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     \n\n# watcher检查节点\n\nexists\n\n * exists(String path, boolean b)\n\n * exists(String path, Watcher w)\n\n * NodeCreated：节点创建\n\n * NodeDeleted：节点删除\n\n * NodeDataChanged：节点内容\n   \n   * 案例\n   \n   * public class EventTypeTest {\n         private static final String IP = "192.168.133.133:2181";\n         private static CountDownLatch countDownLatch = new CountDownLatch(1);\n         private static ZooKeeper zooKeeper;\n     \n         // 采用zookeeper连接创建时的监听器\n         public static void exists1() throws Exception{\n             zooKeeper.exists("/watcher1",true);\n         }\n         // 自定义监听器\n         public static void exists2() throws Exception{\n             zooKeeper.exists("/watcher1",(WatchedEvent w) -> {\n                 System.out.println("自定义" + w.getType());\n             });\n         }\n         // 演示使用多次的监听器\n         public static void exists3() throws Exception{\n             zooKeeper.exists("/watcher1", new Watcher() {\n                 @Override\n                 public void process(WatchedEvent watchedEvent) {\n                     try {\n                         System.out.println("自定义的" + watchedEvent.getType());\n                     } finally {\n                         try {\n                             zooKeeper.exists("/watcher1",this);\n                         } catch (Exception e) {\n                             e.printStackTrace();\n                         }\n                     }\n                 }\n             });\n         }\n         // 演示一节点注册多个监听器\n         public static void exists4() throws Exception{\n             zooKeeper.exists("/watcher1",(WatchedEvent w) -> {\n                 System.out.println("自定义1" + w.getType());\n             });\n             zooKeeper.exists("/watcher1", new Watcher() {\n                 @Override\n                 public void process(WatchedEvent watchedEvent) {\n                     try {\n                         System.out.println("自定义2" + watchedEvent.getType());\n                     } finally {\n                         try {\n                             zooKeeper.exists("/watcher1",this);\n                         } catch (Exception e) {\n                             e.printStackTrace();\n                         }\n                     }\n                 }\n             });\n         }\n         // 测试\n         public static void main(String[] args) throws Exception {\n             zooKeeper = new ZooKeeper(IP, 5000, new ZKWatcher());\n             countDownLatch.await();\n             exists4();\n             TimeUnit.SECONDS.sleep(50);\n         }\n     \n         static class ZKWatcher implements Watcher{\n             @Override\n             public void process(WatchedEvent watchedEvent) {\n                 countDownLatch.countDown();\n                 System.out.println("zk的监听器" + watchedEvent.getType());\n             }\n         }\n     \n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     47\n     48\n     49\n     50\n     51\n     52\n     53\n     54\n     55\n     56\n     57\n     58\n     59\n     60\n     61\n     62\n     63\n     64\n     65\n     66\n     67\n     68\n     69\n     \n\ngetData\n\n * getData(String path, boolean b, Stat stat)\n * getData(String path, Watcher w, Stat stat)\n * NodeDeleted：节点删除\n * NodeDataChange：节点内容发生变化\n\ngetChildren\n\n * getChildren(String path, boolean b)\n * getChildren(String path, Watcher w)\n * NodeChildrenChanged：子节点发生变化\n * NodeDeleted：节点删除\n\n\n# 配置中心案例\n\n工作中有这样的一个场景：数据库用户名和密码信息放在一个配置文件中，应用读取该配置文件，配置文件信息放入缓存\n\n若数据库的用户名和密码改变时候，还需要重新加载媛存，比较麻烦，通过 Zookeeper可以轻松完成,当数据库发生变化时自动完成缓存同步\n\n使用事件监听机制可以做出一个简单的配置中心\n\n设计思路\n\n 1. 连接zookeeper服务器\n 2. 读取zookeeper中的配置信息，注册watcher监听器，存入本地变量\n 3. 当zookeeper中的配置信息发生变化时，通过watcher的回调方法捕获数据变化事件\n 4. 重新获取配置信息\n\n\n# 分布式唯一id案例\n\n在过去的单库单表型系统中，通常第可以使用数据库字段自带的auto_ increment属性来自动为每条记录生成个唯一的ID。但是分库分表后，就无法在依靠数据库的auto_ increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一ID\n\npublic class IdGenerate {\n\n    private static final String IP = "192.168.133.133:2181";\n    private static CountDownLatch countDownLatch = new CountDownLatch(1);\n    private static ZooKeeper zooKeeper;\n\n    public static String generateId() throws Exception {\n        return zooKeeper.create("/id", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        zooKeeper = new ZooKeeper(IP, 5000, new ZKWatcher());\n        countDownLatch.await();\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<>(10));\n        for (int i = 0; i < 10; i++) {\n            threadPoolExecutor.execute(() -> {\n                try {\n                    System.out.println(generateId());\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        TimeUnit.SECONDS.sleep(50);\n        threadPoolExecutor.shutdown();\n    }\n\n    static class ZKWatcher implements Watcher {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n            countDownLatch.countDown();\n            System.out.println("zk的监听器" + watchedEvent.getType());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 分布式锁案例\n\n分布式锁有多种实现方式，比如通过数据库、redis都可实现。作为分布式协同工具Zookeeper，当然也有着标准的实现方式。下面介绍在zookeeper中如果实现排他锁\n\n设计思路\n\n 1. 每个客户端往/Locks下创建临时有序节点/Locks/Lock_，创建成功后/Locks下面会有每个客户端对应的节点，如/Locks/Lock_000000001\n 2. 客户端取得/Locks下子节点，并进行排序，判断排在前面的是否为自己，如果自己的锁节点在第一位，代表获取锁成功\n 3. 如果自己的锁节点不在第一位，则监听自己前一位的锁节点。例如，自己锁节点Lock_000000002，那么则监听Lock_000000001\n 4. 当前一位锁节点(Lock_000000001)对应的客户端执行完成，释放了锁，将会触发监听客户端(Lock_000000002)的逻辑\n 5. 监听客户端重新执行第2步逻辑，判断自己是否获得了锁\n 6. zookeeper是有工具包的(这里采用手写)\n\n// 线程测试类\npublic class ThreadTest {\n    public static void delayOperation(){\n        try {\n            TimeUnit.SECONDS.sleep(5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    static interface Runable{\n        void run();\n    }\n    public static void run(Runable runable,int threadNum){\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(30, 30,\n                0, TimeUnit.SECONDS, new ArrayBlockingQueue<>(10));\n        for (int i = 0; i < threadNum; i++) {\n            threadPoolExecutor.execute(runable::run);\n        }\n        threadPoolExecutor.shutdown();\n    }\n\n    public static void main(String[] args) {\n//        DistributedLock distributedLock = new DistributedLock();\n//        distributedLock.acquireLock();\n//        delayOperation();\n//        distributedLock.releaseLock();\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");\n        // 每秒打印信息\n        run(() -> {\n            for (int i = 0; i < 999999999; i++) {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                String format = dateTimeFormatter.format(LocalDateTime.now());\n                System.out.println(format);\n            }\n        },1);\n        // 线程测试\n        run(() -> {\n            DistributedLock distributedLock = new DistributedLock();\n            distributedLock.acquireLock();\n            delayOperation();\n            distributedLock.releaseLock();\n        },30);\n    }\n}\npublic class DistributedLock {\n    private String IP = "192.168.133.133:2181";\n    private final String ROOT_LOCK = "/Root_Lock";\n    private final String LOCK_PREFIX = "/Lock_";\n    private final CountDownLatch countDownLatch = new CountDownLatch(1);\n    private final byte[] DATA = new byte[0];\n\n    private ZooKeeper zookeeper;\n    private String path;\n\n    private void init(){\n        // 初始化\n        try {\n            zookeeper = new ZooKeeper(IP, 200000, w -> {\n                if(w.getState() == Watcher.Event.KeeperState.SyncConnected){\n                    System.out.println("连接成功");\n                }\n                countDownLatch.countDown();\n            });\n            countDownLatch.await();\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // 暴露的外部方法，主逻辑\n    public void acquireLock(){\n        init();\n        createLock();\n        attemptLock();\n    }\n\n    // 暴露的外部方法，主逻辑\n    public void releaseLock(){\n        try {\n            zookeeper.delete(path,-1);\n            System.out.println("锁释放了" + path);\n        } catch (InterruptedException | KeeperException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void createLock(){\n        try {\n            // 创建一个目录节点\n            Stat root = zookeeper.exists(ROOT_LOCK, false);\n            if(root == null)\n                zookeeper.create(ROOT_LOCK, DATA, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            // 目录下创建子节点\n            path = zookeeper.create(ROOT_LOCK + LOCK_PREFIX, DATA, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n        } catch (KeeperException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    private Watcher watcher = new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n            if (watchedEvent.getType() == Event.EventType.NodeDeleted){\n                synchronized (this){\n                    this.notifyAll();\n                }\n            }\n        }\n    };\n\n    private void attemptLock(){\n        try {\n            // 获取正在排队的节点，由于是zookeeper生成的临时节点，不会出错，这里不能加监视器\n            // 因为添加了监视器后，任何子节点的变化都会触发监视器\n            List<String> nodes = zookeeper.getChildren(ROOT_LOCK,false);\n            nodes.sort(String::compareTo);\n            // 获取自身节点的排名\n            int ranking = nodes.indexOf(path.substring(ROOT_LOCK.length() + 1));\n            // 已经是最靠前的节点了，获取锁\n            if(ranking == 0){\n                return;\n            }else {\n                // 并不是靠前的锁，监视自身节点的前一个节点\n                Stat status = zookeeper.exists(ROOT_LOCK+"/"+nodes.get(ranking - 1), watcher);\n                // 有可能这这个判断的瞬间，0号完成了操作(此时我们应该判断成功自旋才对)，但是上面的status变量已经获取了值并且不为空，1号沉睡\n                // 但是，请注意自行测试，虽然1号表面上沉睡了，但是实际上watcher.wait()是瞬间唤醒的\n                if(status == null){\n                    attemptLock();\n                }else {\n                    synchronized (watcher){\n                        watcher.wait();\n                    }\n                    attemptLock();\n                }\n            }\n        } catch (KeeperException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n\n\n\n# 集群搭建\n\nzookeeper官网——Getting started——https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_RunningReplicatedZooKeeper\n\n完全配置——https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_zkMulitServerSetup https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_configuration\n\n运行时复制的zookeeper\n\n说明：对于复制模式，至少需要三个服务器，并且强烈建议您使用奇数个服务器。如果只有两台服务器，那么您将处于一种情况，如果其中一台服务器发生故障，则没有足够的计算机构成多数仲裁(zk采用的是过半数仲裁。因此，搭建的集群要容忍n个节点的故障，就必须有2n+1台计算机，这是因为宕掉n台后，集群还残余n+1台计算机，n+1台计算机中必定有一个最完整最接近leader的follower，假如宕掉的n台都是有完整信息的，剩下的一台就会出现在残余的zk集群中。也就是说：zk为了安全，必须达到多数仲裁，否则没有leader，集群失败，具体体现在**leader选举-章**)。由于存在两个单点故障，因此两个服务器还不如单个服务器稳定。\n\n——关于2n+1原则，Kafka官网有权威的解释(虽然Kafka不采用)http://kafka.apache.org/0110/documentation.html#design_replicatedlog\n\n多数仲裁的设计是为了避免脑裂(zk，已经采用了多数仲裁，所以不会出现)，和数据一致性的问题\n\n * 脑裂：由于网络延迟等各种因素，最终导致集群一分为二，各自独立运行(两个leader)，集群就是坏的\n * 如果有两台服务器，两台都认为另外的zk宕掉，各自成为leader运行(假设可以，实际上选不出leader，可以实际搭建一个集群，看看一台zk是否能够成功集群，详见**leader选举**)，就会导致数据不一致。\n * 如果有三台服务器，一台因为网络分区，无法连接，剩下两台网络正常，选举出了leader，集群正常\n * 以此类推\n   * \n   * zk的设计天生就是cap中的cp，所以不会出现上述的脑裂和数据一致性问题，我们搭建zk仅需保证2n+1原则\n\n复制模式所需的conf / zoo.cfg文件类似于独立模式下使用的文件，但有一些区别。这是一个例子：\n\ntickTime=2000\ndataDir=/var/lib/zookeeper\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=zoo1:2888:3888 # 这是多机部署\nserver.2=zoo2:2888:3888\nserver.3=zoo3:2888:3888\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 新的键值**initLimit是zookeeper用于限制选举中zookeeper服务连接到leader的时间，syncLimit**限制服务器与leader的过期时间\n * 对于这两个超时，您都可以使用tickTime指定时间单位。在此示例中，initLimit的超时为5个滴答声，即2000毫秒/滴答声，即10秒\n * 表格*server.X的条目列出了组成ZooKeeper服务的服务器。服务器启动时，它通过在数据目录中查找文件myid*来知道它是哪台服务器。该文件包含ASCII的服务器号。\n * 最后，记下每个服务器名称后面的两个端口号：“ 2888”和“ 3888”。对等方使用前一个端口连接到其他对等方。这种连接是必需的，以便对等方可以进行通信，例如，以商定更新顺序。更具体地说，ZooKeeper服务器使用此端口将follower连接到leader。当出现新的leader者时，follower使用此端口打开与leader的TCP连接。因为默认的leader选举也使用TCP，所以我们当前需要另一个端口来进行leader选举。这是第二个端口。\n\n正文搭建：单机环境下，jdk、zookeeper安装完毕，基于一台虚拟机，进行zookeeper伪集群搭建，zookeeper集群中包含3个节点，节点对外提供服务端口号，分别为2181、2182、2183\n\n 1. 基于zookeeper-3.4.10复制三份zookeeper安装好的服务器文件,目录名称分别为zookeeper2181、zookeeper2182、zookeeper2183\n    \n    cp -r zookeeper-3.4.10  zookeeper2181\n    cp -r zookeeper-3.4.10  zookeeper2182\n    cp -r zookeeper-3.4.10  zookeeper2183\n    \n    # cp -r zookeeper-3.1.10 ./zookeeper218{1..3}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 修改zookeeper2181服务器对应配置文件\n\n# 服务器对应端口号\nclientPort=2181\n# 数据快照文件所在路径\ndataDir=/opt/zookeeper2181/data\n# 集群配置信息\n   # server:A=B:C:D\n   # A:是一个数字，表示这个是服务器的编号\n   # B:是这个服务器的ip地址\n   # C:Zookeeper服务器之间通信的端口(数据互通，必须的)\n   # D:Leader选举的端口\nserver.1=192.168.133.133:2287:3387  # 这是伪集群部署，注意端口号  \nserver.2=192.168.133.133:2288:3388\nserver.3=192.168.133.133:2289:3389\n# 对，这些都是2181的配置文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n 3. 在上一步 dataDir指定的目录下，创建myid文件，然后在该文件添加上一步server配置的对应A数字\n    \n    # zookeeper2181对应的数字为1\n    # /opt/zookeeper2181/data目录(即dataDir的目录下)下执行命令\n    echo "1" > myid\n    \n    \n    1\n    2\n    3\n    \n\n 4. zookeeper2182、2183参照2/3进行相应配置\n\n 5. 分别启动三台服务器，检验集群状态\n    \n    检查：cd进入bin目录./zkServer status\n    \n    登录命令：\n    \n    ./zkCli.sh -server 192.168.60.130:2181\n    ./zkCli.sh -server 192.168.60.130:2182\n    ./zkCli.sh -server 192.168.60.130:2183\n    # 如果启动后没有显示出集群的状态，请自己检查端口和配置文件问题，主要是端口占用和配置文件问题\n    # ss -lntpd | grep 2181\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n# 一致性协议——zab协议\n\nzab协议的全称是 Zookeeper Atomic Broadcast (zookeeper原子广播)。zookeeper是通过zab协议来保证分布式事务的最终一致性\n\n基于zab协议，zookeeper集群中的角色主要有以下三类，如下所示：\n\n角色                           描述\n领导者(Leader)                  领导者负责进行投票的发起和决议，更新系统状态\n学习者(Learner)-跟随者(Follower)   Follower用于接收客户端请求并向客户端返回结果，在选主过程中参与投票\n学习者(Learner)-观察者(ObServer)   ObServer可以接收客户端连接，将写请求转发给leader节点。但ObServer不参加投票过程，只同步leader的状态。ObServer的目的是为了扩展系统，提高读取速度\n客户端(Client)                  请求发起方\n\n·zab广播模式工作原理，通过类似两端式提交协议的方式解决数据一致性：\n\n\n\n 1. leader从客户端收到一个写请求\n 2. leader生成一个新的事务并为这个事务生成一个唯一的ZXID\n 3. leader将事务提议(propose)发送给所有的follows节点\n 4. follower节点将收到的事务请求加入到本地历史队列(history queue)中，并发送ack给leader，表示确认提议\n 5. 当leader收到大多数follower(半数以上节点)的ack(acknowledgement)确认消息，leader会本地提交，并发送commit请求\n 6. 当follower收到commit请求时，从历史队列中将事务请求commit\n\n因为是半数以上的结点就可以通过事务请求，所以延迟不高\n\n# leader选举\n\n服务器状态\n\n * looking：寻找leader状态。当服务器处于该状态时，它会认为当前集群中没有leader，因此需要进入leader选举状态\n * following：跟随着状态。表明当前服务器角色是follower\n * observing：观察者状态。表明当前服务器角色是observer\n\n分为两种选举，服务器启动时的选举和服务器运行时期的选举\n\n服务器启动时期的leader选举\n\n在集群初始化节点，当有一台服务器server1启动时，其单独无法进行和完成leader选举，当第二台服务器server2启动时，此时两台及其可以相互通信，每台及其都试图找到leader，于是进入leader选举过程。选举过程如下：\n\n 1. 每个server发出一个投票。由于是初始状态，server1和server2都会将自己作为leader服务器来进行投票，每次投票都会包含所推举的myid和zxid，使用(myid，zxid)，此时server1的投票为(1，0)，server2的投票为(2，0)，然后各自将这个投票发给集群中的其它机器\n\n 2. 集群中的每台服务器都接收来自集群中各个服务器的投票\n\n 3. 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，规则如下\n    \n    * 优先检查zxid。zxid比较大的服务器优先作为leader(zxid较大者保存的数据更多)\n    \n    * 如果zxid相同。那么就比较myid。myid较大的服务器作为leader服务器\n      \n      对于Server1而言，它的投票是(1，0)，接收Server2的投票为(2，0)，首先会比较两者的zxid，均为0，再比较myid，此时server2的myid最大，于是更新自己的投票为(2，0)，然后重新投票，对于server2而言，无需更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可\n\n 4. 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于server1、server2而言，都统计出集群中已经有两台机器接受了(2，0)的投票信息，此时便认为已经选举出了leader\n\n 5. 改变服务器状态。一旦确定了leader,每个服务器就会更新自己的状态，如果是follower，那么就变更为following，如果是leader，就变更为leading\n\n举例：如果我们有三个节点的集群，1，2，3，启动 1 和 2 后，2 一定会是 leader，3 再加入不会进行选举，而是直接成为follower—— 仔细观察 一台zk无法集群，没有leader\n\n服务器运行时期选举\n\n在zookeeper运行期间，leader与非leader服务器各司其职，即使当有非leader服务器宕机或者新加入，此时也不会影响leader，但是一旦leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮leader选举，其过程和启动时期的leader选举过程基本一致\n\n假设正在运行的有server1、server2、server3三台服务器，当前leader是server2，若某一时刻leader挂了，此时便开始Leader选举。选举过程如下\n\n 1. 变更状态。leader挂后，余下的服务器都会将自己的服务器状态变更为looking，然后开始进入leader选举过程\n 2. 每个server发出一个投票。在运行期间，每个服务器上的zxid可能不同，此时假定server1的zxid为122，server3的zxid为122，在第一轮投票中，server1和server3都会投自己，产生投票(1，122)，(3，122)，然后各自将投票发送给集群中所有机器\n 3. 接收来自各个服务器的投票。与启动时过程相同\n 4. 处理投票。与启动时过程相同，此时，server3将会成为leader\n 5. 统计投票。与启动时过程相同\n 6. 改变服务器的状态。与启动时过程相同\n\n# observer角色及其配置\n\nzookeeper官网——Observers Guidehttps://zookeeper.apache.org/doc/r3.4.14/zookeeperObservers.html\n\n尽管ZooKeeper通过使用客户端直接连接到该集合的投票成员表现良好，但是此体系结构使其很难扩展到大量客户端。问题在于，随着我们添加更多的投票成员，写入性能会下降。这是由于以下事实：写操作需要（通常）集合中至少一半节点的同意，因此，随着添加更多的投票者，投票的成本可能会显着增加。\n\n我们引入了一种称为Observer的新型ZooKeeper节点，该节点有助于解决此问题并进一步提高ZooKeeper的可伸缩性。观察员是合法的非投票成员，他们仅听取投票结果，而听不到投票结果。除了这种简单的区别之外，观察者的功能与跟随者的功能完全相同-客户端可以连接到观察者，并向其发送读写请求。观察者像追随者一样将这些请求转发给领导者，但是他们只是等待听取投票结果。因此，我们可以在不影响投票效果的情况下尽可能增加观察员的数量。\n\n观察者还有其他优点。因为他们不投票，所以它们不是ZooKeeper选举中的关键部分。因此，它们可以在不损害ZooKeeper服务可用性的情况下发生故障或与群集断开连接。给用户带来的好处是，观察者可以通过比跟随者更不可靠的网络链接进行连接。实际上，观察者可用于与另一个数据中心的ZooKeeper服务器进行对话。观察者的客户端将看到快速读取，因为所有读取均在本地提供，并且由于缺少表决协议而需要的消息数量较小，因此写入会导致网络流量最小\n\novserver角色特点：\n\n 1. 不参与集群的leader选举\n 2. 不参与集群中写数据时的ack反馈\n\n为了使用observer角色，在任何想变成observer角色的配置文件中加入如下配置：\n\npeerType=observer\n\n\n1\n\n\n并在所有server的配置文件中，配置成observer模式的server的那行配置追加***:observer***，例如\n\nserver.1=192.168.133.133:2287:3387  # 注意端口号  \nserver.2=192.168.133.133:2288:3388\nserver.3=192.168.133.133:2289:3389:observer\n\n\n1\n2\n3\n\n\n注意2n+1原则——集群搭建\n\n# API连接集群\n\nZookeeper(String connectionString, int sessionTimeout, Watcher watcher)\n\n * connectionString ：zookeeper集合主机\n * sessionTimeout：会话超时(以毫秒为单位)\n * watcher：实现"监听器"界面的对象。zookeeper集合通过监视器对象返回连接状态\n\n    public static void main(String[] args) throws Exception {\n        CountDownLatch countDownLatch = new CountDownLatch(1);\n        ZooKeeper connection = new ZooKeeper("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183", 5000, watchedEvent -> {\n            if (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected)\n                System.out.println("连接成功");\n            countDownLatch.countDown();\n        });\n        countDownLatch.await();\n        connection.create("/hadoop",new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);\n        System.out.println(connection.getSessionId());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# curator介绍\n\nhttps://blog.csdn.net/wo541075754/article/details/68067872 关于第三方客户端的小介绍\n\nzkClient有对dubbo的一些操作支持，但是zkClient几乎没有文档，下面是curator\n\ncurator简介\n\ncurator是Netflix公司开源的一个 zookeeper客户端，后捐献给 apache,，curator框架在zookeeper原生API接口上进行了包装，解决了很多zooKeeper客户端非常底层的细节开发。提供zooKeeper各种应用场景(比如:分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等的抽象封装，实现了Fluent风格的APl接口，是最好用，最流行的zookeeper的客户端\n\n原生zookeeperAPI的不足\n\n * 连接对象异步创建，需要开发人员自行编码等待\n * 连接没有自动重连超时机制\n * watcher一次注册生效一次\n * 不支持递归创建树形节点\n\ncurator特点\n\n * 解决session会话超时重连\n * watcher反复注册\n * 简化开发api\n * 遵循Fluent风格API\n\n    \x3c!-- Zookeeper --\x3e\n    <dependency>\n        <groupId>org.apache.zookeeper</groupId>\n        <artifactId>zookeeper</artifactId>\n        <version>3.4.10</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-framework</artifactId>\n        <version>2.6.0</version>\n        <exclustions>\n            <exclustion>\n               <groupId>org.apache.zookeeper</groupId>\n               <artifactId>zookeeper</artifactId>\n            </exclustion>\n        </exclustions>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.curator</groupId>\n        <artifactId>curator-recipes</artifactId>\n        <version>2.6.0</version>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 基础用法\n\n    public static void main(String[] args) {\n        // 工厂创建，fluent风格\n        CuratorFramework client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点\n                .namespace("create")\n                .build();\n        client.start();\n        \n        System.out.println(client.getState());\n        client.close();\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * session重连策略\n   * RetryPolicy retry Policy = new RetryOneTime(3000);\n     * 说明：三秒后重连一次，只重连一次\n   * RetryPolicy retryPolicy = new RetryNTimes(3,3000);\n     * 说明：每三秒重连一次，重连三次\n   * RetryPolicy retryPolicy = new RetryUntilElapsed(1000,3000);\n     * 说明：每三秒重连一次，总等待时间超过个10秒后停止重连\n   * RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3)\n     * 说明：这个策略的重试间隔会越来越长\n       * 公式：baseSleepTImeMs * Math.max(1,random.nextInt(1 << (retryCount + 1)))\n         * baseSleepTimeMs = 1000 例子中的值\n         * maxRetries = 3 例子中的值\n\n# 创建\n\npublic class curatorGettingStart {\n    public static CuratorFramework client;\n\n    // ids权限\n    public static void create1() throws Exception {\n        // 新增节点\n        client.create()\n                // 节点的类型\n                .withMode(CreateMode.EPHEMERAL)\n                // 节点的acl权限列表\n                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                // arg1：节点路径，arg2：节点数据\n                .forPath("/node1",new byte[0]);\n    }\n    // 自定义权限\n    public static void create2() throws Exception {\n        ArrayList<ACL> acls = new ArrayList<>();\n        Id id = new Id("world", "anyone");\n        acls.add(new ACL(ZooDefs.Perms.READ,id));\n        // 新增节点\n        client.create()\n                // 节点的类型\n                .withMode(CreateMode.EPHEMERAL)\n                // 节点的acl权限列表\n                .withACL(acls)\n                // arg1：节点路径，arg2：节点数据\n                .forPath("/node2",new byte[0]);\n    }\n    // 递归创建\n    public static void create3() throws Exception {\n        // 新增节点\n        client.create()\n                // 递归创建\n                .creatingParentsIfNeeded()\n                // 节点的类型\n                .withMode(CreateMode.EPHEMERAL)\n                // 节点的acl权限列表\n                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                // arg1：节点路径，arg2：节点数据\n                .forPath("/node2/nodex",new byte[0]);\n    }\n    // 递归创建\n    public static void create4() throws Exception {\n        // 新增节点\n        System.out.println(1);\n        client.create()\n\n                .creatingParentsIfNeeded()\n                // 节点的类型\n                .withMode(CreateMode.EPHEMERAL)\n                // 节点的acl权限列表\n                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                // 异步\n                .inBackground(new BackgroundCallback() {\n                    @Override\n                    public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception {\n                        System.out.println("异步创建成功");\n                    }\n                })\n                // arg1：节点路径，arg2：节点数据\n                .forPath("/node2/nodex",new byte[0]);\n        System.out.println(2);\n    }\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        CuratorFramework client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点\n                .namespace("create")\n                .build();\n        client.start();\n//        create1();\n//        create2();\n//        create3();\n        create4();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n# 修改\n\npublic class curatorGettingStart {\n    public static CuratorFramework client;\n\n    public static void set1() throws Exception {\n        // 修改节点\n        client.setData()\n                // 版本\n                .withVersion(-1)\n                .forPath("/hadoop","hadoop1".getBytes());\n    }\n    public static void set2() throws Exception {\n        // 修改节点\n        client.setData()\n                .withVersion(1)\n                .forPath("/hadoop","hadoop2".getBytes());\n    }\n    public static void set3() throws Exception {\n        // 修改节点\n        client.setData()\n                .withVersion(1)\n                // 异步\n                .inBackground(new BackgroundCallback() {\n                    @Override\n                    public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception {\n                        if(curatorEvent.getType() == CuratorEventType.SET_DATA)\n                            System.out.println(curatorEvent.getPath()+ "    " +curatorEvent.getType());\n                    }\n                })\n                .forPath("/hadoop","hadoop3".getBytes());\n\n    }\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("update")\n                .build();\n        client.start();\n//        set1();\n        set2();\n//        set3();\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 删除\n\npublic class curatorGettingStart {\n    public static CuratorFramework client;\n    public static void delete1() throws Exception {\n        // 删除节点\n        client.delete()\n                .forPath("node1");\n    }\n\n    public static void delete2() throws Exception {\n        // 删除节点\n        client.delete()\n                // 版本\n                .withVersion(1)\n                .forPath("node2");\n    }\n\n    public static void delete3() throws Exception {\n        // 删除节点\n        client.delete()\n                // 递归删除\n                .deletingChildrenIfNeeded()\n                .withVersion(-1)\n                .forPath("node3");\n    }\n\n    public static void delete4() throws Exception {\n        // 删除节点\n        client.delete()\n                .withVersion(-1)\n                // 异步\n                .inBackground(new BackgroundCallback() {\n                    @Override\n                    public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception {\n                        if (curatorEvent.getType() == CuratorEventType.DELETE)\n                            System.out.println(curatorEvent.getPath() + "    " + curatorEvent.getType());\n                    }\n                })\n                .forPath("node3");\n\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("delete")\n                .build();\n        client.start();\n        //        delete1();\n        //        delete2();\n        //        delete3();\n        // delete4();\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 读取节点\n\npublic class curatorGettingStart {\n    public static CuratorFramework client; \n    public static void get1() throws  Exception {\n        // 获取数据\n        byte[] bytes = client.getData()\n                .forPath("/node");\n        System.out.println(new String((bytes)));\n    }\n    public static void get2() throws  Exception {\n        Stat stat = new Stat();\n        // 获取数据\n        byte[] bytes = client.getData()\n                .storingStatIn(stat)\n                .forPath("/node");;\n        System.out.println(new String((bytes)));\n        System.out.println(stat.getVersion());\n        System.out.println(stat.getCzxid());\n    }\n    public static void get3() throws  Exception {\n        System.out.println(1);\n        // 获取数据\n        client.getData()\n                .inBackground((CuratorFramework curatorFramework, CuratorEvent curatorEvent) -> {\n                    System.out.println(curatorEvent.getPath() + "  " + curatorEvent.getType());\n                })\n                .forPath("/node");;\n        System.out.println(2);\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("get")\n                .build();\n        client.start();\n        get1();\n        get2();\n        get3();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n# 读取子节点\n\n public class curatorGettingStart {\n    public static CuratorFramework client;  \n    public static void getChildren1() throws  Exception {\n        // 获取数据\n        List<String> strings = client.getChildren()\n                .forPath("/get");\n        strings.forEach(System.out::println);\n        System.out.println("------------");\n    }\n    public static void getChildren2() throws  Exception {\n        System.out.println(1);\n        // 获取数据\n        client.getChildren()\n                .inBackground((curatorFramework, curatorEvent) -> {\n                    curatorEvent.getChildren().forEach(System.out::println);\n                    System.out.println("------------");\n                })\n                .forPath("/get");\n        System.out.println(2);\n        System.out.println("------------");\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n//                .namespace("get")\n                .build();\n        client.start();\n\n        getChildren1();\n        getChildren2();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n# watcher\n\npublic class WatcherTest {\n    static CuratorFramework client;\n\n    public static void watcher1() throws Exception {\n        // arg1 curator的客户端\n        // arg2 监视的路径\n        NodeCache nodeCache = new NodeCache(client, "/watcher");\n        // 启动\n        nodeCache.start();\n        nodeCache.getListenable().addListener(new NodeCacheListener() {\n            @Override\n            // 节点变化时的回调方法\n            public void nodeChanged() throws Exception {\n                // 路径\n                System.out.println(nodeCache.getCurrentData().getPath() + "  " + nodeCache.getCurrentData().getStat());\n                // 输出节点内容\n                System.out.println(new String(nodeCache.getCurrentData().getData()));\n            }\n        });\n        System.out.println("注册完成");\n        // 时间窗内可以一直监听\n        //        TimeUnit.SECONDS.sleep(1000);\n        //关 闭\n        nodeCache.close();\n    }\n\n    public static void watcher2() throws Exception {\n        // arg1 客户端\n        // arg2 路径\n        // arg3 事件钟是否可以获取节点数据\n        PathChildrenCache pathChildrenCache = new PathChildrenCache(client, "/watcher", true);\n        // 启动\n        pathChildrenCache.start();\n        pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() {\n            @Override\n            // 节点变化时的回调方法\n            public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent) throws Exception {\n                if (pathChildrenCacheEvent != null) {\n                    // 获取子节点数据\n                    System.out.println(new String(pathChildrenCacheEvent.getData().getData()));\n                    // 路径\n                    System.out.println(pathChildrenCacheEvent.getData().getPath());\n                    // 事件类型\n                    System.out.println(pathChildrenCacheEvent.getType());\n                }\n            }\n        });\n        // 时间窗内可以一直监听\n        TimeUnit.SECONDS.sleep(1000);\n        //关 闭\n        pathChildrenCache.close();\n\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n\n//        watcher1();\n        watcher2();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n# 事务\n\npublic class CuratorTransaction {\n    static CuratorFramework client;\n\n\n    public static void transaction() throws Exception{\n        /*client.inTransaction()\n                .create()\n                    .withMode(CreateMode.PERSISTENT)\n                    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                    .forPath("/transaction",new byte[0])\n                .and()\n                .setData()\n                    .forPath("/setData/transaction",new byte[0])\n                .and()\n                .commit();*/\n        client.create()\n                .withMode(CreateMode.PERSISTENT)\n                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)\n                .forPath("/transaction",new byte[0]);\n        client.setData()\n                .forPath("/setData/transaction",new byte[0]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n        transaction();\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n# 分布式锁\n\n * InterProcessMutex：分布式可重入排它锁\n * InterProcessReadWriteLock：分布式读写锁\n\npublic class CuratorDistributeLock {\n    public static CuratorFramework client;\n\n    public static void interProcessMutex() throws Exception {\n        System.out.println("排他锁");\n        // 获取一个分布式排他锁\n        InterProcessMutex lock = new InterProcessMutex(client, "/lock1");\n        // 开启两个进程测试，会发现：如果一个分布式排它锁获取了锁，那么直到锁释放为止数据都不会被侵扰\n        System.out.println("获取锁中");\n        lock.acquire();\n        System.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            TimeUnit.SECONDS.sleep(1);\n            System.out.println(i);\n        }\n        lock.release();\n        System.out.println("释放锁");\n    }\n\n    public static void interProcessReadWriteLock1() throws Exception {\n        System.out.println("写锁");\n        // 分布式读写锁\n        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock1");\n        // 开启两个进程测试，观察到写写互斥，特性同排它锁\n        System.out.println("获取锁中");\n        lock.writeLock().acquire();\n        System.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            TimeUnit.SECONDS.sleep(1);\n            System.out.println(i);\n        }\n        lock.writeLock().release();\n        System.out.println("释放锁");\n    }\n\n    public static void interProcessReadWriteLock2() throws Exception {\n        System.out.println("读锁");\n        // 分布式读写锁\n        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock1");\n        // 开启两个进程测试，观察得到读读共享，两个进程并发进行，注意并发和并行是两个概念，(并发是线程启动时间段不一定一致，并行是时间轴一致的)\n        // 再测试两个进程，一个读，一个写，也会出现互斥现象\n        System.out.println("获取锁中");\n        lock.readLock().acquire();\n        System.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            TimeUnit.SECONDS.sleep(1);\n            System.out.println(i);\n        }\n        lock.readLock().release();\n        System.out.println("释放锁");\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        // 工厂创建，fluent风格\n        client = CuratorFrameworkFactory.builder()\n                // ip端口号\n                .connectString("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessionTimeoutMs(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retryPolicy(new RetryOneTime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n        //        interProcessMutex();\n//                interProcessReadWriteLock1();\n        interProcessReadWriteLock2();\n\n\n        System.out.println(client.getState() + "操作完成");\n        TimeUnit.SECONDS.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n# 四字监控命令/配置属性\n\nzookeeper文档——administrator\'s Guide——https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_zkCommands 四字命令\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_configuration 配置属性\n\nzookeeper支持某些特定的四字命令与其的交互。它们大多数是查询命令，用来获取zookeeper服务的当前状态及相关信息。用户再客户端可以通过telnet或nc向zookeeper提交相应的命令。zookeeper常用四字命令见下表所示：\n\n命令     描述\nconf   输出相关服务配置的详细信息。比如端口号、zk数据以及日志配置路径、最大连接数，session超时、serverId等\ncons   列出所有连接到这台服务器的客户端连接/会话的详细信息。包括"接收/发送"的包数量、sessionId、操作延迟、最后的操作执行等信息\ncrst   重置当前这台服务器所有连接/会话的统计信息\ndump   列出未经处理的会话和临时节点，这仅适用于领导者\nenvi   处理关于服务器的环境详细信息\nruok   测试服务是否处于正确运行状态。如果正常返回"imok"，否则返回空\nstat   输出服务器的详细信息：接收/发送包数量、连接数、模式(leader/follower)、节点总数、延迟。所有客户端的列表\nsrst   重置server状态\nwchs   列出服务器watchers的简洁信息：连接总数、watching节点总数和watches总数\nwchc   通过session分组，列出watch的所有节点，它的输出是一个与watch相关的会话的节点信息，根据watch数量的不同，此操作可能会很昂贵（即影响服务器性能），请小心使用\nmntr   列出集群的健康状态。包括"接收/发送"的包数量、操作延迟、当前服务模式(leader/follower)、节点总数、watch总数、临时节点总数\n\ntclnet\n\n * yum install -y tclnet\n * tclnet 192.168.133.133 2181(进入终端)\n   * mntr(现在可以看到信息)\n\nnc\n\n * yum install -y nc\n   * echo mntr | nc 192.168.133.133:2181\n\n# conf\n\n输出相关服务配置的详细信息\n\n属性                  含义\nclientPort          客户端端口号\ndataDir             数据快照文件目录，默认情况下10w次事务操作生成一次快照\ndataLogDir          事务日志文件目录，生产环节中放再独立的磁盘上\ntickTime            服务器之间或客户端与服务器之间维持心跳的时间间隔(以毫秒为单位)\nmaxClientCnxns      最大连接数\nminSessionTimeout   最小session超时minSessionTimeout=tickTime*2\n                    ，即使客户端连接设置了会话超时，也不能打破这个限制\nmaxSessionTimeout   最大session超时maxSessionTimeout=tickTime*20，即使客户端连接设置了会话超时，也不能打破这个限制\nserverId            服务器编号\ninitLimit           集群中follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数，实际上以tickTime为单位，换算为毫秒数\nsyncLimit           集群中follower服务器(F)与leader服务器(L)之间请求和应答之间能容忍的最大心跳数，实际上以tickTime为单位，换算为毫秒数\nelectionAlg         0：基于UDP的LeaderElection1：基于UDP的FastLeaderElection2：基于UDP和认证的FastLeaderElection3：基于TCP的FastLeaderElection在3.4.10版本中，默认值为3，另外三种算法以及被弃用，并且有计划在之后的版本中将它们彻底删除且不再支持\nelectionPort        选举端口\nquorumPort          数据通信端口\npeerType            是否为观察者 1为观察者\n\n# cons\n\n列出所有连接到这台服务器的客户端连接/会话的详细信息\n\n属性         含义\nip         IP地址\nport       端口号\nqueued     等待被处理的请求数，请求缓存在队列中\nreceived   收到的包数\nsent       发送的包数\nsid        会话id\nlop        最后的操作 GETD-读取数据 DELE-删除数据 CREA-创建数据\nest        连接时间戳\nto         超时时间\nlcxid      当前会话的操作id\nlzxid      最大事务id\nlresp      最后响应时间戳\nllat       最后/最新 延迟\nminlat     最小延时\nmaxlat     最大延时\navglat     平均延时\n\n# crst\n\n重置当前这台服务器所有连接/会话的统计信息\n\n# dump\n\n列出临时节点信息，适用于leader\n\n# envi\n\n输出关于服务器的环境详细信息\n\n属性                  含义\nzookeeper.version   版本\nhost.name           host信息\njava.version        java版本\njava.vendor         供应商\njava.home           运行环境所在目录\njava.class.path     classpath\njava.library.path   第三方库指定非Java类包的为止(如：dll，so)\njava.io.tmpdir      默认的临时文件路径\njava.compiler       JIT编辑器的名称\nos.name             Linux\nos.arch             amd64\nos.version          3.10.0-1062.el7.x86_64\nuser.name           zookeeper\nuser.home           /opt/zookeeper\nuser.dir            /opt/zookeeper/zookeeper2181/bin\n\n# ruok\n\n测试服务是否处于正确运行状态，如果目标正确运行会返回imok（are you ok | I\'m ok）\n\n# stat\n\n输出服务器的详细信息与srvr相似(srvr这里不举例了，官网有一点描述)，但是多了每个连接的会话信息\n\n属性                    含义\nzookeeper version     版本\nLatency min/avg/max   延时\nReceived              收包\nSent                  发包\nConnections           当前服务器连接数\nOutstanding           服务器堆积的未处理请求数\nZxid                  最大事务id\nMode                  服务器角色\nNode count            节点数\n\n# srst\n\n重置server状态\n\n# wchs\n\n列出服务器watches的简洁信息\n\n属性             含义\nconnectsions   连接数\nwatch-paths    watch节点数\nwatchers       watcher数量\n\n# wchc\n\n通过session分组，列出watch的所有节点，它的输出是一个与watch相关的会话的节点列表\n\n问题\n\nwchc is not executed because it is not in the whitelist\n\n解决办法\n\n# 修改启动指令zkServer.sh\n# 注意找到这个信息\nelse\n\techo "JMX disabled by user request" >&2\n\tZOOMAIN="org.apache.zookeeper.server.quorum.QuorumPeerMain"\nfi\n# 下面添加如下信息\nZOOMAIN="-Dzookeeper.4lw.commands.whitelist=* ${ZOOMAIN}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每一个客户端的连接的watcher信息都会被收集起来，并且监控的路径都会被展示出来（代价高，消耗性能）\n\n[root@localhost bin]# echo wchc | nc 192.168.133.133 2180\n0x171be6c6faf0000\n        /node2\n        /node1\n0x171be6c6faf0001\n        /node3\n\n\n1\n2\n3\n4\n5\n6\n\n\n# wchp\n\n通过路径分组，列出所有的watch的session id 信息\n\n配置同wchc\n\n# mntr\n\n列出服务器的健康状态\n\n属性                              含义\nzk_version                      版本\nzk_avg_latency                  平均延时\nzk_max_latency                  最大延时\nzk_min_latency                  最小延时\nzk_packets_received             收包数\nzk_packets_sent                 发包数\nzk_num_alive_connections        连接数\nzk_outstanding_requests         堆积请求数\nzk_server_state                 leader/follower状态\nzk_znode_count                  znode数量\nzk_watch_count                  watch数量\nzk_ephemerals_count             l临时节点(znode)\nzk_approximate_data_size        数据大小\nzk_open_file_descriptor_count   打开的文件描述符数量\nzk_max_file_descriptor_count    最大文件描述符数量\n\n\n# ZooInspector图形化工具\n\n随便百度一个连接就好了\n\nhttps://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip\n\n * 解压后进入目录ZooInspector\\build，运行zookeeper-dev-ZooInspector.jar\n * java -jar 运行，之后会弹出一个客户端\n * \n * \n * \n * 其它的不必多说，很容易懂(主要是功能也就这几个面板，主要还是直接zkCli.sh)\n\ntaokeeper检控工具\n\nbeta版，也就是公测版本(并不是开源的)，这里我自己都不用了，期待未来，文档我就照搬了\n\n基于zookeeper的监控管理工具taokeeper，由淘宝团队开发的zk管理中间件，安装强要求服务先配置nc和sshd\n\n 1. 下载数据库脚本——算了，我放弃了\n\n',normalizedContent:'官方文档上这么解释zookeeper，它是一个分布式服务框架，是apache hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。\n\n简单来说zookeeper=文件系统+监听通知机制。\n\n\n\n * 简介/快速入门\n * 常用shell命令\n * zookeeper的acl权限控制\n * zookeeper的 javaapi\n * 事件监听机制\n * 配置中心案例\n * 分布式唯一id案例\n * 分布式锁案例\n * 集群搭建\n * curator介绍\n * 四字监控命令/配置属性\n * zooinspector图形化工具\n\n\n\n\n# 简介/快速入门\n\n官网：https://zookeeper.apache.org/\n\n> zookeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. all of these kinds of services are used in some form or another by distributed applications. each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.\n\nzookeeper是一个集中的服务，用于维护配置信息、命名、提供分布式同步和提供组服务。所有这些类型的服务都以某种形式被分布式应用程序使用。每次它们被实现时，都会有大量的工作来修复不可避免的错误和竞争条件。由于实现这些服务的困难，应用程序最初通常会略过这些服务，这使得它们在出现更改时变得脆弱，并且难以管理。即使正确地执行了这些服务，在部署应用程序时，这些服务的不同实现也会导致管理复杂性\n\nzookeeper由雅虎研究院开发,是google chubby的开源实现,后来托管到 apache,于2010年11月正式成为apache的顶级项目\n\n大数据生态系统里由很多组件的命名都是某些动物或者昆虫，比如hadoop大象，hive就是蜂巢，zookeeper即管理员，顾名思义就算管理大数据生态系统各组件的管理员，如下所示：\n\n\n\n# 应用场景\n\nzookeepepr是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用,且具有严格顺序访问控制能力的分布式协调存储服务。\n\n * 维护配置信息\n * 分布式锁服务\n * 集群管理\n * 生成分布式唯一id\n\n 1. 维护配置信息\n    \n    * java编程经常会遇到配置项，比如数据库的url、 schema、user和 password等。通常这些配置项我们会放置在配置文件中，再将配置文件放置在服务器上当需要更改配置项时，需要去服务器上修改对应的配置文件。\n      \n      但是随着分布式系统的兴起,由于许多服务都需要使用到该配置文件,因此有必须保证该配置服务的高可用性(highavailability)和各台服务器上配置数据的一致性。\n      \n      通常会将配置文件部署在一个集群上，然而一个集群动辄上千台服务器，此时如果再一台台服务器逐个修改配置文件那将是非常繁琐且危险的的操作，因此就需要一种服务，能够高效快速且可靠地完成配置项的更改等操作，并能够保证各配置项在每台服务器上的数据一致性。\n      \n      zookeeper就可以提供这样一种服务，其使用zab这种一致性协议来保证一致性。现在有很多开源项目使用zookeeper来维护配置，如在 hbase中，客户端就是连接一个 zookeeper，获得必要的 hbase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列 kafka中，也便用zookeeper来维护 brokers的信息。在 alibaba开源的soa框架dubbo中也广泛的使用zookeeper管理一些配置来实现服务治理。\n      \n      \n\n 2. 分布式锁服务\n    \n    * 一个集群是一个分布式系统，由多台服务器组成。为了提高并发度和可靠性，多台服务器上运行着同一种服务。当多个服务在运行时就需要协调各服务的进度，有时候需要保证当某个服务在进行某个操作时，其他的服务都不能进行该操作，即对该操作进行加锁，如果当前机器挂掉后，释放锁并 fail over到其他的机器继续执行该服务\n\n 3. 集群管理\n    \n    * 一个集群有时会因为各种软硬件故障或者网络故障，出现棊些服务器挂掉而被移除集群，而某些服务器加入到集群中的情况，zookeeper会将这些服务器加入/移出的情况通知给集群中的其他正常工作的服务器，以及时调整存储和计算等任务的分配和执行等。此外zookeeper还会对故障的服务器做出诊断并尝试修复。\n      \n      \n\n 4. 生产分布式唯一id\n    \n    * 在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_ increment属性来自动为每条记录生成一个唯一的id。但是分库分表后，就无法在依靠数据库的auto_ increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一id。\n      \n      做法如下:每次要生成一个新id时，创建一个持久顺序节点，创建操作返回的节点序号，即为新id，然后把比自己节点小的删除即可\n\n# zookeeper的设计目标\n\nzookeeper致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务\n\n 1. 高性能\n    * zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，尤其用于以读为主的应用场景\n 2. 高可用\n    * zookeeper一般以集群的方式对外提供服务，一般3~5台机器就可以组成一个可用的 zookeeper集群了，每台机器都会在内存中维护当前的服务器状态，井且每台机器之间都相互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服务\n 3. 严格顺序访问\n    * 对于来自客户端的每个更新请求，zookeeper都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序\n\n# 数据模型\n\nzookeeper的数据结点可以视为树状结构(或目录)，树中的各个结点被称为znode(即zookeeper node)，一个znode可以由多个子结点。zookeeper结点在结构上表现为树状；\n\n使用路径path来定位某个znode，比如/ns-1/itcast/mysqml/schemal1/table1，此处ns-1，itcast、mysql、schemal1、table1分别是根结点、2级结点、3级结点以及4级结点；其中ns-1是itcast的父结点，itcast是ns-1的子结点，itcast是mysql的父结点....以此类推\n\nznode，间距文件和目录两种特点，即像文件一样维护着数据、元信息、acl、时间戳等数据结构，又像目录一样可以作为路径标识的一部分\n\n\n\n那么如何描述一个znode呢？一个znode大体上分为3个部分：\n\n * 结点的数据：即znode data(结点path，结点data)的关系就像是java map中的 key value关系\n * 结点的子结点children\n * 结点的状态stat：用来描述当前结点的创建、修改记录，包括czxid、ctime等\n\n# 结点状态stat的属性\n\n在zookeeper shell中使用 get命令查看指定路径结点的data、stat信息\n\n\n\n属性说明：\n\n结点的各个属性如下。其中重要的概念是zxid(zookeeper transaction id)，zookeeper结点的每一次更改都具有唯一的zxid，如果zxid-1 小于zxid-2 ，则zxid-1 的更改发生在 zxid-2更改之前\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperprogrammers.html#sc_zkdatamodel_znodes\n\n * czxid数据结点创建时的事务id——针对于zookeeper数据结点的管理：我们对结点数据的一些写操作都会导致zookeeper自动地为我们去开启一个事务，并且自动地去为每一个事务维护一个事务id\n * ctime数据结点创建时的时间\n * mzxid数据结点最后一次更新时的事务id\n * mtime数据结点最后一次更新时的时间\n * pzxid数据节点最后一次修改此znode子节点更改的zxid\n * cversion子结点的更改次数\n * dataversion结点数据的更改次数\n * aclversion结点的acl更改次数——类似linux的权限列表，维护的是当前结点的权限列表被修改的次数\n * ephemeralowner如果结点是临时结点，则表示创建该结点的会话的sessionid；如果是持久结点，该属性值为0\n * datalength数据内容的长度\n * numchildren数据结点当前的子结点个数\n\n结点类型\n\nzookeeper中的结点有两种，分别为临时结点和永久结点。结点的类型在创建时被确定，并且不能改变\n\n * 临时节点：\n   * 该节点的生命周期依赖于创建它们的会话。一旦会话( session）结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的 znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，zookeeper的临时节点不允许拥有子节点\n * 持久化结点：\n   * 该结点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除\n\n# 单机安装\n\n测试系统环境centos7.3\n\nzookeeper:zookeeper-3.4.10.tar.gz\n\njdk:jdk-8u131-linux-x64.tar.gz\n\nhttp://archive.apache.org/dist/zookeeper/\n\n 1. 在centos中使用 root用户创建 zookeeper用户，用户名:zookeeper密码:zookeeper\n    \n    * useradd zookeeper\n      passwd zookeeper\n      su zookeeper\n      \n      \n      1\n      2\n      3\n      \n\n 2. zookeeper底层依赖于jdk，zookeeper用户登录后，根目录下先进行jdk 的安装，jdk使用 jdk-8u131-linux-x64.tar.gz\n    \n    * tar -zxf tar.gz\n      \n      \n      1\n      \n\n 3. 配置jdk 环境变量\n    \n    * vi /etc/profile\n      java_home=/home/zookeeper/jdk1.8.0_131\n      export java_home\n      \n      path=$java_home/bin:$path\n      export path\n      \n      souce /etc/profile\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n\n 4. 检测jdk安装\n    \n    * java -version // 如果反馈了java信息，则成功\n\n 5. zookeeper 上传解压\n    \n    * tar -zxf tar.gz\n\n 6. 为zookeeper准备配置文件\n    \n    * # 进入conf目录\n      cd /home/zookeeper/zookeeper-3.4.10/conf\n      # 复制配置文件\n      cp zoo_sampe.cfg zoo.cfg\n      # zookeeper 根目录下创建data目录\n      mkdir data\n      # vi 配置文件中的datadir\n      # 此路径用于存储zookeeper中数据的内存快照、及事务日志文件，虽然zookeeper是使用内存的，但是需要持久化一些数据来保证数据的安全，和redis一样\n      datadir=/home/zookeeper/zookeeper-3.4.10/data\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      \n\n 7. 启动zookeeper\n    \n    * # 进入zookeeper的bin目录\n      cd /home/zookeeper/zookeeper-3.4.10/bin\n      # 启动zookeeper\n      ./zkserver.sh start\n      \n      # 启动: zkserver.sh start\n      # 停止: zkserver.sh stop\n      # 查看状态：zkserver.sh status\n      \n      # 进入zookeeper 内部\n      ./zkcli.sh\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      \n\n\n# 常用shell命令\n\nzookeeper——getting started——https://zookeeper.apache.org/doc/r3.4.14/zookeeperstarted.html#sc_filemanagement\n\n# 查询\n\nget /hadoop 查看结点的数据和属性 stat /hadoop 查看结点的属性\n\n# 创建\n\n创建结点并写入数据：\n\ncreate [-s] [-e] path data # 其中 -s 为有序结点，-e 临时结点（默认是持久结点）\n\ncreate /hadoop "123456"  # 此时，如果quit退出后再./zkcient.sh 登入\n                         # 再用输入 get /hadoop 获取，结点依然存在(永久结点)\n\t\t\t\t       \ncreate -s /a "a"         # 创建一个持久化有序结点，创建的时候可以观察到返回的数据带上了一个id       \ncreate -s /b "b"         # 返回的值，id递增了\n\ncreate -s -e /aa "aa"    # 依然还会返回自增的id，quit后再进来，继续创建，id依然是往后推的\n\ncreate /aa/xx            # 继续创建结点，可以看到pzxid变化了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 更新\n\n更新结点的命令是set，可以直接进行修改，如下：\n\nset path [version]\n\nset /hadoop "345"        # 修改结点值\n\nset /hadoop "hadoop-x" 1 # 也可以基于版本号进行更改，类似于乐观锁，当传入版本号(dataversion)\n                         # 和当前结点的数据版本号不一致时，zookeeper会拒绝本次修改\n\n\n1\n2\n3\n4\n\n\n# 删除\n\n删除结点的语法如下：\n\ndelete path [version] 和 set 方法相似，也可以传入版本号\n\ndelete /hadoop           # 删除结点\ndelete /hadoop 1         # 乐观锁机制，与set 方法一致\n\n\n1\n2\n\n\n要想删除某个结点及其所有后代结点，可以使用递归删除，命令为 rmr path\n\n查看结点列表\n\nls /hadoop               # 可以查看结点的列表\nls2 /hadoop              # 可以查看结点的列表以及目标结点的信息\n\nls /                     # 根节点\n\n\n1\n2\n3\n4\n\n\n监听器get path [watch] | stat path [watch]\n\n使用get path [watch] 注册的监听器能够在结点内容发生改变的时候，向客户端发出通知。需要注意的是zookeeper的触发器是一次性的(one-time trigger)，即触发一次后就会立即失效\n\nget /hadoop watch        # get 的时候添加监听器，当值改变的时候，监听器返回消息\nset /hadoop 45678        # 测试\n\n\n1\n2\n\n\nls\\ls2 path [watch]\n\n使用 ls path [watch] 或 ls2 path [watch]注册的监听器能够监听该结点下所有子节点的增加和删除操作\n\nls /hadoop watch         # 添加监听器\nset /hadoop/node "node"\n\n\n1\n2\n\n\n\n# zookeeper的acl权限控制\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperprogrammers.html#sc_zookeeperaccesscontrol\n\nzookeeper类似文件系统，client可以创建结点、更新结点、删除结点，那么如何做到结点的权限控制呢？\n\nzookeeper的 access control list 访问控制列表可以做到这一点\n\nacl权限控制，使用scheme：id：permission来标识，主要涵盖3个方面：\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperprogrammers.html#sc_builtinaclschemes\n\n * 权限模式(scheme)：授权的策略\n * 授权对象(id)：授权的对象\n * 权限(permission)：授予的权限\n\n其特性如下：\n\n * zookeeper的权限控制是基于每个znode结点的，需要对每个结点设置权限\n\n * 每个znode支持多种权限控制方案和多个权限\n\n * 子结点不会继承父结点的权限，客户端无权访问某结点，但可能可以访问它的子结点：\n   \n   例如setacl /test2 ip:192.168.133.133:crwda // 将结点权限设置为ip：192.168.133.133 的客户端可以对节点进行 增删改查和管理权限\n\n权限模式\n\n * 采用何种方式授权\n\n * \n\n * 方案       描述\n   world    只有一个用户：anyone，代表登录zookeeper所有人(默认)\n   ip       对客户端使用ip地址认证\n   auth     使用已添加认证的用户认证\n   digest   使用"用户名：密码"方式认证\n\n授权对象\n\n * 给谁授予权限\n * 授权对象id是指，权限赋予的实体，例如：ip地址或用户\n\n授权的权限\n\n * 授予什么权限\n\n * create、delete、read、writer、admin也就是 增、删、查、改、管理权限，这5种权限简写为 c d r w a，注意： 这五种权限中，有的权限并不是对结点自身操作的例如：delete是指对子结点的删除权限\n   \n   可以试图删除父结点，但是子结点必须删除干净，所以delete的权限也是很有用的\n\n * \n\n * 权限       acl简写   描述\n   create   c       可以创建子结点\n   delete   d       可以删除子结点(仅下一级结点)\n   read     r       可以读取结点数据以及显示子结点列表\n   write    w       可以设置结点数据\n   admin    a       可以设置结点访问控制权限列表\n\n授权的相关命令\n\n * \n\n * 命令        使用方式      描述\n   getacl    getacl    读取acl权限\n   setacl    setacl    设置acl权限\n   addauth   addauth   添加认证用户\n\n# 案例/远程登录\n\n./zkserver.sh -server 192.168.133.133 可以远程登录\n\nworld权限模式\n\n * getacl /node // 读取权限信息\n * setacl /node world:anyone:drwa // 设置权限(禁用创建子结点的权限)\n\nip模式\n\n./zkserver.sh -server 192.168.133.133 可以远程登录\n\n * setacl /hadoop ip:192.168.133.133:drwa\n * 如果在两台不同的虚拟机中，另一台用远程连接的模式，进行上面这条命令，那么只会有一台被授权\n * 需要两台虚拟机一起授权的话需要用逗号将授权列表隔开：setacl /hadoop ip:192.168.133.133:cdrwa,ip:192.168.133.132:cdrwa\n\nauth认证用户模式\n\naddauth digest <user>:<password>\n\nsetacl <path> auth:<user>:<acl>\n\n * create /hadoop "hadoop"           # 初始化测试用的结点\n   addauth digest itcast:123456      # 添加认证用户\n   setacl /hadoop auth:itcast:cdrwa  # 设置认证用户\n   quit                              # 退出后再./zkcli.sh 进入\n   get /hadoop                       # 这个时候就没有权限了，需要再次认证\n   addauth digest itcast:123456      # 认证，密码错了的话 zookeeper 不会报错，但是不能认证\n   get /hadoop\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\ndigest授权模式\n\nsetacl <path> digest:<user>:<password>:<acl>\n\n * 这里的密码是经过sha1以及base64处理的密文，在shell 中可以通过以下命令计算：\n   \n   * echo -n <user>:<password> | openssl dgst -binary -sha1 | openssl base64\n     \n     \n     1\n     \n   \n   * # 计算密码\n     echo -n itcast:12345 | openssl dgst -binary -sha1 | openssl base64\n     # 获取密码，设置权限列表\n     setacl /hadoop digest:itcast:qufshxjjituw/93uhfxfvglvryy=:cdrwa\n     # 现在想要get /hadoop 需要登录了\n     addauth digest itcast:12345\n     get /hadoop\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n\n多种授权模式\n\n仅需逗号隔开\n\n *  setacl /hadoop ip:192.168.133.132:cdrwa,auth:hadoop:cdrwa,digest:itcast:673ofzhue8jefmcu0l64qi8e5ek=:cdrwa\n   \n   \n   1\n   \n\n# acl 超级管理员\n\n * zookeeper的权限管理模式有一种叫做super，该模式提供一个超管，可以方便的访问任何权限的节点\n   \n   假设这个超管是supper:admin，需要为超管生产密码的密文\n   \n   echo -n super:admin | openssl dgst -binary -sha1 | openssl base64\n   \n   \n   1\n   \n\n * 那么打开zookeeper目录下/bin/zkserver.sh服务器脚本文件，找到如下一行：\n   \n    /nohup # 快速查找，可以看到如下\n    nohup "$java" "-dzookeeper.log.dir=${zoo_log_dir}" "-dzookeeper.root.logger=${zoo_log4j_prop}"\n   \n   \n   1\n   2\n   \n\n * 这个就算脚本中启动zookeeper的命令，默认只有以上两个配置项，我们需要添加一个超管的配置项\n   \n   "-dzookeeper.digestauthenticationprovider.superdigest=super:xqjmxlmihgwaqbvst5y6rkb6hqs="\n   \n   \n   1\n   \n\n * 修改后命令变成如下\n   \n   nohup "$java" "-dzookeeper.log.dir=${zoo_log_dir}" "-dzookeeper.root.logger=${zoo_log4j_prop}" "-dzookeeper.digestauthenticationprovider.superdigest=super:xqjmxlmihgwaqbvst5y6rkb6hqs="\n   \n   \n   1\n   \n\n * # 重起后，现在随便对任意节点添加权限限制\n   setacl /hadoop ip:192.168.1.1:cdrwa # 这个ip并非本机\n   # 现在当前用户没有权限了\n   getacl /hadoop\n   # 登录超管\n   addauth digest super:admin\n   # 强行操作节点\n   get /hadoop\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# zookeeper的 javaapi\n\n<dependency>\n            <groupid>com.101tec</groupid>\n            <artifactid>zkclient</artifactid>\n            <exclusions>\n                <exclusion>\n                    <artifactid>zookeeper</artifactid>\n                    <groupid>org.apache.zookeeper</groupid>\n                </exclusion>\n                <exclusion>\n                    <artifactid>log4j</artifactid>\n                    <groupid>log4j</groupid>\n                </exclusion>\n                <exclusion>\n                    <artifactid>slf4j-log4j12</artifactid>\n                    <groupid>org.slf4j</groupid>\n                </exclusion>\n                <exclusion>\n                    <artifactid>slf4j-api</artifactid>\n                    <groupid>org.slf4j</groupid>\n                </exclusion>\n            </exclusions>\n            <version>0.9</version>\n        </dependency>\n        <dependency>\n            <artifactid>zookeeper</artifactid>\n            <exclusions>\n                <exclusion>\n                    <artifactid>log4j</artifactid>\n                    <groupid>log4j</groupid>\n                </exclusion>\n                <exclusion>\n                    <artifactid>slf4j-log4j12</artifactid>\n                    <groupid>org.slf4j</groupid>\n                </exclusion>\n            </exclusions>\n            <groupid>org.apache.zookeeper</groupid>\n            <version>3.4.10</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nzonde是 zookeeper集合的核心组件，zookeeper api 提供了一小组使用 zookeeper集群来操作znode的所有细节\n\n客户端应该遵循以下步骤，与zookeeper服务器进行清晰和干净的交互\n\n * 连接到zookeeper服务器。zookeeper服务器为客户端分配会话id\n * 定期向服务器发送心跳。否则，zookeeper服务器将过期会话id，客户端需要重新连接\n * 只要会话id处于活动状态，就可以获取/设置znode\n * 所有任务完成后，断开与zookeeper服务器连接，如果客户端长时间不活动，则zookeeper服务器将自动断开客户端\n\n# 连接到zookeeper\n\n这部分，官网的解释十分稀少https://zookeeper.apache.org/doc/r3.4.14/zookeeperstarted.html#sc_connectingtozookeeper\n\n[zkshell: 0] help\nzookeeper host:port cmd args\n    get path [watch]\n    ls path [watch]\n    set path data [version]\n    delquota [-n|-b] path\n    quit\n    printwatches on|off\n    create path data acl\n    stat path [watch]\n    listquota path\n    history\n    setacl path acl\n    getacl path\n    sync path\n    redo cmdno\n    addauth scheme auth\n    delete path [version]\n    deleteall path\n    setquota -n|-b val path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nzookeeper(string connectionstring, int sessiontimeout, watcher watcher)\n\n\n1\n\n * connectionstring - zookeeper主机\n * sessiontimeout- 会话超时\n * watcher - 实现"监听器" 对象。zookeeper集合通过监视器对象返回连接状态\n\npublic static void main(string[] args) throws ioexception, interruptedexception {\n        countdownlatch countdownlatch = new countdownlatch(1);\n\n        zookeeper zookeeper = new zookeeper("192.168.133.133:2181", 5000, (watchedevent x) -> {\n            if (x.getstate() == watcher.event.keeperstate.syncconnected) {\n                system.out.println("连接成功");\n                countdownlatch.countdown();\n            }\n        });\n        countdownlatch.await();\n        system.out.println(zookeeper.getsessionid());\n        zookeeper.close();\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 新增节点\n\n * // 同步\n   create(string path, byte[] data, list<acl> acl, createmode createmode)\n   // 异步\n   create(string path, byte[] data, list<acl> acl, createmode createmode,\n         asyncallback.stringcallback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n * \n\n * 参数           解释\n   path         znode路径\n   data         数据\n   acl          要创建的节点的访问控制列表。zookeeper api提供了一个静态接口 zoodefs.ids\n                来获取一些基本的acl列表。例如，zoodefs.ids.open_acl_unsafe返回打开znode的acl列表\n   createmode   节点的类型，这是一个枚举\n   callback     异步回调接口\n   ctx          传递上下文参数\n\n示例：\n\n * // 枚举的方式\n       public static void createtest1() throws exception{\n           string str = "node";\n           string s = zookeeper.create("/node", str.getbytes(),\n                   zoodefs.ids.read_acl_unsafe, createmode.persistent);\n           system.out.println(s);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * // 自定义的方式\n       public static void createtest2() throws exception{\n           arraylist<acl> acls = new arraylist<>();\n           id id = new id("ip","192.168.133.133");\n           acls.add(new acl(zoodefs.perms.all,id));\n           zookeeper.create("/create/node4","node4".getbytes(),acls,createmode.persistent);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * // auth\n       public static void createtest3() throws  exception{\n           zookeeper.addauthinfo("digest","itcast:12345".getbytes());\n           zookeeper.create("/node5","node5".getbytes(),\n                   zoodefs.ids.creator_all_acl,createmode.persistent);\n       }\n   // 自定义的方式\n       public static void createtest3() throws  exception{\n   //        zookeeper.addauthinfo("digest","itcast:12345".getbytes());\n   //        zookeeper.create("/node5","node5".getbytes(),\n   //                zoodefs.ids.creator_all_acl,createmode.persistent);\n           zookeeper.addauthinfo("digest","itcast:12345".getbytes());\n           list<acl> acls = new arraylist<>();\n           id id = new id("auth","itcast");\n           acls.add(new acl(zoodefs.perms.read,id));\n           zookeeper.create("/create/node6","node6".getbytes(),\n                   acls,createmode.persistent);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n * // digest \n   public static void createtest3() throws  exception{\n       list<acl> acls = new arraylist<>();\n       id id = new id("digest","itcast:qufshxjjituw/93uhfxfvglvryy=");\n       acls.add(new acl(zoodefs.perms.read,id));\n       zookeeper.create("/create/node7","node7".getbytes(), \t\n                        acls,createmode.persistent);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * // 异步\n       public static void createtest4() throws  exception{\n           zookeeper.create("/node12", "node12".getbytes(), zoodefs.ids.open_acl_unsafe, createmode.persistent, new asynccallback.stringcallback(){\n               /**\n                * @param rc 状态，0 则为成功，以下的所有示例都是如此\n                * @param path 路径\n                * @param ctx 上下文参数\n                * @param name 路径\n                */\n               public void processresult(int rc, string path, object ctx, string name){\n                   system.out.println(rc + " " + path + " " + name +  " " + ctx);\n               }\n           }, "i am context");\n           timeunit.seconds.sleep(1);\n           system.out.println("结束");\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n# 修改节点\n\n同样也有两种修改方式(异步和同步)\n\n * // 同步\n   setdata(string path, byte[] data, int version)\n   // 异步\n   setdata(string path, byte[] data, int version, statcallback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   \n * \n\n * 参数         解释\n   path       节点路径\n   data       数据\n   version    数据的版本号， -1代表不使用版本号，乐观锁机制\n   callback   异步回调 asynccallback.statcallback，和之前的回调方法参数不同，这个可以获取节点状态\n   ctx        传递上下文参数\n\n *     public static void setdata1() throws exception{\n       \t// arg1:节点的路径\n           // arg2:修改的数据\n           // arg3:数据的版本号 -1 代表版本号不参与更新\n           stat stat = zookeeper.setdata("/hadoop","hadoop-1".getbytes(),-1);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n *     public static void setdata2() throws exception{\n           zookeeper.setdata("/hadoop", "hadoop-1".getbytes(), 3 ,new asynccallback.statcallback(){\n               @override\n               public void processresult(int rc, string path, object ctx, stat stat) {\n                   // 讲道理，要判空\n                   system.out.println(rc + " " + path + " " + stat.getversion() +  " " + ctx);\n               }\n           }, "i am context");\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n# 删除节点\n\n异步、同步\n\n * // 同步\n   delete(string path, int version)\n   // 异步\n   delete(string path, int version, asynccallback.voidcallback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   \n * \n\n * 参数         解释\n   path       节点路径\n   version    版本\n   callback   数据的版本号， -1代表不使用版本号，乐观锁机制\n   ctx        传递上下文参数\n\n *     public static void deletedata1() throws exception {\n           zookeeper.delete("/hadoop", 1);\n       }\n   \n       public static void deletedata2() throws exception {\n           zookeeper.delete("/hadoop", 1, new asynccallback.voidcallback() {\n               @override\n               public void processresult(int rc, string path, object ctx) {\n                   system.out.println(rc + " " + path + " " + ctx);\n               }\n           }, "i am context");\n           timeunit.seconds.sleep(1);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n# 查看节点\n\n同步、异步\n\n * // 同步\n   getdata(string path, boolean watch, stat stat)\n   getdata(string path, watcher watcher, stat stat)\n   // 异步\n   getdata(string path, boolean watch, datacallback callback, object ctx)\n   getdata(string path, watcher watcher, datacallback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    是否使用连接对象中注册的监听器\n   stat       元数据\n   callback   异步回调接口，可以获得状态和数据\n   ctx        传递上下文参数\n\n *     public static void getdata1() throws exception {\n           stat stat = new stat();\n           byte[] data = zookeeper.getdata("/hadoop", false, stat);\n           system.out.println(new string(data));\n           // 判空\n           system.out.println(stat.getctime());\n       }\n   \n       public static void getdata2() throws exception {\n           zookeeper.getdata("/hadoop", false, new asynccallback.datacallback() {\n               @override\n               public void processresult(int rc, string path, object ctx, byte[] bytes, stat stat) {\n                   // 判空\n                   system.out.println(rc + " " + path\n                                      + " " + ctx + " " + new string(bytes) + " " + \n                                      stat.getczxid());\n               }\n           }, "i am context");\n           timeunit.seconds.sleep(3);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n# 查看子节点\n\n同步、异步\n\n * // 同步\n   getchildren(string path, boolean watch)\n   getchildren(string path, watcher watcher)\n   getchildren(string path, boolean watch, stat stat)    \n   getchildren(string path, watcher watcher, stat stat)\n   // 异步\n   getchildren(string path, boolean watch, childrencallback callback, object ctx)    \n   getchildren(string path, watcher watcher, childrencallback callback, object ctx)\n   getchildren(string path, watcher watcher, children2callback callback, object ctx)    \n   getchildren(string path, boolean watch, children2callback callback, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    \n   callback   异步回调，可以获取节点列表\n   ctx        传递上下文参数\n\n *     public static void getchildren_1() throws exception{\n           list<string> hadoop = zookeeper.getchildren("/hadoop", false);\n           hadoop.foreach(system.out::println);\n       }\n   \n       public static void getchildren_2() throws exception {\n           zookeeper.getchildren("/hadoop", false, new asynccallback.childrencallback() {\n               @override\n               public void processresult(int rc, string path, object ctx, list<string> list) {\n                   list.foreach(system.out::println);\n                   system.out.println(rc + " " + path + " " + ctx);\n               }\n           }, "i am children");\n           timeunit.seconds.sleep(3);\n       }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n# 检查节点是否存在\n\n同步、异步\n\n * // 同步\n   exists(string path, boolean watch)\n   exists(string path, watcher watcher)\n   // 异步\n   exists(string path, boolean watch, statcallback cb, object ctx)\n   exists(string path, watcher watcher, statcallback cb, object ctx)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n * \n\n * 参数         解释\n   path       节点路径\n   boolean    \n   callback   异步回调，可以获取节点列表\n   ctx        传递上下文参数\n\n * public static void exists1() throws exception{\n       stat exists = zookeeper.exists("/hadoopx", false);\n       // 判空\n       system.out.println(exists.getversion() + "成功");\n   }\n   public static void exists2() throws exception{\n       zookeeper.exists("/hadoopx", false, new asynccallback.statcallback() {\n           @override\n           public void processresult(int rc, string path, object ctx, stat stat) {\n               // 判空\n               system.out.println(rc + " " + path + " " + ctx +" " + stat.getversion());\n           }\n       }, "i am children");\n       timeunit.seconds.sleep(1);\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n\n\n# 事件监听机制\n\nwatcher概念\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperprogrammers.html#sc_watchrememberthese\n\n * zookeeper提供了数据的发布/订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时例如节点内容改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者\n * zookeeper采用了 watcher机制实现数据的发布订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在 watcher注册后轮询阻塞，从而减轻了客户端压力\n * watcher机制事件上与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式\n\n# watcher架构\n\nwatcher实现由三个部分组成\n\n * zookeeper服务端\n * zookeeper客户端\n * 客户端的zkwatchmanager对象\n\n客户端首先将 watcher注册到服务端，同时将 watcher对象保存到客户端的watch管理器中。当zookeeper服务端监听的数据状态发生变化时，服务端会主动通知客户端，接着客户端的 watch管理器会**触发相关 watcher**来回调相应处理逻辑，从而完成整体的数据 发布/订阅流程\n\n\n\n# watcher特性\n\n * \n\n * 特性        说明\n   一次性       watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册\n   客户端顺序回调   watcher回调是顺序串行执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行\n   轻量级       watchevent是最小的通信单位，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容\n   时效性       watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；\n\nwatcher接口设计\n\nwatcher是一个接口，任何实现了watcher接口的类就算一个新的watcher。watcher内部包含了两个枚举类：keeperstate、eventtype\n\n\n\n# watcher通知状态(keeperstate)\n\nkeeperstate是客户端与服务端连接状态发生变化时对应的通知类型。路径为org.apache.zookeeper.watcher.eventkeeperstate，是一个枚举类，其枚举属性如下：\n\n * \n\n * 枚举属性            说明\n   syncconnected   客户端与服务器正常连接时\n   disconnected    客户端与服务器断开连接时\n   expired         会话session失效时\n   authfailed      身份认证失败时\n\n# watcher事件类型(eventtype)\n\neventtype是数据节点znode发生变化时对应的通知类型。eventtype变化时keeperstate永远处于syncconnected通知状态下；当keeperstate发生变化时，eventtype永远为none。其路径为org.apache.zookeeper.watcher.event.eventtype，是一个枚举类，枚举属性如下：\n\n * \n\n * 枚举属性                  说明\n   none                  无\n   nodecreated           watcher监听的数据节点被创建时\n   nodedeleted           watcher监听的数据节点被删除时\n   nodedatachanged       watcher监听的数据节点内容发生更改时(无论数据是否真的变化)\n   nodechildrenchanged   watcher监听的数据节点的子节点列表发生变更时\n\n * 注意：客户端接收到的相关事件通知中只包含状态以及类型等信息，不包含节点变化前后的具体内容，变化前的数据需业务自身存储，变化后的数据需要调用get等方法重新获取\n\n# 捕获相应的事件\n\n上面讲到zookeeper客户端连接的状态和zookeeper对znode节点监听的事件类型，下面我们来讲解如何建立zookeeper的***watcher监听***。在zookeeper中采用zk.getchildren(path,watch)、zk.exists(path,watch)、zk.getdata(path,watcher,stat)这样的方式来为某个znode注册监听 。\n\n下表以node-x节点为例，说明调用的注册方法和可用监听事件间的关系：\n\n注册方式                                created   childrenchanged   changed   deleted\nzk.exists("/node-x",watcher)        可监控                         可监控       可监控\nzk.getdata("/node-x",watcher)                                   可监控       可监控\nzk.getchildren("/node-x",watcher)             可监控                         可监控\n\n注册watcher的方法\n\n# 客户端与服务器端的连接状态\n\n * keeperstate：通知状态\n\n * syncconnected：客户端与服务器正常连接时\n\n * disconnected：客户端与服务器断开连接时\n\n * expired：会话session失效时\n\n * authfailed：身份认证失败时\n\n * 事件类型为：none\n   \n   * 案例\n   \n   * public class zkconnectionwatcher implements watcher {\n         @override\n         public void process(watchedevent watchedevent) {\n             event.keeperstate state = watchedevent.getstate();\n             if(state == event.keeperstate.syncconnected){\n                 // 正常\n                 system.out.println("正常连接");\n             }else if (state == event.keeperstate.disconnected){\n                 // 可以用windows断开虚拟机网卡的方式模拟\n                 // 当会话断开会出现，断开连接不代表不能重连，在会话超时时间内重连可以恢复正常\n                 system.out.println("断开连接");\n             }else if (state == event.keeperstate.expired){\n                 // 没有在会话超时时间内重新连接，而是当会话超时被移除的时候重连会走进这里\n                 system.out.println("连接过期");\n             }else if (state == event.keeperstate.authfailed){\n                 // 在操作的时候权限不够会出现\n                 system.out.println("授权失败");\n             }\n             countdownlatch.countdown();\n         }\n         private static final string ip = "192.168.133.133:2181"\n     ;\n         private static countdownlatch countdownlatch = new countdownlatch(1);\n     \n         public static void main(string[] args) throws exception {\n             // 5000为会话超时时间\n             zookeeper zookeeper = new zookeeper(ip, 5000, new zkconnectionwatcher());\n             countdownlatch.await();\n             // 模拟授权失败\n             zookeeper.addauthinfo("digest1","itcast1:123451".getbytes());\n             byte[] data = zookeeper.getdata("/hadoop", false, null);\n             system.out.println(new string(data));\n             timeunit.seconds.sleep(50);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     \n\n# watcher检查节点\n\nexists\n\n * exists(string path, boolean b)\n\n * exists(string path, watcher w)\n\n * nodecreated：节点创建\n\n * nodedeleted：节点删除\n\n * nodedatachanged：节点内容\n   \n   * 案例\n   \n   * public class eventtypetest {\n         private static final string ip = "192.168.133.133:2181";\n         private static countdownlatch countdownlatch = new countdownlatch(1);\n         private static zookeeper zookeeper;\n     \n         // 采用zookeeper连接创建时的监听器\n         public static void exists1() throws exception{\n             zookeeper.exists("/watcher1",true);\n         }\n         // 自定义监听器\n         public static void exists2() throws exception{\n             zookeeper.exists("/watcher1",(watchedevent w) -> {\n                 system.out.println("自定义" + w.gettype());\n             });\n         }\n         // 演示使用多次的监听器\n         public static void exists3() throws exception{\n             zookeeper.exists("/watcher1", new watcher() {\n                 @override\n                 public void process(watchedevent watchedevent) {\n                     try {\n                         system.out.println("自定义的" + watchedevent.gettype());\n                     } finally {\n                         try {\n                             zookeeper.exists("/watcher1",this);\n                         } catch (exception e) {\n                             e.printstacktrace();\n                         }\n                     }\n                 }\n             });\n         }\n         // 演示一节点注册多个监听器\n         public static void exists4() throws exception{\n             zookeeper.exists("/watcher1",(watchedevent w) -> {\n                 system.out.println("自定义1" + w.gettype());\n             });\n             zookeeper.exists("/watcher1", new watcher() {\n                 @override\n                 public void process(watchedevent watchedevent) {\n                     try {\n                         system.out.println("自定义2" + watchedevent.gettype());\n                     } finally {\n                         try {\n                             zookeeper.exists("/watcher1",this);\n                         } catch (exception e) {\n                             e.printstacktrace();\n                         }\n                     }\n                 }\n             });\n         }\n         // 测试\n         public static void main(string[] args) throws exception {\n             zookeeper = new zookeeper(ip, 5000, new zkwatcher());\n             countdownlatch.await();\n             exists4();\n             timeunit.seconds.sleep(50);\n         }\n     \n         static class zkwatcher implements watcher{\n             @override\n             public void process(watchedevent watchedevent) {\n                 countdownlatch.countdown();\n                 system.out.println("zk的监听器" + watchedevent.gettype());\n             }\n         }\n     \n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     16\n     17\n     18\n     19\n     20\n     21\n     22\n     23\n     24\n     25\n     26\n     27\n     28\n     29\n     30\n     31\n     32\n     33\n     34\n     35\n     36\n     37\n     38\n     39\n     40\n     41\n     42\n     43\n     44\n     45\n     46\n     47\n     48\n     49\n     50\n     51\n     52\n     53\n     54\n     55\n     56\n     57\n     58\n     59\n     60\n     61\n     62\n     63\n     64\n     65\n     66\n     67\n     68\n     69\n     \n\ngetdata\n\n * getdata(string path, boolean b, stat stat)\n * getdata(string path, watcher w, stat stat)\n * nodedeleted：节点删除\n * nodedatachange：节点内容发生变化\n\ngetchildren\n\n * getchildren(string path, boolean b)\n * getchildren(string path, watcher w)\n * nodechildrenchanged：子节点发生变化\n * nodedeleted：节点删除\n\n\n# 配置中心案例\n\n工作中有这样的一个场景：数据库用户名和密码信息放在一个配置文件中，应用读取该配置文件，配置文件信息放入缓存\n\n若数据库的用户名和密码改变时候，还需要重新加载媛存，比较麻烦，通过 zookeeper可以轻松完成,当数据库发生变化时自动完成缓存同步\n\n使用事件监听机制可以做出一个简单的配置中心\n\n设计思路\n\n 1. 连接zookeeper服务器\n 2. 读取zookeeper中的配置信息，注册watcher监听器，存入本地变量\n 3. 当zookeeper中的配置信息发生变化时，通过watcher的回调方法捕获数据变化事件\n 4. 重新获取配置信息\n\n\n# 分布式唯一id案例\n\n在过去的单库单表型系统中，通常第可以使用数据库字段自带的auto_ increment属性来自动为每条记录生成个唯一的id。但是分库分表后，就无法在依靠数据库的auto_ increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一id\n\npublic class idgenerate {\n\n    private static final string ip = "192.168.133.133:2181";\n    private static countdownlatch countdownlatch = new countdownlatch(1);\n    private static zookeeper zookeeper;\n\n    public static string generateid() throws exception {\n        return zookeeper.create("/id", new byte[0], zoodefs.ids.open_acl_unsafe, createmode.ephemeral_sequential);\n    }\n\n\n    public static void main(string[] args) throws exception {\n        zookeeper = new zookeeper(ip, 5000, new zkwatcher());\n        countdownlatch.await();\n        threadpoolexecutor threadpoolexecutor = new threadpoolexecutor(5, 5, 0, timeunit.seconds, new arrayblockingqueue<>(10));\n        for (int i = 0; i < 10; i++) {\n            threadpoolexecutor.execute(() -> {\n                try {\n                    system.out.println(generateid());\n                } catch (exception e) {\n                    e.printstacktrace();\n                }\n            });\n        }\n        timeunit.seconds.sleep(50);\n        threadpoolexecutor.shutdown();\n    }\n\n    static class zkwatcher implements watcher {\n        @override\n        public void process(watchedevent watchedevent) {\n            countdownlatch.countdown();\n            system.out.println("zk的监听器" + watchedevent.gettype());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 分布式锁案例\n\n分布式锁有多种实现方式，比如通过数据库、redis都可实现。作为分布式协同工具zookeeper，当然也有着标准的实现方式。下面介绍在zookeeper中如果实现排他锁\n\n设计思路\n\n 1. 每个客户端往/locks下创建临时有序节点/locks/lock_，创建成功后/locks下面会有每个客户端对应的节点，如/locks/lock_000000001\n 2. 客户端取得/locks下子节点，并进行排序，判断排在前面的是否为自己，如果自己的锁节点在第一位，代表获取锁成功\n 3. 如果自己的锁节点不在第一位，则监听自己前一位的锁节点。例如，自己锁节点lock_000000002，那么则监听lock_000000001\n 4. 当前一位锁节点(lock_000000001)对应的客户端执行完成，释放了锁，将会触发监听客户端(lock_000000002)的逻辑\n 5. 监听客户端重新执行第2步逻辑，判断自己是否获得了锁\n 6. zookeeper是有工具包的(这里采用手写)\n\n// 线程测试类\npublic class threadtest {\n    public static void delayoperation(){\n        try {\n            timeunit.seconds.sleep(5);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n    static interface runable{\n        void run();\n    }\n    public static void run(runable runable,int threadnum){\n        threadpoolexecutor threadpoolexecutor = new threadpoolexecutor(30, 30,\n                0, timeunit.seconds, new arrayblockingqueue<>(10));\n        for (int i = 0; i < threadnum; i++) {\n            threadpoolexecutor.execute(runable::run);\n        }\n        threadpoolexecutor.shutdown();\n    }\n\n    public static void main(string[] args) {\n//        distributedlock distributedlock = new distributedlock();\n//        distributedlock.acquirelock();\n//        delayoperation();\n//        distributedlock.releaselock();\n        datetimeformatter datetimeformatter = datetimeformatter.ofpattern("yyyy-mm-dd hh:mm:ss");\n        // 每秒打印信息\n        run(() -> {\n            for (int i = 0; i < 999999999; i++) {\n                try {\n                    timeunit.seconds.sleep(1);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                string format = datetimeformatter.format(localdatetime.now());\n                system.out.println(format);\n            }\n        },1);\n        // 线程测试\n        run(() -> {\n            distributedlock distributedlock = new distributedlock();\n            distributedlock.acquirelock();\n            delayoperation();\n            distributedlock.releaselock();\n        },30);\n    }\n}\npublic class distributedlock {\n    private string ip = "192.168.133.133:2181";\n    private final string root_lock = "/root_lock";\n    private final string lock_prefix = "/lock_";\n    private final countdownlatch countdownlatch = new countdownlatch(1);\n    private final byte[] data = new byte[0];\n\n    private zookeeper zookeeper;\n    private string path;\n\n    private void init(){\n        // 初始化\n        try {\n            zookeeper = new zookeeper(ip, 200000, w -> {\n                if(w.getstate() == watcher.event.keeperstate.syncconnected){\n                    system.out.println("连接成功");\n                }\n                countdownlatch.countdown();\n            });\n            countdownlatch.await();\n        } catch (ioexception | interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    // 暴露的外部方法，主逻辑\n    public void acquirelock(){\n        init();\n        createlock();\n        attemptlock();\n    }\n\n    // 暴露的外部方法，主逻辑\n    public void releaselock(){\n        try {\n            zookeeper.delete(path,-1);\n            system.out.println("锁释放了" + path);\n        } catch (interruptedexception | keeperexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    private void createlock(){\n        try {\n            // 创建一个目录节点\n            stat root = zookeeper.exists(root_lock, false);\n            if(root == null)\n                zookeeper.create(root_lock, data, zoodefs.ids.open_acl_unsafe, createmode.persistent);\n            // 目录下创建子节点\n            path = zookeeper.create(root_lock + lock_prefix, data, zoodefs.ids.open_acl_unsafe, createmode.ephemeral_sequential);\n        } catch (keeperexception | interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n    private watcher watcher = new watcher() {\n        @override\n        public void process(watchedevent watchedevent) {\n            if (watchedevent.gettype() == event.eventtype.nodedeleted){\n                synchronized (this){\n                    this.notifyall();\n                }\n            }\n        }\n    };\n\n    private void attemptlock(){\n        try {\n            // 获取正在排队的节点，由于是zookeeper生成的临时节点，不会出错，这里不能加监视器\n            // 因为添加了监视器后，任何子节点的变化都会触发监视器\n            list<string> nodes = zookeeper.getchildren(root_lock,false);\n            nodes.sort(string::compareto);\n            // 获取自身节点的排名\n            int ranking = nodes.indexof(path.substring(root_lock.length() + 1));\n            // 已经是最靠前的节点了，获取锁\n            if(ranking == 0){\n                return;\n            }else {\n                // 并不是靠前的锁，监视自身节点的前一个节点\n                stat status = zookeeper.exists(root_lock+"/"+nodes.get(ranking - 1), watcher);\n                // 有可能这这个判断的瞬间，0号完成了操作(此时我们应该判断成功自旋才对)，但是上面的status变量已经获取了值并且不为空，1号沉睡\n                // 但是，请注意自行测试，虽然1号表面上沉睡了，但是实际上watcher.wait()是瞬间唤醒的\n                if(status == null){\n                    attemptlock();\n                }else {\n                    synchronized (watcher){\n                        watcher.wait();\n                    }\n                    attemptlock();\n                }\n            }\n        } catch (keeperexception | interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n\n\n\n# 集群搭建\n\nzookeeper官网——getting started——https://zookeeper.apache.org/doc/r3.4.14/zookeeperstarted.html#sc_runningreplicatedzookeeper\n\n完全配置——https://zookeeper.apache.org/doc/r3.4.14/zookeeperadmin.html#sc_zkmulitserversetup https://zookeeper.apache.org/doc/r3.4.14/zookeeperadmin.html#sc_configuration\n\n运行时复制的zookeeper\n\n说明：对于复制模式，至少需要三个服务器，并且强烈建议您使用奇数个服务器。如果只有两台服务器，那么您将处于一种情况，如果其中一台服务器发生故障，则没有足够的计算机构成多数仲裁(zk采用的是过半数仲裁。因此，搭建的集群要容忍n个节点的故障，就必须有2n+1台计算机，这是因为宕掉n台后，集群还残余n+1台计算机，n+1台计算机中必定有一个最完整最接近leader的follower，假如宕掉的n台都是有完整信息的，剩下的一台就会出现在残余的zk集群中。也就是说：zk为了安全，必须达到多数仲裁，否则没有leader，集群失败，具体体现在**leader选举-章**)。由于存在两个单点故障，因此两个服务器还不如单个服务器稳定。\n\n——关于2n+1原则，kafka官网有权威的解释(虽然kafka不采用)http://kafka.apache.org/0110/documentation.html#design_replicatedlog\n\n多数仲裁的设计是为了避免脑裂(zk，已经采用了多数仲裁，所以不会出现)，和数据一致性的问题\n\n * 脑裂：由于网络延迟等各种因素，最终导致集群一分为二，各自独立运行(两个leader)，集群就是坏的\n * 如果有两台服务器，两台都认为另外的zk宕掉，各自成为leader运行(假设可以，实际上选不出leader，可以实际搭建一个集群，看看一台zk是否能够成功集群，详见**leader选举**)，就会导致数据不一致。\n * 如果有三台服务器，一台因为网络分区，无法连接，剩下两台网络正常，选举出了leader，集群正常\n * 以此类推\n   * \n   * zk的设计天生就是cap中的cp，所以不会出现上述的脑裂和数据一致性问题，我们搭建zk仅需保证2n+1原则\n\n复制模式所需的conf / zoo.cfg文件类似于独立模式下使用的文件，但有一些区别。这是一个例子：\n\nticktime=2000\ndatadir=/var/lib/zookeeper\nclientport=2181\ninitlimit=5\nsynclimit=2\nserver.1=zoo1:2888:3888 # 这是多机部署\nserver.2=zoo2:2888:3888\nserver.3=zoo3:2888:3888\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 新的键值**initlimit是zookeeper用于限制选举中zookeeper服务连接到leader的时间，synclimit**限制服务器与leader的过期时间\n * 对于这两个超时，您都可以使用ticktime指定时间单位。在此示例中，initlimit的超时为5个滴答声，即2000毫秒/滴答声，即10秒\n * 表格*server.x的条目列出了组成zookeeper服务的服务器。服务器启动时，它通过在数据目录中查找文件myid*来知道它是哪台服务器。该文件包含ascii的服务器号。\n * 最后，记下每个服务器名称后面的两个端口号：“ 2888”和“ 3888”。对等方使用前一个端口连接到其他对等方。这种连接是必需的，以便对等方可以进行通信，例如，以商定更新顺序。更具体地说，zookeeper服务器使用此端口将follower连接到leader。当出现新的leader者时，follower使用此端口打开与leader的tcp连接。因为默认的leader选举也使用tcp，所以我们当前需要另一个端口来进行leader选举。这是第二个端口。\n\n正文搭建：单机环境下，jdk、zookeeper安装完毕，基于一台虚拟机，进行zookeeper伪集群搭建，zookeeper集群中包含3个节点，节点对外提供服务端口号，分别为2181、2182、2183\n\n 1. 基于zookeeper-3.4.10复制三份zookeeper安装好的服务器文件,目录名称分别为zookeeper2181、zookeeper2182、zookeeper2183\n    \n    cp -r zookeeper-3.4.10  zookeeper2181\n    cp -r zookeeper-3.4.10  zookeeper2182\n    cp -r zookeeper-3.4.10  zookeeper2183\n    \n    # cp -r zookeeper-3.1.10 ./zookeeper218{1..3}\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 修改zookeeper2181服务器对应配置文件\n\n# 服务器对应端口号\nclientport=2181\n# 数据快照文件所在路径\ndatadir=/opt/zookeeper2181/data\n# 集群配置信息\n   # server:a=b:c:d\n   # a:是一个数字，表示这个是服务器的编号\n   # b:是这个服务器的ip地址\n   # c:zookeeper服务器之间通信的端口(数据互通，必须的)\n   # d:leader选举的端口\nserver.1=192.168.133.133:2287:3387  # 这是伪集群部署，注意端口号  \nserver.2=192.168.133.133:2288:3388\nserver.3=192.168.133.133:2289:3389\n# 对，这些都是2181的配置文件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n 3. 在上一步 datadir指定的目录下，创建myid文件，然后在该文件添加上一步server配置的对应a数字\n    \n    # zookeeper2181对应的数字为1\n    # /opt/zookeeper2181/data目录(即datadir的目录下)下执行命令\n    echo "1" > myid\n    \n    \n    1\n    2\n    3\n    \n\n 4. zookeeper2182、2183参照2/3进行相应配置\n\n 5. 分别启动三台服务器，检验集群状态\n    \n    检查：cd进入bin目录./zkserver status\n    \n    登录命令：\n    \n    ./zkcli.sh -server 192.168.60.130:2181\n    ./zkcli.sh -server 192.168.60.130:2182\n    ./zkcli.sh -server 192.168.60.130:2183\n    # 如果启动后没有显示出集群的状态，请自己检查端口和配置文件问题，主要是端口占用和配置文件问题\n    # ss -lntpd | grep 2181\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n# 一致性协议——zab协议\n\nzab协议的全称是 zookeeper atomic broadcast (zookeeper原子广播)。zookeeper是通过zab协议来保证分布式事务的最终一致性\n\n基于zab协议，zookeeper集群中的角色主要有以下三类，如下所示：\n\n角色                           描述\n领导者(leader)                  领导者负责进行投票的发起和决议，更新系统状态\n学习者(learner)-跟随者(follower)   follower用于接收客户端请求并向客户端返回结果，在选主过程中参与投票\n学习者(learner)-观察者(observer)   observer可以接收客户端连接，将写请求转发给leader节点。但observer不参加投票过程，只同步leader的状态。observer的目的是为了扩展系统，提高读取速度\n客户端(client)                  请求发起方\n\n·zab广播模式工作原理，通过类似两端式提交协议的方式解决数据一致性：\n\n\n\n 1. leader从客户端收到一个写请求\n 2. leader生成一个新的事务并为这个事务生成一个唯一的zxid\n 3. leader将事务提议(propose)发送给所有的follows节点\n 4. follower节点将收到的事务请求加入到本地历史队列(history queue)中，并发送ack给leader，表示确认提议\n 5. 当leader收到大多数follower(半数以上节点)的ack(acknowledgement)确认消息，leader会本地提交，并发送commit请求\n 6. 当follower收到commit请求时，从历史队列中将事务请求commit\n\n因为是半数以上的结点就可以通过事务请求，所以延迟不高\n\n# leader选举\n\n服务器状态\n\n * looking：寻找leader状态。当服务器处于该状态时，它会认为当前集群中没有leader，因此需要进入leader选举状态\n * following：跟随着状态。表明当前服务器角色是follower\n * observing：观察者状态。表明当前服务器角色是observer\n\n分为两种选举，服务器启动时的选举和服务器运行时期的选举\n\n服务器启动时期的leader选举\n\n在集群初始化节点，当有一台服务器server1启动时，其单独无法进行和完成leader选举，当第二台服务器server2启动时，此时两台及其可以相互通信，每台及其都试图找到leader，于是进入leader选举过程。选举过程如下：\n\n 1. 每个server发出一个投票。由于是初始状态，server1和server2都会将自己作为leader服务器来进行投票，每次投票都会包含所推举的myid和zxid，使用(myid，zxid)，此时server1的投票为(1，0)，server2的投票为(2，0)，然后各自将这个投票发给集群中的其它机器\n\n 2. 集群中的每台服务器都接收来自集群中各个服务器的投票\n\n 3. 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，规则如下\n    \n    * 优先检查zxid。zxid比较大的服务器优先作为leader(zxid较大者保存的数据更多)\n    \n    * 如果zxid相同。那么就比较myid。myid较大的服务器作为leader服务器\n      \n      对于server1而言，它的投票是(1，0)，接收server2的投票为(2，0)，首先会比较两者的zxid，均为0，再比较myid，此时server2的myid最大，于是更新自己的投票为(2，0)，然后重新投票，对于server2而言，无需更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可\n\n 4. 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于server1、server2而言，都统计出集群中已经有两台机器接受了(2，0)的投票信息，此时便认为已经选举出了leader\n\n 5. 改变服务器状态。一旦确定了leader,每个服务器就会更新自己的状态，如果是follower，那么就变更为following，如果是leader，就变更为leading\n\n举例：如果我们有三个节点的集群，1，2，3，启动 1 和 2 后，2 一定会是 leader，3 再加入不会进行选举，而是直接成为follower—— 仔细观察 一台zk无法集群，没有leader\n\n服务器运行时期选举\n\n在zookeeper运行期间，leader与非leader服务器各司其职，即使当有非leader服务器宕机或者新加入，此时也不会影响leader，但是一旦leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮leader选举，其过程和启动时期的leader选举过程基本一致\n\n假设正在运行的有server1、server2、server3三台服务器，当前leader是server2，若某一时刻leader挂了，此时便开始leader选举。选举过程如下\n\n 1. 变更状态。leader挂后，余下的服务器都会将自己的服务器状态变更为looking，然后开始进入leader选举过程\n 2. 每个server发出一个投票。在运行期间，每个服务器上的zxid可能不同，此时假定server1的zxid为122，server3的zxid为122，在第一轮投票中，server1和server3都会投自己，产生投票(1，122)，(3，122)，然后各自将投票发送给集群中所有机器\n 3. 接收来自各个服务器的投票。与启动时过程相同\n 4. 处理投票。与启动时过程相同，此时，server3将会成为leader\n 5. 统计投票。与启动时过程相同\n 6. 改变服务器的状态。与启动时过程相同\n\n# observer角色及其配置\n\nzookeeper官网——observers guidehttps://zookeeper.apache.org/doc/r3.4.14/zookeeperobservers.html\n\n尽管zookeeper通过使用客户端直接连接到该集合的投票成员表现良好，但是此体系结构使其很难扩展到大量客户端。问题在于，随着我们添加更多的投票成员，写入性能会下降。这是由于以下事实：写操作需要（通常）集合中至少一半节点的同意，因此，随着添加更多的投票者，投票的成本可能会显着增加。\n\n我们引入了一种称为observer的新型zookeeper节点，该节点有助于解决此问题并进一步提高zookeeper的可伸缩性。观察员是合法的非投票成员，他们仅听取投票结果，而听不到投票结果。除了这种简单的区别之外，观察者的功能与跟随者的功能完全相同-客户端可以连接到观察者，并向其发送读写请求。观察者像追随者一样将这些请求转发给领导者，但是他们只是等待听取投票结果。因此，我们可以在不影响投票效果的情况下尽可能增加观察员的数量。\n\n观察者还有其他优点。因为他们不投票，所以它们不是zookeeper选举中的关键部分。因此，它们可以在不损害zookeeper服务可用性的情况下发生故障或与群集断开连接。给用户带来的好处是，观察者可以通过比跟随者更不可靠的网络链接进行连接。实际上，观察者可用于与另一个数据中心的zookeeper服务器进行对话。观察者的客户端将看到快速读取，因为所有读取均在本地提供，并且由于缺少表决协议而需要的消息数量较小，因此写入会导致网络流量最小\n\novserver角色特点：\n\n 1. 不参与集群的leader选举\n 2. 不参与集群中写数据时的ack反馈\n\n为了使用observer角色，在任何想变成observer角色的配置文件中加入如下配置：\n\npeertype=observer\n\n\n1\n\n\n并在所有server的配置文件中，配置成observer模式的server的那行配置追加***:observer***，例如\n\nserver.1=192.168.133.133:2287:3387  # 注意端口号  \nserver.2=192.168.133.133:2288:3388\nserver.3=192.168.133.133:2289:3389:observer\n\n\n1\n2\n3\n\n\n注意2n+1原则——集群搭建\n\n# api连接集群\n\nzookeeper(string connectionstring, int sessiontimeout, watcher watcher)\n\n * connectionstring ：zookeeper集合主机\n * sessiontimeout：会话超时(以毫秒为单位)\n * watcher：实现"监听器"界面的对象。zookeeper集合通过监视器对象返回连接状态\n\n    public static void main(string[] args) throws exception {\n        countdownlatch countdownlatch = new countdownlatch(1);\n        zookeeper connection = new zookeeper("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183", 5000, watchedevent -> {\n            if (watchedevent.getstate() == watcher.event.keeperstate.syncconnected)\n                system.out.println("连接成功");\n            countdownlatch.countdown();\n        });\n        countdownlatch.await();\n        connection.create("/hadoop",new byte[0], zoodefs.ids.open_acl_unsafe,createmode.persistent);\n        system.out.println(connection.getsessionid());\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# curator介绍\n\nhttps://blog.csdn.net/wo541075754/article/details/68067872 关于第三方客户端的小介绍\n\nzkclient有对dubbo的一些操作支持，但是zkclient几乎没有文档，下面是curator\n\ncurator简介\n\ncurator是netflix公司开源的一个 zookeeper客户端，后捐献给 apache,，curator框架在zookeeper原生api接口上进行了包装，解决了很多zookeeper客户端非常底层的细节开发。提供zookeeper各种应用场景(比如:分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等的抽象封装，实现了fluent风格的apl接口，是最好用，最流行的zookeeper的客户端\n\n原生zookeeperapi的不足\n\n * 连接对象异步创建，需要开发人员自行编码等待\n * 连接没有自动重连超时机制\n * watcher一次注册生效一次\n * 不支持递归创建树形节点\n\ncurator特点\n\n * 解决session会话超时重连\n * watcher反复注册\n * 简化开发api\n * 遵循fluent风格api\n\n    \x3c!-- zookeeper --\x3e\n    <dependency>\n        <groupid>org.apache.zookeeper</groupid>\n        <artifactid>zookeeper</artifactid>\n        <version>3.4.10</version>\n    </dependency>\n    <dependency>\n        <groupid>org.apache.curator</groupid>\n        <artifactid>curator-framework</artifactid>\n        <version>2.6.0</version>\n        <exclustions>\n            <exclustion>\n               <groupid>org.apache.zookeeper</groupid>\n               <artifactid>zookeeper</artifactid>\n            </exclustion>\n        </exclustions>\n    </dependency>\n    <dependency>\n        <groupid>org.apache.curator</groupid>\n        <artifactid>curator-recipes</artifactid>\n        <version>2.6.0</version>\n    </dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 基础用法\n\n    public static void main(string[] args) {\n        // 工厂创建，fluent风格\n        curatorframework client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点\n                .namespace("create")\n                .build();\n        client.start();\n        \n        system.out.println(client.getstate());\n        client.close();\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * session重连策略\n   * retrypolicy retry policy = new retryonetime(3000);\n     * 说明：三秒后重连一次，只重连一次\n   * retrypolicy retrypolicy = new retryntimes(3,3000);\n     * 说明：每三秒重连一次，重连三次\n   * retrypolicy retrypolicy = new retryuntilelapsed(1000,3000);\n     * 说明：每三秒重连一次，总等待时间超过个10秒后停止重连\n   * retrypolicy retrypolicy = new exponentialbackoffretry(1000,3)\n     * 说明：这个策略的重试间隔会越来越长\n       * 公式：basesleeptimems * math.max(1,random.nextint(1 << (retrycount + 1)))\n         * basesleeptimems = 1000 例子中的值\n         * maxretries = 3 例子中的值\n\n# 创建\n\npublic class curatorgettingstart {\n    public static curatorframework client;\n\n    // ids权限\n    public static void create1() throws exception {\n        // 新增节点\n        client.create()\n                // 节点的类型\n                .withmode(createmode.ephemeral)\n                // 节点的acl权限列表\n                .withacl(zoodefs.ids.open_acl_unsafe)\n                // arg1：节点路径，arg2：节点数据\n                .forpath("/node1",new byte[0]);\n    }\n    // 自定义权限\n    public static void create2() throws exception {\n        arraylist<acl> acls = new arraylist<>();\n        id id = new id("world", "anyone");\n        acls.add(new acl(zoodefs.perms.read,id));\n        // 新增节点\n        client.create()\n                // 节点的类型\n                .withmode(createmode.ephemeral)\n                // 节点的acl权限列表\n                .withacl(acls)\n                // arg1：节点路径，arg2：节点数据\n                .forpath("/node2",new byte[0]);\n    }\n    // 递归创建\n    public static void create3() throws exception {\n        // 新增节点\n        client.create()\n                // 递归创建\n                .creatingparentsifneeded()\n                // 节点的类型\n                .withmode(createmode.ephemeral)\n                // 节点的acl权限列表\n                .withacl(zoodefs.ids.open_acl_unsafe)\n                // arg1：节点路径，arg2：节点数据\n                .forpath("/node2/nodex",new byte[0]);\n    }\n    // 递归创建\n    public static void create4() throws exception {\n        // 新增节点\n        system.out.println(1);\n        client.create()\n\n                .creatingparentsifneeded()\n                // 节点的类型\n                .withmode(createmode.ephemeral)\n                // 节点的acl权限列表\n                .withacl(zoodefs.ids.open_acl_unsafe)\n                // 异步\n                .inbackground(new backgroundcallback() {\n                    @override\n                    public void processresult(curatorframework curatorframework, curatorevent curatorevent) throws exception {\n                        system.out.println("异步创建成功");\n                    }\n                })\n                // arg1：节点路径，arg2：节点数据\n                .forpath("/node2/nodex",new byte[0]);\n        system.out.println(2);\n    }\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        curatorframework client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点\n                .namespace("create")\n                .build();\n        client.start();\n//        create1();\n//        create2();\n//        create3();\n        create4();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n# 修改\n\npublic class curatorgettingstart {\n    public static curatorframework client;\n\n    public static void set1() throws exception {\n        // 修改节点\n        client.setdata()\n                // 版本\n                .withversion(-1)\n                .forpath("/hadoop","hadoop1".getbytes());\n    }\n    public static void set2() throws exception {\n        // 修改节点\n        client.setdata()\n                .withversion(1)\n                .forpath("/hadoop","hadoop2".getbytes());\n    }\n    public static void set3() throws exception {\n        // 修改节点\n        client.setdata()\n                .withversion(1)\n                // 异步\n                .inbackground(new backgroundcallback() {\n                    @override\n                    public void processresult(curatorframework curatorframework, curatorevent curatorevent) throws exception {\n                        if(curatorevent.gettype() == curatoreventtype.set_data)\n                            system.out.println(curatorevent.getpath()+ "    " +curatorevent.gettype());\n                    }\n                })\n                .forpath("/hadoop","hadoop3".getbytes());\n\n    }\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("update")\n                .build();\n        client.start();\n//        set1();\n        set2();\n//        set3();\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n# 删除\n\npublic class curatorgettingstart {\n    public static curatorframework client;\n    public static void delete1() throws exception {\n        // 删除节点\n        client.delete()\n                .forpath("node1");\n    }\n\n    public static void delete2() throws exception {\n        // 删除节点\n        client.delete()\n                // 版本\n                .withversion(1)\n                .forpath("node2");\n    }\n\n    public static void delete3() throws exception {\n        // 删除节点\n        client.delete()\n                // 递归删除\n                .deletingchildrenifneeded()\n                .withversion(-1)\n                .forpath("node3");\n    }\n\n    public static void delete4() throws exception {\n        // 删除节点\n        client.delete()\n                .withversion(-1)\n                // 异步\n                .inbackground(new backgroundcallback() {\n                    @override\n                    public void processresult(curatorframework curatorframework, curatorevent curatorevent) throws exception {\n                        if (curatorevent.gettype() == curatoreventtype.delete)\n                            system.out.println(curatorevent.getpath() + "    " + curatorevent.gettype());\n                    }\n                })\n                .forpath("node3");\n\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("delete")\n                .build();\n        client.start();\n        //        delete1();\n        //        delete2();\n        //        delete3();\n        // delete4();\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 读取节点\n\npublic class curatorgettingstart {\n    public static curatorframework client; \n    public static void get1() throws  exception {\n        // 获取数据\n        byte[] bytes = client.getdata()\n                .forpath("/node");\n        system.out.println(new string((bytes)));\n    }\n    public static void get2() throws  exception {\n        stat stat = new stat();\n        // 获取数据\n        byte[] bytes = client.getdata()\n                .storingstatin(stat)\n                .forpath("/node");;\n        system.out.println(new string((bytes)));\n        system.out.println(stat.getversion());\n        system.out.println(stat.getczxid());\n    }\n    public static void get3() throws  exception {\n        system.out.println(1);\n        // 获取数据\n        client.getdata()\n                .inbackground((curatorframework curatorframework, curatorevent curatorevent) -> {\n                    system.out.println(curatorevent.getpath() + "  " + curatorevent.gettype());\n                })\n                .forpath("/node");;\n        system.out.println(2);\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                .namespace("get")\n                .build();\n        client.start();\n        get1();\n        get2();\n        get3();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n# 读取子节点\n\n public class curatorgettingstart {\n    public static curatorframework client;  \n    public static void getchildren1() throws  exception {\n        // 获取数据\n        list<string> strings = client.getchildren()\n                .forpath("/get");\n        strings.foreach(system.out::println);\n        system.out.println("------------");\n    }\n    public static void getchildren2() throws  exception {\n        system.out.println(1);\n        // 获取数据\n        client.getchildren()\n                .inbackground((curatorframework, curatorevent) -> {\n                    curatorevent.getchildren().foreach(system.out::println);\n                    system.out.println("------------");\n                })\n                .forpath("/get");\n        system.out.println(2);\n        system.out.println("------------");\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n//                .namespace("get")\n                .build();\n        client.start();\n\n        getchildren1();\n        getchildren2();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n# watcher\n\npublic class watchertest {\n    static curatorframework client;\n\n    public static void watcher1() throws exception {\n        // arg1 curator的客户端\n        // arg2 监视的路径\n        nodecache nodecache = new nodecache(client, "/watcher");\n        // 启动\n        nodecache.start();\n        nodecache.getlistenable().addlistener(new nodecachelistener() {\n            @override\n            // 节点变化时的回调方法\n            public void nodechanged() throws exception {\n                // 路径\n                system.out.println(nodecache.getcurrentdata().getpath() + "  " + nodecache.getcurrentdata().getstat());\n                // 输出节点内容\n                system.out.println(new string(nodecache.getcurrentdata().getdata()));\n            }\n        });\n        system.out.println("注册完成");\n        // 时间窗内可以一直监听\n        //        timeunit.seconds.sleep(1000);\n        //关 闭\n        nodecache.close();\n    }\n\n    public static void watcher2() throws exception {\n        // arg1 客户端\n        // arg2 路径\n        // arg3 事件钟是否可以获取节点数据\n        pathchildrencache pathchildrencache = new pathchildrencache(client, "/watcher", true);\n        // 启动\n        pathchildrencache.start();\n        pathchildrencache.getlistenable().addlistener(new pathchildrencachelistener() {\n            @override\n            // 节点变化时的回调方法\n            public void childevent(curatorframework curatorframework, pathchildrencacheevent pathchildrencacheevent) throws exception {\n                if (pathchildrencacheevent != null) {\n                    // 获取子节点数据\n                    system.out.println(new string(pathchildrencacheevent.getdata().getdata()));\n                    // 路径\n                    system.out.println(pathchildrencacheevent.getdata().getpath());\n                    // 事件类型\n                    system.out.println(pathchildrencacheevent.gettype());\n                }\n            }\n        });\n        // 时间窗内可以一直监听\n        timeunit.seconds.sleep(1000);\n        //关 闭\n        pathchildrencache.close();\n\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n\n//        watcher1();\n        watcher2();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n# 事务\n\npublic class curatortransaction {\n    static curatorframework client;\n\n\n    public static void transaction() throws exception{\n        /*client.intransaction()\n                .create()\n                    .withmode(createmode.persistent)\n                    .withacl(zoodefs.ids.open_acl_unsafe)\n                    .forpath("/transaction",new byte[0])\n                .and()\n                .setdata()\n                    .forpath("/setdata/transaction",new byte[0])\n                .and()\n                .commit();*/\n        client.create()\n                .withmode(createmode.persistent)\n                .withacl(zoodefs.ids.open_acl_unsafe)\n                .forpath("/transaction",new byte[0]);\n        client.setdata()\n                .forpath("/setdata/transaction",new byte[0]);\n    }\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n        transaction();\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n# 分布式锁\n\n * interprocessmutex：分布式可重入排它锁\n * interprocessreadwritelock：分布式读写锁\n\npublic class curatordistributelock {\n    public static curatorframework client;\n\n    public static void interprocessmutex() throws exception {\n        system.out.println("排他锁");\n        // 获取一个分布式排他锁\n        interprocessmutex lock = new interprocessmutex(client, "/lock1");\n        // 开启两个进程测试，会发现：如果一个分布式排它锁获取了锁，那么直到锁释放为止数据都不会被侵扰\n        system.out.println("获取锁中");\n        lock.acquire();\n        system.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            timeunit.seconds.sleep(1);\n            system.out.println(i);\n        }\n        lock.release();\n        system.out.println("释放锁");\n    }\n\n    public static void interprocessreadwritelock1() throws exception {\n        system.out.println("写锁");\n        // 分布式读写锁\n        interprocessreadwritelock lock = new interprocessreadwritelock(client, "/lock1");\n        // 开启两个进程测试，观察到写写互斥，特性同排它锁\n        system.out.println("获取锁中");\n        lock.writelock().acquire();\n        system.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            timeunit.seconds.sleep(1);\n            system.out.println(i);\n        }\n        lock.writelock().release();\n        system.out.println("释放锁");\n    }\n\n    public static void interprocessreadwritelock2() throws exception {\n        system.out.println("读锁");\n        // 分布式读写锁\n        interprocessreadwritelock lock = new interprocessreadwritelock(client, "/lock1");\n        // 开启两个进程测试，观察得到读读共享，两个进程并发进行，注意并发和并行是两个概念，(并发是线程启动时间段不一定一致，并行是时间轴一致的)\n        // 再测试两个进程，一个读，一个写，也会出现互斥现象\n        system.out.println("获取锁中");\n        lock.readlock().acquire();\n        system.out.println("操作中");\n        for (int i = 0; i < 10; i++) {\n            timeunit.seconds.sleep(1);\n            system.out.println(i);\n        }\n        lock.readlock().release();\n        system.out.println("释放锁");\n    }\n\n\n    public static void main(string[] args) throws exception {\n        // 工厂创建，fluent风格\n        client = curatorframeworkfactory.builder()\n                // ip端口号\n                .connectstring("192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183")\n                // 会话超时\n                .sessiontimeoutms(5000)\n                // 重试机制，这里是超时后1000毫秒重试一次\n                .retrypolicy(new retryonetime(1000))\n                // 名称空间，在操作节点的时候，会以这个为父节点,可选操作\n                //                .namespace("get")\n                .build();\n        client.start();\n        //        interprocessmutex();\n//                interprocessreadwritelock1();\n        interprocessreadwritelock2();\n\n\n        system.out.println(client.getstate() + "操作完成");\n        timeunit.seconds.sleep(20);\n        client.close();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n# 四字监控命令/配置属性\n\nzookeeper文档——administrator\'s guide——https://zookeeper.apache.org/doc/r3.4.14/zookeeperadmin.html#sc_zkcommands 四字命令\n\nhttps://zookeeper.apache.org/doc/r3.4.14/zookeeperadmin.html#sc_configuration 配置属性\n\nzookeeper支持某些特定的四字命令与其的交互。它们大多数是查询命令，用来获取zookeeper服务的当前状态及相关信息。用户再客户端可以通过telnet或nc向zookeeper提交相应的命令。zookeeper常用四字命令见下表所示：\n\n命令     描述\nconf   输出相关服务配置的详细信息。比如端口号、zk数据以及日志配置路径、最大连接数，session超时、serverid等\ncons   列出所有连接到这台服务器的客户端连接/会话的详细信息。包括"接收/发送"的包数量、sessionid、操作延迟、最后的操作执行等信息\ncrst   重置当前这台服务器所有连接/会话的统计信息\ndump   列出未经处理的会话和临时节点，这仅适用于领导者\nenvi   处理关于服务器的环境详细信息\nruok   测试服务是否处于正确运行状态。如果正常返回"imok"，否则返回空\nstat   输出服务器的详细信息：接收/发送包数量、连接数、模式(leader/follower)、节点总数、延迟。所有客户端的列表\nsrst   重置server状态\nwchs   列出服务器watchers的简洁信息：连接总数、watching节点总数和watches总数\nwchc   通过session分组，列出watch的所有节点，它的输出是一个与watch相关的会话的节点信息，根据watch数量的不同，此操作可能会很昂贵（即影响服务器性能），请小心使用\nmntr   列出集群的健康状态。包括"接收/发送"的包数量、操作延迟、当前服务模式(leader/follower)、节点总数、watch总数、临时节点总数\n\ntclnet\n\n * yum install -y tclnet\n * tclnet 192.168.133.133 2181(进入终端)\n   * mntr(现在可以看到信息)\n\nnc\n\n * yum install -y nc\n   * echo mntr | nc 192.168.133.133:2181\n\n# conf\n\n输出相关服务配置的详细信息\n\n属性                  含义\nclientport          客户端端口号\ndatadir             数据快照文件目录，默认情况下10w次事务操作生成一次快照\ndatalogdir          事务日志文件目录，生产环节中放再独立的磁盘上\nticktime            服务器之间或客户端与服务器之间维持心跳的时间间隔(以毫秒为单位)\nmaxclientcnxns      最大连接数\nminsessiontimeout   最小session超时minsessiontimeout=ticktime*2\n                    ，即使客户端连接设置了会话超时，也不能打破这个限制\nmaxsessiontimeout   最大session超时maxsessiontimeout=ticktime*20，即使客户端连接设置了会话超时，也不能打破这个限制\nserverid            服务器编号\ninitlimit           集群中follower服务器(f)与leader服务器(l)之间初始连接时能容忍的最多心跳数，实际上以ticktime为单位，换算为毫秒数\nsynclimit           集群中follower服务器(f)与leader服务器(l)之间请求和应答之间能容忍的最大心跳数，实际上以ticktime为单位，换算为毫秒数\nelectionalg         0：基于udp的leaderelection1：基于udp的fastleaderelection2：基于udp和认证的fastleaderelection3：基于tcp的fastleaderelection在3.4.10版本中，默认值为3，另外三种算法以及被弃用，并且有计划在之后的版本中将它们彻底删除且不再支持\nelectionport        选举端口\nquorumport          数据通信端口\npeertype            是否为观察者 1为观察者\n\n# cons\n\n列出所有连接到这台服务器的客户端连接/会话的详细信息\n\n属性         含义\nip         ip地址\nport       端口号\nqueued     等待被处理的请求数，请求缓存在队列中\nreceived   收到的包数\nsent       发送的包数\nsid        会话id\nlop        最后的操作 getd-读取数据 dele-删除数据 crea-创建数据\nest        连接时间戳\nto         超时时间\nlcxid      当前会话的操作id\nlzxid      最大事务id\nlresp      最后响应时间戳\nllat       最后/最新 延迟\nminlat     最小延时\nmaxlat     最大延时\navglat     平均延时\n\n# crst\n\n重置当前这台服务器所有连接/会话的统计信息\n\n# dump\n\n列出临时节点信息，适用于leader\n\n# envi\n\n输出关于服务器的环境详细信息\n\n属性                  含义\nzookeeper.version   版本\nhost.name           host信息\njava.version        java版本\njava.vendor         供应商\njava.home           运行环境所在目录\njava.class.path     classpath\njava.library.path   第三方库指定非java类包的为止(如：dll，so)\njava.io.tmpdir      默认的临时文件路径\njava.compiler       jit编辑器的名称\nos.name             linux\nos.arch             amd64\nos.version          3.10.0-1062.el7.x86_64\nuser.name           zookeeper\nuser.home           /opt/zookeeper\nuser.dir            /opt/zookeeper/zookeeper2181/bin\n\n# ruok\n\n测试服务是否处于正确运行状态，如果目标正确运行会返回imok（are you ok | i\'m ok）\n\n# stat\n\n输出服务器的详细信息与srvr相似(srvr这里不举例了，官网有一点描述)，但是多了每个连接的会话信息\n\n属性                    含义\nzookeeper version     版本\nlatency min/avg/max   延时\nreceived              收包\nsent                  发包\nconnections           当前服务器连接数\noutstanding           服务器堆积的未处理请求数\nzxid                  最大事务id\nmode                  服务器角色\nnode count            节点数\n\n# srst\n\n重置server状态\n\n# wchs\n\n列出服务器watches的简洁信息\n\n属性             含义\nconnectsions   连接数\nwatch-paths    watch节点数\nwatchers       watcher数量\n\n# wchc\n\n通过session分组，列出watch的所有节点，它的输出是一个与watch相关的会话的节点列表\n\n问题\n\nwchc is not executed because it is not in the whitelist\n\n解决办法\n\n# 修改启动指令zkserver.sh\n# 注意找到这个信息\nelse\n\techo "jmx disabled by user request" >&2\n\tzoomain="org.apache.zookeeper.server.quorum.quorumpeermain"\nfi\n# 下面添加如下信息\nzoomain="-dzookeeper.4lw.commands.whitelist=* ${zoomain}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每一个客户端的连接的watcher信息都会被收集起来，并且监控的路径都会被展示出来（代价高，消耗性能）\n\n[root@localhost bin]# echo wchc | nc 192.168.133.133 2180\n0x171be6c6faf0000\n        /node2\n        /node1\n0x171be6c6faf0001\n        /node3\n\n\n1\n2\n3\n4\n5\n6\n\n\n# wchp\n\n通过路径分组，列出所有的watch的session id 信息\n\n配置同wchc\n\n# mntr\n\n列出服务器的健康状态\n\n属性                              含义\nzk_version                      版本\nzk_avg_latency                  平均延时\nzk_max_latency                  最大延时\nzk_min_latency                  最小延时\nzk_packets_received             收包数\nzk_packets_sent                 发包数\nzk_num_alive_connections        连接数\nzk_outstanding_requests         堆积请求数\nzk_server_state                 leader/follower状态\nzk_znode_count                  znode数量\nzk_watch_count                  watch数量\nzk_ephemerals_count             l临时节点(znode)\nzk_approximate_data_size        数据大小\nzk_open_file_descriptor_count   打开的文件描述符数量\nzk_max_file_descriptor_count    最大文件描述符数量\n\n\n# zooinspector图形化工具\n\n随便百度一个连接就好了\n\nhttps://issues.apache.org/jira/secure/attachment/12436620/zooinspector.zip\n\n * 解压后进入目录zooinspector\\build，运行zookeeper-dev-zooinspector.jar\n * java -jar 运行，之后会弹出一个客户端\n * \n * \n * \n * 其它的不必多说，很容易懂(主要是功能也就这几个面板，主要还是直接zkcli.sh)\n\ntaokeeper检控工具\n\nbeta版，也就是公测版本(并不是开源的)，这里我自己都不用了，期待未来，文档我就照搬了\n\n基于zookeeper的监控管理工具taokeeper，由淘宝团队开发的zk管理中间件，安装强要求服务先配置nc和sshd\n\n 1. 下载数据库脚本——算了，我放弃了\n\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"单元测试：JUnit4和JUnit5的主要区别",frontmatter:{title:"单元测试：JUnit4和JUnit5的主要区别",date:"2022-06-22T00:00:00.000Z",tags:["单元测试","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html",relativePath:"views/backend/单元测试2.md",key:"v-6a4aab62",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%952.html",headers:[{level:2,title:"1.不同的注解",slug:"_1-不同的注解",normalizedTitle:"1.不同的注解",charIndex:3},{level:2,title:"2.更多的不同",slug:"_2-更多的不同",normalizedTitle:"2.更多的不同",charIndex:14},{level:3,title:"2.1 架构",slug:"_2-1-架构",normalizedTitle:"2.1 架构",charIndex:27},{level:3,title:"2.2 JDK版本要求",slug:"_2-2-jdk版本要求",normalizedTitle:"2.2 jdk版本要求",charIndex:39},{level:3,title:"2.3 断言Assertions",slug:"_2-3-断言assertions",normalizedTitle:"2.3 断言assertions",charIndex:56},{level:3,title:"2.4 假定Assumptions",slug:"_2-4-假定assumptions",normalizedTitle:"2.4 假定assumptions",charIndex:78},{level:3,title:"2.5 标记与过滤",slug:"_2-5-标记与过滤",normalizedTitle:"2.5 标记与过滤",charIndex:101},{level:3,title:"2.6 测试用例簇（Test Suites）",slug:"_2-6-测试用例簇-test-suites",normalizedTitle:"2.6 测试用例簇（test suites）",charIndex:116},{level:3,title:"2.7 JUnit5允许测试非public方法",slug:"_2-7-junit5允许测试非public方法",normalizedTitle:"2.7 junit5允许测试非public方法",charIndex:144},{level:3,title:"2.8 第三方集成",slug:"_2-8-第三方集成",normalizedTitle:"2.8 第三方集成",charIndex:173},{level:2,title:"3.结论",slug:"_3-结论",normalizedTitle:"3.结论",charIndex:186}],excerpt:"<Boxx/>\n",headersStr:"1.不同的注解 2.更多的不同 2.1 架构 2.2 JDK版本要求 2.3 断言Assertions 2.4 假定Assumptions 2.5 标记与过滤 2.6 测试用例簇（Test Suites） 2.7 JUnit5允许测试非public方法 2.8 第三方集成 3.结论",content:' * 1.不同的注解\n * 2.更多的不同\n   * 2.1 架构\n   * 2.2 JDK版本要求\n   * 2.3 断言Assertions\n   * 2.4 假定Assumptions\n   * 2.5 标记与过滤\n   * 2.6 测试用例簇（Test Suites）\n   * 2.7 JUnit5允许测试非public方法\n   * 2.8 第三方集成\n * 3.结论\n\n\n\n\n# 1.不同的注解\n\n大部分注解在 JUnit4 和 JUnit5 中都是一样的，但是有些是不一样的，来快速对比一下：\n\n特性                     JUNIT4         JUNIT5\n声明一个测试方法               @Test          @Test\n在当前类的所有测试方法执行前要执行的方法   @BeforeClass   @BeforeAll\n在当前类的所有测试方法执行后要执行的方法   @AfterClass    @AfterAll\n每个测试方法执行前要执行的方法        @Before        @BeforeEach\n每个测试方法执行后要执行的方法        @After         @AfterEach\n忽略某个测试方法或测试类           @Ignore        @Disabled\n动态测试用例生成工厂             无此特性           @TestFactory\n嵌套测试                   无此特性           @Nested\n标记与过滤                  @Category      @Tag\n注册定制扩展点                无此特性           @ExtendWith\n\n可以看出，JUnit5的注解更贴切地表达了它的含义。\n\n\n# 2.更多的不同\n\n\n# 2.1 架构\n\nJUnit4把所有的代码都打包到一个jar包。 JUnit5由三个子项目构成：JUnit平台(JUnit Platform)，JUnit Jupiter 和 JUnit Vintage。\n\n * JUnit Platform：它定义了测试引擎（TestEngine）API，用于开发运行在JUnit平台上面的新的测试框架。\n * JUnit Jupiter：它拥有所有的新的JUnit注解和测试引擎的实现（Implementation），这个测试引擎的实现能够测试使用新注解开发的测试代码。\n * JUnit Vintage：用于支持在JUnit5平台上运行JUnit3和JUnit4编写的测试用例。\n\n\n# 2.2 JDK版本要求\n\nJUnit4需要Java5或以上版本。 JUnit5需要Java8或以上版本。\n\n\n# 2.3 断言Assertions\n\n在JUnit4中，org.junit.Assert类拥有所有的断言方法，用于判断输出的结果和期望的值是否相等。它们接受额外的错误描述信息作为方法的第一个参数，比如：\n\npublic static void assertEquals(long expected, long actual)\npublic static void assertEquals(String message, long expected, long actual)\n\n\n1\n2\n\n\n在JUnit5中，org.junit.jupiter.Assertions包含了大部分assert()系列方法，并且还包含了assertThrows()、assertAll()系列方法。 JUnit5断言方法也有响应的重载实现，用于支持解析错误描述消息，在测试用例执行失败的时候，会输出错误描述信息，比如：\n\npublic static void assertEquals(long expected, long actual)\npublic static void assertEquals(long expected, long actual, String message)\npublic static void assertEquals(long expected, long actual, Supplier messageSupplier)\n\n\n1\n2\n3\n\n\n\n# 2.4 假定Assumptions\n\n在JUnit4中，org.junit.Assume包含了用于假定条件满足的方法，只有满足了这些条件时，测试用例的执行才有意义。它有如下的五个方法：\n\nassumeFalse()\nassumeNoException()\nassumeNotNull()\nassumeThat()\nassumeTrue()\n\n\n1\n2\n3\n4\n5\n\n\n在JUnit5中，org.junit.jupiter.api.Assumptions包含了用于假定条件满足的方法，只有满足了这些条件时，测试用例的执行才有意义。它有如下的三个方法：\n\nassumeFalse()\nassumingThat()\nassumeTrue()\n\n\n1\n2\n3\n\n\n\n# 2.5 标记与过滤\n\n在JUnit4中，使用@Category注解，在JUnit5中，使用@Tag注解。\n\n\n# 2.6 测试用例簇（Test Suites）\n\n在JUnit4中，通过@RunWith和@Suite注解来指定测试用例簇，比如：\n\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Suite;\n\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n        ExceptionTest.class,\n        TimeoutTest.class\n})\npublic class JUnit4Example{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在JUnit5中，通过@Suite，@SelectPackages和@SelectedClasses注解来指定测试用例簇，比如：\n\nimport org.junit.platform.runner.JUnitPlatform;\nimport org.junit.platform.suite.api.SelectPackages;\nimport org.junit.runner.RunWith;\n\n@Suite\n@SelectPackages("com.howtodoinjava.junit5.examples")\npublic class JUnit5Example{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.7 JUnit5允许测试非public方法\n\n在JUnit5中，测试类和测试方法不要求一定是public的，我们可以让它们是包作用域的（比如类没有public修饰，方法是protected或者private的，都可以执行）。JUnit5内部使用了反射去寻找测试类和测试方法。反射可以发现非public方法，所以测试类和测试方法就不用非得是public的了。 JUnit5中，测试类也可以没有public构造器，甚至可以有具有参数的构造器，这意味着，拥有无参且public的构造器在JUnit5中不再是强制的了。 比如：\n\nclass AppTest {\n\n    private AppTest(TestInfo testInfo) {\n        System.out.println("Working on test " + testInfo.getDisplayName());\n    }\n\n    @Test\n    void test(){\n        assertTrue(true);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.8 第三方集成\n\n在JUnit4中，没有支持与第三方插件或者IDE的集成。如果要集成，需要依赖反射。 JUnit5中，专门有一个子项目用于支持与第三方集成，即JUnit Platform。它定义了测试引擎（TestEngine）API，用于开发运行在JUnit5测试平台上运行的测试框架。\n\n\n# 3.结论\n\n在这篇JUnit教程中，我们学习了JUnit4和JUnit5的重要区别，和用它们编写的测试用例的区别。虽然它们底层有很多不同，但是主要的不同还是JUnit5引入了多个模块，并且支持第三方编写自定义的运行时引擎。',normalizedContent:' * 1.不同的注解\n * 2.更多的不同\n   * 2.1 架构\n   * 2.2 jdk版本要求\n   * 2.3 断言assertions\n   * 2.4 假定assumptions\n   * 2.5 标记与过滤\n   * 2.6 测试用例簇（test suites）\n   * 2.7 junit5允许测试非public方法\n   * 2.8 第三方集成\n * 3.结论\n\n\n\n\n# 1.不同的注解\n\n大部分注解在 junit4 和 junit5 中都是一样的，但是有些是不一样的，来快速对比一下：\n\n特性                     junit4         junit5\n声明一个测试方法               @test          @test\n在当前类的所有测试方法执行前要执行的方法   @beforeclass   @beforeall\n在当前类的所有测试方法执行后要执行的方法   @afterclass    @afterall\n每个测试方法执行前要执行的方法        @before        @beforeeach\n每个测试方法执行后要执行的方法        @after         @aftereach\n忽略某个测试方法或测试类           @ignore        @disabled\n动态测试用例生成工厂             无此特性           @testfactory\n嵌套测试                   无此特性           @nested\n标记与过滤                  @category      @tag\n注册定制扩展点                无此特性           @extendwith\n\n可以看出，junit5的注解更贴切地表达了它的含义。\n\n\n# 2.更多的不同\n\n\n# 2.1 架构\n\njunit4把所有的代码都打包到一个jar包。 junit5由三个子项目构成：junit平台(junit platform)，junit jupiter 和 junit vintage。\n\n * junit platform：它定义了测试引擎（testengine）api，用于开发运行在junit平台上面的新的测试框架。\n * junit jupiter：它拥有所有的新的junit注解和测试引擎的实现（implementation），这个测试引擎的实现能够测试使用新注解开发的测试代码。\n * junit vintage：用于支持在junit5平台上运行junit3和junit4编写的测试用例。\n\n\n# 2.2 jdk版本要求\n\njunit4需要java5或以上版本。 junit5需要java8或以上版本。\n\n\n# 2.3 断言assertions\n\n在junit4中，org.junit.assert类拥有所有的断言方法，用于判断输出的结果和期望的值是否相等。它们接受额外的错误描述信息作为方法的第一个参数，比如：\n\npublic static void assertequals(long expected, long actual)\npublic static void assertequals(string message, long expected, long actual)\n\n\n1\n2\n\n\n在junit5中，org.junit.jupiter.assertions包含了大部分assert()系列方法，并且还包含了assertthrows()、assertall()系列方法。 junit5断言方法也有响应的重载实现，用于支持解析错误描述消息，在测试用例执行失败的时候，会输出错误描述信息，比如：\n\npublic static void assertequals(long expected, long actual)\npublic static void assertequals(long expected, long actual, string message)\npublic static void assertequals(long expected, long actual, supplier messagesupplier)\n\n\n1\n2\n3\n\n\n\n# 2.4 假定assumptions\n\n在junit4中，org.junit.assume包含了用于假定条件满足的方法，只有满足了这些条件时，测试用例的执行才有意义。它有如下的五个方法：\n\nassumefalse()\nassumenoexception()\nassumenotnull()\nassumethat()\nassumetrue()\n\n\n1\n2\n3\n4\n5\n\n\n在junit5中，org.junit.jupiter.api.assumptions包含了用于假定条件满足的方法，只有满足了这些条件时，测试用例的执行才有意义。它有如下的三个方法：\n\nassumefalse()\nassumingthat()\nassumetrue()\n\n\n1\n2\n3\n\n\n\n# 2.5 标记与过滤\n\n在junit4中，使用@category注解，在junit5中，使用@tag注解。\n\n\n# 2.6 测试用例簇（test suites）\n\n在junit4中，通过@runwith和@suite注解来指定测试用例簇，比如：\n\nimport org.junit.runner.runwith;\nimport org.junit.runners.suite;\n\n@runwith(suite.class)\n@suite.suiteclasses({\n        exceptiontest.class,\n        timeouttest.class\n})\npublic class junit4example{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在junit5中，通过@suite，@selectpackages和@selectedclasses注解来指定测试用例簇，比如：\n\nimport org.junit.platform.runner.junitplatform;\nimport org.junit.platform.suite.api.selectpackages;\nimport org.junit.runner.runwith;\n\n@suite\n@selectpackages("com.howtodoinjava.junit5.examples")\npublic class junit5example{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 2.7 junit5允许测试非public方法\n\n在junit5中，测试类和测试方法不要求一定是public的，我们可以让它们是包作用域的（比如类没有public修饰，方法是protected或者private的，都可以执行）。junit5内部使用了反射去寻找测试类和测试方法。反射可以发现非public方法，所以测试类和测试方法就不用非得是public的了。 junit5中，测试类也可以没有public构造器，甚至可以有具有参数的构造器，这意味着，拥有无参且public的构造器在junit5中不再是强制的了。 比如：\n\nclass apptest {\n\n    private apptest(testinfo testinfo) {\n        system.out.println("working on test " + testinfo.getdisplayname());\n    }\n\n    @test\n    void test(){\n        asserttrue(true);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.8 第三方集成\n\n在junit4中，没有支持与第三方插件或者ide的集成。如果要集成，需要依赖反射。 junit5中，专门有一个子项目用于支持与第三方集成，即junit platform。它定义了测试引擎（testengine）api，用于开发运行在junit5测试平台上运行的测试框架。\n\n\n# 3.结论\n\n在这篇junit教程中，我们学习了junit4和junit5的重要区别，和用它们编写的测试用例的区别。虽然它们底层有很多不同，但是主要的不同还是junit5引入了多个模块，并且支持第三方编写自定义的运行时引擎。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"订单超时自动取消/延时任务，如何实现？",frontmatter:{title:"订单超时自动取消/延时任务，如何实现？",date:"2021-11-23T00:00:00.000Z",tags:["Java","RabbitMQ"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html",relativePath:"views/backend/超时取消分析.md",key:"v-65899d47",path:"/views/backend/%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88%E5%88%86%E6%9E%90.html",headers:[{level:2,title:"方案调研",slug:"方案调研",normalizedTitle:"方案调研",charIndex:86},{level:2,title:"方案分析",slug:"方案分析",normalizedTitle:"方案分析",charIndex:94},{level:3,title:"1、数据库轮询",slug:"_1、数据库轮询",normalizedTitle:"1、数据库轮询",charIndex:104},{level:4,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:1045},{level:4,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:558},{level:3,title:"2、JDK的延迟队列",slug:"_2、jdk的延迟队列",normalizedTitle:"2、jdk的延迟队列",charIndex:117},{level:4,title:"思路",slug:"思路-2",normalizedTitle:"思路",charIndex:1045},{level:4,title:"实现",slug:"实现-2",normalizedTitle:"实现",charIndex:558},{level:3,title:"3、时间轮算法",slug:"_3、时间轮算法",normalizedTitle:"3、时间轮算法",charIndex:133},{level:4,title:"思路",slug:"思路-3",normalizedTitle:"思路",charIndex:1045},{level:4,title:"实现",slug:"实现-3",normalizedTitle:"实现",charIndex:558},{level:3,title:"4、redis缓存",slug:"_4、redis缓存",normalizedTitle:"4、redis缓存",charIndex:146},{level:3,title:"5、使用消息队列",slug:"_5、使用消息队列",normalizedTitle:"5、使用消息队列",charIndex:161},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:173}],excerpt:"<Boxx/>\n<p>在开发中，往往会遇到一些关于延时任务的需求，例如：</p>\n<ul>\n<li>生成订单30分钟未支付，则自动取消</li>\n<li>生成订单60秒后,给用户发短信</li>\n</ul>\n<p>该如何解决这类需求呢？</p>\n",headersStr:"方案调研 方案分析 1、数据库轮询 思路 实现 2、JDK的延迟队列 思路 实现 3、时间轮算法 思路 实现 4、redis缓存 5、使用消息队列 参考",content:'在开发中，往往会遇到一些关于延时任务的需求，例如：\n\n * 生成订单30分钟未支付，则自动取消\n * 生成订单60秒后,给用户发短信\n\n该如何解决这类需求呢？\n\n\n\n * 方案调研\n * 方案分析\n   * 1、数据库轮询\n   * 2、JDK的延迟队列\n   * 3、时间轮算法\n   * 4、redis缓存\n   * 5、使用消息队列\n * 参考\n\n\n\n对上述的任务，我们给一个专业的名字来形容，那就是延时任务。那么这里就会产生一个问题，这个延时任务和定时任务的区别究竟在哪里呢？一共有如下几点区别\n\n * 定时任务有明确的触发时间，延时任务没有\n * 定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期\n * 定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务\n\n下面，我们以判断订单是否超时为例，进行方案调研\n\n\n# 方案调研\n\n * 定时任务全表扫描\n   \n   缺点：需要全表扫描，任务设置轮询时间就是最大延迟时间，如 12 : 01下的订单，在 12 : 15 是有一次轮询，发现还没超时，此次不处理，在下一次 12 : 30 的执行时候发现超时需要处理了，但此时已过期（15 + 14）分钟。对数据库有一定压力，仅适合数据量少的业务场景\n   \n   优点: 实现简单，仅需要任务调度即可\n\n * 基于java DelayQueue\n   \n   缺点: 单机、不能持久化、宕机任务丢失等等;\n   \n   优点：不依赖任何三方，仅java原生api即可\n\n * redis过期消息通知\n   \n   缺点： 开启键通知会对redis有额外的开销 键通知暂时redis并不保证消息必达，redis客户端断开连接所有key丢失 消费速度不可自控,如果一瞬间QPS非常高,接收到的通知会非常密集,消费不过来, 如果用线程池消费,大部分的待消费任务会放入到阻塞队列 一旦服务宕机,阻塞队列消息全部丢失\n\n * mq提供的延时队列\n   \n   优点：消息0丢失，可抗高并发\n   \n   缺点：需要额外引入mq中间件，提高系统复杂性和mq高可用维护性\n\n * 借鉴redis的惰性删除策略\n   \n   订单过期时不删除，在查询订单时对订单过期时间作校验，如果过期则删除\n   \n   优点：减少对过期订单的检测，提高cpu利用率\n   \n   缺点：如果一直不访问订单，则库存一直无法回滚\n\n\n# 方案分析\n\n\n# 1、数据库轮询\n\n# 思路\n\n该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作\n\n# 实现\n\n博主当年早期是用quartz来实现的(实习那会的事)，简单介绍一下\n\nmaven项目引入一个依赖如下所示\n\n<dependency>\n    <groupId>org.quartz-scheduler</groupId>\n    <artifactId>quartz</artifactId>\n    <version>2.2.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n调用Demo类MyJob如下所示\n\npackage com.rjzheng.delay1;\n\nimport org.quartz.JobBuilder;\n\nimport org.quartz.JobDetail;\n\nimport org.quartz.Scheduler;\n\nimport org.quartz.SchedulerException;\n\nimport org.quartz.SchedulerFactory;\n\nimport org.quartz.SimpleScheduleBuilder;\n\nimport org.quartz.Trigger;\n\nimport org.quartz.TriggerBuilder;\n\nimport org.quartz.impl.StdSchedulerFactory;\n\nimport org.quartz.Job;\n\nimport org.quartz.JobExecutionContext;\n\nimport org.quartz.JobExecutionException;\n\npublic class MyJob implements Job {\n\n    public void execute(JobExecutionContext context)\n\n            throws JobExecutionException {\n\n        System.out.println("要去数据库扫描啦。。。");\n\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        // 创建任务\n\n        JobDetail jobDetail = JobBuilder.newJob(MyJob.class)\n\n                .withIdentity("job1", "group1").build();\n\n        // 创建触发器 每3秒钟执行一次\n\n        Trigger trigger = TriggerBuilder\n\n                .newTrigger()\n\n                .withIdentity("trigger1", "group3")\n\n                .withSchedule(\n\n                        SimpleScheduleBuilder.simpleSchedule()\n\n                                .withIntervalInSeconds(3).repeatForever())\n\n                .build();\n\n        Scheduler scheduler = new StdSchedulerFactory().getScheduler();\n\n        // 将任务及其触发器放入调度器\n\n        scheduler.scheduleJob(jobDetail, trigger);\n\n        // 调度器开始调度任务\n\n        scheduler.start();\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n运行代码，可发现每隔3秒，输出如下\n\n要去数据库扫描啦。。。\n\n优缺点\n\n优点:简单易行，支持集群操作\n\n缺点:(1)对服务器内存消耗大\n\n(2)存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟\n\n(3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大\n\n\n# 2、JDK的延迟队列\n\n# 思路\n\n该方案是利用JDK自带的DelayQueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入DelayQueue中的对象，是必须实现Delayed接口的。\n\nDelayedQueue实现工作流程如下图所示\n\n\n\n其中Poll():获取并移除队列的超时元素，没有则返回空\n\ntake():获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。\n\n# 实现\n\n定义一个类OrderDelay实现Delayed，代码如下\n\npackage com.rjzheng.delay2;\n\nimport java.util.concurrent.Delayed;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class OrderDelay implements Delayed {\n\n    private String orderId;\n\n    private long timeout;\n\n    OrderDelay(String orderId, long timeout) {\n\n        this.orderId = orderId;\n\n        this.timeout = timeout + System.nanoTime();\n\n    }\n\n    public int compareTo(Delayed other) {\n\n        if (other == this)\n\n            return 0;\n\n        OrderDelay t = (OrderDelay) other;\n\n        long d = (getDelay(TimeUnit.NANOSECONDS) - t\n\n                .getDelay(TimeUnit.NANOSECONDS));\n\n        return (d == 0) ? 0 : ((d < 0) ? -1 : 1);\n\n    }\n\n    // 返回距离你自定义的超时时间还有多少\n\n    public long getDelay(TimeUnit unit) {\n\n        return unit.convert(timeout - System.nanoTime(),TimeUnit.NANOSECONDS);\n\n    }\n\n    void print() {\n\n        System.out.println(orderId+"编号的订单要删除啦。。。。");\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n运行的测试Demo为，我们设定延迟时间为3秒\n\npackage com.rjzheng.delay2;\n\nimport java.util.ArrayList;\n\nimport java.util.List;\n\nimport java.util.concurrent.DelayQueue;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class DelayQueueDemo {\n\n     public static void main(String[] args) {  \n\n            // TODO Auto-generated method stub  \n\n            List<String> list = new ArrayList<String>();  \n\n            list.add("00000001");  \n\n            list.add("00000002");  \n\n            list.add("00000003");  \n\n            list.add("00000004");  \n\n            list.add("00000005");  \n\n            DelayQueue<OrderDelay> queue = newDelayQueue<OrderDelay>();  \n\n            long start = System.currentTimeMillis();  \n\n            for(int i = 0;i<5;i++){  \n\n                //延迟三秒取出\n\n                queue.put(new OrderDelay(list.get(i),  \n\n                        TimeUnit.NANOSECONDS.convert(3,TimeUnit.SECONDS)));  \n\n                    try {  \n\n                         queue.take().print();  \n\n                         System.out.println("After " +  \n\n                                 (System.currentTimeMillis()-start) + " MilliSeconds");  \n\n                } catch (InterruptedException e) {  \n\n                    // TODO Auto-generated catch block  \n\n                    e.printStackTrace();  \n\n                }  \n\n            }  \n\n        }  \n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n输出如下\n\n00000001编号的订单要删除啦。。。。\n\nAfter 3003 MilliSeconds\n\n00000002编号的订单要删除啦。。。。\n\nAfter 6006 MilliSeconds\n\n00000003编号的订单要删除啦。。。。\n\nAfter 9006 MilliSeconds\n\n00000004编号的订单要删除啦。。。。\n\nAfter 12008 MilliSeconds\n\n00000005编号的订单要删除啦。。。。\n\nAfter 15009 MilliSeconds\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以看到都是延迟3秒，订单被删除\n\n优缺点\n\n优点:效率高,任务触发时间延迟低。\n\n缺点:\n\n(1)服务器重启后，数据全部消失，怕宕机 (2)集群扩展相当麻烦 (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常 (4)代码复杂度较高\n\n\n# 3、时间轮算法\n\n# 思路\n\n先上一张时间轮的图(这图到处都是啦)\n\n\n\n时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，ticksPerWheel（一轮的tick数），tickDuration（一个tick的持续时间）以及 timeUnit（时间单位），例如当ticksPerWheel=60，tickDuration=1，timeUnit=秒，这就和现实中的始终的秒针走动完全类似了。\n\n如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）\n\n# 实现\n\n我们用Netty的HashedWheelTimer来实现\n\n给Pom加上下面的依赖\n\n<dependency>\n\n    <groupId>io.netty</groupId>\n\n    <artifactId>netty-all</artifactId>\n\n    <version>4.1.24.Final</version>\n\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n测试代码HashedWheelTimerTest如下所示\n\npackage com.rjzheng.delay3;\n\nimport io.netty.util.HashedWheelTimer;\n\nimport io.netty.util.Timeout;\n\nimport io.netty.util.Timer;\n\nimport io.netty.util.TimerTask;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class HashedWheelTimerTest {\n\n    static class MyTimerTask implements TimerTask{\n\n        boolean flag;\n\n        public MyTimerTask(boolean flag){\n\n            this.flag = flag;\n\n        }\n\n        public void run(Timeout timeout) throws Exception {\n\n            // TODO Auto-generated method stub\n\n             System.out.println("要去数据库删除订单了。。。。");\n\n             this.flag =false;\n\n        }\n\n    }\n\n    public static void main(String[] argv) {\n\n        MyTimerTask timerTask = new MyTimerTask(true);\n\n        Timer timer = new HashedWheelTimer();\n\n        timer.newTimeout(timerTask, 5, TimeUnit.SECONDS);\n\n        int i = 1;\n\n        while(timerTask.flag){\n\n            try {\n\n                Thread.sleep(1000);\n\n            } catch (InterruptedException e) {\n\n                // TODO Auto-generated catch block\n\n                e.printStackTrace();\n\n            }\n\n            System.out.println(i+"秒过去了");\n\n            i++;\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n输出如下\n\n1秒过去了\n\n2秒过去了\n\n3秒过去了\n\n4秒过去了\n\n5秒过去了\n\n要去数据库删除订单了。。。。\n\n6秒过去了\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n优缺点\n\n优点:效率高,任务触发时间延迟时间比delayQueue低，代码复杂度比delayQueue低。\n\n缺点:\n\n(1)服务器重启后，数据全部消失，怕宕机\n\n(2)集群扩展相当麻烦\n\n(3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常\n\n\n# 4、redis缓存\n\n * 思路一\n\n利用redis的zset,zset是一个有序集合，每一个元素(member)都关联了一个score,通过score排序来取集合中的值\n\n添加元素:ZADD key score member [[score member] [score member] …]\n\n按顺序查询元素:ZRANGE key start stop [WITHSCORES]\n\n查询元素score:ZSCORE key member\n\n移除元素:ZREM key member [member …]\n\n测试如下\n\n添加单个元素\n\nredis> ZADD page_rank 10 google.com\n\n(integer) 1\n\n添加多个元素\n\nredis> ZADD page_rank 9 baidu.com 8 bing.com\n\n(integer) 2\n\nredis> ZRANGE page_rank 0 -1 WITHSCORES\n\n1) "bing.com"\n\n2) "8"\n\n3) "baidu.com"\n\n4) "9"\n\n5) "google.com"\n\n6) "10"\n\n查询元素的score值\n\nredis> ZSCORE page_rank bing.com\n\n"8"\n\n移除单个元素\n\nredis> ZREM page_rank google.com\n\n(integer) 1\n\nredis> ZRANGE page_rank 0 -1 WITHSCORES\n\n1) "bing.com"\n\n2) "8"\n\n3) "baidu.com"\n\n4) "9"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n那么如何实现呢？我们将订单超时时间戳与订单号分别设置为score和member,系统扫描第一个元素判断是否超时，具体如下图所示\n\n\n\n实现一\n\npackage com.rjzheng.delay4;\n\nimport java.util.Calendar;\n\nimport java.util.Set;\n\nimport redis.clients.jedis.Jedis;\n\nimport redis.clients.jedis.JedisPool;\n\nimport redis.clients.jedis.Tuple;\n\npublic class AppTest {\n\n    private static final String ADDR = "127.0.0.1";\n\n    private static final int PORT = 6379;\n\n    private static JedisPool jedisPool = new JedisPool(ADDR, PORT);\n\n    public static Jedis getJedis() {\n\n       return jedisPool.getResource();\n\n    }\n\n    //生产者,生成5个订单放进去\n\n    public void productionDelayMessage(){\n\n        for(int i=0;i<5;i++){\n\n            //延迟3秒\n\n            Calendar cal1 = Calendar.getInstance();\n\n            cal1.add(Calendar.SECOND, 3);\n\n            int second3later = (int) (cal1.getTimeInMillis() / 1000);\n\n            AppTest.getJedis().zadd("OrderId",second3later,"OID0000001"+i);\n\n            System.out.println(System.currentTimeMillis()+"ms:redis生成了一个订单任务：订单ID为"+"OID0000001"+i);\n\n        }\n\n    }\n\n    //消费者，取订单\n\n    public void consumerDelayMessage(){\n\n        Jedis jedis = AppTest.getJedis();\n\n        while(true){\n\n            Set<Tuple> items = jedis.zrangeWithScores("OrderId", 0, 1);\n\n            if(items == null || items.isEmpty()){\n\n                System.out.println("当前没有等待的任务");\n\n                try {\n\n                    Thread.sleep(500);\n\n                } catch (InterruptedException e) {\n\n                    // TODO Auto-generated catch block\n\n                    e.printStackTrace();\n\n                }\n\n                continue;\n\n            }\n\n            int  score = (int) ((Tuple)items.toArray()[0]).getScore();\n\n            Calendar cal = Calendar.getInstance();\n\n            int nowSecond = (int) (cal.getTimeInMillis() / 1000);\n\n            if(nowSecond >= score){\n\n                String orderId = ((Tuple)items.toArray()[0]).getElement();\n\n                jedis.zrem("OrderId", orderId);\n\n                System.out.println(System.currentTimeMillis() +"ms:redis消费了一个任务：消费的订单OrderId为"+orderId);\n\n            }\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        AppTest appTest =new AppTest();\n\n        appTest.productionDelayMessage();\n\n        appTest.consumerDelayMessage();\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n\n\n此时对应输出如下\n\n\n\n可以看到，几乎都是3秒之后，消费订单。\n\n然而，这一版存在一个致命的硬伤，在高并发条件下，多消费者会取到同一个订单号，我们上测试代码ThreadTest\n\npackage com.rjzheng.delay4;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class ThreadTest {\n\n    private static final int threadNum = 10;\n\n    private static CountDownLatch cdl = newCountDownLatch(threadNum);\n\n    static class DelayMessage implements Runnable{\n\n        public void run() {\n\n            try {\n\n                cdl.await();\n\n            } catch (InterruptedException e) {\n\n                // TODO Auto-generated catch block\n\n                e.printStackTrace();\n\n            }\n\n            AppTest appTest =new AppTest();\n\n            appTest.consumerDelayMessage();\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        AppTest appTest =new AppTest();\n\n        appTest.productionDelayMessage();\n\n        for(int i=0;i<threadNum;i++){\n\n            new Thread(new DelayMessage()).start();\n\n            cdl.countDown();\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n输出如下所示\n\n\n\n显然，出现了多个线程消费同一个资源的情况。\n\n解决方案\n\n(1)用分布式锁，但是用分布式锁，性能下降了，该方案不细说。\n\n(2)对ZREM的返回值进行判断，只有大于0的时候，才消费数据，于是将consumerDelayMessage()方法里的\n\nif(nowSecond >= score){\n\n    String orderId = ((Tuple)items.toArray()[0]).getElement();\n\n    jedis.zrem("OrderId", orderId);\n\n    System.out.println(System.currentTimeMillis()+"ms:redis消费了一个任务：消费的订单OrderId为"+orderId);\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n修改为\n\nif(nowSecond >= score){\n\n    String orderId = ((Tuple)items.toArray()[0]).getElement();\n\n    Long num = jedis.zrem("OrderId", orderId);\n\n    if( num != null && num>0){\n\n        System.out.println(System.currentTimeMillis()+"ms:redis消费了一个任务：消费的订单OrderId为"+orderId);\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在这种修改后，重新运行ThreadTest类，发现输出正常了\n\n * 思路二\n\n该方案使用redis的Keyspace Notifications，中文翻译就是键空间机制，就是利用该机制可以在key失效之后，提供一个回调，实际上是redis会给客户端发送一个消息。是需要redis版本2.8以上。\n\n实现二\n\n在redis.conf中，加入一条配置\n\nnotify-keyspace-events Ex\n\n运行代码如下\n\npackage com.rjzheng.delay5;\n\nimport redis.clients.jedis.Jedis;\n\nimport redis.clients.jedis.JedisPool;\n\nimport redis.clients.jedis.JedisPubSub;\n\npublic class RedisTest {\n\n    private static final String ADDR = "127.0.0.1";\n\n    private static final int PORT = 6379;\n\n    private static JedisPool jedis = new JedisPool(ADDR, PORT);\n\n    private static RedisSub sub = new RedisSub();\n\n    public static void init() {\n\n        new Thread(new Runnable() {\n\n            public void run() {\n\n                jedis.getResource().subscribe(sub, "__keyevent@0__:expired");\n\n            }\n\n        }).start();\n\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n\n        init();\n\n        for(int i =0;i<10;i++){\n\n            String orderId = "OID000000"+i;\n\n            jedis.getResource().setex(orderId, 3, orderId);\n\n            System.out.println(System.currentTimeMillis()+"ms:"+orderId+"订单生成");\n\n        }\n\n    }\n\n    static class RedisSub extends JedisPubSub {\n\n        <ahref=\'http://www.jobbole.com/members/wx610506454\'>@Override</a>\n\n        public void onMessage(String channel, String message) {\n\n            System.out.println(System.currentTimeMillis()+"ms:"+message+"订单取消");\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n输出如下\n\n\n\n可以明显看到3秒过后，订单取消了\n\nps:redis的pub/sub机制存在一个硬伤，官网内容如下\n\n原:Because Redis Pub/Sub is fire and forget currently there is no way to use this feature if your application demands reliable notification of events, that is, if your Pub/Sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.\n\n翻: Redis的发布/订阅目前是即发即弃(fire and forget)模式的，因此无法实现事件的可靠通知。也就是说，如果发布/订阅的客户端断链之后又重连，则在客户端断链期间的所有事件都丢失了。因此，方案二不是太推荐。当然，如果你对可靠性要求不高，可以使用。\n\n优缺点\n\n优点:(1)由于使用Redis作为消息通道，消息都存储在Redis中。如果发送程序或者任务处理程序挂了，重启之后，还有重新处理数据的可能性。(2)做集群扩展相当方便 (3)时间准确度高\n\n缺点:(1)需要额外进行redis维护\n\n\n# 5、使用消息队列\n\n我们可以采用rabbitMQ的延时队列。RabbitMQ具有以下两个特性，可以实现延迟队列\n\nRabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter\n\nlRabbitMQ的Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了deadletter，则按照这两个参数重新路由。结合以上两个特性，就可以模拟出延迟消息的功能,具体的，我改天再写一篇文章，这里再讲下去，篇幅太长。\n\n优缺点\n\n优点: 高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。\n\n缺点：本身的易用度要依赖于rabbitMq的运维.因为要引用rabbitMq,所以复杂度和成本变高。\n\n\n# 参考\n\nhttps://weihubeats.blog.csdn.net/article/details/106279593\n\nhttps://juejin.cn/post/7006898754926329869',normalizedContent:'在开发中，往往会遇到一些关于延时任务的需求，例如：\n\n * 生成订单30分钟未支付，则自动取消\n * 生成订单60秒后,给用户发短信\n\n该如何解决这类需求呢？\n\n\n\n * 方案调研\n * 方案分析\n   * 1、数据库轮询\n   * 2、jdk的延迟队列\n   * 3、时间轮算法\n   * 4、redis缓存\n   * 5、使用消息队列\n * 参考\n\n\n\n对上述的任务，我们给一个专业的名字来形容，那就是延时任务。那么这里就会产生一个问题，这个延时任务和定时任务的区别究竟在哪里呢？一共有如下几点区别\n\n * 定时任务有明确的触发时间，延时任务没有\n * 定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期\n * 定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务\n\n下面，我们以判断订单是否超时为例，进行方案调研\n\n\n# 方案调研\n\n * 定时任务全表扫描\n   \n   缺点：需要全表扫描，任务设置轮询时间就是最大延迟时间，如 12 : 01下的订单，在 12 : 15 是有一次轮询，发现还没超时，此次不处理，在下一次 12 : 30 的执行时候发现超时需要处理了，但此时已过期（15 + 14）分钟。对数据库有一定压力，仅适合数据量少的业务场景\n   \n   优点: 实现简单，仅需要任务调度即可\n\n * 基于java delayqueue\n   \n   缺点: 单机、不能持久化、宕机任务丢失等等;\n   \n   优点：不依赖任何三方，仅java原生api即可\n\n * redis过期消息通知\n   \n   缺点： 开启键通知会对redis有额外的开销 键通知暂时redis并不保证消息必达，redis客户端断开连接所有key丢失 消费速度不可自控,如果一瞬间qps非常高,接收到的通知会非常密集,消费不过来, 如果用线程池消费,大部分的待消费任务会放入到阻塞队列 一旦服务宕机,阻塞队列消息全部丢失\n\n * mq提供的延时队列\n   \n   优点：消息0丢失，可抗高并发\n   \n   缺点：需要额外引入mq中间件，提高系统复杂性和mq高可用维护性\n\n * 借鉴redis的惰性删除策略\n   \n   订单过期时不删除，在查询订单时对订单过期时间作校验，如果过期则删除\n   \n   优点：减少对过期订单的检测，提高cpu利用率\n   \n   缺点：如果一直不访问订单，则库存一直无法回滚\n\n\n# 方案分析\n\n\n# 1、数据库轮询\n\n# 思路\n\n该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作\n\n# 实现\n\n博主当年早期是用quartz来实现的(实习那会的事)，简单介绍一下\n\nmaven项目引入一个依赖如下所示\n\n<dependency>\n    <groupid>org.quartz-scheduler</groupid>\n    <artifactid>quartz</artifactid>\n    <version>2.2.2</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n调用demo类myjob如下所示\n\npackage com.rjzheng.delay1;\n\nimport org.quartz.jobbuilder;\n\nimport org.quartz.jobdetail;\n\nimport org.quartz.scheduler;\n\nimport org.quartz.schedulerexception;\n\nimport org.quartz.schedulerfactory;\n\nimport org.quartz.simpleschedulebuilder;\n\nimport org.quartz.trigger;\n\nimport org.quartz.triggerbuilder;\n\nimport org.quartz.impl.stdschedulerfactory;\n\nimport org.quartz.job;\n\nimport org.quartz.jobexecutioncontext;\n\nimport org.quartz.jobexecutionexception;\n\npublic class myjob implements job {\n\n    public void execute(jobexecutioncontext context)\n\n            throws jobexecutionexception {\n\n        system.out.println("要去数据库扫描啦。。。");\n\n    }\n\n    public static void main(string[] args) throws exception {\n\n        // 创建任务\n\n        jobdetail jobdetail = jobbuilder.newjob(myjob.class)\n\n                .withidentity("job1", "group1").build();\n\n        // 创建触发器 每3秒钟执行一次\n\n        trigger trigger = triggerbuilder\n\n                .newtrigger()\n\n                .withidentity("trigger1", "group3")\n\n                .withschedule(\n\n                        simpleschedulebuilder.simpleschedule()\n\n                                .withintervalinseconds(3).repeatforever())\n\n                .build();\n\n        scheduler scheduler = new stdschedulerfactory().getscheduler();\n\n        // 将任务及其触发器放入调度器\n\n        scheduler.schedulejob(jobdetail, trigger);\n\n        // 调度器开始调度任务\n\n        scheduler.start();\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n运行代码，可发现每隔3秒，输出如下\n\n要去数据库扫描啦。。。\n\n优缺点\n\n优点:简单易行，支持集群操作\n\n缺点:(1)对服务器内存消耗大\n\n(2)存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟\n\n(3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大\n\n\n# 2、jdk的延迟队列\n\n# 思路\n\n该方案是利用jdk自带的delayqueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入delayqueue中的对象，是必须实现delayed接口的。\n\ndelayedqueue实现工作流程如下图所示\n\n\n\n其中poll():获取并移除队列的超时元素，没有则返回空\n\ntake():获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。\n\n# 实现\n\n定义一个类orderdelay实现delayed，代码如下\n\npackage com.rjzheng.delay2;\n\nimport java.util.concurrent.delayed;\n\nimport java.util.concurrent.timeunit;\n\npublic class orderdelay implements delayed {\n\n    private string orderid;\n\n    private long timeout;\n\n    orderdelay(string orderid, long timeout) {\n\n        this.orderid = orderid;\n\n        this.timeout = timeout + system.nanotime();\n\n    }\n\n    public int compareto(delayed other) {\n\n        if (other == this)\n\n            return 0;\n\n        orderdelay t = (orderdelay) other;\n\n        long d = (getdelay(timeunit.nanoseconds) - t\n\n                .getdelay(timeunit.nanoseconds));\n\n        return (d == 0) ? 0 : ((d < 0) ? -1 : 1);\n\n    }\n\n    // 返回距离你自定义的超时时间还有多少\n\n    public long getdelay(timeunit unit) {\n\n        return unit.convert(timeout - system.nanotime(),timeunit.nanoseconds);\n\n    }\n\n    void print() {\n\n        system.out.println(orderid+"编号的订单要删除啦。。。。");\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n运行的测试demo为，我们设定延迟时间为3秒\n\npackage com.rjzheng.delay2;\n\nimport java.util.arraylist;\n\nimport java.util.list;\n\nimport java.util.concurrent.delayqueue;\n\nimport java.util.concurrent.timeunit;\n\npublic class delayqueuedemo {\n\n     public static void main(string[] args) {  \n\n            // todo auto-generated method stub  \n\n            list<string> list = new arraylist<string>();  \n\n            list.add("00000001");  \n\n            list.add("00000002");  \n\n            list.add("00000003");  \n\n            list.add("00000004");  \n\n            list.add("00000005");  \n\n            delayqueue<orderdelay> queue = newdelayqueue<orderdelay>();  \n\n            long start = system.currenttimemillis();  \n\n            for(int i = 0;i<5;i++){  \n\n                //延迟三秒取出\n\n                queue.put(new orderdelay(list.get(i),  \n\n                        timeunit.nanoseconds.convert(3,timeunit.seconds)));  \n\n                    try {  \n\n                         queue.take().print();  \n\n                         system.out.println("after " +  \n\n                                 (system.currenttimemillis()-start) + " milliseconds");  \n\n                } catch (interruptedexception e) {  \n\n                    // todo auto-generated catch block  \n\n                    e.printstacktrace();  \n\n                }  \n\n            }  \n\n        }  \n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n输出如下\n\n00000001编号的订单要删除啦。。。。\n\nafter 3003 milliseconds\n\n00000002编号的订单要删除啦。。。。\n\nafter 6006 milliseconds\n\n00000003编号的订单要删除啦。。。。\n\nafter 9006 milliseconds\n\n00000004编号的订单要删除啦。。。。\n\nafter 12008 milliseconds\n\n00000005编号的订单要删除啦。。。。\n\nafter 15009 milliseconds\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以看到都是延迟3秒，订单被删除\n\n优缺点\n\n优点:效率高,任务触发时间延迟低。\n\n缺点:\n\n(1)服务器重启后，数据全部消失，怕宕机 (2)集群扩展相当麻烦 (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现oom异常 (4)代码复杂度较高\n\n\n# 3、时间轮算法\n\n# 思路\n\n先上一张时间轮的图(这图到处都是啦)\n\n\n\n时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，ticksperwheel（一轮的tick数），tickduration（一个tick的持续时间）以及 timeunit（时间单位），例如当ticksperwheel=60，tickduration=1，timeunit=秒，这就和现实中的始终的秒针走动完全类似了。\n\n如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）\n\n# 实现\n\n我们用netty的hashedwheeltimer来实现\n\n给pom加上下面的依赖\n\n<dependency>\n\n    <groupid>io.netty</groupid>\n\n    <artifactid>netty-all</artifactid>\n\n    <version>4.1.24.final</version>\n\n</dependency>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n测试代码hashedwheeltimertest如下所示\n\npackage com.rjzheng.delay3;\n\nimport io.netty.util.hashedwheeltimer;\n\nimport io.netty.util.timeout;\n\nimport io.netty.util.timer;\n\nimport io.netty.util.timertask;\n\nimport java.util.concurrent.timeunit;\n\npublic class hashedwheeltimertest {\n\n    static class mytimertask implements timertask{\n\n        boolean flag;\n\n        public mytimertask(boolean flag){\n\n            this.flag = flag;\n\n        }\n\n        public void run(timeout timeout) throws exception {\n\n            // todo auto-generated method stub\n\n             system.out.println("要去数据库删除订单了。。。。");\n\n             this.flag =false;\n\n        }\n\n    }\n\n    public static void main(string[] argv) {\n\n        mytimertask timertask = new mytimertask(true);\n\n        timer timer = new hashedwheeltimer();\n\n        timer.newtimeout(timertask, 5, timeunit.seconds);\n\n        int i = 1;\n\n        while(timertask.flag){\n\n            try {\n\n                thread.sleep(1000);\n\n            } catch (interruptedexception e) {\n\n                // todo auto-generated catch block\n\n                e.printstacktrace();\n\n            }\n\n            system.out.println(i+"秒过去了");\n\n            i++;\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n输出如下\n\n1秒过去了\n\n2秒过去了\n\n3秒过去了\n\n4秒过去了\n\n5秒过去了\n\n要去数据库删除订单了。。。。\n\n6秒过去了\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n优缺点\n\n优点:效率高,任务触发时间延迟时间比delayqueue低，代码复杂度比delayqueue低。\n\n缺点:\n\n(1)服务器重启后，数据全部消失，怕宕机\n\n(2)集群扩展相当麻烦\n\n(3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现oom异常\n\n\n# 4、redis缓存\n\n * 思路一\n\n利用redis的zset,zset是一个有序集合，每一个元素(member)都关联了一个score,通过score排序来取集合中的值\n\n添加元素:zadd key score member [[score member] [score member] …]\n\n按顺序查询元素:zrange key start stop [withscores]\n\n查询元素score:zscore key member\n\n移除元素:zrem key member [member …]\n\n测试如下\n\n添加单个元素\n\nredis> zadd page_rank 10 google.com\n\n(integer) 1\n\n添加多个元素\n\nredis> zadd page_rank 9 baidu.com 8 bing.com\n\n(integer) 2\n\nredis> zrange page_rank 0 -1 withscores\n\n1) "bing.com"\n\n2) "8"\n\n3) "baidu.com"\n\n4) "9"\n\n5) "google.com"\n\n6) "10"\n\n查询元素的score值\n\nredis> zscore page_rank bing.com\n\n"8"\n\n移除单个元素\n\nredis> zrem page_rank google.com\n\n(integer) 1\n\nredis> zrange page_rank 0 -1 withscores\n\n1) "bing.com"\n\n2) "8"\n\n3) "baidu.com"\n\n4) "9"\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n那么如何实现呢？我们将订单超时时间戳与订单号分别设置为score和member,系统扫描第一个元素判断是否超时，具体如下图所示\n\n\n\n实现一\n\npackage com.rjzheng.delay4;\n\nimport java.util.calendar;\n\nimport java.util.set;\n\nimport redis.clients.jedis.jedis;\n\nimport redis.clients.jedis.jedispool;\n\nimport redis.clients.jedis.tuple;\n\npublic class apptest {\n\n    private static final string addr = "127.0.0.1";\n\n    private static final int port = 6379;\n\n    private static jedispool jedispool = new jedispool(addr, port);\n\n    public static jedis getjedis() {\n\n       return jedispool.getresource();\n\n    }\n\n    //生产者,生成5个订单放进去\n\n    public void productiondelaymessage(){\n\n        for(int i=0;i<5;i++){\n\n            //延迟3秒\n\n            calendar cal1 = calendar.getinstance();\n\n            cal1.add(calendar.second, 3);\n\n            int second3later = (int) (cal1.gettimeinmillis() / 1000);\n\n            apptest.getjedis().zadd("orderid",second3later,"oid0000001"+i);\n\n            system.out.println(system.currenttimemillis()+"ms:redis生成了一个订单任务：订单id为"+"oid0000001"+i);\n\n        }\n\n    }\n\n    //消费者，取订单\n\n    public void consumerdelaymessage(){\n\n        jedis jedis = apptest.getjedis();\n\n        while(true){\n\n            set<tuple> items = jedis.zrangewithscores("orderid", 0, 1);\n\n            if(items == null || items.isempty()){\n\n                system.out.println("当前没有等待的任务");\n\n                try {\n\n                    thread.sleep(500);\n\n                } catch (interruptedexception e) {\n\n                    // todo auto-generated catch block\n\n                    e.printstacktrace();\n\n                }\n\n                continue;\n\n            }\n\n            int  score = (int) ((tuple)items.toarray()[0]).getscore();\n\n            calendar cal = calendar.getinstance();\n\n            int nowsecond = (int) (cal.gettimeinmillis() / 1000);\n\n            if(nowsecond >= score){\n\n                string orderid = ((tuple)items.toarray()[0]).getelement();\n\n                jedis.zrem("orderid", orderid);\n\n                system.out.println(system.currenttimemillis() +"ms:redis消费了一个任务：消费的订单orderid为"+orderid);\n\n            }\n\n        }\n\n    }\n\n    public static void main(string[] args) {\n\n        apptest apptest =new apptest();\n\n        apptest.productiondelaymessage();\n\n        apptest.consumerdelaymessage();\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n\n\n此时对应输出如下\n\n\n\n可以看到，几乎都是3秒之后，消费订单。\n\n然而，这一版存在一个致命的硬伤，在高并发条件下，多消费者会取到同一个订单号，我们上测试代码threadtest\n\npackage com.rjzheng.delay4;\n\nimport java.util.concurrent.countdownlatch;\n\npublic class threadtest {\n\n    private static final int threadnum = 10;\n\n    private static countdownlatch cdl = newcountdownlatch(threadnum);\n\n    static class delaymessage implements runnable{\n\n        public void run() {\n\n            try {\n\n                cdl.await();\n\n            } catch (interruptedexception e) {\n\n                // todo auto-generated catch block\n\n                e.printstacktrace();\n\n            }\n\n            apptest apptest =new apptest();\n\n            apptest.consumerdelaymessage();\n\n        }\n\n    }\n\n    public static void main(string[] args) {\n\n        apptest apptest =new apptest();\n\n        apptest.productiondelaymessage();\n\n        for(int i=0;i<threadnum;i++){\n\n            new thread(new delaymessage()).start();\n\n            cdl.countdown();\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n输出如下所示\n\n\n\n显然，出现了多个线程消费同一个资源的情况。\n\n解决方案\n\n(1)用分布式锁，但是用分布式锁，性能下降了，该方案不细说。\n\n(2)对zrem的返回值进行判断，只有大于0的时候，才消费数据，于是将consumerdelaymessage()方法里的\n\nif(nowsecond >= score){\n\n    string orderid = ((tuple)items.toarray()[0]).getelement();\n\n    jedis.zrem("orderid", orderid);\n\n    system.out.println(system.currenttimemillis()+"ms:redis消费了一个任务：消费的订单orderid为"+orderid);\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n修改为\n\nif(nowsecond >= score){\n\n    string orderid = ((tuple)items.toarray()[0]).getelement();\n\n    long num = jedis.zrem("orderid", orderid);\n\n    if( num != null && num>0){\n\n        system.out.println(system.currenttimemillis()+"ms:redis消费了一个任务：消费的订单orderid为"+orderid);\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在这种修改后，重新运行threadtest类，发现输出正常了\n\n * 思路二\n\n该方案使用redis的keyspace notifications，中文翻译就是键空间机制，就是利用该机制可以在key失效之后，提供一个回调，实际上是redis会给客户端发送一个消息。是需要redis版本2.8以上。\n\n实现二\n\n在redis.conf中，加入一条配置\n\nnotify-keyspace-events ex\n\n运行代码如下\n\npackage com.rjzheng.delay5;\n\nimport redis.clients.jedis.jedis;\n\nimport redis.clients.jedis.jedispool;\n\nimport redis.clients.jedis.jedispubsub;\n\npublic class redistest {\n\n    private static final string addr = "127.0.0.1";\n\n    private static final int port = 6379;\n\n    private static jedispool jedis = new jedispool(addr, port);\n\n    private static redissub sub = new redissub();\n\n    public static void init() {\n\n        new thread(new runnable() {\n\n            public void run() {\n\n                jedis.getresource().subscribe(sub, "__keyevent@0__:expired");\n\n            }\n\n        }).start();\n\n    }\n\n    public static void main(string[] args) throws interruptedexception {\n\n        init();\n\n        for(int i =0;i<10;i++){\n\n            string orderid = "oid000000"+i;\n\n            jedis.getresource().setex(orderid, 3, orderid);\n\n            system.out.println(system.currenttimemillis()+"ms:"+orderid+"订单生成");\n\n        }\n\n    }\n\n    static class redissub extends jedispubsub {\n\n        <ahref=\'http://www.jobbole.com/members/wx610506454\'>@override</a>\n\n        public void onmessage(string channel, string message) {\n\n            system.out.println(system.currenttimemillis()+"ms:"+message+"订单取消");\n\n        }\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n输出如下\n\n\n\n可以明显看到3秒过后，订单取消了\n\nps:redis的pub/sub机制存在一个硬伤，官网内容如下\n\n原:because redis pub/sub is fire and forget currently there is no way to use this feature if your application demands reliable notification of events, that is, if your pub/sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.\n\n翻: redis的发布/订阅目前是即发即弃(fire and forget)模式的，因此无法实现事件的可靠通知。也就是说，如果发布/订阅的客户端断链之后又重连，则在客户端断链期间的所有事件都丢失了。因此，方案二不是太推荐。当然，如果你对可靠性要求不高，可以使用。\n\n优缺点\n\n优点:(1)由于使用redis作为消息通道，消息都存储在redis中。如果发送程序或者任务处理程序挂了，重启之后，还有重新处理数据的可能性。(2)做集群扩展相当方便 (3)时间准确度高\n\n缺点:(1)需要额外进行redis维护\n\n\n# 5、使用消息队列\n\n我们可以采用rabbitmq的延时队列。rabbitmq具有以下两个特性，可以实现延迟队列\n\nrabbitmq可以针对queue和message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter\n\nlrabbitmq的queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，用来控制队列内出现了deadletter，则按照这两个参数重新路由。结合以上两个特性，就可以模拟出延迟消息的功能,具体的，我改天再写一篇文章，这里再讲下去，篇幅太长。\n\n优缺点\n\n优点: 高效,可以利用rabbitmq的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。\n\n缺点：本身的易用度要依赖于rabbitmq的运维.因为要引用rabbitmq,所以复杂度和成本变高。\n\n\n# 参考\n\nhttps://weihubeats.blog.csdn.net/article/details/106279593\n\nhttps://juejin.cn/post/7006898754926329869',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"单元测试：SpringBoot Test",frontmatter:{title:"单元测试：SpringBoot Test",date:"2022-09-17T00:00:00.000Z",tags:["单元测试","Java"],categories:["后端 Back-end"],isShowComments:!0},regularPath:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html",relativePath:"views/backend/单元测试3.md",key:"v-f1f5b922",path:"/views/backend/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%953.html",headers:[{level:2,title:"1. 功能分类",slug:"_1-功能分类",normalizedTitle:"1. 功能分类",charIndex:173},{level:2,title:"1.1 配置类型的注解",slug:"_1-1-配置类型的注解",normalizedTitle:"1.1 配置类型的注解",charIndex:184},{level:3,title:"1.2 mock类型的注解",slug:"_1-2-mock类型的注解",normalizedTitle:"1.2 mock类型的注解",charIndex:201},{level:3,title:"1.3 自动配置类型的注解（@AutoConfigure*）",slug:"_1-3-自动配置类型的注解-autoconfigure",normalizedTitle:"1.3 自动配置类型的注解（@autoconfigure*）",charIndex:220},{level:3,title:"1.4 启动测试类型的注解（@*Test）",slug:"_1-4-启动测试类型的注解-test",normalizedTitle:"1.4 启动测试类型的注解（@*test）",charIndex:256},{level:2,title:"2. 相互之间的搭配组合",slug:"_2-相互之间的搭配组合",normalizedTitle:"2. 相互之间的搭配组合",charIndex:281},{level:2,title:"3. 相似注解的区别和联系",slug:"_3-相似注解的区别和联系",normalizedTitle:"3. 相似注解的区别和联系",charIndex:297},{level:3,title:"3.1 @TestComment vs @Comment",slug:"_3-1-testcomment-vs-comment",normalizedTitle:"3.1 @testcomment vs @comment",charIndex:316},{level:3,title:"3.2 @TestConfiguration vs @Configuration",slug:"_3-2-testconfiguration-vs-configuration",normalizedTitle:"3.2 @testconfiguration vs @configuration",charIndex:350},{level:3,title:"3.3 @SpringBootTest vs @WebMvcTest(或@*Test)",slug:"_3-3-springboottest-vs-webmvctest-或-test",normalizedTitle:"3.3 @springboottest vs @webmvctest(或@*test)",charIndex:396},{level:2,title:"4. 小结",slug:"_4-小结",normalizedTitle:"4. 小结",charIndex:443}],excerpt:"<Boxx/>\n<p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，在 Spring Boot 2.2.0 版本之前，spring-boot-starter-test 包含了 JUnit 4 的依赖，Spring Boot 2.2.0 版本之后替换成了 Junit Jupiter （没有@RunWith注解了）。</p>\n",headersStr:"1. 功能分类 1.1 配置类型的注解 1.2 mock类型的注解 1.3 自动配置类型的注解（@AutoConfigure*） 1.4 启动测试类型的注解（@*Test） 2. 相互之间的搭配组合 3. 相似注解的区别和联系 3.1 @TestComment vs @Comment 3.2 @TestConfiguration vs @Configuration 3.3 @SpringBootTest vs @WebMvcTest(或@*Test) 4. 小结",content:'Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，在 Spring Boot 2.2.0 版本之前，spring-boot-starter-test 包含了 JUnit 4 的依赖，Spring Boot 2.2.0 版本之后替换成了 Junit Jupiter （没有@RunWith注解了）。\n\n\n\n * 1. 功能分类\n * 1.1 配置类型的注解\n   * 1.2 mock类型的注解\n   * 1.3 自动配置类型的注解（@AutoConfigure*）\n   * 1.4 启动测试类型的注解（@*Test）\n * 2. 相互之间的搭配组合\n * 3. 相似注解的区别和联系\n   * 3.1 @TestComment vs @Comment\n   * 3.2 @TestConfiguration vs @Configuration\n   * 3.3 @SpringBootTest vs @WebMvcTest(或@*Test)\n * 4. 小结\n\n\n\nSpringBootTest默认集成了以下功能：\n\n * JUnit 5: Java单元测试框架\n * Spring Test & Spring Boot Test: Spring Boot的测试工具和支持\n * AssertJ: 流式断言\n * Hamcrest: Hamcrest断言\n * Mockito: Java Mock框架\n * JSONassert: JSON断言\n * JsonPath: XPath for JSON\n\n\n# 1. 功能分类\n\n从功能上讲，Spring Boot Test中的注解主要分如下几类：\n\n类别       示例                    格式                说明\n配置类型     @TestConfiguration等                     提供一些测试相关的配置入口\nmock类型   @MockBean等                              提供mock支持\n启动测试类型   @SpringBootTest       @*Test            以Test结尾的注解，具有加载applicationContext的能力\n自动配置类型   @AutoConfigureJdbc等   @AutoConfigure*   以AutoConfigure开头的注解，具有加载测试支持功能的能力。\n\n\n# 1.1 配置类型的注解\n\n注解                           作用                                                                                                  实践中的使用\n@TestComponent               该注解另一种@Component，在语义上用来指定某个Bean是专门用于测试的。                                                            该注解适用于测试代码和正式混合在一起时，不加载被该注解描述的Bean，使用不多。\n@TestConfiguration           该注解是另一种@TestComponent，它用于补充额外的Bean或覆盖已存在的Bean                                                       在不修改正式代码的前提下，使配置更加灵活\n@TypeExcludeFilters          用来排除@TestConfiguration和@TestComponent                                                               适用于测试代码和正式代码混合的场景，使用不多\n@OverrideAutoConfiguration   可用于覆盖@EnableAutoConfiguration，与ImportAutoConfiguration结合使用，以限制所加载的自动配置类                             在不修改正式代码的前提下，提供了修改配置自动配置类的能力\n@PropertyMapping             定义@AutoConfigure*注解中用到的变量名称，例如在@AutoConfigureMockMvc中定义名为spring.test.mockmvc.webclient.enabled的变量   一般不使用\n\n> 使用@SpringBootApplication启动测试或者生产代码，被@TestComponent描述的Bean会自动被排除掉。如果不是则需要向@SpringBootApplication添加TypeExcludeFilter。\n\n\n# 1.2 mock类型的注解\n\n注解           作用\n@MockBean    用于mock指定的class或被注解的属性（或者说在测试类中排除一个bean，Spring将使用这个mock而不是真正的类，所以不会调用@PostConstruct方法）\n@MockBeans   使@MockBean支持在同一类型或属性上多次出现\n@SpyBean     用于spy指定的class或被注解的属性\n@SpyBeans    使@SpyBeans支持在同一类型或属性上多次出现\n\n@MockBean和@SpyBean这两个注解，在mockito框架中本来已经存在，且功能基本相同。Spring Boot Test又定义一份重复的注解，目的在于使MockBean和SpyBean被ApplicationContext管理，从而方便使用。\n\n> MockBean和SpyBean功能非常相似，都能模拟方法的各种行为。不同之处在于MockBean是全新的对象，跟正式对象没有关系；而SpyBean与正式对象紧密联系，可以模拟正式对象的部分方法，没有被模拟的方法仍然可以运行正式代码。\n\n\n# 1.3 自动配置类型的注解（@AutoConfigure*）\n\n注解                                    作用\n@AutoConfigureJdbc                    自动配置 JDBC\n@AutoConfigureCache                   自动配置缓存\n@AutoConfigureDataLdap                自动配置 LDAP\n@AutoConfigureJson                    自动配置 JSON\n@AutoConfigureJsonTesters             自动配置 JsonTester\n@AutoConfigureDataJpa                 自动配置 JPA\n@AutoConfigureTestEntityManager       自动配置 TestEntityManager\n@AutoConfigureRestDocs                自动配置 Rest Docs\n@AutoConfigureMockRestServiceServer   自动配置 MockRestServiceServer\n@AutoConfigureWebClient               自动配置 WebClient\n@AutoConfigureWebFlux                 自动配置 WebFlux\n@AutoConfigureWebTestClient           自动配置 WebTestClient\n@AutoConfigureMockMvc                 自动配置 MockMvc\n@AutoConfigureWebMvc                  自动配置 WebMvc\n@AutoConfigureDataNeo4j               自动配置 Neo4j\n@AutoConfigureDataRedis               自动配置 Redis\n@AutoConfigureJooq                    自动配置 Jooq\n@AutoConfigureTestDatabase            自动配置Test Database，可以使用内存数据库\n\n这些注解可以搭配@\\*Test使用，用于开启在@\\*Test中未自动配置的功能。例如@SpringBootTest和@AutoConfigureMockMvc组合后，就可以注入org.springframework.test.web.servlet.MockMvc。\n\n> “自动配置类型”有两种使用方式：\n> \n>  1. 在功能测试（即使用@SpringBootTest）时显示添加。\n>  2. 一般在切片测试中被隐式使用，例如@WebMvcTest注解时，隐式添加了@AutoConfigureCache、@AutoConfigureWebMvc、@AutoConfigureMockMvc。\n\n> 实现原理 与spring-boot-\bautoconfigure\b\b中的@\\*AutoConfiguration实现略有不同，Test包中的@AutoConfigure\\*通过DeterminableImports接口作为指定代码的识别入口，通过ImportAutoConfiguration注解作为配置入口，从Test包下的spring.factories读取配置文件，每个@AutoConfigure\\*中都可以包含多个\bSpring Boot的@\\*AutoConfiguration，例如：\n> \n> \n> \n> AutoConfigureWebMvc\n\n\n# 1.4 启动测试类型的注解（@*Test）\n\n所有的 @*Test 注解都被 @BootstrapWith 注解，它们可以启动 ApplicationContext，是测试的入口，所有的测试类必须声明一个 @*Test注解。\n\n注解                作用                                                                                \n@SpringBootTest   自动侦测并加载@SpringBootApplication或@SpringBootConfiguration中的配置，默认web环境为MOCK，不监听任务端口   \n@DataRedisTest    测试对Redis操作，自动扫描被@RedisHash描述的类，并配置Spring Data Redis的库                             \n@DataJpaTest      测试基于JPA的数据库操作，同时提供了TestEntityManager替代JPA的EntityManager                           \n@DataJdbcTest     测试基于Spring Data JDBC的数据库操作                                                        \n@JsonTest         测试JSON的序列化和反序列化                                                                   \n@WebMvcTest       测试Spring MVC中的controllers                                                         \n@WebFluxTest      测试Spring WebFlux中的controllers                                                     \n@RestClientTest   测试对REST客户端的操作                                                                     \n@DataLdapTest     测试对LDAP的操作                                                                        \n@DataMongoTest    测试对MongoDB的操作                                                                     \n@DataNeo4jTest    测试对Neo4j的操作                                                                       \n\n> 除了@SpringBootTest之外的注解都是用来进行切面测试的，他们会默认导入一些自动配置，点击官方docs查看详情。\n\n一般情况下，推荐使用@SpringBootTest而非其它切片测试的注解，简单有效。若某次改动仅涉及特定切片，可以考虑使用切片测试。\n\n@SpringBootTest是这些注解中最常用的一个，其中包含的配置项如下：\n\n配置名称             说明\nvalue            指定配置属性\nproperties       指定配置属性，和value意义相同\nclasses          指定配置类，等同于@ContextConfiguration中的class，若没有显示指定，将查找嵌套的@Configuration类，然后返回到SpringBootConfiguration搜索配置\nwebEnvironment   指定web环境，可选值有：MOCK、RANDOM_PORT、DEFINED_PORT、NONE\n\nwebEnvironment详细说明：\n\n可选值            说明\nMOCK           此值为默认值，该类型提供一个mock环境，此时内嵌的服务（servlet容器）并没有真正启动，也不会监听web端口。\nRANDOM_PORT    启动一个真实的web服务，监听一个随机端口。\nDEFINED_PORT   启动一个真实的web服务，监听一个定义好的端口（从配置中读取）。\nNONE           启动一个非web的ApplicationContext，既不提供mock环境，也不提供真是的web服务。\n\n\n# 2. 相互之间的搭配组合\n\n典型的搭配如下：\n\npackage sample.test;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport sample.test.domain.VehicleIdentificationNumber;\nimport sample.test.service.VehicleDetails;\nimport sample.test.service.VehicleDetailsService;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.context.SpringBootTest.WebEnvironment;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport static org.mockito.BDDMockito.given;\n\n/**\n * {@code @SpringBootTest} with a random port for {@link SampleTestApplication}.\n *\n * @author Phillip Webb\n */\n@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\n@AutoConfigureTestDatabase\npublic class SampleTestApplicationWebIntegrationTests {\n\n    private static final VehicleIdentificationNumber VIN = new VehicleIdentificationNumber(\n            "01234567890123456");\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @MockBean\n    private VehicleDetailsService vehicleDetailsService;\n\n    @Before\n    public void setup() {\n        given(this.vehicleDetailsService.getVehicleDetails(VIN))\n                .willReturn(new VehicleDetails("Honda", "Civic"));\n    }\n\n    @Test\n    public void test() {\n        this.restTemplate.getForEntity("/{username}/vehicle", String.class, "sframework");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * @RunWith(SpringRunner.class)是JUnit的注解，作用是关联Spring Boot Test，在运行JUnit时同时启动Spring\n * @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) 作用是启动Spring的ApplicationContext，参数webEnvironment指定了运行的web环境\n * @AutoConfigureTestDatabase 作用是启动一个内存数据库，不使用真实的数据库\n\n其中@RunWith和@Test必须存在，@AutoConfigure可以同时配置任意多个，而配置类型的注解可以在需要时添加。\n\n\n# 3. 相似注解的区别和联系\n\n\n# 3.1 @TestComment vs @Comment\n\n * @TestComponent是另一种@Component，在语义上用来指定某个Bean是专门用于测试的\n * 使用@SpringBootApplication服务时，@TestComponent会被自动排除\n\n\n# 3.2 @TestConfiguration vs @Configuration\n\n * @TestConfiguration是Spring Boot Boot Test提供的，@Configuration是Spring Framework提供的。\n * @TestConfiguration实际上是也是一种@TestComponent，只是这个@TestComponent专门用来做配置用。\n * @TestConfiguration和@Configuration不同，它不会阻止@SpringBootTest的查找机制，相当于是对既有配置的补充或覆盖。\n\n\n# 3.3 @SpringBootTest vs @WebMvcTest(或@*Test)\n\n * 都可以启动 Spring 的 ApplicationContext\n * @SpringBootTest自动侦测并加载@SpringBootApplication或@SpringBootConfiguration中的配置，@WebMvcTest不侦测配置，只是默认加载一些自动配置。\n * @SpringBootTest测试范围一般比@WebMvcTest大。\n\n\n# 4. 小结\n\n本文主要介绍了Spring Boot Test中新增的注解，这些注解分为这几个类型：配置类型、mock类型、启动测试类型、自动配置类型。\n\n 1. “配置类型”中的@TestComponent、@TestConfiguration、@OverrideAutoConfiguration使配置更加灵活。\n 2. 封装了mockito的@MockBean和@SpyBean，使其可以自然的注入到Spring容器中。\n 3. 每个测试类必须包含一个“启动测试类型”的注解(@\\*Test)，同时可以根据需要添加”自动配置类型”的注解(@AutoConfigure*)。\n 4. @SpringBootTest是最常用的“启动测试类型”注解',normalizedContent:'spring boot 2.2.0 版本开始引入 junit 5 作为单元测试默认库，在 spring boot 2.2.0 版本之前，spring-boot-starter-test 包含了 junit 4 的依赖，spring boot 2.2.0 版本之后替换成了 junit jupiter （没有@runwith注解了）。\n\n\n\n * 1. 功能分类\n * 1.1 配置类型的注解\n   * 1.2 mock类型的注解\n   * 1.3 自动配置类型的注解（@autoconfigure*）\n   * 1.4 启动测试类型的注解（@*test）\n * 2. 相互之间的搭配组合\n * 3. 相似注解的区别和联系\n   * 3.1 @testcomment vs @comment\n   * 3.2 @testconfiguration vs @configuration\n   * 3.3 @springboottest vs @webmvctest(或@*test)\n * 4. 小结\n\n\n\nspringboottest默认集成了以下功能：\n\n * junit 5: java单元测试框架\n * spring test & spring boot test: spring boot的测试工具和支持\n * assertj: 流式断言\n * hamcrest: hamcrest断言\n * mockito: java mock框架\n * jsonassert: json断言\n * jsonpath: xpath for json\n\n\n# 1. 功能分类\n\n从功能上讲，spring boot test中的注解主要分如下几类：\n\n类别       示例                    格式                说明\n配置类型     @testconfiguration等                     提供一些测试相关的配置入口\nmock类型   @mockbean等                              提供mock支持\n启动测试类型   @springboottest       @*test            以test结尾的注解，具有加载applicationcontext的能力\n自动配置类型   @autoconfigurejdbc等   @autoconfigure*   以autoconfigure开头的注解，具有加载测试支持功能的能力。\n\n\n# 1.1 配置类型的注解\n\n注解                           作用                                                                                                  实践中的使用\n@testcomponent               该注解另一种@component，在语义上用来指定某个bean是专门用于测试的。                                                            该注解适用于测试代码和正式混合在一起时，不加载被该注解描述的bean，使用不多。\n@testconfiguration           该注解是另一种@testcomponent，它用于补充额外的bean或覆盖已存在的bean                                                       在不修改正式代码的前提下，使配置更加灵活\n@typeexcludefilters          用来排除@testconfiguration和@testcomponent                                                               适用于测试代码和正式代码混合的场景，使用不多\n@overrideautoconfiguration   可用于覆盖@enableautoconfiguration，与importautoconfiguration结合使用，以限制所加载的自动配置类                             在不修改正式代码的前提下，提供了修改配置自动配置类的能力\n@propertymapping             定义@autoconfigure*注解中用到的变量名称，例如在@autoconfiguremockmvc中定义名为spring.test.mockmvc.webclient.enabled的变量   一般不使用\n\n> 使用@springbootapplication启动测试或者生产代码，被@testcomponent描述的bean会自动被排除掉。如果不是则需要向@springbootapplication添加typeexcludefilter。\n\n\n# 1.2 mock类型的注解\n\n注解           作用\n@mockbean    用于mock指定的class或被注解的属性（或者说在测试类中排除一个bean，spring将使用这个mock而不是真正的类，所以不会调用@postconstruct方法）\n@mockbeans   使@mockbean支持在同一类型或属性上多次出现\n@spybean     用于spy指定的class或被注解的属性\n@spybeans    使@spybeans支持在同一类型或属性上多次出现\n\n@mockbean和@spybean这两个注解，在mockito框架中本来已经存在，且功能基本相同。spring boot test又定义一份重复的注解，目的在于使mockbean和spybean被applicationcontext管理，从而方便使用。\n\n> mockbean和spybean功能非常相似，都能模拟方法的各种行为。不同之处在于mockbean是全新的对象，跟正式对象没有关系；而spybean与正式对象紧密联系，可以模拟正式对象的部分方法，没有被模拟的方法仍然可以运行正式代码。\n\n\n# 1.3 自动配置类型的注解（@autoconfigure*）\n\n注解                                    作用\n@autoconfigurejdbc                    自动配置 jdbc\n@autoconfigurecache                   自动配置缓存\n@autoconfiguredataldap                自动配置 ldap\n@autoconfigurejson                    自动配置 json\n@autoconfigurejsontesters             自动配置 jsontester\n@autoconfiguredatajpa                 自动配置 jpa\n@autoconfiguretestentitymanager       自动配置 testentitymanager\n@autoconfigurerestdocs                自动配置 rest docs\n@autoconfiguremockrestserviceserver   自动配置 mockrestserviceserver\n@autoconfigurewebclient               自动配置 webclient\n@autoconfigurewebflux                 自动配置 webflux\n@autoconfigurewebtestclient           自动配置 webtestclient\n@autoconfiguremockmvc                 自动配置 mockmvc\n@autoconfigurewebmvc                  自动配置 webmvc\n@autoconfiguredataneo4j               自动配置 neo4j\n@autoconfiguredataredis               自动配置 redis\n@autoconfigurejooq                    自动配置 jooq\n@autoconfiguretestdatabase            自动配置test database，可以使用内存数据库\n\n这些注解可以搭配@\\*test使用，用于开启在@\\*test中未自动配置的功能。例如@springboottest和@autoconfiguremockmvc组合后，就可以注入org.springframework.test.web.servlet.mockmvc。\n\n> “自动配置类型”有两种使用方式：\n> \n>  1. 在功能测试（即使用@springboottest）时显示添加。\n>  2. 一般在切片测试中被隐式使用，例如@webmvctest注解时，隐式添加了@autoconfigurecache、@autoconfigurewebmvc、@autoconfiguremockmvc。\n\n> 实现原理 与spring-boot-\bautoconfigure\b\b中的@\\*autoconfiguration实现略有不同，test包中的@autoconfigure\\*通过determinableimports接口作为指定代码的识别入口，通过importautoconfiguration注解作为配置入口，从test包下的spring.factories读取配置文件，每个@autoconfigure\\*中都可以包含多个\bspring boot的@\\*autoconfiguration，例如：\n> \n> \n> \n> autoconfigurewebmvc\n\n\n# 1.4 启动测试类型的注解（@*test）\n\n所有的 @*test 注解都被 @bootstrapwith 注解，它们可以启动 applicationcontext，是测试的入口，所有的测试类必须声明一个 @*test注解。\n\n注解                作用                                                                                \n@springboottest   自动侦测并加载@springbootapplication或@springbootconfiguration中的配置，默认web环境为mock，不监听任务端口   \n@dataredistest    测试对redis操作，自动扫描被@redishash描述的类，并配置spring data redis的库                             \n@datajpatest      测试基于jpa的数据库操作，同时提供了testentitymanager替代jpa的entitymanager                           \n@datajdbctest     测试基于spring data jdbc的数据库操作                                                        \n@jsontest         测试json的序列化和反序列化                                                                   \n@webmvctest       测试spring mvc中的controllers                                                         \n@webfluxtest      测试spring webflux中的controllers                                                     \n@restclienttest   测试对rest客户端的操作                                                                     \n@dataldaptest     测试对ldap的操作                                                                        \n@datamongotest    测试对mongodb的操作                                                                     \n@dataneo4jtest    测试对neo4j的操作                                                                       \n\n> 除了@springboottest之外的注解都是用来进行切面测试的，他们会默认导入一些自动配置，点击官方docs查看详情。\n\n一般情况下，推荐使用@springboottest而非其它切片测试的注解，简单有效。若某次改动仅涉及特定切片，可以考虑使用切片测试。\n\n@springboottest是这些注解中最常用的一个，其中包含的配置项如下：\n\n配置名称             说明\nvalue            指定配置属性\nproperties       指定配置属性，和value意义相同\nclasses          指定配置类，等同于@contextconfiguration中的class，若没有显示指定，将查找嵌套的@configuration类，然后返回到springbootconfiguration搜索配置\nwebenvironment   指定web环境，可选值有：mock、random_port、defined_port、none\n\nwebenvironment详细说明：\n\n可选值            说明\nmock           此值为默认值，该类型提供一个mock环境，此时内嵌的服务（servlet容器）并没有真正启动，也不会监听web端口。\nrandom_port    启动一个真实的web服务，监听一个随机端口。\ndefined_port   启动一个真实的web服务，监听一个定义好的端口（从配置中读取）。\nnone           启动一个非web的applicationcontext，既不提供mock环境，也不提供真是的web服务。\n\n\n# 2. 相互之间的搭配组合\n\n典型的搭配如下：\n\npackage sample.test;\n\nimport org.junit.before;\nimport org.junit.test;\nimport org.junit.runner.runwith;\nimport sample.test.domain.vehicleidentificationnumber;\nimport sample.test.service.vehicledetails;\nimport sample.test.service.vehicledetailsservice;\n\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.boot.test.autoconfigure.jdbc.autoconfiguretestdatabase;\nimport org.springframework.boot.test.context.springboottest;\nimport org.springframework.boot.test.context.springboottest.webenvironment;\nimport org.springframework.boot.test.mock.mockito.mockbean;\nimport org.springframework.boot.test.web.client.testresttemplate;\nimport org.springframework.test.context.junit4.springrunner;\n\nimport static org.mockito.bddmockito.given;\n\n/**\n * {@code @springboottest} with a random port for {@link sampletestapplication}.\n *\n * @author phillip webb\n */\n@runwith(springrunner.class)\n@springboottest(webenvironment = webenvironment.random_port)\n@autoconfiguretestdatabase\npublic class sampletestapplicationwebintegrationtests {\n\n    private static final vehicleidentificationnumber vin = new vehicleidentificationnumber(\n            "01234567890123456");\n\n    @autowired\n    private testresttemplate resttemplate;\n\n    @mockbean\n    private vehicledetailsservice vehicledetailsservice;\n\n    @before\n    public void setup() {\n        given(this.vehicledetailsservice.getvehicledetails(vin))\n                .willreturn(new vehicledetails("honda", "civic"));\n    }\n\n    @test\n    public void test() {\n        this.resttemplate.getforentity("/{username}/vehicle", string.class, "sframework");\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * @runwith(springrunner.class)是junit的注解，作用是关联spring boot test，在运行junit时同时启动spring\n * @springboottest(webenvironment = webenvironment.random_port) 作用是启动spring的applicationcontext，参数webenvironment指定了运行的web环境\n * @autoconfiguretestdatabase 作用是启动一个内存数据库，不使用真实的数据库\n\n其中@runwith和@test必须存在，@autoconfigure可以同时配置任意多个，而配置类型的注解可以在需要时添加。\n\n\n# 3. 相似注解的区别和联系\n\n\n# 3.1 @testcomment vs @comment\n\n * @testcomponent是另一种@component，在语义上用来指定某个bean是专门用于测试的\n * 使用@springbootapplication服务时，@testcomponent会被自动排除\n\n\n# 3.2 @testconfiguration vs @configuration\n\n * @testconfiguration是spring boot boot test提供的，@configuration是spring framework提供的。\n * @testconfiguration实际上是也是一种@testcomponent，只是这个@testcomponent专门用来做配置用。\n * @testconfiguration和@configuration不同，它不会阻止@springboottest的查找机制，相当于是对既有配置的补充或覆盖。\n\n\n# 3.3 @springboottest vs @webmvctest(或@*test)\n\n * 都可以启动 spring 的 applicationcontext\n * @springboottest自动侦测并加载@springbootapplication或@springbootconfiguration中的配置，@webmvctest不侦测配置，只是默认加载一些自动配置。\n * @springboottest测试范围一般比@webmvctest大。\n\n\n# 4. 小结\n\n本文主要介绍了spring boot test中新增的注解，这些注解分为这几个类型：配置类型、mock类型、启动测试类型、自动配置类型。\n\n 1. “配置类型”中的@testcomponent、@testconfiguration、@overrideautoconfiguration使配置更加灵活。\n 2. 封装了mockito的@mockbean和@spybean，使其可以自然的注入到spring容器中。\n 3. 每个测试类必须包含一个“启动测试类型”的注解(@\\*test)，同时可以根据需要添加”自动配置类型”的注解(@autoconfigure*)。\n 4. @springboottest是最常用的“启动测试类型”注解',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"不要在命运需要你逆风飞翔时，选择随风而去",frontmatter:{title:"不要在命运需要你逆风飞翔时，选择随风而去",date:"2019-09-28T20:53:26.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0},regularPath:"/views/essay/20190928.html",relativePath:"views/essay/20190928.md",key:"v-5d97d573",path:"/views/essay/20190928.html",headers:[{level:2,title:"无聊之时",slug:"无聊之时",normalizedTitle:"无聊之时",charIndex:2}],excerpt:'<Boxx/>\n<h2 id="无聊之时"><a class="header-anchor" href="#无聊之时">#</a> 无聊之时</h2>\n<p>你是否有过这样的经历，在黄昏时分被一种浓浓的情绪气氛笼罩着，无限的压抑、茫然、空虚和无所适从，情感没有依托，你感觉“抓”不住任何东西，世界像个巨大的空洞，任何事物进人，都被消解。你甚至对自己陌生……，你想逃离，它却如影随形。</p>\n',headersStr:"无聊之时",content:"# 无聊之时\n\n你是否有过这样的经历，在黄昏时分被一种浓浓的情绪气氛笼罩着，无限的压抑、茫然、空虚和无所适从，情感没有依托，你感觉“抓”不住任何东西，世界像个巨大的空洞，任何事物进人，都被消解。你甚至对自己陌生……，你想逃离，它却如影随形。\n\n或是在寂静的夜里，你感觉时间滴滴答答仿佛吞噬着你的生命，而你却在窒息的、无能为力的绝望中遇见了另一个自己，那个隐藏的很深的超越你自己的真正的自己。\n\n……\n\n告别无聊：\n\n> 从小事情做起，从细节入手。\n> 首先恢复信心，重新激发生活的热情！你可以采取以下建议：\n\n * You Can Do It！勇敢不是不害怕，而是害怕的时候你还能坚持去做！\n\nTO    DO\n1.    做自己喜欢做的事情，做自己擅长的事情，找回成功的喜悦，找回失去的信心，找到前进动力和方向；\n2.    心累了，人烦恼了就歇歇，让心灵去旅行，可以去爬山，看海，感受壮丽风光，拥抱自然，融入自然；\n3.    可以做喜欢的运动发泄一些，推荐篮球，散步和跑步。跑步可以锻炼身体，锻炼和提高人的意志；\n4.    可以找知心朋友小聚，小酌几杯，向朋友倾诉，让温馨的友情驱散你内心的无聊，苦闷和孤独；\n5.    多和家人聊天，或者打电话，加强沟通，增进感情，告诉家人，我爱他们；\n6.    寻找知心恋人，让爱情升华你的情感，点缀你的生活，照亮你的灵魂；\n7.    如果有什么烦恼不方便和朋友，家人说的，可以上网于陌生人聊天，倾吐一下，也可以找到新的朋友；\n8.    在网上写日记，记下生活的点滴；\n9.    可以和三五知己逛街购物，说不定有意外的便宜货或者意外的美食在等着你，从中你可以收获意外的惊喜;\n10.   好好学习，找到学习的乐趣，不断进步，提高自己的学习成绩，结合自己的兴趣多看有关书籍，规划好自己的专业和就业道路，规划好自己的人生道路；\n11.   可以和家人适当地观看自己喜爱的电视剧，同时又可以和家人聊聊天，增进感情；\n12.   可以阅读自己感兴趣的书籍，开拓视野，增长见闻，丰富知识，为学习和工作打下良好的基础；\n13.   可以练练书法，画画，钢琴或者其它乐器，陶冶情操，增加气质；\n14.   提倡绿色上网，看看新闻，适当玩玩游戏，但是不是沉迷，这样可以打发时间；\n15.   适当地在家里做家务，这样既可以保持卫生，有可以得到家人的赞扬，可以得到生活的乐趣；\n16.   夕阳西下，来到野外寻找蒲公英，对着夕阳，迎着晚风轻轻一吹，那就是我飞扬的蒲公英；\n17.   睡不着的时候，可以想象你可以让谁开心，帮助别人是对自己最大的回报！\n\nOK，写给自己同时分享给别人，以后无聊的时候不要再没事做啦！",normalizedContent:"# 无聊之时\n\n你是否有过这样的经历，在黄昏时分被一种浓浓的情绪气氛笼罩着，无限的压抑、茫然、空虚和无所适从，情感没有依托，你感觉“抓”不住任何东西，世界像个巨大的空洞，任何事物进人，都被消解。你甚至对自己陌生……，你想逃离，它却如影随形。\n\n或是在寂静的夜里，你感觉时间滴滴答答仿佛吞噬着你的生命，而你却在窒息的、无能为力的绝望中遇见了另一个自己，那个隐藏的很深的超越你自己的真正的自己。\n\n……\n\n告别无聊：\n\n> 从小事情做起，从细节入手。\n> 首先恢复信心，重新激发生活的热情！你可以采取以下建议：\n\n * you can do it！勇敢不是不害怕，而是害怕的时候你还能坚持去做！\n\nto    do\n1.    做自己喜欢做的事情，做自己擅长的事情，找回成功的喜悦，找回失去的信心，找到前进动力和方向；\n2.    心累了，人烦恼了就歇歇，让心灵去旅行，可以去爬山，看海，感受壮丽风光，拥抱自然，融入自然；\n3.    可以做喜欢的运动发泄一些，推荐篮球，散步和跑步。跑步可以锻炼身体，锻炼和提高人的意志；\n4.    可以找知心朋友小聚，小酌几杯，向朋友倾诉，让温馨的友情驱散你内心的无聊，苦闷和孤独；\n5.    多和家人聊天，或者打电话，加强沟通，增进感情，告诉家人，我爱他们；\n6.    寻找知心恋人，让爱情升华你的情感，点缀你的生活，照亮你的灵魂；\n7.    如果有什么烦恼不方便和朋友，家人说的，可以上网于陌生人聊天，倾吐一下，也可以找到新的朋友；\n8.    在网上写日记，记下生活的点滴；\n9.    可以和三五知己逛街购物，说不定有意外的便宜货或者意外的美食在等着你，从中你可以收获意外的惊喜;\n10.   好好学习，找到学习的乐趣，不断进步，提高自己的学习成绩，结合自己的兴趣多看有关书籍，规划好自己的专业和就业道路，规划好自己的人生道路；\n11.   可以和家人适当地观看自己喜爱的电视剧，同时又可以和家人聊聊天，增进感情；\n12.   可以阅读自己感兴趣的书籍，开拓视野，增长见闻，丰富知识，为学习和工作打下良好的基础；\n13.   可以练练书法，画画，钢琴或者其它乐器，陶冶情操，增加气质；\n14.   提倡绿色上网，看看新闻，适当玩玩游戏，但是不是沉迷，这样可以打发时间；\n15.   适当地在家里做家务，这样既可以保持卫生，有可以得到家人的赞扬，可以得到生活的乐趣；\n16.   夕阳西下，来到野外寻找蒲公英，对着夕阳，迎着晚风轻轻一吹，那就是我飞扬的蒲公英；\n17.   睡不着的时候，可以想象你可以让谁开心，帮助别人是对自己最大的回报！\n\nok，写给自己同时分享给别人，以后无聊的时候不要再没事做啦！",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"此一去不过经年，再回首不复往昔",frontmatter:{title:"此一去不过经年，再回首不复往昔",date:"2018-11-09T15:54:56.000Z",tags:["随笔"],categories:["随笔 Essay"],sticky:1,isShowComments:!0},regularPath:"/views/essay/20191109.html",relativePath:"views/essay/20191109.md",key:"v-5dec17bf",path:"/views/essay/20191109.html",headers:[{level:2,title:"浪费的时间",slug:"浪费的时间",normalizedTitle:"浪费的时间",charIndex:38},{level:2,title:"学习",slug:"学习",normalizedTitle:"学习",charIndex:709},{level:2,title:"我这是怎么了",slug:"我这是怎么了",normalizedTitle:"我这是怎么了",charIndex:1231}],excerpt:"<Boxx/>\n<p>不知道怎么开头，就是想写点东西，然后记录一下自己，嗯，就这么简单。</p>\n",headersStr:"浪费的时间 学习 我这是怎么了",content:"不知道怎么开头，就是想写点东西，然后记录一下自己，嗯，就这么简单。\n\n\n# 浪费的时间\n\n不知不觉北京深秋已过，渐入初冬了。而我自工作以来，似乎是适应了北京的这种快节奏和生活。\n\n上班，下班，吃饭，睡觉，单位宿舍两点一线，属于自己的时间很少，不对，不是很少，只不过是都用来做无用功了，无意义的加班、游戏以及挤地铁。\n\n每个人都生活在自己的舒适区，一旦我们适应了这种生活就很难做出改变，同样，也就很难成长。\n\n而我已不自觉的掉了进去，当然，更多的还是自己对时间概念认识的不足。\n\n前几天看到时间管理中与“墨菲定律”、“彼得原理”同样有趣的定律是“帕金森定理”，第一次看到“帕金森”这个词，我不禁想到了一代传奇人物尼古拉斯赵四，哈哈，赵四跳舞，大个儿说：没有精神病还真跳不出这帕金森的感觉！\n\n帕金森定理按我的理解通俗来讲：就是不管给你的一项工作分配多少时间，这项工作总会膨胀使用完这段时间。\n\n举个例子，就好比当时上大学的时候，老师布置的作业，不管给你三天、五天、一个月，但在这段时间内，我们总是会找各种借口去拖延，去占用这段时间，在完成作业或任务的时候往往是最后那几天。\n\n无奈吧，但这就是拖延的后果，令人沮丧。\n\n同时也通俗的介绍一下墨菲定律和彼得原理吧：\n\n * 墨菲定律：越害怕（担心）什么，就越会发生什么。\n * 彼得原理：一个人的能力和要提升的职位不相匹配，从公司角度出发短期内可能看不出来有什么不好的地方，但长远来看，会对公司对组织的长远发展造成不利影响。\n\n所以，我给自己总结一招就是：简单的事情简单做，复杂的事情简单做。手机上也下载了ToDo，就像微软介绍的那样，就从“我的一天”开始吧。\n\n\n\n\n# 学习\n\n前端时间一直在搞自己的博客，从之前的hexo迁到了新兴的vuepress，从而认识了vuepress-theme-reco这里的好多小伙伴。\n\n有幸，我的博客被当做“Nice Blog Examples”被展示在了官网上供其他人交流和参考。\n\n\n\n话说回来，除了做博客之外，这段时间也真的学了不少，Vue、JWT、Mq、Redis、SpringBoot、SpringCloud，且不说工作中有没有用到，但奈何都只是皮毛，更何况学的多又杂，很多的知识层面都只是停留在基础上或者会用上，更多的原理、底层都还需要挖掘。\n\n虽然大部分知识都过了一遍，但脑子里还没形成自己的架构，这就真的是没有学透。\n\n好比Vue，之前跟着教程学了一遍敲了个项目在github上，也有十几个人start了，但前段时间有人问我问题的时候，内心动态是这样的：“我去，什么鬼，当时为什么这样写？”，事情往往就是这样，刚学完的时候感觉，嗯，也还可以，但时间长不接触或者不看之后，真的是会忘的。\n\n怎么说呢，知识这种东西，学过一遍和没学过是不一样的，我可能忘了它，但我的骨子里已经有了它。\n\n希望它没有忘记我吧！\n\n只能找个时间再学一遍了，来，ToDo，安排上！\n\n\n# 我这是怎么了\n\n每隔一段时间，就忍不住想写写东西，明明心里有话但就是敲不出来。\n\n定个目标：每月抽些时间，随笔也好，记录也罢，总得要拿些东西出来的呀！\n\n可能对于那些“不存在读者”来说，这些文字就是一些乱七八糟的鸡汤，但对我来说，是对我过去的一些记录也是对我之后的一点鼓励。\n\n搞了一个小时就这样吧！2333",normalizedContent:"不知道怎么开头，就是想写点东西，然后记录一下自己，嗯，就这么简单。\n\n\n# 浪费的时间\n\n不知不觉北京深秋已过，渐入初冬了。而我自工作以来，似乎是适应了北京的这种快节奏和生活。\n\n上班，下班，吃饭，睡觉，单位宿舍两点一线，属于自己的时间很少，不对，不是很少，只不过是都用来做无用功了，无意义的加班、游戏以及挤地铁。\n\n每个人都生活在自己的舒适区，一旦我们适应了这种生活就很难做出改变，同样，也就很难成长。\n\n而我已不自觉的掉了进去，当然，更多的还是自己对时间概念认识的不足。\n\n前几天看到时间管理中与“墨菲定律”、“彼得原理”同样有趣的定律是“帕金森定理”，第一次看到“帕金森”这个词，我不禁想到了一代传奇人物尼古拉斯赵四，哈哈，赵四跳舞，大个儿说：没有精神病还真跳不出这帕金森的感觉！\n\n帕金森定理按我的理解通俗来讲：就是不管给你的一项工作分配多少时间，这项工作总会膨胀使用完这段时间。\n\n举个例子，就好比当时上大学的时候，老师布置的作业，不管给你三天、五天、一个月，但在这段时间内，我们总是会找各种借口去拖延，去占用这段时间，在完成作业或任务的时候往往是最后那几天。\n\n无奈吧，但这就是拖延的后果，令人沮丧。\n\n同时也通俗的介绍一下墨菲定律和彼得原理吧：\n\n * 墨菲定律：越害怕（担心）什么，就越会发生什么。\n * 彼得原理：一个人的能力和要提升的职位不相匹配，从公司角度出发短期内可能看不出来有什么不好的地方，但长远来看，会对公司对组织的长远发展造成不利影响。\n\n所以，我给自己总结一招就是：简单的事情简单做，复杂的事情简单做。手机上也下载了todo，就像微软介绍的那样，就从“我的一天”开始吧。\n\n\n\n\n# 学习\n\n前端时间一直在搞自己的博客，从之前的hexo迁到了新兴的vuepress，从而认识了vuepress-theme-reco这里的好多小伙伴。\n\n有幸，我的博客被当做“nice blog examples”被展示在了官网上供其他人交流和参考。\n\n\n\n话说回来，除了做博客之外，这段时间也真的学了不少，vue、jwt、mq、redis、springboot、springcloud，且不说工作中有没有用到，但奈何都只是皮毛，更何况学的多又杂，很多的知识层面都只是停留在基础上或者会用上，更多的原理、底层都还需要挖掘。\n\n虽然大部分知识都过了一遍，但脑子里还没形成自己的架构，这就真的是没有学透。\n\n好比vue，之前跟着教程学了一遍敲了个项目在github上，也有十几个人start了，但前段时间有人问我问题的时候，内心动态是这样的：“我去，什么鬼，当时为什么这样写？”，事情往往就是这样，刚学完的时候感觉，嗯，也还可以，但时间长不接触或者不看之后，真的是会忘的。\n\n怎么说呢，知识这种东西，学过一遍和没学过是不一样的，我可能忘了它，但我的骨子里已经有了它。\n\n希望它没有忘记我吧！\n\n只能找个时间再学一遍了，来，todo，安排上！\n\n\n# 我这是怎么了\n\n每隔一段时间，就忍不住想写写东西，明明心里有话但就是敲不出来。\n\n定个目标：每月抽些时间，随笔也好，记录也罢，总得要拿些东西出来的呀！\n\n可能对于那些“不存在读者”来说，这些文字就是一些乱七八糟的鸡汤，但对我来说，是对我过去的一些记录也是对我之后的一点鼓励。\n\n搞了一个小时就这样吧！2333",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"牢骚太盛防肠断，风物长宜放眼量",frontmatter:{title:"牢骚太盛防肠断，风物长宜放眼量",date:"2019-12-16T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0},regularPath:"/views/essay/20191116.html",relativePath:"views/essay/20191116.md",key:"v-bed2e2f2",path:"/views/essay/20191116.html",headers:[{level:2,title:"游戏",slug:"游戏",normalizedTitle:"游戏",charIndex:187},{level:2,title:"订阅号",slug:"订阅号",normalizedTitle:"订阅号",charIndex:482}],headersStr:"游戏 订阅号",content:"“牢骚太盛防肠断，风物长宜放眼量” ——出自《赠柳亚子先生》\n\n意思是：你遇到一些不顺心的事，牢骚太多了，要提防有碍身心健康，对一切风光景物要放开眼界去衡量。\n\n这句诗是针对柳亚子来诗所表现的思想情绪进行正面的批评和规劝。诗人说，应该放开眼界，从远处，大处着眼，也就是从未来从全局着眼，胸襟开阔，保持健康的心态。\n\n而闲来无事的我也只能写写东西发发牢骚来解解闷啦~\n\n\n# 游戏\n\n今天和基友开了两把，爽了一番，心情很是舒畅。\n\n\n\n作为王者多赛季最强王者资深老玩家，装了卸，卸了装，一次又一次。相信不少人对这个游戏是既爱又恨，爱它给我带来的身心放松、精神享受，恨它给我带来的愧疚不堪、萎靡不振！\n\n每当我意识到这个问题，常常是懊悔不已。几次下定决心退出，奈何不如人意。\n\n故，此次，一定，必须，是我的最后一次。\n\n也致我亲爱的基友们：希望你们下次开玩时千万不要喊我，更不要说 等你 这两个字眼，唉哟，最受不了这个了。\n\n放弃这些无意义的游戏之后，准备转战写作剪辑方向了，闲来无事拍拍照片，练练文笔，捎带着思考一下人生，这一天不也就这么过去了嘛！捂脸笑！\n\n\n# 订阅号\n\n说到订阅号不得不吐槽一下微信新版订阅号展示逻辑问题，让我使用起来非常难受，借用知友的回答：\n\n\n\n确实，之前的订阅号列表就像是我关注的微博博主，常常是因为我对这个人感兴趣，然后他更新了信息，我才会去主动点进列表页面去观看他的相关消息。\n\n而现在的订阅号更多的是从订阅号作者角度出发，以信息流的方式展示给我们，不管质量好坏和我们是否喜欢，作为用户我们只能被动接受这些消息，较比之前不能主动选择（还需要按右上角进入订阅号列表，对我来说太难了），让人十分难受。\n\n当然，这从订阅号作者角度出发来说是好的，因为这种信息流的方式增加了你文章的曝光率，只要你的内容足够优秀，你会引来大批的追随者。\n\n相信这也是微信交互设计师权衡之后决定的吧，牺牲部分用户体验，加强订阅号生态质量。\n\n话说回来订阅号也准备改版了，就同博客（znote）同步更新吧，从资料、笔记、学习出发，整理知识，梳理架构，就先从随笔开始吧。",normalizedContent:"“牢骚太盛防肠断，风物长宜放眼量” ——出自《赠柳亚子先生》\n\n意思是：你遇到一些不顺心的事，牢骚太多了，要提防有碍身心健康，对一切风光景物要放开眼界去衡量。\n\n这句诗是针对柳亚子来诗所表现的思想情绪进行正面的批评和规劝。诗人说，应该放开眼界，从远处，大处着眼，也就是从未来从全局着眼，胸襟开阔，保持健康的心态。\n\n而闲来无事的我也只能写写东西发发牢骚来解解闷啦~\n\n\n# 游戏\n\n今天和基友开了两把，爽了一番，心情很是舒畅。\n\n\n\n作为王者多赛季最强王者资深老玩家，装了卸，卸了装，一次又一次。相信不少人对这个游戏是既爱又恨，爱它给我带来的身心放松、精神享受，恨它给我带来的愧疚不堪、萎靡不振！\n\n每当我意识到这个问题，常常是懊悔不已。几次下定决心退出，奈何不如人意。\n\n故，此次，一定，必须，是我的最后一次。\n\n也致我亲爱的基友们：希望你们下次开玩时千万不要喊我，更不要说 等你 这两个字眼，唉哟，最受不了这个了。\n\n放弃这些无意义的游戏之后，准备转战写作剪辑方向了，闲来无事拍拍照片，练练文笔，捎带着思考一下人生，这一天不也就这么过去了嘛！捂脸笑！\n\n\n# 订阅号\n\n说到订阅号不得不吐槽一下微信新版订阅号展示逻辑问题，让我使用起来非常难受，借用知友的回答：\n\n\n\n确实，之前的订阅号列表就像是我关注的微博博主，常常是因为我对这个人感兴趣，然后他更新了信息，我才会去主动点进列表页面去观看他的相关消息。\n\n而现在的订阅号更多的是从订阅号作者角度出发，以信息流的方式展示给我们，不管质量好坏和我们是否喜欢，作为用户我们只能被动接受这些消息，较比之前不能主动选择（还需要按右上角进入订阅号列表，对我来说太难了），让人十分难受。\n\n当然，这从订阅号作者角度出发来说是好的，因为这种信息流的方式增加了你文章的曝光率，只要你的内容足够优秀，你会引来大批的追随者。\n\n相信这也是微信交互设计师权衡之后决定的吧，牺牲部分用户体验，加强订阅号生态质量。\n\n话说回来订阅号也准备改版了，就同博客（znote）同步更新吧，从资料、笔记、学习出发，整理知识，梳理架构，就先从随笔开始吧。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"末年初雪至",frontmatter:{title:"末年初雪至",date:"2019-11-30T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0},regularPath:"/views/essay/20191130.html",relativePath:"views/essay/20191130.md",key:"v-25eb7c17",path:"/views/essay/20191130.html",headers:[{level:2,title:"初雪",slug:"初雪",normalizedTitle:"初雪",charIndex:2},{level:2,title:"计划",slug:"计划",normalizedTitle:"计划",charIndex:280},{level:2,title:"随笔小结",slug:"随笔小结",normalizedTitle:"随笔小结",charIndex:384},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:268}],excerpt:'<Boxx/>\n<h2 id="初雪"><a class="header-anchor" href="#初雪">#</a> 初雪</h2>\n<p><img src="https://s2.ax1x.com/2019/12/28/lmNRgg.png" alt="lmNRgg.png" /></p>\n<p>自昨晚就从朋友圈刷屁屁的雪，也是累坏了一群人，看给孩子高兴的。</p>\n',headersStr:"初雪 计划 随笔小结 其他",content:"# 初雪\n\n\n\n自昨晚就从朋友圈刷屁屁的雪，也是累坏了一群人，看给孩子高兴的。\n\n今早还睡意朦胧的时候，就听见屋外铁锹稀里咣当的声音，掀开窗户一看，啧啧啧，屋外已是一偏雪景，开心。\n\n于是赶紧打开电脑，深吸一口仙气，准备发一篇万字长文来表达我一下此时此刻激动的心情（/激动脸）。\n\n\n\n红墙飞白雪，这个简直就是帝都的风雪标志，下雪天的时候人不多，拍照、观景估计都是不错的，可惜媳妇儿上班班，唉，不然来一次雪中漫步可能也不错吧，哈哈哈~\n\n随着初雪已致，2019尾声悄然到来，仿佛也在跟我说：臭小子，准备好迎接2020吧。\n\n然后就是一些其他的牢骚了。\n\n\n# 计划\n\n说起来真的是有好多事情没有做呢，年末总结没有动，计划单没有写，项目梳理还不完善，光是想想就疯了。（一脸的不情愿）\n\n没办法，得交点东西出来呀，只好先截个脑图了，暂且算是对自己的草草交代。\n\n\n\n\n# 随笔小结\n\n前言：随笔这个东西，不是那么简单唷。。\n\n学生时代，没事搞个命题作文来应付应付考试，顺带还能展示展示风采！职场时光，执笔次数都屈指可数，文采更是大不如从前，还风采...，依旧？更多的是记录一些生活的感悟，以及经历，想想真是挺怀念以前的在校生活呀！！\n\n刚开始的时候也是抽空挤时间东一句西一句的凑，但是后来慢慢发现写作这个东西，就跟待人待事一样，需要拿出专门的时间思考，下笔，修改，再修改。\n\n平时灵感来了记录一下，时间到了就静下心来好好写。\n\n现在很少能沉静下来，闲余时间不是在刷手机就是在刷手机的路上，安静下来读一本书都很难，甚至最近都没有好好听一首歌，就是那种融入到歌曲里面，神游天外的感觉。\n\n所以最近我在努力，努力，努力找寻属于自己的 “静”。\n\n静，则光通达。什么是静，一个人内心很沉静的时候，你的内心就会很纯洁，就像池塘的水一样，当池塘的水很静的时候，它往往污泥什么的都沉淀了，你能够一眼看到底，所以保持内心的沉静，于是，静则光通达。——陈果\n\n怎么样，读书有用了吧，将别人的知识点引入到自己的文章中去，并加以修饰，这就是我们自己的东西，发光了别人，强大了自己。\n\n这里不由得推荐一下 old Chinese person，网易云歌单ID：3068309305，每次写点东西的时候总得听着它才能有孜孜不倦的灵感，是从友人那儿偷来的，真的是一首能让人静下心来的神曲！\n\n\n# 其他\n\n有位自由诗人，他叫许巍；有位孤独诗人，他叫朴树；有位理想诗人，他叫李健；有位摇滚诗人，他叫郑钧。\n\n以上几位都是我喜欢的歌手，熟悉我的朋友都知道，之前非常喜欢许巍，故乡、像风一样自由，都是我K歌必点歌曲，唱K时也能唱好它，是因为我感觉我就是曲中之魂，嗨歌时更有一种身临其境之感，也总能把自己带入歌曲的那种情景中去，仿佛自己就是其中的主人公。\n\n但是现在再听，已完全没有当时的那种触动感，一度怀疑是不是工作之后劳碌的我没有了当年的热枕（哭笑脸），同时，期待可以遇见那么一首歌，能够唤起我的回忆。\n\n所以，保持内心的沉静。（昨晚下单了XS，%@3&……，怎么让我保持沉静！）\n\n就这样吧，北京的初雪，11月底12月初，19年末20年始，一切都是那么的刚刚好！",normalizedContent:"# 初雪\n\n\n\n自昨晚就从朋友圈刷屁屁的雪，也是累坏了一群人，看给孩子高兴的。\n\n今早还睡意朦胧的时候，就听见屋外铁锹稀里咣当的声音，掀开窗户一看，啧啧啧，屋外已是一偏雪景，开心。\n\n于是赶紧打开电脑，深吸一口仙气，准备发一篇万字长文来表达我一下此时此刻激动的心情（/激动脸）。\n\n\n\n红墙飞白雪，这个简直就是帝都的风雪标志，下雪天的时候人不多，拍照、观景估计都是不错的，可惜媳妇儿上班班，唉，不然来一次雪中漫步可能也不错吧，哈哈哈~\n\n随着初雪已致，2019尾声悄然到来，仿佛也在跟我说：臭小子，准备好迎接2020吧。\n\n然后就是一些其他的牢骚了。\n\n\n# 计划\n\n说起来真的是有好多事情没有做呢，年末总结没有动，计划单没有写，项目梳理还不完善，光是想想就疯了。（一脸的不情愿）\n\n没办法，得交点东西出来呀，只好先截个脑图了，暂且算是对自己的草草交代。\n\n\n\n\n# 随笔小结\n\n前言：随笔这个东西，不是那么简单唷。。\n\n学生时代，没事搞个命题作文来应付应付考试，顺带还能展示展示风采！职场时光，执笔次数都屈指可数，文采更是大不如从前，还风采...，依旧？更多的是记录一些生活的感悟，以及经历，想想真是挺怀念以前的在校生活呀！！\n\n刚开始的时候也是抽空挤时间东一句西一句的凑，但是后来慢慢发现写作这个东西，就跟待人待事一样，需要拿出专门的时间思考，下笔，修改，再修改。\n\n平时灵感来了记录一下，时间到了就静下心来好好写。\n\n现在很少能沉静下来，闲余时间不是在刷手机就是在刷手机的路上，安静下来读一本书都很难，甚至最近都没有好好听一首歌，就是那种融入到歌曲里面，神游天外的感觉。\n\n所以最近我在努力，努力，努力找寻属于自己的 “静”。\n\n静，则光通达。什么是静，一个人内心很沉静的时候，你的内心就会很纯洁，就像池塘的水一样，当池塘的水很静的时候，它往往污泥什么的都沉淀了，你能够一眼看到底，所以保持内心的沉静，于是，静则光通达。——陈果\n\n怎么样，读书有用了吧，将别人的知识点引入到自己的文章中去，并加以修饰，这就是我们自己的东西，发光了别人，强大了自己。\n\n这里不由得推荐一下 old chinese person，网易云歌单id：3068309305，每次写点东西的时候总得听着它才能有孜孜不倦的灵感，是从友人那儿偷来的，真的是一首能让人静下心来的神曲！\n\n\n# 其他\n\n有位自由诗人，他叫许巍；有位孤独诗人，他叫朴树；有位理想诗人，他叫李健；有位摇滚诗人，他叫郑钧。\n\n以上几位都是我喜欢的歌手，熟悉我的朋友都知道，之前非常喜欢许巍，故乡、像风一样自由，都是我k歌必点歌曲，唱k时也能唱好它，是因为我感觉我就是曲中之魂，嗨歌时更有一种身临其境之感，也总能把自己带入歌曲的那种情景中去，仿佛自己就是其中的主人公。\n\n但是现在再听，已完全没有当时的那种触动感，一度怀疑是不是工作之后劳碌的我没有了当年的热枕（哭笑脸），同时，期待可以遇见那么一首歌，能够唤起我的回忆。\n\n所以，保持内心的沉静。（昨晚下单了xs，%@3&……，怎么让我保持沉静！）\n\n就这样吧，北京的初雪，11月底12月初，19年末20年始，一切都是那么的刚刚好！",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"超级无敌睡眠法则",frontmatter:{title:"超级无敌睡眠法则",date:"2020-02-27T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0},regularPath:"/views/essay/20200227.html",relativePath:"views/essay/20200227.md",key:"v-09c6eb57",path:"/views/essay/20200227.html",headers:[{level:2,title:"姿势",slug:"姿势",normalizedTitle:"姿势",charIndex:132},{level:2,title:"放松",slug:"放松",normalizedTitle:"放松",charIndex:174},{level:2,title:"呼吸",slug:"呼吸",normalizedTitle:"呼吸",charIndex:163}],excerpt:"<Boxx/>\n<br/>\n<ul>\n<li>\n<p>你睡了么，可惜我失眠了 -</p>\n<p>终于，我这么没心没肺连梦都不做的人也失眠了😭...</p>\n<p>谁能告诉我该怎么办，接连好几天了额，太太太痛苦了~</p>\n</li>\n</ul>\n",headersStr:"姿势 放松 呼吸",content:"\n\n\n * 你睡了么，可惜我失眠了 -\n   \n   终于，我这么没心没肺连梦都不做的人也失眠了😭...\n   \n   谁能告诉我该怎么办，接连好几天了额，太太太痛苦了~\n\n\n\n网上查了一下，最近压力🍐大？好嘛，么得办法，自我总结一套睡眠法则💪💪\n\n\n# 姿势\n\n 1. 全身平躺，双手自然放下\n\n 2. 脑子放空，深呼吸👃一次\n\n\n# 放松\n\n 1. 脑子放空，5秒的 深呼吸 一次\n\n 2. 集中注意力，放在脑子里，告诉自己全身开始 放松\n    [1] 慢慢的，将注意力集中到脚部，脚开始放松\n    [2] 慢慢的，随着注意力来到小腿部，小腿放松\n    [3] 慢慢的，随之来到大腿部，大腿放松\n    [4] 慢慢的，来到臀部，臀部放松\n    [5] 慢慢的，来到腰部，腰部放松\n    [6] 慢慢的，来到手臂处，手臂放松\n    [7] 慢慢的，来到肩膀处，肩膀放松\n    [8] 慢慢的，回到头部，放松...\n\n\n# 呼吸\n\n 1. 然后保持 478呼吸法 来帮助睡眠（可依据个人调整为456呼吸等）\n    [1] 吸气⏪，1，2，3，4\n    [2] 停气🤫，1，2，3，4，5，6，7\n    [3] 呼气⏩，1，2，3，4，5，6，7，8\n    [4] 吸气⏪，1，2，3，4\n    [5] 停气🤫，1，2，3，4，5，6，7\n    [6] 呼气⏩，1，2，3，4，5，6，7，8\n    [7] 吸气⏪，1，2，3，4\n    [8] 停气🤫，1，2，3，4，5，6，7\n    [9] 呼气⏩，1，2，3，4，5，6，7，8\n    [10] 如此反复 ⏪🤫⏩ ...\n    \n\n * 安静的，睡吧~ 睡吧~ 😴😴🌙\n\n本人夜观天象，觉今日晚10:10乃是睡觉吉时，睡个好觉妥妥的。",normalizedContent:"\n\n\n * 你睡了么，可惜我失眠了 -\n   \n   终于，我这么没心没肺连梦都不做的人也失眠了😭...\n   \n   谁能告诉我该怎么办，接连好几天了额，太太太痛苦了~\n\n\n\n网上查了一下，最近压力🍐大？好嘛，么得办法，自我总结一套睡眠法则💪💪\n\n\n# 姿势\n\n 1. 全身平躺，双手自然放下\n\n 2. 脑子放空，深呼吸👃一次\n\n\n# 放松\n\n 1. 脑子放空，5秒的 深呼吸 一次\n\n 2. 集中注意力，放在脑子里，告诉自己全身开始 放松\n    [1] 慢慢的，将注意力集中到脚部，脚开始放松\n    [2] 慢慢的，随着注意力来到小腿部，小腿放松\n    [3] 慢慢的，随之来到大腿部，大腿放松\n    [4] 慢慢的，来到臀部，臀部放松\n    [5] 慢慢的，来到腰部，腰部放松\n    [6] 慢慢的，来到手臂处，手臂放松\n    [7] 慢慢的，来到肩膀处，肩膀放松\n    [8] 慢慢的，回到头部，放松...\n\n\n# 呼吸\n\n 1. 然后保持 478呼吸法 来帮助睡眠（可依据个人调整为456呼吸等）\n    [1] 吸气⏪，1，2，3，4\n    [2] 停气🤫，1，2，3，4，5，6，7\n    [3] 呼气⏩，1，2，3，4，5，6，7，8\n    [4] 吸气⏪，1，2，3，4\n    [5] 停气🤫，1，2，3，4，5，6，7\n    [6] 呼气⏩，1，2，3，4，5，6，7，8\n    [7] 吸气⏪，1，2，3，4\n    [8] 停气🤫，1，2，3，4，5，6，7\n    [9] 呼气⏩，1，2，3，4，5，6，7，8\n    [10] 如此反复 ⏪🤫⏩ ...\n    \n\n * 安静的，睡吧~ 睡吧~ 😴😴🌙\n\n本人夜观天象，觉今日晚10:10乃是睡觉吉时，睡个好觉妥妥的。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"汝之为何 吾之奈何",frontmatter:{title:"汝之为何 吾之奈何",date:"2020-03-01T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],keys:["5201314"],isShowComments:!0},regularPath:"/views/essay/20200301.html",relativePath:"views/essay/20200301.md",key:"v-57f1379d",path:"/views/essay/20200301.html",headers:[{level:2,title:"伤脑",slug:"伤脑",normalizedTitle:"伤脑",charIndex:2},{level:2,title:"热狗之应",slug:"热狗之应",normalizedTitle:"热狗之应",charIndex:101},{level:2,title:"最后的总结",slug:"最后的总结",normalizedTitle:"最后的总结",charIndex:2590},{level:2,title:"气之因 行之果",slug:"气之因-行之果",normalizedTitle:"气之因 行之果",charIndex:2943}],headersStr:"伤脑 热狗之应 最后的总结 气之因 行之果",content:"# 伤脑\n\n女朋友生气了，而你毫无察觉。等到你看到女友那哀怨的小眼神，你才知道事情不妙，女朋友生气了。 问题的关键是，你觉得你压根就没有惹她。 故，今天，伤脑筋的是：女朋友生气了怎么办? 😱\n\n\n# 热狗之应\n\n女朋友生气的时候，或许你很莫名其妙，或许你很不理解，或许你还很心累很烦躁，但绝不要让自己的情绪被她更强烈的负面情绪带走。 或许她说话带刺，很难听，很伤人，也或许她的态度让人很不舒服，对你冷暴力，这时候万万不可动怒，一旦你也生气了，两人势必大吵一架，大吵之后若不能得到良好处理，就可能会产生感情隔阂，两人之间存在了不能触碰的禁区，显然会对日后分手埋下伏笔。\n\n所以你首先不能让自己产生情绪。\n\n发现女朋友生气了，首先你要理性地想，又来了，又耍小孩子脾气了，又要满嘴气话了，真拿这孩子没办法，好好哄吧。 没错，你要全程保持理性，跳出事件本身，清楚她说的难听的话都是气话，该想的是她为什么生气，这次该怎么哄，如何处理好她的这次生气。\n\n当然，如果真的很难忍，你还是爆炸了，那就尽兴大吵一架吧。不过等你冷静了，你还是得继续放下面子按以下步骤去哄。\n\n第一步 发现原因 对症下药 认真解释\n\n我怎么知道她为什么生气呢？ 这需要直男的你好好锻炼，日后慢慢get到你女朋友的生气点。 那最初小白的你怎么去了解呢？ 当然还得问她本人。\n\n如果你不是故意犯错，同时你真的直到实在不知道女朋友为什么生气，你完全可以拿出你最诚恳的态度去问。 必须是掏心肺腑的诚恳。 如果你单纯一句，宝贝，发生什么了，我到底哪儿做错了？ 可能只能得到一句反问，你居然不知道你哪儿错了？ 随后一句，你自己想，好好想想哪儿错了。 你只能原地懵逼百思不得解。\n\n拿出最诚恳的态度掏心肺腑地问应该是这样的。 宝贝，可能真的是我太笨太蠢了，我实在想不明白宝贝为什么生气，如果是因为我的问题，一定告诉我好吗，是我哪里考虑的太少，惹宝贝生气了？我总是很迟钝，一直不懂女孩子的心，可以给我一点点耐心吗？\n\n像这样把你真实心理过程掏心肺腑给她说，尽可能多地说，让她相信你是真不知道，你真是钢铁直男，那就没办法了只好告诉你了。\n\n知道了原因后必须对症下药，解释清楚。 为什么错了，为什么发生了，起因经过结尾，以及自己的全部心理过程。 没错这又是一个掏心肺腑的过程，要把自己的所有心里想法全透明给她。 当时怎么想的，之后怎么想的，为什么会发生这样的事，具体到每个细节，原原本本地说清楚。 如果你是冤枉的，就务必这样解释清楚，如果你真的有错，讲清情况后要立刻承认错误。 如果你的女朋友也很理性，能明事理，这样解释应该就可以解决问题。 但大多数不能，会认死理，要面子等等，那就要进行下一步。\n\n第二步 深情吐露心声\n\n这个标题感觉好违和。 先听我慢慢说吧。\n\n解释清楚后，就不要再拘泥于她生气的原因了，别揪着一个点再翻来覆去解释，只会越解释她越烦。\n\n在明了过程后，如果她还生气，可能是以下三个原因，一原因已经发生变化，比如你之后的态度不好之类，二可能是认死理，不行你犯了错咱俩就不能好了，三可能是爱面子，不行这事没完你得哄我。 无论哪种情况这时候都该进入哄的正题了。\n\n深情告白嘛就是再掏心肺腑地表达你有么多爱她，你有么多在乎她，你有多么重视她，这绝对是每个女孩子最想听的。\n\n直男不会花言巧语，就该掏心肺腑，而且女生相比花言巧语，更喜欢真实想法。就类似之前解释原因一样，你把重视她在乎她的心理过程再加进去，表达出你其实一直都是在想着她考虑着她，只是有时候方式方法出现了问题，你以后不会这样了。\n\n当然你可以跳出这件事，举例一些别的事，或者不具体到事，让她知道在你心里她多么重要，让她知道她的情绪总在影响着你的情绪，让她知道她开心你也开心，她不开心你也不开心，希望你可以让她总是有好心情，而不像这样因为自己而不高兴，让她知道她对你来说多么多么重要。 这里说的别俗套，把自己的真实想法说清楚就好。\n\n你爱他的时候，每个发自心底的想法都可以是好听的情话，即使表达拙劣一点，也会很感人。\n\n第三步 厚脸皮地哄她开心\n\n有时候，你深情太多，会显得自己很卑微，像个小丑一样在求她，这种时候不仅你自己会产生负面情绪，她也会有，会让她心里烦躁，感到有负担。你继续掏心肺腑反倒会换来她的不舒服，感觉跟你在一起是对你多大的亏欠。 所以你要及时切换心情，变成一个坏坏的，厚脸皮的，或者霸道的男友形象。 这时候必须已经过了她的气头，而在她单纯耍脾气求哄阶段。 怎么操作呢，夸她，各种夸张各种不要脸地夸，说难听点，就像卖国求荣的汉奸在讨好小日本。 然后就是说自己的不是，说自己蠢说自己笨，求包容求原谅。 然后再不停夸她，啊呀老婆最美最贤惠最善良天下第一好，得此良妻犹有何憾？ 啊呀宝贝最乖最可爱。 以后保证好好听你的。 乖，别闹了，听话。 你是我的，别想跑。 诸如此类。\n\n有时候哄女朋友不是你要哄到什么点哄到什么程度的问题，而是你要积累哄的时间，拿出你认真哄的态度给她看，这也是证明你多重视她的过程。\n\n第四步 事后沟通总结 我一直觉得情侣之间无论如何沟通最重要，尤其是异地恋。 包括之前说的，一旦你也爆炸了两人大吵一架，事后冷静了哄好后必须沟通好，必须针对此事好好谈谈交换想法，修补可能存在的裂缝。\n\n包括她生气了你单方面哄（她依然会觉得这是你们两人在吵架），哄完了你们也需要沟通，说说你们关于这件事的真实想法，说说两人以后怎么做。 遇到问题必须解决。\n\n当然，有些话你还是不敢对她说。 我替你说。\n\n哄女朋友确实是男朋友应该有的技能，尤其是异地恋，更容易缺乏安全感，再加上看着别的情侣秀恩爱，女孩子会更加觉得缺爱，所以会生气烦躁闹脾气很正常。\n\n可是啊，真的不要太作，一次两次或许可以接受，隔三差五的来，真的受不了，说不好听的，男朋友再好，再爱你，再温柔，迟早有一天也会给作没了。\n\n有的男生很直，很幼稚，很自私，但他们会为了女朋友在努力改变。 女生也会幼稚，也会自私，所以会作，会整天揪着他到底爱不爱我，有多在乎我，是不是没当初那么重视我了，然后以此去为难男朋友。\n\n即使像上述生气到哄的过程，也会耗费两人尤其是男生许多时间精力，这样的情况多了必然会影响到正常的生活。 两个人应该多些平等，多些理解，多些沟通，都该因为在一起而有所成长。\n\n\n# 最后的总结\n\n不管女朋友心情不好，无理取闹，还是你做错了事，你只要记住第一件事“你错了”。男人嘛，要大度一点。她很在意你此时的态度，如果你不理她或者一走了之，那我很悲伤地告诉你，你倒霉了。\n\n讲笑话，扮鬼脸，怎么搞笑怎么来，如果她忍不住破涕为笑，她生气这件事就算过去了。\n\n最重要的一点，一定要厚脸皮的，无休止的献殷勤，直到她开心或者和你说话为止。放心，你发过去她肯定会看到，女生往往都是在考验你或者说就是在等你一直发发发。\n\n补充一点，态度一定要诚恳，女人这件事她要的还是你一个态度，只要态度够诚恳够真心，能让她感受到的话，人家也肯定会原谅你的。\n\n最后一点就是事后一定要多沟通了，知道问题的关键所在(可能的话记下来)，下次才能尽量避免杜绝这样的事情发生，只要女友不生气，那咱不就剩哈哈哈了嘛。\n\n\n# 气之因 行之果\n\n男生一定主动一点\n\n女人都是口是心非，说你忙去吧不要真的去忙\n\n多找时间陪她\n\n两个人不要互相迁就，有什么一定要说\n\n每个女生都希望她是个小公主，希望你对她越来越好，是偏爱加独宠\n\n没事就一定一定一定要多找她多给她发消息",normalizedContent:"# 伤脑\n\n女朋友生气了，而你毫无察觉。等到你看到女友那哀怨的小眼神，你才知道事情不妙，女朋友生气了。 问题的关键是，你觉得你压根就没有惹她。 故，今天，伤脑筋的是：女朋友生气了怎么办? 😱\n\n\n# 热狗之应\n\n女朋友生气的时候，或许你很莫名其妙，或许你很不理解，或许你还很心累很烦躁，但绝不要让自己的情绪被她更强烈的负面情绪带走。 或许她说话带刺，很难听，很伤人，也或许她的态度让人很不舒服，对你冷暴力，这时候万万不可动怒，一旦你也生气了，两人势必大吵一架，大吵之后若不能得到良好处理，就可能会产生感情隔阂，两人之间存在了不能触碰的禁区，显然会对日后分手埋下伏笔。\n\n所以你首先不能让自己产生情绪。\n\n发现女朋友生气了，首先你要理性地想，又来了，又耍小孩子脾气了，又要满嘴气话了，真拿这孩子没办法，好好哄吧。 没错，你要全程保持理性，跳出事件本身，清楚她说的难听的话都是气话，该想的是她为什么生气，这次该怎么哄，如何处理好她的这次生气。\n\n当然，如果真的很难忍，你还是爆炸了，那就尽兴大吵一架吧。不过等你冷静了，你还是得继续放下面子按以下步骤去哄。\n\n第一步 发现原因 对症下药 认真解释\n\n我怎么知道她为什么生气呢？ 这需要直男的你好好锻炼，日后慢慢get到你女朋友的生气点。 那最初小白的你怎么去了解呢？ 当然还得问她本人。\n\n如果你不是故意犯错，同时你真的直到实在不知道女朋友为什么生气，你完全可以拿出你最诚恳的态度去问。 必须是掏心肺腑的诚恳。 如果你单纯一句，宝贝，发生什么了，我到底哪儿做错了？ 可能只能得到一句反问，你居然不知道你哪儿错了？ 随后一句，你自己想，好好想想哪儿错了。 你只能原地懵逼百思不得解。\n\n拿出最诚恳的态度掏心肺腑地问应该是这样的。 宝贝，可能真的是我太笨太蠢了，我实在想不明白宝贝为什么生气，如果是因为我的问题，一定告诉我好吗，是我哪里考虑的太少，惹宝贝生气了？我总是很迟钝，一直不懂女孩子的心，可以给我一点点耐心吗？\n\n像这样把你真实心理过程掏心肺腑给她说，尽可能多地说，让她相信你是真不知道，你真是钢铁直男，那就没办法了只好告诉你了。\n\n知道了原因后必须对症下药，解释清楚。 为什么错了，为什么发生了，起因经过结尾，以及自己的全部心理过程。 没错这又是一个掏心肺腑的过程，要把自己的所有心里想法全透明给她。 当时怎么想的，之后怎么想的，为什么会发生这样的事，具体到每个细节，原原本本地说清楚。 如果你是冤枉的，就务必这样解释清楚，如果你真的有错，讲清情况后要立刻承认错误。 如果你的女朋友也很理性，能明事理，这样解释应该就可以解决问题。 但大多数不能，会认死理，要面子等等，那就要进行下一步。\n\n第二步 深情吐露心声\n\n这个标题感觉好违和。 先听我慢慢说吧。\n\n解释清楚后，就不要再拘泥于她生气的原因了，别揪着一个点再翻来覆去解释，只会越解释她越烦。\n\n在明了过程后，如果她还生气，可能是以下三个原因，一原因已经发生变化，比如你之后的态度不好之类，二可能是认死理，不行你犯了错咱俩就不能好了，三可能是爱面子，不行这事没完你得哄我。 无论哪种情况这时候都该进入哄的正题了。\n\n深情告白嘛就是再掏心肺腑地表达你有么多爱她，你有么多在乎她，你有多么重视她，这绝对是每个女孩子最想听的。\n\n直男不会花言巧语，就该掏心肺腑，而且女生相比花言巧语，更喜欢真实想法。就类似之前解释原因一样，你把重视她在乎她的心理过程再加进去，表达出你其实一直都是在想着她考虑着她，只是有时候方式方法出现了问题，你以后不会这样了。\n\n当然你可以跳出这件事，举例一些别的事，或者不具体到事，让她知道在你心里她多么重要，让她知道她的情绪总在影响着你的情绪，让她知道她开心你也开心，她不开心你也不开心，希望你可以让她总是有好心情，而不像这样因为自己而不高兴，让她知道她对你来说多么多么重要。 这里说的别俗套，把自己的真实想法说清楚就好。\n\n你爱他的时候，每个发自心底的想法都可以是好听的情话，即使表达拙劣一点，也会很感人。\n\n第三步 厚脸皮地哄她开心\n\n有时候，你深情太多，会显得自己很卑微，像个小丑一样在求她，这种时候不仅你自己会产生负面情绪，她也会有，会让她心里烦躁，感到有负担。你继续掏心肺腑反倒会换来她的不舒服，感觉跟你在一起是对你多大的亏欠。 所以你要及时切换心情，变成一个坏坏的，厚脸皮的，或者霸道的男友形象。 这时候必须已经过了她的气头，而在她单纯耍脾气求哄阶段。 怎么操作呢，夸她，各种夸张各种不要脸地夸，说难听点，就像卖国求荣的汉奸在讨好小日本。 然后就是说自己的不是，说自己蠢说自己笨，求包容求原谅。 然后再不停夸她，啊呀老婆最美最贤惠最善良天下第一好，得此良妻犹有何憾？ 啊呀宝贝最乖最可爱。 以后保证好好听你的。 乖，别闹了，听话。 你是我的，别想跑。 诸如此类。\n\n有时候哄女朋友不是你要哄到什么点哄到什么程度的问题，而是你要积累哄的时间，拿出你认真哄的态度给她看，这也是证明你多重视她的过程。\n\n第四步 事后沟通总结 我一直觉得情侣之间无论如何沟通最重要，尤其是异地恋。 包括之前说的，一旦你也爆炸了两人大吵一架，事后冷静了哄好后必须沟通好，必须针对此事好好谈谈交换想法，修补可能存在的裂缝。\n\n包括她生气了你单方面哄（她依然会觉得这是你们两人在吵架），哄完了你们也需要沟通，说说你们关于这件事的真实想法，说说两人以后怎么做。 遇到问题必须解决。\n\n当然，有些话你还是不敢对她说。 我替你说。\n\n哄女朋友确实是男朋友应该有的技能，尤其是异地恋，更容易缺乏安全感，再加上看着别的情侣秀恩爱，女孩子会更加觉得缺爱，所以会生气烦躁闹脾气很正常。\n\n可是啊，真的不要太作，一次两次或许可以接受，隔三差五的来，真的受不了，说不好听的，男朋友再好，再爱你，再温柔，迟早有一天也会给作没了。\n\n有的男生很直，很幼稚，很自私，但他们会为了女朋友在努力改变。 女生也会幼稚，也会自私，所以会作，会整天揪着他到底爱不爱我，有多在乎我，是不是没当初那么重视我了，然后以此去为难男朋友。\n\n即使像上述生气到哄的过程，也会耗费两人尤其是男生许多时间精力，这样的情况多了必然会影响到正常的生活。 两个人应该多些平等，多些理解，多些沟通，都该因为在一起而有所成长。\n\n\n# 最后的总结\n\n不管女朋友心情不好，无理取闹，还是你做错了事，你只要记住第一件事“你错了”。男人嘛，要大度一点。她很在意你此时的态度，如果你不理她或者一走了之，那我很悲伤地告诉你，你倒霉了。\n\n讲笑话，扮鬼脸，怎么搞笑怎么来，如果她忍不住破涕为笑，她生气这件事就算过去了。\n\n最重要的一点，一定要厚脸皮的，无休止的献殷勤，直到她开心或者和你说话为止。放心，你发过去她肯定会看到，女生往往都是在考验你或者说就是在等你一直发发发。\n\n补充一点，态度一定要诚恳，女人这件事她要的还是你一个态度，只要态度够诚恳够真心，能让她感受到的话，人家也肯定会原谅你的。\n\n最后一点就是事后一定要多沟通了，知道问题的关键所在(可能的话记下来)，下次才能尽量避免杜绝这样的事情发生，只要女友不生气，那咱不就剩哈哈哈了嘛。\n\n\n# 气之因 行之果\n\n男生一定主动一点\n\n女人都是口是心非，说你忙去吧不要真的去忙\n\n多找时间陪她\n\n两个人不要互相迁就，有什么一定要说\n\n每个女生都希望她是个小公主，希望你对她越来越好，是偏爱加独宠\n\n没事就一定一定一定要多找她多给她发消息",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"人逐渐成熟的过程往往也是心逐渐麻木的过程",frontmatter:{title:"人逐渐成熟的过程往往也是心逐渐麻木的过程",date:"2020-07-03T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0},regularPath:"/views/essay/20200703.html",relativePath:"views/essay/20200703.md",key:"v-1cf9f311",path:"/views/essay/20200703.html",headers:[{level:2,title:"始",slug:"始",normalizedTitle:"始",charIndex:2},{level:2,title:"感",slug:"感",normalizedTitle:"感",charIndex:167},{level:2,title:"奈",slug:"奈",normalizedTitle:"奈",charIndex:515}],headersStr:"始 感 奈",content:"# 始\n\n\n\n前阵子在豆瓣上看到一个帖子，提问是：“你的工资能满足你体面的生活吗？”\n\n底下评论的人很多，其中最让人深刻的是这三条：\n\n 1. “四线城市，公务员，两个月的工资勉强够一个月的开销。”\n\n 2. “两万左右，在北京，不买房子的话，活得还行，就是要出卖自己的健康。”\n\n 3. “税后一万二，在广州，偶尔得出卖自己的灵魂，感觉前途一片灰暗，唯一值得庆幸的是不靠家里…”\n\n\n# 感\n\n看完这个帖子我突然觉得有些凄凉，按理说这是最好的时代，你头上明明顶着21世纪的太阳，但是抬头看，依然有阴霾；你明明生长在一个蓬勃发展的时代，但是你心里依然充满不安。\n\n更可怕的是，你的身体就像一块劣质的电池，充电需要充很久，不但充不满而且用得快。你看起来很忙，忙得根本停不下来。可你实际上又很穷，穷得不敢停下来。至于体面地生活，遥远得像是下辈子的事儿。\n\n你学会了说：“谈钱伤感情”，可后来才发现，没钱才伤感情。\n\n你学会了说：“要保持独立的人格，不被金钱左右”，可后来才发现，没钱的灵魂根本就没法硬气地站立。\n\n你学会了说：“要孝敬父母、让在乎的人过上幸福的日子”，可后才发现，没钱根本就做不了孝子，也给不了在乎的人幸福。\n\n\n# 奈\n\n看，你学了多少年的对错，可现如今才明白，现实只讲输赢。",normalizedContent:"# 始\n\n\n\n前阵子在豆瓣上看到一个帖子，提问是：“你的工资能满足你体面的生活吗？”\n\n底下评论的人很多，其中最让人深刻的是这三条：\n\n 1. “四线城市，公务员，两个月的工资勉强够一个月的开销。”\n\n 2. “两万左右，在北京，不买房子的话，活得还行，就是要出卖自己的健康。”\n\n 3. “税后一万二，在广州，偶尔得出卖自己的灵魂，感觉前途一片灰暗，唯一值得庆幸的是不靠家里…”\n\n\n# 感\n\n看完这个帖子我突然觉得有些凄凉，按理说这是最好的时代，你头上明明顶着21世纪的太阳，但是抬头看，依然有阴霾；你明明生长在一个蓬勃发展的时代，但是你心里依然充满不安。\n\n更可怕的是，你的身体就像一块劣质的电池，充电需要充很久，不但充不满而且用得快。你看起来很忙，忙得根本停不下来。可你实际上又很穷，穷得不敢停下来。至于体面地生活，遥远得像是下辈子的事儿。\n\n你学会了说：“谈钱伤感情”，可后来才发现，没钱才伤感情。\n\n你学会了说：“要保持独立的人格，不被金钱左右”，可后来才发现，没钱的灵魂根本就没法硬气地站立。\n\n你学会了说：“要孝敬父母、让在乎的人过上幸福的日子”，可后才发现，没钱根本就做不了孝子，也给不了在乎的人幸福。\n\n\n# 奈\n\n看，你学了多少年的对错，可现如今才明白，现实只讲输赢。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"平海漫漫惜别离",frontmatter:{title:"平海漫漫惜别离",date:"2020-07-15T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0,author:"zhangpengjun,liuhongliang"},regularPath:"/views/essay/20200715.html",relativePath:"views/essay/20200715.md",key:"v-6b8bff0f",path:"/views/essay/20200715.html",headers:[{level:2,title:"近况",slug:"近况",normalizedTitle:"近况",charIndex:33},{level:2,title:"唏嘘",slug:"唏嘘",normalizedTitle:"唏嘘",charIndex:163},{level:2,title:"成熟",slug:"成熟",normalizedTitle:"成熟",charIndex:7}],excerpt:"<Boxx/>\n<p>人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。</p>\n",headersStr:"近况 唏嘘 成熟",content:"人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。\n\n\n# 近况\n\n许久不见，疫情影响，近来居家隔离中。\n\n短短几天，都不晓得外面世界的样子了，真想一下打破这股子宁静，出去狂吸几口子那干净而又充满了夏季香草味的雨后空气。\n\n奈。。\n\n人在家中坐，心游身不由，只能体验下 刘禹锡 的 “斯是陋室，惟吾德馨” 了。\n\n\n# 唏嘘\n\n这不，只剩无情的工作外加挚友聊天，又外加近期博文没更。\n\n故，社会你亮哥把珍藏多年的金句给了我才有了这篇合作，心想存下金句的同时也为友情留个纪念，如若下次相遇或待年老之后，也为吹嘘打闹作一番唏嘘😄，注意哈，云瀚语录要开始了：\n\n * 因为有你, 让我变成更优秀的自己\n\n * 我明白你的意思，你我之间不需要解释\n\n * 你许我一时温柔，我还你一个春秋\n\n * 柜子里的衣服在不断更迭，身边的朋友何尝不是\n\n * 生活已经让他们失望很多次了，不差这一次\n\n * 不做无谓之争，输了你赢了世界又如何\n\n * 苟且的生活中也有诗与远方\n\n * 没有希望就没有失望，普通的生活才是常态\n\n * 努力学习一项技能或许不能马上变现，但它却是你一辈子的财富\n\n * 地点还是那个地点，人群却不是那个人群了\n\n * 有些人虽然说了再见，却有可能再也不见了\n\n * 我又不喜欢你，凭什么要求我渣你\n\n * 我们一直拥有的，原本是自己早已拥有的\n\n * 曾经心塞的地方，如今向往的地方\n\n * 别傻了，生活是自己的，不是给别人看的\n\n * 知世故而不世故，愿你保持善良，一如既往\n\n * 何必极力追求终点，路上亦是风景\n\n * 不念过去，不畏将来，珍惜当下，好好生活\n\n * 幸福其实很简单，此处省略无数个字\n\n * 看这人群熙熙攘攘，却不知自己该去向何方\n\n * 如果你不够优秀，人脉是不值钱的，它不是追求来的，而是吸引来的。只有等价的交换，才能得到合理的帮助，虽然听起来很冷，但这是事实\n\n * 你看着别人遥不可及的技能，可能是别人生存的本能\n\n * 生活就像咖啡只有细品才能尝到苦中的甜\n\n * 不是它不够好，是你欣赏不了\n\n * 希望你能时刻感受到生活的美好，不留遗憾\n\n * 学最好的别人，做最好的自己\n\n夏季\n\n友情\n\n- img: https://images.pexels.com/photos/158827/field-corn-air-frisch-158827.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=450&w=260\n  link: https://images.pexels.com/photos/158827/field-corn-air-frisch-158827.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=450&w=260\n  name: 夏季\n- img: https://images.pexels.com/photos/853168/pexels-photo-853168.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=260\n  link: https://images.pexels.com/photos/853168/pexels-photo-853168.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=260\n  name: 友情\n\n\n1\n2\n3\n4\n5\n6\n\n\n寥寥几句，我相信每一句的背后肯定都是一个故事，记录着成长路上的点滴。\n\n\n# 成熟\n\n你看，其实每个人都有自己的成长感悟，可能是只言片句，可能是散水流文，也可能是心语言不语。\n\n人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。越成熟越发现，成年人的发泄方式，不再是改头像、换签名、发朋友圈，而是吹吹风，静一静，习惯性的等待自愈！\n\n生活离我们越来越近，朋友之间的联系不再那么频繁，恋人又即将占据我们的全部，愿兄弟们都能找到心满意足的生活，在这个繁杂的社会上，简单、快乐就好！\n\n还有啊，还有虽然平时不怎么联系，但偶尔会给你打个电话问候一下的朋友，真的，很幸运能在人生的路上遇到你们，亮，雷，坤，伟，大军，我想你们拉~~",normalizedContent:"人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。\n\n\n# 近况\n\n许久不见，疫情影响，近来居家隔离中。\n\n短短几天，都不晓得外面世界的样子了，真想一下打破这股子宁静，出去狂吸几口子那干净而又充满了夏季香草味的雨后空气。\n\n奈。。\n\n人在家中坐，心游身不由，只能体验下 刘禹锡 的 “斯是陋室，惟吾德馨” 了。\n\n\n# 唏嘘\n\n这不，只剩无情的工作外加挚友聊天，又外加近期博文没更。\n\n故，社会你亮哥把珍藏多年的金句给了我才有了这篇合作，心想存下金句的同时也为友情留个纪念，如若下次相遇或待年老之后，也为吹嘘打闹作一番唏嘘😄，注意哈，云瀚语录要开始了：\n\n * 因为有你, 让我变成更优秀的自己\n\n * 我明白你的意思，你我之间不需要解释\n\n * 你许我一时温柔，我还你一个春秋\n\n * 柜子里的衣服在不断更迭，身边的朋友何尝不是\n\n * 生活已经让他们失望很多次了，不差这一次\n\n * 不做无谓之争，输了你赢了世界又如何\n\n * 苟且的生活中也有诗与远方\n\n * 没有希望就没有失望，普通的生活才是常态\n\n * 努力学习一项技能或许不能马上变现，但它却是你一辈子的财富\n\n * 地点还是那个地点，人群却不是那个人群了\n\n * 有些人虽然说了再见，却有可能再也不见了\n\n * 我又不喜欢你，凭什么要求我渣你\n\n * 我们一直拥有的，原本是自己早已拥有的\n\n * 曾经心塞的地方，如今向往的地方\n\n * 别傻了，生活是自己的，不是给别人看的\n\n * 知世故而不世故，愿你保持善良，一如既往\n\n * 何必极力追求终点，路上亦是风景\n\n * 不念过去，不畏将来，珍惜当下，好好生活\n\n * 幸福其实很简单，此处省略无数个字\n\n * 看这人群熙熙攘攘，却不知自己该去向何方\n\n * 如果你不够优秀，人脉是不值钱的，它不是追求来的，而是吸引来的。只有等价的交换，才能得到合理的帮助，虽然听起来很冷，但这是事实\n\n * 你看着别人遥不可及的技能，可能是别人生存的本能\n\n * 生活就像咖啡只有细品才能尝到苦中的甜\n\n * 不是它不够好，是你欣赏不了\n\n * 希望你能时刻感受到生活的美好，不留遗憾\n\n * 学最好的别人，做最好的自己\n\n夏季\n\n友情\n\n- img: https://images.pexels.com/photos/158827/field-corn-air-frisch-158827.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=450&w=260\n  link: https://images.pexels.com/photos/158827/field-corn-air-frisch-158827.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=450&w=260\n  name: 夏季\n- img: https://images.pexels.com/photos/853168/pexels-photo-853168.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=260\n  link: https://images.pexels.com/photos/853168/pexels-photo-853168.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=260\n  name: 友情\n\n\n1\n2\n3\n4\n5\n6\n\n\n寥寥几句，我相信每一句的背后肯定都是一个故事，记录着成长路上的点滴。\n\n\n# 成熟\n\n你看，其实每个人都有自己的成长感悟，可能是只言片句，可能是散水流文，也可能是心语言不语。\n\n人生啊，渐渐的成熟，是青春的终点线，又是新路程的起始符。越成熟越发现，成年人的发泄方式，不再是改头像、换签名、发朋友圈，而是吹吹风，静一静，习惯性的等待自愈！\n\n生活离我们越来越近，朋友之间的联系不再那么频繁，恋人又即将占据我们的全部，愿兄弟们都能找到心满意足的生活，在这个繁杂的社会上，简单、快乐就好！\n\n还有啊，还有虽然平时不怎么联系，但偶尔会给你打个电话问候一下的朋友，真的，很幸运能在人生的路上遇到你们，亮，雷，坤，伟，大军，我想你们拉~~",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"好歌 200813 - 旅行",frontmatter:{title:"好歌 200813 - 旅行",date:"2020-08-13T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0},regularPath:"/views/essay/20200813.html",relativePath:"views/essay/20200813.md",key:"v-56da6351",path:"/views/essay/20200813.html",headers:[{level:3,title:"云热评：",slug:"云热评",normalizedTitle:"云热评：",charIndex:480}],excerpt:"<Boxx/>\n<p>这首歌是许巍为了纪念 2004 年初因车祸逝世的青岛朋友丁志强创作的 ，事实上这是一首很早就录音完成的歌，却是最后才有名字的 。</p>\n",headersStr:"云热评：",content:"这首歌是许巍为了纪念 2004 年初因车祸逝世的青岛朋友丁志强创作的 ，事实上这是一首很早就录音完成的歌，却是最后才有名字的 。\n\n借许巍老师的话来说，旅行是经历种种景色的地理意义上的跋涉，人生更是这样一场需要经历风雨的 “旅行” 。\n\n人生处处在旅行亦或修行，旅行的意义在于，它是一次成长的历练，强迫你独立生活，心智成长。\n\n旅行 - 许巍\n\n旅行 (《后会无期》电影插曲) - 许巍\n\n词：许巍\n曲：许巍\n编曲：许巍\n\n阵阵晚风吹动着松涛\n吹响这风铃声如天籁\n站在这城市的寂静处\n让一切喧嚣走远\n\n只有青山藏在白云间\n蝴蝶自由穿行在清涧\n看那晚霞盛开在天边\n有一群向西归鸟\n\n谁画出这天地 又画下我和你\n让我们的世界绚丽多彩\n谁让我们哭泣 又给我们惊喜\n让我们就这样相爱相遇\n总是要说再见 相聚又分离\n总是走在漫长的路上\n\n只有青山藏在白云间\n蝴蝶自由穿行在清涧\n看那晚霞盛开在天边\n有一群向西归鸟\n\n谁画出这天地 又画下我和你\n让我们的世界绚丽多彩\n谁让我们哭泣 又给我们惊喜\n让我们就这样相爱相遇\n总是要说再见 相聚又分离\n总是走在漫长的路上\n\n\n# 云热评：\n\n黑龙江大庆：有位自由诗人，他叫许巍；有位孤独诗人，他叫朴树；有位理想诗人，他叫李健；有位摇滚诗人，他叫郑钧\n\n2015 年 1 月 12 日\n\n趴着睡比较好：许巍的歌，不买个 SUV 在高速上面边听边开都算埋汰了啊～！！！！！！\n\n2014 年 12 月 28 日\n\n睦寰：变老的标志就是口味的改变，喜欢一些之前觉得土的东西，然后对生活麻木，过一天就一天。\n\n2014 年 11 月 26 日\n\n757351：去年我辞掉工作 八个月时间 16000 公里环骑游中国 我真不敢想像如果没有许巍这一路是怎么过来的 现在想想挺着他的歌陪着我走过高原 山区 平地 古镇 古迹 以及眼前看过的一切美景 真的感谢许巍\n\n2016 年 2 月 13 日\n\n为什么注册不上：上大学的时候有个新疆的同学，我们都问他，为什么跑这么远来西安上学，他说：西安有许巍，有郑钧，有城墙\n\n2015 年 10 月 9 日\n\n素颜嫣然：天亮是六点半到六点四十，十分钟之间。今天天空非常清亮，站在阳台能望得很远很远，甚至看见了天边久违的思念... 裹紧外套，煎荷包蛋叫孩子们吃饭！早安，今天！\n\n2014 年 12 月 4 日",normalizedContent:"这首歌是许巍为了纪念 2004 年初因车祸逝世的青岛朋友丁志强创作的 ，事实上这是一首很早就录音完成的歌，却是最后才有名字的 。\n\n借许巍老师的话来说，旅行是经历种种景色的地理意义上的跋涉，人生更是这样一场需要经历风雨的 “旅行” 。\n\n人生处处在旅行亦或修行，旅行的意义在于，它是一次成长的历练，强迫你独立生活，心智成长。\n\n旅行 - 许巍\n\n旅行 (《后会无期》电影插曲) - 许巍\n\n词：许巍\n曲：许巍\n编曲：许巍\n\n阵阵晚风吹动着松涛\n吹响这风铃声如天籁\n站在这城市的寂静处\n让一切喧嚣走远\n\n只有青山藏在白云间\n蝴蝶自由穿行在清涧\n看那晚霞盛开在天边\n有一群向西归鸟\n\n谁画出这天地 又画下我和你\n让我们的世界绚丽多彩\n谁让我们哭泣 又给我们惊喜\n让我们就这样相爱相遇\n总是要说再见 相聚又分离\n总是走在漫长的路上\n\n只有青山藏在白云间\n蝴蝶自由穿行在清涧\n看那晚霞盛开在天边\n有一群向西归鸟\n\n谁画出这天地 又画下我和你\n让我们的世界绚丽多彩\n谁让我们哭泣 又给我们惊喜\n让我们就这样相爱相遇\n总是要说再见 相聚又分离\n总是走在漫长的路上\n\n\n# 云热评：\n\n黑龙江大庆：有位自由诗人，他叫许巍；有位孤独诗人，他叫朴树；有位理想诗人，他叫李健；有位摇滚诗人，他叫郑钧\n\n2015 年 1 月 12 日\n\n趴着睡比较好：许巍的歌，不买个 suv 在高速上面边听边开都算埋汰了啊～！！！！！！\n\n2014 年 12 月 28 日\n\n睦寰：变老的标志就是口味的改变，喜欢一些之前觉得土的东西，然后对生活麻木，过一天就一天。\n\n2014 年 11 月 26 日\n\n757351：去年我辞掉工作 八个月时间 16000 公里环骑游中国 我真不敢想像如果没有许巍这一路是怎么过来的 现在想想挺着他的歌陪着我走过高原 山区 平地 古镇 古迹 以及眼前看过的一切美景 真的感谢许巍\n\n2016 年 2 月 13 日\n\n为什么注册不上：上大学的时候有个新疆的同学，我们都问他，为什么跑这么远来西安上学，他说：西安有许巍，有郑钧，有城墙\n\n2015 年 10 月 9 日\n\n素颜嫣然：天亮是六点半到六点四十，十分钟之间。今天天空非常清亮，站在阳台能望得很远很远，甚至看见了天边久违的思念... 裹紧外套，煎荷包蛋叫孩子们吃饭！早安，今天！\n\n2014 年 12 月 4 日",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"我爱你，爱的却不是那么尽如人意",frontmatter:{title:"我爱你，爱的却不是那么尽如人意",date:"2020-10-12T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],keys:["5201314"],isShowComments:!0},regularPath:"/views/essay/20201012.html",relativePath:"views/essay/20201012.md",key:"v-33ecb7b6",path:"/views/essay/20201012.html",headers:[{level:2,title:"爱之初体验",slug:"爱之初体验",normalizedTitle:"爱之初体验",charIndex:2},{level:2,title:"爱是你我，用心交织的生活",slug:"爱是你我-用心交织的生活",normalizedTitle:"爱是你我，用心交织的生活",charIndex:196},{level:2,title:"爱要向前进",slug:"爱要向前进",normalizedTitle:"爱要向前进",charIndex:901}],headersStr:"爱之初体验 爱是你我，用心交织的生活 爱要向前进",content:"# 爱之初体验\n\n亲爱的，开头请允许我引用昨晚曾说过的一句话：“我爱你，但爱的却不是那么尽如人意！”，因为这将是全文的重点，也是引领我之后成为一个“合格男友”的重要指示。\n\n首先说一下我自己吧，我这个人长久下来你可能也会发现最大的毛病就是不会与人交流（其他人我不管，单说你），不善表达，脑子里不记事，从小就一直被人说太老实太内向，这是与生俱来的毛病，想过改，但自己终究还是自己。\n\n\n\n\n# 爱是你我，用心交织的生活\n\n接下来说说正事\n\n生气，吵架，这是每对情侣都会发生的事情，结婚之后更是如此。\n\n确实，在恋爱方面我更是不善于表达，包括想的说的做的等一切，是真的不善于表达是脑子里都没有冒出那种想法一直是空白那种都傻傻的不知道说什么一直等对方开话题那种，你能理解的吧？\n\n不懂得关心不知道照顾对方的感受，尤其是经历过这么多事以后，越发认识到自己的错误，但是每每当问题发生时，仍不知道自己错在哪，这是最致命的，我是多想希望啊，多想希望能get到你那个点，然后知错能改善莫大焉！从你能感受到的地方开始呵护你关心你，完犊子了这个真的只是说说因为我实在不知道从哪方面下手，照我的理解就是明天多找你然后多陪你。\n\n有时候我说 我也不知道怎么办了是真的不知道怎么办了，因为第一我不敢瞎说第二我怕说错了又惹你生气，还有时候我怕我天天光说做不到而你到时候更失望，因为你不止一次说过类似的话：“你告诉我我很重要，你认定我了，你会好好对我，可你的表现却不是这样”，你知道吗，光是最后几个字，每看到一次就伤心一次，我真的很努力了，每每看到发“你的表现却不是这样”，我不知道是是你真的不满意还是我真的没做好，导致我也真的真的很内疚。\n\n而应对它我也一直说一直说我想变，变成那么一个大暖男好男友，或如你期望的那样（虽然我至今还不知道），主动关心你爱护你把你捧在手心里，这真的不是你的压力也不是你的要求，这些也真的是一个合格男友该做的事情，所以你不必自责！\n\n或许你也发现了，“真的”这两个字出现的次数太多太频繁了，说这么多一是表达出强调作用，二是“真的”想表达出我爱你，是从心里的爱，虽然不如你期望的爱！( T_T)\n\n\n# 爱要向前进\n\n\n\n我记得你也说过，缺点是每个人都有的，而爱情教会则是教会了彼此包容。以后的路还很长，生气吵架拌嘴是少不了的，但是不管发生什么，希望余生，有你陪我度过！",normalizedContent:"# 爱之初体验\n\n亲爱的，开头请允许我引用昨晚曾说过的一句话：“我爱你，但爱的却不是那么尽如人意！”，因为这将是全文的重点，也是引领我之后成为一个“合格男友”的重要指示。\n\n首先说一下我自己吧，我这个人长久下来你可能也会发现最大的毛病就是不会与人交流（其他人我不管，单说你），不善表达，脑子里不记事，从小就一直被人说太老实太内向，这是与生俱来的毛病，想过改，但自己终究还是自己。\n\n\n\n\n# 爱是你我，用心交织的生活\n\n接下来说说正事\n\n生气，吵架，这是每对情侣都会发生的事情，结婚之后更是如此。\n\n确实，在恋爱方面我更是不善于表达，包括想的说的做的等一切，是真的不善于表达是脑子里都没有冒出那种想法一直是空白那种都傻傻的不知道说什么一直等对方开话题那种，你能理解的吧？\n\n不懂得关心不知道照顾对方的感受，尤其是经历过这么多事以后，越发认识到自己的错误，但是每每当问题发生时，仍不知道自己错在哪，这是最致命的，我是多想希望啊，多想希望能get到你那个点，然后知错能改善莫大焉！从你能感受到的地方开始呵护你关心你，完犊子了这个真的只是说说因为我实在不知道从哪方面下手，照我的理解就是明天多找你然后多陪你。\n\n有时候我说 我也不知道怎么办了是真的不知道怎么办了，因为第一我不敢瞎说第二我怕说错了又惹你生气，还有时候我怕我天天光说做不到而你到时候更失望，因为你不止一次说过类似的话：“你告诉我我很重要，你认定我了，你会好好对我，可你的表现却不是这样”，你知道吗，光是最后几个字，每看到一次就伤心一次，我真的很努力了，每每看到发“你的表现却不是这样”，我不知道是是你真的不满意还是我真的没做好，导致我也真的真的很内疚。\n\n而应对它我也一直说一直说我想变，变成那么一个大暖男好男友，或如你期望的那样（虽然我至今还不知道），主动关心你爱护你把你捧在手心里，这真的不是你的压力也不是你的要求，这些也真的是一个合格男友该做的事情，所以你不必自责！\n\n或许你也发现了，“真的”这两个字出现的次数太多太频繁了，说这么多一是表达出强调作用，二是“真的”想表达出我爱你，是从心里的爱，虽然不如你期望的爱！( t_t)\n\n\n# 爱要向前进\n\n\n\n我记得你也说过，缺点是每个人都有的，而爱情教会则是教会了彼此包容。以后的路还很长，生气吵架拌嘴是少不了的，但是不管发生什么，希望余生，有你陪我度过！",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"项目管理 - 工作安排",frontmatter:{title:"项目管理 - 工作安排",date:"2020-11-19T00:00:00.000Z",sidebarDepth:0,tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0},regularPath:"/views/essay/20201119.html",relativePath:"views/essay/20201119.md",key:"v-3274a2d6",path:"/views/essay/20201119.html",headers:[{level:2,title:"任务",slug:"任务",normalizedTitle:"任务",charIndex:69},{level:2,title:"做法",slug:"做法",normalizedTitle:"做法",charIndex:261},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:269}],excerpt:"<Boxx/>\n<p>近期项目中遇到一些管理方面的问题，虽说目前技术开发占多一点，但工作中人际交往必不可少，人只有在心情愉悦的情况下才能更高效的工作。</p>\n",headersStr:"任务 做法 总结",content:"近期项目中遇到一些管理方面的问题，虽说目前技术开发占多一点，但工作中人际交往必不可少，人只有在心情愉悦的情况下才能更高效的工作。\n\n\n# 任务\n\n安排任务，首先是个人对工作量的总体把握程度。毕竟有的人效率高，能在很短时间解决很大问题；有的人效率低，就需要有人催一下，加把劲。\n\n但是切记不要催的次数过多了，你去催他，催的次数多了，他自然烦你，而你又操着这份心，本想着都是将这份工组做好，结果却是典型的双方吃力不讨好！\n\n作为下属，忙的时候压力肯定是有的，但也要体谅领导的难处和工作的需要，做到忙中能稳，稳中有戏。\n\n\n# 做法\n\n拿住性子总结了以下几点，上至领导下至下属皆可参考吧：\n\n 1. 任务拆分：将任务分割化，尽量提前到距目标期限前几天，以保证缓冲时间可以解决其他突发性问题。\n 2. 合理安排：将分割后的几个子任务再以天或时间段为单位进行拆分并合理安排，并不定时检查工作结果。\n 3. 协商处理：双方协商工作安排是否合理，有难度一定要提前说，保证每个人有自己的当天工作任务量，在完成任务的前提下其他时间自由支配，只需保证按时交工即可。\n 4. 勤换位思考，多保持沟通。沟通是非常重要重要重要的。\n\n\n# 总结\n\n\n\n相比较而言，这样安排：时间既合理，双方又省时省力！",normalizedContent:"近期项目中遇到一些管理方面的问题，虽说目前技术开发占多一点，但工作中人际交往必不可少，人只有在心情愉悦的情况下才能更高效的工作。\n\n\n# 任务\n\n安排任务，首先是个人对工作量的总体把握程度。毕竟有的人效率高，能在很短时间解决很大问题；有的人效率低，就需要有人催一下，加把劲。\n\n但是切记不要催的次数过多了，你去催他，催的次数多了，他自然烦你，而你又操着这份心，本想着都是将这份工组做好，结果却是典型的双方吃力不讨好！\n\n作为下属，忙的时候压力肯定是有的，但也要体谅领导的难处和工作的需要，做到忙中能稳，稳中有戏。\n\n\n# 做法\n\n拿住性子总结了以下几点，上至领导下至下属皆可参考吧：\n\n 1. 任务拆分：将任务分割化，尽量提前到距目标期限前几天，以保证缓冲时间可以解决其他突发性问题。\n 2. 合理安排：将分割后的几个子任务再以天或时间段为单位进行拆分并合理安排，并不定时检查工作结果。\n 3. 协商处理：双方协商工作安排是否合理，有难度一定要提前说，保证每个人有自己的当天工作任务量，在完成任务的前提下其他时间自由支配，只需保证按时交工即可。\n 4. 勤换位思考，多保持沟通。沟通是非常重要重要重要的。\n\n\n# 总结\n\n\n\n相比较而言，这样安排：时间既合理，双方又省时省力！",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"TCP,UDP,HTTP的认识",frontmatter:{title:"TCP,UDP,HTTP的认识",date:"2018-01-16T00:00:00.000Z",tags:["网络协议"],categories:["前端 Front-end","规范 Standard"],isShowComments:!1},regularPath:"/views/frontend/TCP&UDP.html",relativePath:"views/frontend/TCP&UDP.md",key:"v-b517ba06",path:"/views/frontend/TCP&UDP.html",headers:[{level:2,title:"TCP",slug:"tcp",normalizedTitle:"tcp",charIndex:0},{level:3,title:"TCP三次握手 ★",slug:"tcp三次握手-★",normalizedTitle:"tcp三次握手 ★",charIndex:70},{level:3,title:"为什么TCP客户端最后还要发送一次确认呢？",slug:"为什么tcp客户端最后还要发送一次确认呢",normalizedTitle:"为什么tcp客户端最后还要发送一次确认呢？",charIndex:85},{level:2,title:"UDP",slug:"udp",normalizedTitle:"udp",charIndex:4},{level:2,title:"TCP和UDP区别",slug:"tcp和udp区别",normalizedTitle:"tcp和udp区别",charIndex:117},{level:2,title:"TCP与UDP的适用场景",slug:"tcp与udp的适用场景",normalizedTitle:"tcp与udp的适用场景",charIndex:130},{level:2,title:"WebSocket",slug:"websocket",normalizedTitle:"websocket",charIndex:146},{level:2,title:"HTTP",slug:"http",normalizedTitle:"http",charIndex:32},{level:3,title:"HTTP 协议格式",slug:"http-协议格式",normalizedTitle:"http 协议格式",charIndex:169},{level:3,title:"HTTP Method",slug:"http-method",normalizedTitle:"http method",charIndex:184},{level:3,title:"HTTP Status code和Status text",slug:"http-status-code和status-text",normalizedTitle:"http status code和status text",charIndex:201},{level:3,title:"HTTP Head (HTTP 头)",slug:"http-head-http-头",normalizedTitle:"http head (http 头)",charIndex:235},{level:3,title:"HTTP Request Body",slug:"http-request-body",normalizedTitle:"http request body",charIndex:259},{level:2,title:"HTTPS",slug:"https",normalizedTitle:"https",charIndex:280},{level:2,title:"HTTP2",slug:"http2",normalizedTitle:"http2",charIndex:289}],excerpt:"<Boxx/>\n<p>TCP/UDP协议是<strong>传输层协议</strong>，主要解决数据如何在网络中传输，而HTTP是<strong>应用层协议</strong>，主要解决如何包装数据。</p>\n",headersStr:"TCP TCP三次握手 ★ 为什么TCP客户端最后还要发送一次确认呢？ UDP TCP和UDP区别 TCP与UDP的适用场景 WebSocket HTTP HTTP 协议格式 HTTP Method HTTP Status code和Status text HTTP Head (HTTP 头) HTTP Request Body HTTPS HTTP2",content:"TCP/UDP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。\n\n\n\n * TCP\n   * TCP三次握手 ★\n   * 为什么TCP客户端最后还要发送一次确认呢？\n * UDP\n * TCP和UDP区别\n * TCP与UDP的适用场景\n * WebSocket\n * HTTP\n   * HTTP 协议格式\n   * HTTP Method\n   * HTTP Status code和Status text\n   * HTTP Head (HTTP 头)\n   * HTTP Request Body\n * HTTPS\n * HTTP2\n\n\n\n简单理解： “IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的卡车，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。\n\n当然还有像SOCKET这种抽象层：TCP/IP网络的API。Socket（相当于码头/车站）是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n\nTCP提供有保证的数据传输，UDP不提供，而HTTP就是基于TCP实现的应用层协议。\n\n\n# TCP\n\nTCP是一种面向连接的、可靠的传输层协议；\n\nTCP协议建立在不可靠的网络层 IP 协议之上，IP协议并不能提供任何可靠性机制，TCP的可靠性完全由自己实现；\n\nTCP采用的最基本的可靠性技术是：确认与超时重传机制、流量控制机制（别发的太快已保证对方能收到）；\n\n\n# TCP三次握手 ★\n\n* 第一次握手：客户端向服务器发送请求报文段，其中同步位SYN=1，序号SEQ=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；\n\n* 第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位SYN=1，确认号ACK=x+1，序号SEQ=y；\n\n* 第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ACK(ack=y+1)，进而完成三次握手。\n\n\n# 为什么TCP客户端最后还要发送一次确认呢？\n\n一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n# UDP\n\nUDP是一种无连接的、不可靠的传输层协议； 提供了有限的差错检验功能；目的是希望以最小的开销来达到网络环境中的进程通信目的。\n\nUDP（用户数据报协议）- 类似发短信：\n\n 1. 只管发送，不确认对方是否接收到\n 2. 将数据及源和目的封装成数据包中，不需要建立连接\n 3. 每个数据包的大小限制在64K之内\n 4. 因为无需连接，因此是不可靠协议\n 5. 不需要建立连接，速度快\n\n随着现代网速的提升，UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP ， 如网页浏览、流媒体、实时游戏、物联网。\n\n\n# TCP和UDP区别\n\nTCP：\n\n面向连接、传输可靠（保证数据正确性）、有序（保证数据顺序）、传输大量数据（流模式）、速度慢、对系统资源的要求多，程序结构较复杂， 每一条TCP连接只能是点到点的， TCP首部开销20字节。\n\nUDP：\n\n面向非连接 、传输不可靠（可能丢包）、无序、传输少量数据（数据报模式）、速度快，对系统资源的要求少，程序结构较简单 ， UDP支持一对一，一对多，多对一和多对多的交互通信， UDP的首部开销小，只有8个字节。\n\n\n# TCP与UDP的适用场景\n\n 1. TCP用于在传输层有必要实现可靠传输的情况。\n\n 2. UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。\n    \n    举一个通过 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失就会被重发，这样就会导致无法流畅地传输通话人的声音。而采用UDP，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。\n\n\n# WebSocket\n\n可以把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。\n\nHTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。\n\nWebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\n\n# HTTP\n\nHTTP 标准由 IETF 组织制定。\n\nHTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 模式。这个模式决定了通讯必定由浏览器端首先发起。\n\nHTTP 是存粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。\n\n\n# HTTP 协议格式\n\n\n\n\n# HTTP Method\n\n * GET：浏览器通过地址栏访问页面都是 GET 方法。\n * POST：表单提交产生 POST 方法。\n * HEAD：HEAD 跟 GET 类似，只返回请求头，多数由 JavaScript 发起。\n * PUT：添加资源，语义上的约束。\n * DELETE ：删除资源，语义上的约束。\n * CONNECT：CONNECT 多用于 HTTPS 和 WebSocket。\n * OPTIONS：一般用于调试，多数线上服务都不支持。\n * TRACE：一般用于调试，多数线上服务都不支持。\n\n\n# HTTP Status code和Status text\n\n * 1xx：临时回应，表示客户端请继续，被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓\n\n * 2xx：请求成功\n   \n   * 200：请求成功\n\n * 3xx：表示请求的目标由变化，希望客户端进一步处理\n   \n   * 301&302：当前资源已经被转移，永久性与临时性的转移。 301 更接近一种报错，提示客户端下次别来了。\n   * 304：客户端本地已经由缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。\n\n * 4xx：客户端请求错误\n   \n   * 403：无权限\n   * 404：表示请求的页面不存在\n\n * 5xx：服务端请求错误\n   \n   * 500：服务端错误\n   * 503：服务端暂时性错误，可以一会再试\n\n\n# HTTP Head (HTTP 头)\n\n> 可以看作键值对。\n\nRequest Header\n\nREQUEST HEADER      规定\nAccept              浏览器端接受的格式\nAccept-Encoding     浏览器端接受的编码方式\nAccpet-Language     浏览器端接受的语言，用于服务器端判断多语言\nCache-Control       控制缓存的时效性\nConnection          连接方式，如果是 keep-alive，且服务器端支持，则会复用连接\nHost                HTTP访问使用的域名\nIf-Modified-Since   上次访问时的更改时间，如果服务器认为此时间后自己没有更新，则会给出 304 响应\nIf-None-Match       上次访问时使用的 E-Tag，通常是页面的信息摘要，这个比更改时间更准确一些\nUser-Agent          客户端标识\nCookie              客户端存储的 Cookie 字符串\n\nResponse Header\n\nRESPONSE HEADER    规定\nCache-Control      缓存控制，用于通知各级缓存保存的时间，例如 max-age=0 表示不要缓存\nConnection         连接类型，Keep-Alive表示复用连接\nContent-Encoding   内容编码方式，通常是gzip\nContent-Length     内容的长度，有利于浏览器判断内容是否已经结束\nContent-Type       内容类型，所有请求网页的都是 text/html\nDate               当前的服务器日期\nETag               页面的信息摘要，用于判断是否需要重新到服务器端取回页面\nExpires            过期时间，用于判断下次请求是否需要到服务器端取回页面\nKeep-Alive         保持连接不断时需要的一些信息，如 timeout=5，max=100\nLast-Modified      页面上次修改的时间\nServer             服务器软件的类型\nSet-Cookie         设置 cookie 可以存在多个\nVia                服务器端的请求链路，对一些调试场景至关重要的一个头\n\n\n# HTTP Request Body\n\n> HTTP 请求的 body 主要用于提交表单场景。比较自由，服务端认可即可。\n\n常见的 body 格式：\n\n * application/json\n * application/x-www-form-urlencoded\n * multipart/form-data\n * text/xml\n\n使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 数据格式，当由文件上传时，则使用 multipart/form-data。\n\n\n# HTTPS\n\n> 在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。\n\nHTTPS 作用：\n\n * 确定请求的目标服务端身份\n * 保证传输的数据不会被网络中间节点窃听或者篡改\n\nHTTPS 是使用加密通道来传输 HTTP 的内容。 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。\n\n\n# HTTP2\n\n> HTTP 2 是 HTTP 1.1 的升级版本。\n\nHTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接推送。\n\n服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存中，可以避免客户端请求顺序带来的并行度不高，从而导致性能问题。\n\nTCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。",normalizedContent:"tcp/udp协议是传输层协议，主要解决数据如何在网络中传输，而http是应用层协议，主要解决如何包装数据。\n\n\n\n * tcp\n   * tcp三次握手 ★\n   * 为什么tcp客户端最后还要发送一次确认呢？\n * udp\n * tcp和udp区别\n * tcp与udp的适用场景\n * websocket\n * http\n   * http 协议格式\n   * http method\n   * http status code和status text\n   * http head (http 头)\n   * http request body\n * https\n * http2\n\n\n\n简单理解： “ip”代表网际协议，tcp和udp使用该协议从一个网络传送数据包到另一个网络。把ip想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。tcp和udp是高速公路上的卡车，它们携带的货物就是像http，文件传输协议ftp这样的协议等。\n\n当然还有像socket这种抽象层：tcp/ip网络的api。socket（相当于码头/车站）是应用层与tcp/ip协议族通信的中间软件抽象层，它是一组接口。socket是在应用层和传输层之间的一个抽象层，它把tcp/ip层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n\ntcp提供有保证的数据传输，udp不提供，而http就是基于tcp实现的应用层协议。\n\n\n# tcp\n\ntcp是一种面向连接的、可靠的传输层协议；\n\ntcp协议建立在不可靠的网络层 ip 协议之上，ip协议并不能提供任何可靠性机制，tcp的可靠性完全由自己实现；\n\ntcp采用的最基本的可靠性技术是：确认与超时重传机制、流量控制机制（别发的太快已保证对方能收到）；\n\n\n# tcp三次握手 ★\n\n* 第一次握手：客户端向服务器发送请求报文段，其中同步位syn=1，序号seq=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；\n\n* 第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位syn=1，确认号ack=x+1，序号seq=y；\n\n* 第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ack(ack=y+1)，进而完成三次握手。\n\n\n# 为什么tcp客户端最后还要发送一次确认呢？\n\n一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于tcp的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n\n\n# udp\n\nudp是一种无连接的、不可靠的传输层协议； 提供了有限的差错检验功能；目的是希望以最小的开销来达到网络环境中的进程通信目的。\n\nudp（用户数据报协议）- 类似发短信：\n\n 1. 只管发送，不确认对方是否接收到\n 2. 将数据及源和目的封装成数据包中，不需要建立连接\n 3. 每个数据包的大小限制在64k之内\n 4. 因为无需连接，因此是不可靠协议\n 5. 不需要建立连接，速度快\n\n随着现代网速的提升，udp协议以其简单、传输快的优势，在越来越多场景下取代了tcp ， 如网页浏览、流媒体、实时游戏、物联网。\n\n\n# tcp和udp区别\n\ntcp：\n\n面向连接、传输可靠（保证数据正确性）、有序（保证数据顺序）、传输大量数据（流模式）、速度慢、对系统资源的要求多，程序结构较复杂， 每一条tcp连接只能是点到点的， tcp首部开销20字节。\n\nudp：\n\n面向非连接 、传输不可靠（可能丢包）、无序、传输少量数据（数据报模式）、速度快，对系统资源的要求少，程序结构较简单 ， udp支持一对一，一对多，多对一和多对多的交互通信， udp的首部开销小，只有8个字节。\n\n\n# tcp与udp的适用场景\n\n 1. tcp用于在传输层有必要实现可靠传输的情况。\n\n 2. udp主要用于那些对高速传输和实时性有较高要求的通信或广播通信。\n    \n    举一个通过 ip 电话进行通话的例子。如果使用 tcp，数据在传送途中如果丢失就会被重发，这样就会导致无法流畅地传输通话人的声音。而采用udp，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。\n\n\n# websocket\n\n可以把websocket想象成http(应用层)，http和socket什么关系，websocket和socket就是什么关系。\n\nhttp 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。\n\nwebsocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\n\n# http\n\nhttp 标准由 ietf 组织制定。\n\nhttp 协议是基于 tcp 协议出现的，对 tcp 协议来说，tcp 协议是一条双向的通讯通道，http 在 tcp 的基础上，规定了 request-response 模式。这个模式决定了通讯必定由浏览器端首先发起。\n\nhttp 是存粹的文本协议，它是规定了使用 tcp 协议来传输文本格式的一个应用层协议。\n\n\n# http 协议格式\n\n\n\n\n# http method\n\n * get：浏览器通过地址栏访问页面都是 get 方法。\n * post：表单提交产生 post 方法。\n * head：head 跟 get 类似，只返回请求头，多数由 javascript 发起。\n * put：添加资源，语义上的约束。\n * delete ：删除资源，语义上的约束。\n * connect：connect 多用于 https 和 websocket。\n * options：一般用于调试，多数线上服务都不支持。\n * trace：一般用于调试，多数线上服务都不支持。\n\n\n# http status code和status text\n\n * 1xx：临时回应，表示客户端请继续，被浏览器 http 库直接处理掉了，不会让上层应用知晓\n\n * 2xx：请求成功\n   \n   * 200：请求成功\n\n * 3xx：表示请求的目标由变化，希望客户端进一步处理\n   \n   * 301&302：当前资源已经被转移，永久性与临时性的转移。 301 更接近一种报错，提示客户端下次别来了。\n   * 304：客户端本地已经由缓存的版本，并且在 request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。\n\n * 4xx：客户端请求错误\n   \n   * 403：无权限\n   * 404：表示请求的页面不存在\n\n * 5xx：服务端请求错误\n   \n   * 500：服务端错误\n   * 503：服务端暂时性错误，可以一会再试\n\n\n# http head (http 头)\n\n> 可以看作键值对。\n\nrequest header\n\nrequest header      规定\naccept              浏览器端接受的格式\naccept-encoding     浏览器端接受的编码方式\naccpet-language     浏览器端接受的语言，用于服务器端判断多语言\ncache-control       控制缓存的时效性\nconnection          连接方式，如果是 keep-alive，且服务器端支持，则会复用连接\nhost                http访问使用的域名\nif-modified-since   上次访问时的更改时间，如果服务器认为此时间后自己没有更新，则会给出 304 响应\nif-none-match       上次访问时使用的 e-tag，通常是页面的信息摘要，这个比更改时间更准确一些\nuser-agent          客户端标识\ncookie              客户端存储的 cookie 字符串\n\nresponse header\n\nresponse header    规定\ncache-control      缓存控制，用于通知各级缓存保存的时间，例如 max-age=0 表示不要缓存\nconnection         连接类型，keep-alive表示复用连接\ncontent-encoding   内容编码方式，通常是gzip\ncontent-length     内容的长度，有利于浏览器判断内容是否已经结束\ncontent-type       内容类型，所有请求网页的都是 text/html\ndate               当前的服务器日期\netag               页面的信息摘要，用于判断是否需要重新到服务器端取回页面\nexpires            过期时间，用于判断下次请求是否需要到服务器端取回页面\nkeep-alive         保持连接不断时需要的一些信息，如 timeout=5，max=100\nlast-modified      页面上次修改的时间\nserver             服务器软件的类型\nset-cookie         设置 cookie 可以存在多个\nvia                服务器端的请求链路，对一些调试场景至关重要的一个头\n\n\n# http request body\n\n> http 请求的 body 主要用于提交表单场景。比较自由，服务端认可即可。\n\n常见的 body 格式：\n\n * application/json\n * application/x-www-form-urlencoded\n * multipart/form-data\n * text/xml\n\n使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 数据格式，当由文件上传时，则使用 multipart/form-data。\n\n\n# https\n\n> 在 http 协议的基础上，https 和 http2 规定了更复杂的内容，但是它基本保持了 http 的设计思想，即：使用上的 request-response 模式。\n\nhttps 作用：\n\n * 确定请求的目标服务端身份\n * 保证传输的数据不会被网络中间节点窃听或者篡改\n\nhttps 是使用加密通道来传输 http 的内容。 https 首先与服务端建立一条 tls 加密通道。tls 构建于 tcp 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，https 跟 http 没有任何区别。\n\n\n# http2\n\n> http 2 是 http 1.1 的升级版本。\n\nhttp 2.0 最大的改进有两点，一是支持服务端推送，二是支持 tcp 连接推送。\n\n服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存中，可以避免客户端请求顺序带来的并行度不高，从而导致性能问题。\n\ntcp 连接复用，则使用同一个 tcp 连接来传输多个 http 请求，避免了 tcp 连接建立时的三次握手开销，和初建 tcp 连接时传输窗口小的问题。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"JavaScript中JSON对象和串的互转",frontmatter:{title:"JavaScript中JSON对象和串的互转",date:"2019-03-23T00:00:00.000Z",tags:["JavaScript","json"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/js-json.html",relativePath:"views/frontend/js-json.md",key:"v-3419df1d",path:"/views/frontend/js-json.html",headers:[{level:2,title:"JavaScript中的JSON",slug:"javascript中的json",normalizedTitle:"javascript中的json",charIndex:3},{level:2,title:"JSON互转的第二种用法",slug:"json互转的第二种用法",normalizedTitle:"json互转的第二种用法",charIndex:23},{level:2,title:"写给自己的js规范",slug:"写给自己的js规范",normalizedTitle:"写给自己的js规范",charIndex:39},{level:4,title:"在js中书写代码给自己定的规范：（或者objet转string之前）",slug:"在js中书写代码给自己定的规范-或者objet转string之前",normalizedTitle:"在js中书写代码给自己定的规范：（或者objet转string之前）",charIndex:1444},{level:4,title:"在js中书写代码给自己定的规范：（或者string转object之前）",slug:"在js中书写代码给自己定的规范-或者string转object之前",normalizedTitle:"在js中书写代码给自己定的规范：（或者string转object之前）",charIndex:1618},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:52}],headersStr:"JavaScript中的JSON JSON互转的第二种用法 写给自己的js规范 在js中书写代码给自己定的规范：（或者objet转string之前） 在js中书写代码给自己定的规范：（或者string转object之前） 其它",content:' * JavaScript中的JSON\n * JSON互转的第二种用法\n * 写给自己的js规范\n * 其它\n\n\n\n\n# JavaScript中的JSON\n\n> 在实际工作中，我么最常用的就是简单的 JSON.parse(str) 和 JSON.stringify (obj) 做JSON对象和字符串之间的相互转换\n\n * JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象\n * JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串\n\n> 上面那种JSON.parse(string)用法只能转普通对象，当对象中有function事件的时候会自动过滤掉。如下：\n\nvar json={\n  name:\'json\',\n  getName:function(){\n     return this.name;   \n  }\n}\n\nconsole.log(JSON.stringify(json));\n//"{"name":"json"}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 这就坑了，因为需要，必须要得把function也转了才行，怎么办呢？其实大家都没注意到 JSON.stringify还有些参数\n\n\n# JSON互转的第二种用法\n\n * 从Object转为String\n\n  var json={\n    name:\'json\',\n    getName:function(){\n       return this.name;   \n    }\n  }\n  \n  var s=JSON.stringify(json, function(key, val) {\n    if (typeof val === \'function\') {\n      return val + \'\';\n    }\n    return val;\n  });\n  \n  console.log(s);\n  //"{"name":"json","getName":"function (){\\n     return this.name;   \\n  }"}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意转换完成之后记得把 \\n 全部删掉，不然从string再转为object的时候会报错，没错，就是这么坑。\n\n不信的话可以去这么网址试一下：传送们\n\n * 从String转为Object\n\nvar s=`{"name":"json","getName":"function (){     return this.name;     }"}`;\n\nvar o = JSON.parse(s,function(k,v){\n  if(v.indexOf&&v.indexOf(\'function\')>-1){\n     return eval("(function(){return "+v+" })()")\n  }\n  return v;\n});\n\nconsole.log(o);//就是原对象啦\n//{ name: "json", getName: function (){     return this.name;     } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 写给自己的js规范\n\n# 在js中书写代码给自己定的规范：（或者objet转string之前）\n\n 1. 在js中能用的话 一定要用单引号\n 2. 在使用 if(){}else{} 的时候，一定不要省略大括号\n 3. js中一段代码结束后一定要加 ;（虽然在js中不加不会报错，把对象转为串的时候也不会报错，但是json从串转为对象的时候就会报错了，亲身经历啊！！）\n\n# 在js中书写代码给自己定的规范：（或者string转object之前）\n\n 1. 把所有的 \\r\\n 删掉\n 2. 把所有的 \\t 删掉\n 3. 把所有的 function 中的注释都删掉\n 4. 注意有没有代码不规范的地方（如上规范）\n\n\n# 其它\n\n * JSON转换简单使用\n * JSON转换的第二个参数\n * 在线写js尝试JSON转换',normalizedContent:' * javascript中的json\n * json互转的第二种用法\n * 写给自己的js规范\n * 其它\n\n\n\n\n# javascript中的json\n\n> 在实际工作中，我么最常用的就是简单的 json.parse(str) 和 json.stringify (obj) 做json对象和字符串之间的相互转换\n\n * json.parse(string) ：接受一个 json 字符串并将其转换成一个 javascript 对象\n * json.stringify(obj) ：接受一个 javascript 对象并将其转换为一个 json 字符串\n\n> 上面那种json.parse(string)用法只能转普通对象，当对象中有function事件的时候会自动过滤掉。如下：\n\nvar json={\n  name:\'json\',\n  getname:function(){\n     return this.name;   \n  }\n}\n\nconsole.log(json.stringify(json));\n//"{"name":"json"}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 这就坑了，因为需要，必须要得把function也转了才行，怎么办呢？其实大家都没注意到 json.stringify还有些参数\n\n\n# json互转的第二种用法\n\n * 从object转为string\n\n  var json={\n    name:\'json\',\n    getname:function(){\n       return this.name;   \n    }\n  }\n  \n  var s=json.stringify(json, function(key, val) {\n    if (typeof val === \'function\') {\n      return val + \'\';\n    }\n    return val;\n  });\n  \n  console.log(s);\n  //"{"name":"json","getname":"function (){\\n     return this.name;   \\n  }"}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n注意转换完成之后记得把 \\n 全部删掉，不然从string再转为object的时候会报错，没错，就是这么坑。\n\n不信的话可以去这么网址试一下：传送们\n\n * 从string转为object\n\nvar s=`{"name":"json","getname":"function (){     return this.name;     }"}`;\n\nvar o = json.parse(s,function(k,v){\n  if(v.indexof&&v.indexof(\'function\')>-1){\n     return eval("(function(){return "+v+" })()")\n  }\n  return v;\n});\n\nconsole.log(o);//就是原对象啦\n//{ name: "json", getname: function (){     return this.name;     } }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 写给自己的js规范\n\n# 在js中书写代码给自己定的规范：（或者objet转string之前）\n\n 1. 在js中能用的话 一定要用单引号\n 2. 在使用 if(){}else{} 的时候，一定不要省略大括号\n 3. js中一段代码结束后一定要加 ;（虽然在js中不加不会报错，把对象转为串的时候也不会报错，但是json从串转为对象的时候就会报错了，亲身经历啊！！）\n\n# 在js中书写代码给自己定的规范：（或者string转object之前）\n\n 1. 把所有的 \\r\\n 删掉\n 2. 把所有的 \\t 删掉\n 3. 把所有的 function 中的注释都删掉\n 4. 注意有没有代码不规范的地方（如上规范）\n\n\n# 其它\n\n * json转换简单使用\n * json转换的第二个参数\n * 在线写js尝试json转换',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"vuepress-theme-reco主题开发",frontmatter:{title:"vuepress-theme-reco主题开发",date:"2019-11-14T16:41:12.000Z",sidebar:!0,sidebarDepth:5,tags:["vuepress"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/reco-info.html",relativePath:"views/frontend/reco-info.md",key:"v-28ad82bd",path:"/views/frontend/reco-info.html",headers:[{level:2,title:"序言",slug:"序言",normalizedTitle:"序言",charIndex:3},{level:2,title:"本地环境搭建",slug:"本地环境搭建",normalizedTitle:"本地环境搭建",charIndex:9},{level:3,title:"1. 去 theme-example ，找个合心意的博客 clone",slug:"_1-去-theme-example-找个合心意的博客-clone",normalizedTitle:"1. 去 theme-example ，找个合心意的博客 clone",charIndex:21},{level:3,title:"2. 把项目下载之后，修改 package.json",slug:"_2-把项目下载之后-修改-package-json",normalizedTitle:"2. 把项目下载之后，修改 package.json",charIndex:61},{level:3,title:"3. 更换主题为本地",slug:"_3-更换主题为本地",normalizedTitle:"3. 更换主题为本地",charIndex:93},{level:2,title:"可能遇到的问题",slug:"可能遇到的问题",normalizedTitle:"可能遇到的问题",charIndex:107},{level:3,title:"1. 插件解析失败问题",slug:"_1-插件解析失败问题",normalizedTitle:"1. 插件解析失败问题",charIndex:120}],headersStr:"序言 本地环境搭建 1. 去 theme-example ，找个合心意的博客 clone 2. 把项目下载之后，修改 package.json 3. 更换主题为本地 可能遇到的问题 1. 插件解析失败问题",content:' * 序言\n * 本地环境搭建\n   * 1. 去 theme-example ，找个合心意的博客 clone\n   * 2. 把项目下载之后，修改 package.json\n   * 3. 更换主题为本地\n * 可能遇到的问题\n   * 1. 插件解析失败问题\n\n\n\n\n# 序言\n\n如果你开始或已经使用 vuepress-theme-reco 搭建了属于自己的个人博客的时候，那么恭喜你，你已经成为我们的一员了。 那么我想以下一定是需要了解的：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n\n# 本地环境搭建\n\n\n# 1. 去 theme-example ，找个合心意的博客 clone\n\n * 我就以我的下载我的为例：git clone https://github.com/zpj80231/znote.git\n\n\n# 2. 把项目下载之后，修改 package.json\n\n{\n    "scripts": {\n        "docs:dev": "vuepress dev docs",\n        "docs:build": "vuepress build docs",\n        "deploy": "bash deploy.sh"\n    },\n    "devDependencies": {\n        "vuepress": "^1.2.0",\n        "vuepress-theme-reco": "^1.1.2-alpha.2"        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 然后在此目录下打开命令窗口执行：npm install（提前安装好node.js环境）\n\n\n# 3. 更换主题为本地\n\n * 打开git，克隆：git clone https://github.com/vuepress-reco/vuepress-theme-reco.git\n   \n   把下载下来的文件夹更名为 theme，粘贴至 .vuepress下即可。\n\n * 将主题文件放到本地开发环境\n\n##复制node_modules/vuepress-theme-reco 文件夹\n##粘贴至.vuepress/ 下并更名为theme\nDev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles // 样式\n│   │    │   ├── util // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopModule.js // 依赖注入\n│   │    │   ├── package.json // 主题依赖\n│   │    │   ├── README.md // 主题说明\n│   │    └── config.js\n│   ├── FAQ     // 求索模块\n│   ├── Store   // 仓库模块\n│   ├── Thought // 随笔模块\n│   └── README.md   // 博客首页\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n * 运行预览\n   \n   执行命令：vuepress dev docs\n   \n   当看到控制台输出：tip Apply theme located at ... 并正常启动，则表示本地环境搭建成功。\n   \n   在浏览器地址输入：http://localhost:8080即可看到界面：\n   \n   \n\n * 如果想直接使用 .html文件的话将 .html文件放在 .vuepress/public 目录下即可（需自己配置引用路径）。\n\n\n# 可能遇到的问题\n\n\n# 1. 插件解析失败问题\n\n> 有这几个解决办法，就是无法解析node_modules依赖关系\n\n * 根目录下安装一下vuepress-theme-reco这个依赖\n * 最直接的就是在主题目录执行一下npm install\n * 或许你删除node_modules，重新安装一下依赖也有可能解决\n * 如以上三步都不行的话，以这个命令npm run docs:dev启动项目，或者联系我',normalizedContent:' * 序言\n * 本地环境搭建\n   * 1. 去 theme-example ，找个合心意的博客 clone\n   * 2. 把项目下载之后，修改 package.json\n   * 3. 更换主题为本地\n * 可能遇到的问题\n   * 1. 插件解析失败问题\n\n\n\n\n# 序言\n\n如果你开始或已经使用 vuepress-theme-reco 搭建了属于自己的个人博客的时候，那么恭喜你，你已经成为我们的一员了。 那么我想以下一定是需要了解的：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n\n# 本地环境搭建\n\n\n# 1. 去 theme-example ，找个合心意的博客 clone\n\n * 我就以我的下载我的为例：git clone https://github.com/zpj80231/znote.git\n\n\n# 2. 把项目下载之后，修改 package.json\n\n{\n    "scripts": {\n        "docs:dev": "vuepress dev docs",\n        "docs:build": "vuepress build docs",\n        "deploy": "bash deploy.sh"\n    },\n    "devdependencies": {\n        "vuepress": "^1.2.0",\n        "vuepress-theme-reco": "^1.1.2-alpha.2"        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 然后在此目录下打开命令窗口执行：npm install（提前安装好node.js环境）\n\n\n# 3. 更换主题为本地\n\n * 打开git，克隆：git clone https://github.com/vuepress-reco/vuepress-theme-reco.git\n   \n   把下载下来的文件夹更名为 theme，粘贴至 .vuepress下即可。\n\n * 将主题文件放到本地开发环境\n\n##复制node_modules/vuepress-theme-reco 文件夹\n##粘贴至.vuepress/ 下并更名为theme\ndev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles // 样式\n│   │    │   ├── util // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopmodule.js // 依赖注入\n│   │    │   ├── package.json // 主题依赖\n│   │    │   ├── readme.md // 主题说明\n│   │    └── config.js\n│   ├── faq     // 求索模块\n│   ├── store   // 仓库模块\n│   ├── thought // 随笔模块\n│   └── readme.md   // 博客首页\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n * 运行预览\n   \n   执行命令：vuepress dev docs\n   \n   当看到控制台输出：tip apply theme located at ... 并正常启动，则表示本地环境搭建成功。\n   \n   在浏览器地址输入：http://localhost:8080即可看到界面：\n   \n   \n\n * 如果想直接使用 .html文件的话将 .html文件放在 .vuepress/public 目录下即可（需自己配置引用路径）。\n\n\n# 可能遇到的问题\n\n\n# 1. 插件解析失败问题\n\n> 有这几个解决办法，就是无法解析node_modules依赖关系\n\n * 根目录下安装一下vuepress-theme-reco这个依赖\n * 最直接的就是在主题目录执行一下npm install\n * 或许你删除node_modules，重新安装一下依赖也有可能解决\n * 如以上三步都不行的话，以这个命令npm run docs:dev启动项目，或者联系我',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"viaStart",frontmatter:{title:"viaStart",date:"2018-04-23T15:31:26.000Z",tags:["Via"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/viaStart.html",relativePath:"views/frontend/viaStart.md",key:"v-fd18a65e",path:"/views/frontend/viaStart.html",headers:[{level:2,title:"via或其他浏览器的必选首页",slug:"via或其他浏览器的必选首页",normalizedTitle:"via或其他浏览器的必选首页",charIndex:3},{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:21},{level:2,title:"如何使用",slug:"如何使用",normalizedTitle:"如何使用",charIndex:27},{level:2,title:"首页如下",slug:"首页如下",normalizedTitle:"首页如下",charIndex:35}],headersStr:"via或其他浏览器的必选首页 简介 如何使用 首页如下",content:" * via或其他浏览器的必选首页\n * 简介\n * 如何使用\n * 首页如下\n\n\n\n\n# via或其他浏览器的必选首页\n\n\n# 简介\n\n * 现在的手机浏览器样式百出，功能臃肿且复杂\n * 作为极客爱好者，我只需要一个简单的浏览器，so，手机用的 Chrome + Via\n * 但Via浏览器都需要自定义，所以搞了这个HomePage来为Via增加点人性化体验\n\n\n# 如何使用\n\n * 打开via手机浏览器，找到设置\n\n * 进入设置后，找到为浏览器设置主页的地方\n\n * 点击设定主页为特定网页，输入如下地址即可：\n   \n   > http://zpj80231.gitee.io/viastart\n\n * 如果你喜欢的话还可以为你自己的浏览器（手机电脑都OK哟）设置为这个主页！o(￣▽￣)ブ\n\n\n# 首页如下\n\n",normalizedContent:" * via或其他浏览器的必选首页\n * 简介\n * 如何使用\n * 首页如下\n\n\n\n\n# via或其他浏览器的必选首页\n\n\n# 简介\n\n * 现在的手机浏览器样式百出，功能臃肿且复杂\n * 作为极客爱好者，我只需要一个简单的浏览器，so，手机用的 chrome + via\n * 但via浏览器都需要自定义，所以搞了这个homepage来为via增加点人性化体验\n\n\n# 如何使用\n\n * 打开via手机浏览器，找到设置\n\n * 进入设置后，找到为浏览器设置主页的地方\n\n * 点击设定主页为特定网页，输入如下地址即可：\n   \n   > http://zpj80231.gitee.io/viastart\n\n * 如果你喜欢的话还可以为你自己的浏览器（手机电脑都ok哟）设置为这个主页！o(￣▽￣)ブ\n\n\n# 首页如下\n\n",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"关于Vue的学习",frontmatter:{title:"关于Vue的学习",catalog:!0,date:"2019-05-12T13:59:44.000Z",tags:["Vue"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/vue-demo.html",relativePath:"views/frontend/vue-demo.md",key:"v-209f2ade",path:"/views/frontend/vue-demo.html",headers:[{level:2,title:"Vue-Demo",slug:"vue-demo",normalizedTitle:"vue-demo",charIndex:3},{level:2,title:"主要完成的功能",slug:"主要完成的功能",normalizedTitle:"主要完成的功能",charIndex:15},{level:2,title:"图形界面展示",slug:"图形界面展示",normalizedTitle:"图形界面展示",charIndex:26},{level:2,title:"感谢",slug:"感谢",normalizedTitle:"感谢",charIndex:36}],headersStr:"Vue-Demo 主要完成的功能 图形界面展示 感谢",content:" * Vue-Demo\n * 主要完成的功能\n * 图形界面展示\n * 感谢\n\n\n\n\n# Vue-Demo\n\n * 这是在学习Vue的同时，写的一个demo\n\n * 项目地址：https://github.com/zpj80231/vue-demo\n   \n   > 点击右上角克隆或下载 下载完成之后，在vue-demo文件目录打开命令窗口 输入命令： npm install （需提前装好node.js环境，如果没有请自行百度） 待npm安装完成之后输入： npm run dev 即可在浏览器看到窗口界面\n\n\n# 主要完成的功能\n\n * 新闻资讯\n   * 新闻资讯列表\n   * 新闻资讯列表详情\n   * 新闻评论功能\n * 图片分享\n   * 图片列表\n   * 图片缩略图功能\n * 商品购买\n   * 经典商品列表布局\n   * 商品详情页面\n   * 添加购物车\n * 购物车（难点）\n\n\n# 图形界面展示\n\n\n# 感谢\n\n * bilibili: vue教程-黑马-205集完整版\n\n * bilibili: hulala赵四(我用的是他的接口)\n\n> http://www.liulongbin.top:3005\n\n * bilibili: 有点小岁\n\n> 服务器：https://github.com/arm-liang/vue-mobbile-server\n> \n> 客户端：https://github.com/arm-liang/vue-mobbile-learning\n> \n> 项目服务器接口： http://120.77.181.41:3000，具体API 接口看GITHUB\n> \n> 项目演示： http://120.77.181.41/vue-learn/",normalizedContent:" * vue-demo\n * 主要完成的功能\n * 图形界面展示\n * 感谢\n\n\n\n\n# vue-demo\n\n * 这是在学习vue的同时，写的一个demo\n\n * 项目地址：https://github.com/zpj80231/vue-demo\n   \n   > 点击右上角克隆或下载 下载完成之后，在vue-demo文件目录打开命令窗口 输入命令： npm install （需提前装好node.js环境，如果没有请自行百度） 待npm安装完成之后输入： npm run dev 即可在浏览器看到窗口界面\n\n\n# 主要完成的功能\n\n * 新闻资讯\n   * 新闻资讯列表\n   * 新闻资讯列表详情\n   * 新闻评论功能\n * 图片分享\n   * 图片列表\n   * 图片缩略图功能\n * 商品购买\n   * 经典商品列表布局\n   * 商品详情页面\n   * 添加购物车\n * 购物车（难点）\n\n\n# 图形界面展示\n\n\n# 感谢\n\n * bilibili: vue教程-黑马-205集完整版\n\n * bilibili: hulala赵四(我用的是他的接口)\n\n> http://www.liulongbin.top:3005\n\n * bilibili: 有点小岁\n\n> 服务器：https://github.com/arm-liang/vue-mobbile-server\n> \n> 客户端：https://github.com/arm-liang/vue-mobbile-learning\n> \n> 项目服务器接口： http://120.77.181.41:3000，具体api 接口看github\n> \n> 项目演示： http://120.77.181.41/vue-learn/",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"vuepress插件：<Boxx/>",frontmatter:{title:"vuepress插件：`<Boxx/>`",date:"2019-11-17T15:53:26.000Z",tags:["vuepress"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/vuepress-plugin-boxx.html",relativePath:"views/frontend/vuepress-plugin-boxx.md",key:"v-193cdd9e",path:"/views/frontend/vuepress-plugin-boxx.html",headers:[{level:2,title:"序言",slug:"序言",normalizedTitle:"序言",charIndex:2},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:131},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:63},{level:2,title:"默认样式",slug:"默认样式",normalizedTitle:"默认样式",charIndex:569},{level:2,title:"自定义标题和内容",slug:"自定义标题和内容",normalizedTitle:"自定义标题和内容",charIndex:578},{level:2,title:"自定义样式",slug:"自定义样式",normalizedTitle:"自定义样式",charIndex:786}],headersStr:"序言 安装 使用 默认样式 自定义标题和内容 自定义样式",content:'# 序言\n\n * 由于在引入默认的VuePress Custom Containers太过笨重了，故闲来无事对其做一层封装简化使用\n * Github地址：https://github.com/zpj80231/vuepress-plugin-boxx\n\n\n# 安装\n\n * 在文件package.json中的devDependencies下加入"vuepress-plugin-boxx": "0.0.7"：\n\n"devDependencies": {\n    "vuepress-plugin-boxx": "0.0.7"\n}\n\n\n1\n2\n3\n\n * 在 vuepress 的config.js中配置plugins：\n\nplugins: [\n    ["vuepress-plugin-boxx"]\n],\n\n\n1\n2\n3\n\n * 在package.json目录下执行命令：npm install\n * 正常启动项目，接着如下使用即可\n\n\n# 使用\n\n * 引入：只需在你想要插入的地方加入 <Boxx/> 即可（如顶部所示）\n * 内容：默认随机展示名人名句，支持自定义\n * 样式：有三种样式，默认为 tip 样式，支持自定义\n * 注意：除<Boxx/>这个标签是必须外，标签属性均为可选，所有标签属性会在下文中详细介绍\n\n\n# 默认样式\n\n\n# 自定义标题和内容\n\n * 如果默认的名人名句不满足需求的话，自定义只需指定两个属性title和content的值\n\nNAME      TYPE     DESCRIPTION\ntitle     String   要展示的title的内容，支持html标签\ncontent   String   要展示的content的内容，支持html标签\n\n * 当然你也可以只输入title或content，如下：\n\n\n# 自定义样式\n\n * 可以通过以下几个属性实现\n\nNAME           TYPE     DESCRIPTION\nblockStyle     Object   整体块元素的样式\ntitleStyle     Object   只针对title的样式\ncontentStyle   Object   只针对content的样式\nchangeTime     Number   以毫秒值为单位的动态变化时间，顶部为例\n\n需要注意的是：属性值传输的对象只能通过v-bind:绑定来实现\n\n * 以下是对如上样式的示例，在Markdown中这样书写即可：\n\n<marquee>\n<Boxx :blockStyle="blockStyle"  />\n<Boxx type="warning" :blockStyle="titleStyle" :titleStyle="titleStyle" changeTime="1000" title="我是一个大大的且变化的 title"/>\n<Boxx type="danger" :blockStyle="contentStyle" :contentStyle="contentStyle" content="我是一个小小的<br><marquee>content</marquee>"/>\n</marquee>\n\n<script>\n\texport default {\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tblockStyle: {\'background\':\'#eee\',\'color\':\'red\'},\n                titleStyle: {\'margin-right\': \'10%\',\'font-size\':\'16px\'},\n                contentStyle: {\'margin-right\': \'20%\',\'font-size\':\'10px\',\n                               "margin-top": "1rem","margin-bottom": "0.4rem"},\n\t\t\t}\n\t\t}\n\t}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:'# 序言\n\n * 由于在引入默认的vuepress custom containers太过笨重了，故闲来无事对其做一层封装简化使用\n * github地址：https://github.com/zpj80231/vuepress-plugin-boxx\n\n\n# 安装\n\n * 在文件package.json中的devdependencies下加入"vuepress-plugin-boxx": "0.0.7"：\n\n"devdependencies": {\n    "vuepress-plugin-boxx": "0.0.7"\n}\n\n\n1\n2\n3\n\n * 在 vuepress 的config.js中配置plugins：\n\nplugins: [\n    ["vuepress-plugin-boxx"]\n],\n\n\n1\n2\n3\n\n * 在package.json目录下执行命令：npm install\n * 正常启动项目，接着如下使用即可\n\n\n# 使用\n\n * 引入：只需在你想要插入的地方加入 <boxx/> 即可（如顶部所示）\n * 内容：默认随机展示名人名句，支持自定义\n * 样式：有三种样式，默认为 tip 样式，支持自定义\n * 注意：除<boxx/>这个标签是必须外，标签属性均为可选，所有标签属性会在下文中详细介绍\n\n\n# 默认样式\n\n\n# 自定义标题和内容\n\n * 如果默认的名人名句不满足需求的话，自定义只需指定两个属性title和content的值\n\nname      type     description\ntitle     string   要展示的title的内容，支持html标签\ncontent   string   要展示的content的内容，支持html标签\n\n * 当然你也可以只输入title或content，如下：\n\n\n# 自定义样式\n\n * 可以通过以下几个属性实现\n\nname           type     description\nblockstyle     object   整体块元素的样式\ntitlestyle     object   只针对title的样式\ncontentstyle   object   只针对content的样式\nchangetime     number   以毫秒值为单位的动态变化时间，顶部为例\n\n需要注意的是：属性值传输的对象只能通过v-bind:绑定来实现\n\n * 以下是对如上样式的示例，在markdown中这样书写即可：\n\n<marquee>\n<boxx :blockstyle="blockstyle"  />\n<boxx type="warning" :blockstyle="titlestyle" :titlestyle="titlestyle" changetime="1000" title="我是一个大大的且变化的 title"/>\n<boxx type="danger" :blockstyle="contentstyle" :contentstyle="contentstyle" content="我是一个小小的<br><marquee>content</marquee>"/>\n</marquee>\n\n<script>\n\texport default {\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tblockstyle: {\'background\':\'#eee\',\'color\':\'red\'},\n                titlestyle: {\'margin-right\': \'10%\',\'font-size\':\'16px\'},\n                contentstyle: {\'margin-right\': \'20%\',\'font-size\':\'10px\',\n                               "margin-top": "1rem","margin-bottom": "0.4rem"},\n\t\t\t}\n\t\t}\n\t}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-数据库基础篇",frontmatter:{title:"Q&A宝典-数据库基础篇",date:"2019-10-20T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_db_001.html",relativePath:"views/qaq/sum_db_001.md",key:"v-21bc8b46",path:"/views/qaq/sum_db_001.html",headers:[{level:2,title:"第一天",slug:"第一天",normalizedTitle:"第一天",charIndex:2},{level:2,title:"第二天",slug:"第二天",normalizedTitle:"第二天",charIndex:1181},{level:2,title:"第三天",slug:"第三天",normalizedTitle:"第三天",charIndex:3163},{level:2,title:"第四天",slug:"第四天",normalizedTitle:"第四天",charIndex:4473},{level:2,title:"第五天",slug:"第五天",normalizedTitle:"第五天",charIndex:6295}],headersStr:"第一天 第二天 第三天 第四天 第五天",content:"# 第一天\n\n1. 分页怎么实现的\n * Mysql分页使用limit：select 列名 from 表名 limit 10,10;\n * Oracle分页使用rownum：select a.* from (select rownum rw, 列名 from 表名 where 条件) a where a.rw>数字 and a.rw<=y;\n\n2. sql语句优化\n 1. 合理使用索引\n 2. 用exists代替in，exists是直接判断存不存在，而in会挨个比较\n 3. 复杂的业务功能可以使用存储过程\n 4. 应尽量避免在 where 子句中使用!=、<>、or、in、not in操作符，否则将引擎放弃使用索引而进行全表扫描\n 5. 能多表关联的尽量不写子查询\n 6. 避免%xxx式查询，前置%查询会导致查全表\n\n3. Oracle中drop 和truncate的区别？\n * drop是删除表，不会释放表原先占有的内存空间；\n * truncate是截断表，能够释放表中数据所占有的内存空间，保留表结构；\n\n如果使用drop table 表名 purge;语句则能够直接释放表占有的内存空间。\n\n4. delete，drop，truncate 区别？\n\ndelete，drop，truncate 都有删除表的作用，区别在于：\n\n * delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。\n * delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。\n * 执行的速度上，drop>truncate>delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。\n\n5. 左外连接，右外连接，说一下?\n\n * 左外连接：from 原表 left join 新表 on 关联关系\n   原表和新表能够关联的数据+无法通过关联关系关联到原表的数据\n\n * 右外连接：from 原表 right join 新表 on 关联关系\n   原表和新表能够关联的数据+无法通过关联关系关联到新表的数据\n\n6. sql语句中怎么判断一个字段是不是空\n\n与空判断使用is null或者is not null\n\n7. 数据源、数据库连接池、DBCP三者的关系？\n 1. 数据源：是连接数据库的一个标准\n 2. 数据库：连接池是实现数据源的一种解决方案\n 3. DBCP：是连接池的具体实现\n\n\n# 第二天\n\n1. Mysql和Oracle的区别\n 1. Oracle使用rownum来实现分页，MySQL使用limit实现分页\n\n-- - mysql查询行号\nselect \n\tw.id,\n\t@rowno := @rowno + 1 AS rowno,\n\t-- 查到当前这一行的行号\n\tCASE WHEN w.ID ='123456' THEN\n@rowno END currentrowno \n\tfrom table w order by w.rowno;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. Oracle没有主键自增特性,可以使用调用序列的方式来实现主键自增；MySQL可以在主键列之后添加auto_increment设置自增特性\n 3. Oracle有表空间的概念，MySQL没有表空间\n 4. Oracle的分组函数中select之后不能直接写非分组的其他列；MySQL如果没有聚组函数则可以写 其他列\n 5. Oracle的表存放在用户（其实是schema对象）所属的表空间的数据文件中，   mySQL的表存放在某个database中（mysql一个root用户下可以有很多database）\n 6. Oracle中的一些函数和MySQL也不一样 如：ORACLE：substr('abcd',2,2) ，MYSQL：substring('abcd',2,2),ORACLE：to_char(sysdate,'yyyy-mm-dd') ，MYSQL：date_format(now(),'%Y-%m-%d')\n 7. Oracle中的字符类型可以使用varchar2，MySQL不能使用该类型\n\n2. jdbc怎样执行sql语句？\n 1. 加载驱动\n 2. 通过驱动管理对象获得连接\n 3. 获得执行器对象编写SQL语句,JAVA中用String类型表示SQL\n 4. 通过执行器执行SQL语句\n    常用的执行SQL语句的方法有:  execute()  boolean (执行select语句时返回true,因为select能够返回一个查询结果 其他命令开头的语句返回false)； executeUpdate()  int； executeQuery()   ResultSet\n 5. 释放资源\n\n3. 索引用过吗？在什么情况下会导致索引失效？用索引还需要注意哪些问题呢？索引分为几种？\n\n * 用过；如果有索引的列空值比较多、重复数据比较多的话索引不起作用。   通常索引用在查询较多而增删改较少的列，因为索引也会花时间自己维护会降低增删改的效率。\n\n * 常用的索引有普通索引、唯一性索引、位图索引，如果某个列上经常使用函数，还可以建一个函数索引。\n\n4. like 用过吗？怎么用的？\n\nlike常用来实现模糊查询，与%和_匹配使用，如果需要匹配特殊字符，则需要使用escape逃离符。\n例:搜索以“QA_”开头的数据：select code from 表 where code like 'QA/_%' escape '/'\n\n5. union 和union all的区别\n * 都是取并集，可以用来代替 or\n\n例如：有{1，2，3}和{2，3，4}\n  union 能够去除重复数据 (做排序操作)（1，2，3，4）\n  union all 不会做去重操作 效率高 （1，2，2，3，3，4）\n\n * 多个查询语句必须有相同的列数\n   多个查询语句中的列对应的数据类型必须一致\n   如：select ename,job from emp01   union   select ename,job from emp02;\n\n6. 事务的特性\n * 事务四大特性(简称ACID)\n\n 1. 原子性(Atomicity)： 事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。\n 2. 一致性(Consistency)： 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n 3. 隔离性(Isolation)： 事务的执行不受其他事务的干扰。\n 4. 持久性(Durability)： 能够将提交的数据持久化到数据库中。\n\n7. 什么是事务？特征？JDBC如何控制事务？\n\n * 多条sql语句作为 一个执行单元，要么全部执行，要么全不执行\n\n * 四大特性：原子性，一致性，隔离性，持久性\n\n * JDBC控制事务：\n   \n   * 开始事务：connection.setAutoCommit(false);\n   * 执行sql语句\n   * 提交:connection.commit();\n   * 回滚：Connection.rollback();\n\n\n# 第三天\n\n1. 存储过程、视图、触发器\n\n * 存储过程 procedure： 在服务器端，能够被多个程序调用的一段SQL语句块。\n   简单来说就是事先用数据库语言写好的一段功能，能够像函数一样被程序调用，但是存储过程本身没有返回值，是通过返回参数的形式返回数据。\n\n * 视图 View ： 视图其实就是伪表，将编译后的SQL语句保存在数据库中，拿出只想让用户看见的字段，这就是视图。\n   一般来讲视图不能创建索引（因为视图本身只是一个编译后的查询语句，索引只能创建在表的列上），但是Oracle提供了一种物化视图可以创建索引（物化视图：虽然叫视图但是实际类似于表，将数据暂时存储并在基表刷新或者提交数据时刷新本视图以便与基表数据保持一致）。\n\n * 触发器 trigger： 一种特殊的存储过程，不需要调用，在满足条件时触发。\n   触发条件：在对某个表做insert 、 update 或delete操作之前或之后（取决于如何实现）自动执行\n\n2. 如何调用存储过程？\n 1. JDBC中使用CallableStatement执行器对象，通过execute(\"{call  过程名(?,?)}\") 的方式来调用；\n 2. PL/SQL Developer工具中可以通过declare begin 过程名(参数);  end;的方式调用；\n\n3. 备份数据\n 1. 第一种方式： 通过导入导出命令备份数据库中全部数据\n    Oracle用exp命令导出数据，MySQL使用mysqldump命令备份数据\n 2. 第二种方式： 使用工具导出数据\n\n4. in与exists的区别? 那个效率更高?\n\nexists效率更高\n\n * in :需要通过条件比较结果中的所有数据\n * exists: 只关心子查询能够查询出数据\n\n5. 悲观锁与乐观锁?\n\n * 悲观锁: 在操作表时认为另外一个对表的操作会修改数据\n   1.所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。\n   2.java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\n   3.传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n * 乐观锁: 在操作表时认为别的操作不会对表有修改数据的操作\n   1.所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制(原子类)和CAS算法实现。\n   2.乐观锁适用于多读的应用类型，这样可以提高吞吐量。\n\n6. Hibernate中常见的主键增长策略？\n * Assigned:在调用save方法之前设置，自定义主键增长方式\n * Identity:建表语句必须支持auto_increment\n * Sequence:指定序列生成主键\n * Native:底层自动选择合适的策略\n * Increment：最大值+1的方式\n * Uuid:生成32为字符串\n\n\n# 第四天\n\n1. 结构化查询语言都是什么？\n 1. DDL alter drop truncate create\n 2. DML insert delete update\n 3. DQL select\n 4. DCL grant revoke\n 5. TCL commit rollback savepoint\n\n2. drop和truncate的区别?\n * drop：删除表结构和表数据(如果删除表空间的话需要+purge)\n * truncate：删除表数据和表空间，会保留表结构\n\n3. 组函数?多行函数?\n * sum() avg() count() max() min()\n\n4. 怎么去重？\n 1. distinct 专业去重(支持多列) select distinct salary,name from student;\n 2. group by 聚合统计\n\n5. 什么时候使用多表连接？什么时候使用子查询？\n 1. 如果需要查询的数据在多个表中,一定要使用多表连接\n 2. 不需要表A中的列,但是下需要表A中的条件,可以用子查询\n 3. 子查询中如果使用了in some any all这几个关键字,效率比较低,可以转换成多表关联\n\n6. 为什么要使用视图?\n 1. 节省编译时间,提高查询效率\n 2. 屏蔽原表中的字段，避免没有权限的用户查询到其他字段\n 3. 视图的数据能够动态的来源于原表\n 4. 简单的视图可以更新视图中的数据，复杂的视图无法更新\n    create view 视图名 as select name from student;\n\n7. 为什么要给普通用户创建属于自己的表空间?\n 1. 项目中很有可能与其他项目使用同一个数据库, 多个用户在使用用一个数据库时有可能访问同一个数据库文件, 就会产生资源争用的问题。给不同的用户指定不同的表空间， 就可以让他们使用不同的数据库文件，解决资源争用的问题。\n 2. 给予用户部分权限\n\n8. 约束有哪几种?\n 1. 外键约束 foreign key references\n 2. 唯一约束 unique\n 3. 非空约束 not null\n 4. 主键约束 primary key\n 5. 检查约束 check\n\n9. 索引有哪几种?\n 1. 函数索引\n 2. 普通索引 normal\n 3. 唯一索引 unique\n 4. 位图索引 bitmap（适合在数据量比较大，基数比较小的列 如：男/女）\n\n10. 索引的优缺点?\n * 能够更快的帮助我们提高查询效率\n * 索引会降低数据库的增删改的效率，因为数据库需要花时间去维护索引,所以索引适合数据量比较大而且数据不经常改动的列\n\n11. sql语句怎么优化?\n 1. 尽量用exists代替in\n 2. 合理使用索引\n 3. 查询多个表中的数据时,尽量用多表连接\n 4. 多表连接时尽量把多的数据放在where之后\n 5. 多表连接时尽量使用表的别名,减少数据库的解析时间\n 6. 在确保语句完整的情况下,多使用commit提交语句\n 7. 优化group by，将不需要的记录在group by之前过滤掉\n\n12. 查询语句常见的关键字的优先级?\n 1. select 列名 优先级高于order by\n 2. from 表明 优先级最高\n 3. where 条件 优先级次高\n 4. group by条件 优先级次于where\n 5. having 条件 优先级一定在group by之后\n 6. order by分组 优先级最低\n\n13. Oracle分页\n\nrownum，这是Oracle对动态查询结果的编号，用来实现分页查询有序的整数列，每多一条自动加1\n\n 1. 不能和 group by 在同一个查询语句中\n 2. 不能用 表名.rownum\n 3. 它肯定是从1开始\n\n * 编号21-30，实现排序效果的分页\n\nselect rownum,a.*\n   \tfrom\n   \t\t(select rownum rn,b.* \n         from (select * from student order by salary) b\n         where rownum <=30) a\n   \twhere\n   \t\ta.rn >=21;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 第五天\n\n1. mysql 引擎 b+树索引（文件系统常用索引）\n\n> https://www.cnblogs.com/tiancai/p/9024351.html\n\n * 平衡二叉树：每个节点只保存一份数据\n\n * b树：每个节点可以保存多份数据，减少磁盘I/O所花的时间。\n\nB树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。\n\n * b+树：只有最底层的叶子节点（文件）保存数据，非叶子节点只保存索引。\n\n由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。\n\n非叶子节点的子树指针与关键字个数相同。B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。",normalizedContent:"# 第一天\n\n1. 分页怎么实现的\n * mysql分页使用limit：select 列名 from 表名 limit 10,10;\n * oracle分页使用rownum：select a.* from (select rownum rw, 列名 from 表名 where 条件) a where a.rw>数字 and a.rw<=y;\n\n2. sql语句优化\n 1. 合理使用索引\n 2. 用exists代替in，exists是直接判断存不存在，而in会挨个比较\n 3. 复杂的业务功能可以使用存储过程\n 4. 应尽量避免在 where 子句中使用!=、<>、or、in、not in操作符，否则将引擎放弃使用索引而进行全表扫描\n 5. 能多表关联的尽量不写子查询\n 6. 避免%xxx式查询，前置%查询会导致查全表\n\n3. oracle中drop 和truncate的区别？\n * drop是删除表，不会释放表原先占有的内存空间；\n * truncate是截断表，能够释放表中数据所占有的内存空间，保留表结构；\n\n如果使用drop table 表名 purge;语句则能够直接释放表占有的内存空间。\n\n4. delete，drop，truncate 区别？\n\ndelete，drop，truncate 都有删除表的作用，区别在于：\n\n * delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。\n * delete 是 dml 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 ddl 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。\n * 执行的速度上，drop>truncate>delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。\n\n5. 左外连接，右外连接，说一下?\n\n * 左外连接：from 原表 left join 新表 on 关联关系\n   原表和新表能够关联的数据+无法通过关联关系关联到原表的数据\n\n * 右外连接：from 原表 right join 新表 on 关联关系\n   原表和新表能够关联的数据+无法通过关联关系关联到新表的数据\n\n6. sql语句中怎么判断一个字段是不是空\n\n与空判断使用is null或者is not null\n\n7. 数据源、数据库连接池、dbcp三者的关系？\n 1. 数据源：是连接数据库的一个标准\n 2. 数据库：连接池是实现数据源的一种解决方案\n 3. dbcp：是连接池的具体实现\n\n\n# 第二天\n\n1. mysql和oracle的区别\n 1. oracle使用rownum来实现分页，mysql使用limit实现分页\n\n-- - mysql查询行号\nselect \n\tw.id,\n\t@rowno := @rowno + 1 as rowno,\n\t-- 查到当前这一行的行号\n\tcase when w.id ='123456' then\n@rowno end currentrowno \n\tfrom table w order by w.rowno;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. oracle没有主键自增特性,可以使用调用序列的方式来实现主键自增；mysql可以在主键列之后添加auto_increment设置自增特性\n 3. oracle有表空间的概念，mysql没有表空间\n 4. oracle的分组函数中select之后不能直接写非分组的其他列；mysql如果没有聚组函数则可以写 其他列\n 5. oracle的表存放在用户（其实是schema对象）所属的表空间的数据文件中，   mysql的表存放在某个database中（mysql一个root用户下可以有很多database）\n 6. oracle中的一些函数和mysql也不一样 如：oracle：substr('abcd',2,2) ，mysql：substring('abcd',2,2),oracle：to_char(sysdate,'yyyy-mm-dd') ，mysql：date_format(now(),'%y-%m-%d')\n 7. oracle中的字符类型可以使用varchar2，mysql不能使用该类型\n\n2. jdbc怎样执行sql语句？\n 1. 加载驱动\n 2. 通过驱动管理对象获得连接\n 3. 获得执行器对象编写sql语句,java中用string类型表示sql\n 4. 通过执行器执行sql语句\n    常用的执行sql语句的方法有:  execute()  boolean (执行select语句时返回true,因为select能够返回一个查询结果 其他命令开头的语句返回false)； executeupdate()  int； executequery()   resultset\n 5. 释放资源\n\n3. 索引用过吗？在什么情况下会导致索引失效？用索引还需要注意哪些问题呢？索引分为几种？\n\n * 用过；如果有索引的列空值比较多、重复数据比较多的话索引不起作用。   通常索引用在查询较多而增删改较少的列，因为索引也会花时间自己维护会降低增删改的效率。\n\n * 常用的索引有普通索引、唯一性索引、位图索引，如果某个列上经常使用函数，还可以建一个函数索引。\n\n4. like 用过吗？怎么用的？\n\nlike常用来实现模糊查询，与%和_匹配使用，如果需要匹配特殊字符，则需要使用escape逃离符。\n例:搜索以“qa_”开头的数据：select code from 表 where code like 'qa/_%' escape '/'\n\n5. union 和union all的区别\n * 都是取并集，可以用来代替 or\n\n例如：有{1，2，3}和{2，3，4}\n  union 能够去除重复数据 (做排序操作)（1，2，3，4）\n  union all 不会做去重操作 效率高 （1，2，2，3，3，4）\n\n * 多个查询语句必须有相同的列数\n   多个查询语句中的列对应的数据类型必须一致\n   如：select ename,job from emp01   union   select ename,job from emp02;\n\n6. 事务的特性\n * 事务四大特性(简称acid)\n\n 1. 原子性(atomicity)： 事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。\n 2. 一致性(consistency)： 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n 3. 隔离性(isolation)： 事务的执行不受其他事务的干扰。\n 4. 持久性(durability)： 能够将提交的数据持久化到数据库中。\n\n7. 什么是事务？特征？jdbc如何控制事务？\n\n * 多条sql语句作为 一个执行单元，要么全部执行，要么全不执行\n\n * 四大特性：原子性，一致性，隔离性，持久性\n\n * jdbc控制事务：\n   \n   * 开始事务：connection.setautocommit(false);\n   * 执行sql语句\n   * 提交:connection.commit();\n   * 回滚：connection.rollback();\n\n\n# 第三天\n\n1. 存储过程、视图、触发器\n\n * 存储过程 procedure： 在服务器端，能够被多个程序调用的一段sql语句块。\n   简单来说就是事先用数据库语言写好的一段功能，能够像函数一样被程序调用，但是存储过程本身没有返回值，是通过返回参数的形式返回数据。\n\n * 视图 view ： 视图其实就是伪表，将编译后的sql语句保存在数据库中，拿出只想让用户看见的字段，这就是视图。\n   一般来讲视图不能创建索引（因为视图本身只是一个编译后的查询语句，索引只能创建在表的列上），但是oracle提供了一种物化视图可以创建索引（物化视图：虽然叫视图但是实际类似于表，将数据暂时存储并在基表刷新或者提交数据时刷新本视图以便与基表数据保持一致）。\n\n * 触发器 trigger： 一种特殊的存储过程，不需要调用，在满足条件时触发。\n   触发条件：在对某个表做insert 、 update 或delete操作之前或之后（取决于如何实现）自动执行\n\n2. 如何调用存储过程？\n 1. jdbc中使用callablestatement执行器对象，通过execute(\"{call  过程名(?,?)}\") 的方式来调用；\n 2. pl/sql developer工具中可以通过declare begin 过程名(参数);  end;的方式调用；\n\n3. 备份数据\n 1. 第一种方式： 通过导入导出命令备份数据库中全部数据\n    oracle用exp命令导出数据，mysql使用mysqldump命令备份数据\n 2. 第二种方式： 使用工具导出数据\n\n4. in与exists的区别? 那个效率更高?\n\nexists效率更高\n\n * in :需要通过条件比较结果中的所有数据\n * exists: 只关心子查询能够查询出数据\n\n5. 悲观锁与乐观锁?\n\n * 悲观锁: 在操作表时认为另外一个对表的操作会修改数据\n   1.所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。\n   2.java中synchronized和reentrantlock等独占锁就是悲观锁思想的实现。\n   3.传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n * 乐观锁: 在操作表时认为别的操作不会对表有修改数据的操作\n   1.所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制(原子类)和cas算法实现。\n   2.乐观锁适用于多读的应用类型，这样可以提高吞吐量。\n\n6. hibernate中常见的主键增长策略？\n * assigned:在调用save方法之前设置，自定义主键增长方式\n * identity:建表语句必须支持auto_increment\n * sequence:指定序列生成主键\n * native:底层自动选择合适的策略\n * increment：最大值+1的方式\n * uuid:生成32为字符串\n\n\n# 第四天\n\n1. 结构化查询语言都是什么？\n 1. ddl alter drop truncate create\n 2. dml insert delete update\n 3. dql select\n 4. dcl grant revoke\n 5. tcl commit rollback savepoint\n\n2. drop和truncate的区别?\n * drop：删除表结构和表数据(如果删除表空间的话需要+purge)\n * truncate：删除表数据和表空间，会保留表结构\n\n3. 组函数?多行函数?\n * sum() avg() count() max() min()\n\n4. 怎么去重？\n 1. distinct 专业去重(支持多列) select distinct salary,name from student;\n 2. group by 聚合统计\n\n5. 什么时候使用多表连接？什么时候使用子查询？\n 1. 如果需要查询的数据在多个表中,一定要使用多表连接\n 2. 不需要表a中的列,但是下需要表a中的条件,可以用子查询\n 3. 子查询中如果使用了in some any all这几个关键字,效率比较低,可以转换成多表关联\n\n6. 为什么要使用视图?\n 1. 节省编译时间,提高查询效率\n 2. 屏蔽原表中的字段，避免没有权限的用户查询到其他字段\n 3. 视图的数据能够动态的来源于原表\n 4. 简单的视图可以更新视图中的数据，复杂的视图无法更新\n    create view 视图名 as select name from student;\n\n7. 为什么要给普通用户创建属于自己的表空间?\n 1. 项目中很有可能与其他项目使用同一个数据库, 多个用户在使用用一个数据库时有可能访问同一个数据库文件, 就会产生资源争用的问题。给不同的用户指定不同的表空间， 就可以让他们使用不同的数据库文件，解决资源争用的问题。\n 2. 给予用户部分权限\n\n8. 约束有哪几种?\n 1. 外键约束 foreign key references\n 2. 唯一约束 unique\n 3. 非空约束 not null\n 4. 主键约束 primary key\n 5. 检查约束 check\n\n9. 索引有哪几种?\n 1. 函数索引\n 2. 普通索引 normal\n 3. 唯一索引 unique\n 4. 位图索引 bitmap（适合在数据量比较大，基数比较小的列 如：男/女）\n\n10. 索引的优缺点?\n * 能够更快的帮助我们提高查询效率\n * 索引会降低数据库的增删改的效率，因为数据库需要花时间去维护索引,所以索引适合数据量比较大而且数据不经常改动的列\n\n11. sql语句怎么优化?\n 1. 尽量用exists代替in\n 2. 合理使用索引\n 3. 查询多个表中的数据时,尽量用多表连接\n 4. 多表连接时尽量把多的数据放在where之后\n 5. 多表连接时尽量使用表的别名,减少数据库的解析时间\n 6. 在确保语句完整的情况下,多使用commit提交语句\n 7. 优化group by，将不需要的记录在group by之前过滤掉\n\n12. 查询语句常见的关键字的优先级?\n 1. select 列名 优先级高于order by\n 2. from 表明 优先级最高\n 3. where 条件 优先级次高\n 4. group by条件 优先级次于where\n 5. having 条件 优先级一定在group by之后\n 6. order by分组 优先级最低\n\n13. oracle分页\n\nrownum，这是oracle对动态查询结果的编号，用来实现分页查询有序的整数列，每多一条自动加1\n\n 1. 不能和 group by 在同一个查询语句中\n 2. 不能用 表名.rownum\n 3. 它肯定是从1开始\n\n * 编号21-30，实现排序效果的分页\n\nselect rownum,a.*\n   \tfrom\n   \t\t(select rownum rn,b.* \n         from (select * from student order by salary) b\n         where rownum <=30) a\n   \twhere\n   \t\ta.rn >=21;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 第五天\n\n1. mysql 引擎 b+树索引（文件系统常用索引）\n\n> https://www.cnblogs.com/tiancai/p/9024351.html\n\n * 平衡二叉树：每个节点只保存一份数据\n\n * b树：每个节点可以保存多份数据，减少磁盘i/o所花的时间。\n\nb树在提高了io性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，b+树应用而生。b+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而b树不支持这样的操作或者说效率太低。\n\n * b+树：只有最底层的叶子节点（文件）保存数据，非叶子节点只保存索引。\n\n由于b+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是b树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以b+树更加适合在区间查询的情况，所以通常b+树用于数据库索引。\n\n非叶子节点的子树指针与关键字个数相同。b+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-前端基础篇",frontmatter:{title:"Q&A宝典-前端基础篇",date:"2019-03-26T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_fe_001.html",relativePath:"views/qaq/sum_fe_001.md",key:"v-7ad83f1b",path:"/views/qaq/sum_fe_001.html",headers:[{level:2,title:"Ajax",slug:"ajax",normalizedTitle:"ajax",charIndex:2},{level:2,title:"Json",slug:"json",normalizedTitle:"json",charIndex:88},{level:2,title:"jQuery",slug:"jquery",normalizedTitle:"jquery",charIndex:888},{level:2,title:"Jsp el表达式",slug:"jsp-el表达式",normalizedTitle:"jsp el表达式",charIndex:1499}],headersStr:"Ajax Json jQuery Jsp el表达式",content:'# Ajax\n\n1. Ajax支持几种数据传递的方式?\n 1. 字符串 text/plain\n 2. xml text/xml\n 3. json text/plain\n\n\n# Json\n\n1. json的格式?\n\n 1. 键值对 {key1:value1,key2:value2..}\n\n 2. 数组 [value1,value2..]\n\n> 其中key必须是String类型,value支持null,Object,json等\n\n2. json有哪几种封装方式?\n\n 1. 可以封装任意类型的数据\n    \n    JSONObject jo1 = new JSONObject(); jo1.put("key",value);\n\n 2. 用来封装自定义数据类型和Map\n    \n    Map<Integer,String> map = new HashMap<>();\n    map.put(1,"王者"); map.put(2,"荣耀");\n    JSONObject jo2 = JSONObject.fromObject(map);\n\n 3. 专门用来封装集合和数组\n    \n    List<String> list = new ArrayList<>();\n    list.add("飞龙");list.add("在天");\n    JSONArray jo3 = JSONArray.fromObject(list);\n\n3. json如何对自定义数据类型进行有选择性的封装?(hibernate中`防止`多表级联发生的`死循环`)\n\n * 引入JsonConfig\n   \n   JsonConfig jc = new JsonConfig(new String[]{"不想要的属性1","不想要的属性2"..});\n   JSONObject jo = JSONObject.fromObject(对象,jc);\n\n4. json的包名是?\n\nnet.sf.json.JSONArray;\nnet.sf.json.JSONObject;\n\n\n# jQuery\n\n1. jQuery基本选择器\n * #id、.class\n * 查找所有未选中的input元素：$("input:not(:checked)");\n * 选中所有name属性是newsletter的input元素：$("input[name=\'newsletter\']").attr("checked",true);\n\n2. attr和prop的区别\n\nattr：可以获取元素自定义属性和本身自带的属性\nprop：用来获取元素本身属性\n\n3. disabled和readonly的区别\n\ndisabled：样式 灰色，后台请求接收不到参数 始终为null\nreadonly：样式 白色，后台请求参数可以接收\n\n3. 简述Css层叠特性与继承特性\n\n * 层叠特性: 当多种基本选择器出现冲突时优先级问题，id选择器>类别选择器>标记选择器\n\n * 继承特性: 当子元素与父元素没有任何冲突时，子元素会完全继承父元素的所有css渲染样式\n\n4. 写出至少三种Js选择器的使用方式\n\ndocument.getElementById("idName");\ndocument.getElementsByTagName("tagName");\ndocument.getElementsByClassName("className");\ndocument.getElementsByName("name");\n\n\n# Jsp el表达式\n\n1. 请使用Js脚本在页面显示九九乘法表\n\nlet str = "";\nfor(let a = 1;a<=9;a++){\n    for(let b = 1;b<=a;b++){\n        str += b+"*"+a+"="+b*a+"\\t";\n    }\n    str += "<br />";\n}\t\t\t\t\t\ndocument.write(str);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n2. el表达式取值\n\n 1. 通过属性取值：${param.键}\n    拿取全局参数：${initParam.键}\n\n 2. 四范围取值：\n    ${pageScope.elena} 当前页有效\n    ${requestScope.elena} 跳转页面有效\n    ${sessionScope.elena} session范围有效\n    ${application.elena} 时间到期前一直有效\n\n> 我们一般只写键,但是当有多个范围的键冲突时,默认拿取范围最小的键值\n\n3. el表达式的缺陷\n 1. EL表达式无法直接取值，必须通过key和提供的四范围取值，如果取值失败,什么都不显示\n 2. 解决：空验证，如果取不到值返回true，如果可以取值返回false\n    如：${empty sessionScope.key}',normalizedContent:'# ajax\n\n1. ajax支持几种数据传递的方式?\n 1. 字符串 text/plain\n 2. xml text/xml\n 3. json text/plain\n\n\n# json\n\n1. json的格式?\n\n 1. 键值对 {key1:value1,key2:value2..}\n\n 2. 数组 [value1,value2..]\n\n> 其中key必须是string类型,value支持null,object,json等\n\n2. json有哪几种封装方式?\n\n 1. 可以封装任意类型的数据\n    \n    jsonobject jo1 = new jsonobject(); jo1.put("key",value);\n\n 2. 用来封装自定义数据类型和map\n    \n    map<integer,string> map = new hashmap<>();\n    map.put(1,"王者"); map.put(2,"荣耀");\n    jsonobject jo2 = jsonobject.fromobject(map);\n\n 3. 专门用来封装集合和数组\n    \n    list<string> list = new arraylist<>();\n    list.add("飞龙");list.add("在天");\n    jsonarray jo3 = jsonarray.fromobject(list);\n\n3. json如何对自定义数据类型进行有选择性的封装?(hibernate中`防止`多表级联发生的`死循环`)\n\n * 引入jsonconfig\n   \n   jsonconfig jc = new jsonconfig(new string[]{"不想要的属性1","不想要的属性2"..});\n   jsonobject jo = jsonobject.fromobject(对象,jc);\n\n4. json的包名是?\n\nnet.sf.json.jsonarray;\nnet.sf.json.jsonobject;\n\n\n# jquery\n\n1. jquery基本选择器\n * #id、.class\n * 查找所有未选中的input元素：$("input:not(:checked)");\n * 选中所有name属性是newsletter的input元素：$("input[name=\'newsletter\']").attr("checked",true);\n\n2. attr和prop的区别\n\nattr：可以获取元素自定义属性和本身自带的属性\nprop：用来获取元素本身属性\n\n3. disabled和readonly的区别\n\ndisabled：样式 灰色，后台请求接收不到参数 始终为null\nreadonly：样式 白色，后台请求参数可以接收\n\n3. 简述css层叠特性与继承特性\n\n * 层叠特性: 当多种基本选择器出现冲突时优先级问题，id选择器>类别选择器>标记选择器\n\n * 继承特性: 当子元素与父元素没有任何冲突时，子元素会完全继承父元素的所有css渲染样式\n\n4. 写出至少三种js选择器的使用方式\n\ndocument.getelementbyid("idname");\ndocument.getelementsbytagname("tagname");\ndocument.getelementsbyclassname("classname");\ndocument.getelementsbyname("name");\n\n\n# jsp el表达式\n\n1. 请使用js脚本在页面显示九九乘法表\n\nlet str = "";\nfor(let a = 1;a<=9;a++){\n    for(let b = 1;b<=a;b++){\n        str += b+"*"+a+"="+b*a+"\\t";\n    }\n    str += "<br />";\n}\t\t\t\t\t\ndocument.write(str);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n2. el表达式取值\n\n 1. 通过属性取值：${param.键}\n    拿取全局参数：${initparam.键}\n\n 2. 四范围取值：\n    ${pagescope.elena} 当前页有效\n    ${requestscope.elena} 跳转页面有效\n    ${sessionscope.elena} session范围有效\n    ${application.elena} 时间到期前一直有效\n\n> 我们一般只写键,但是当有多个范围的键冲突时,默认拿取范围最小的键值\n\n3. el表达式的缺陷\n 1. el表达式无法直接取值，必须通过key和提供的四范围取值，如果取值失败,什么都不显示\n 2. 解决：空验证，如果取不到值返回true，如果可以取值返回false\n    如：${empty sessionscope.key}',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-Java基础篇",frontmatter:{title:"Q&A宝典-Java基础篇",date:"2019-02-17T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_java_001.html",relativePath:"views/qaq/sum_java_001.md",key:"v-59d18056",path:"/views/qaq/sum_java_001.html",headers:[{level:2,title:"第一天",slug:"第一天",normalizedTitle:"第一天",charIndex:2},{level:2,title:"第二天",slug:"第二天",normalizedTitle:"第二天",charIndex:1194},{level:2,title:"第三天",slug:"第三天",normalizedTitle:"第三天",charIndex:3230},{level:2,title:"第四天",slug:"第四天",normalizedTitle:"第四天",charIndex:4597},{level:2,title:"第五天",slug:"第五天",normalizedTitle:"第五天",charIndex:5918}],headersStr:"第一天 第二天 第三天 第四天 第五天",content:'# 第一天\n\n1. 常用的集合有哪些？\n\nMap接口和Collection接口是所有集合框架的父接口：\n\n * Collection接口的子接口包括：Set接口和List接口；\n * Map接口的实现类主要有：HashMap、ConcurrentHashMap、TreeMap、Hashtable以及Properties等；\n * Set接口的实现类主要有：HashSet、LinkedHashSet、TreeSet等；\n * List接口的实现类主要有：ArrayList、LinkedList、Stack、Vector等。\n\n2. 静态变量和成员变量的区别？\n * 所属不同： 静态变量属于类，所以也成为类变量；成员变量属于对象，所有也成为实例变量（对象变量）；\n * 在内存中出现的时间不同： 静态变量只在类创建时加载一次，随着类的加载而加载随着类的消失而消失；成员变量随着对象（也叫实例）的创建而存在，随着对象的消失而消失；\n * 在内存中的位置不同： 静态变量存储于方法区里的静态区，成员变量属于对内存；\n * 调用方式不同： 静态变量可以通过类名调用，也可以通过对象调用；成员变量只能通过对象调用；\n\n3. filter过滤器用过吗？一般用在什么地方？\n * 用过\n * 例如实现Servlet，Jsp或静态html等文件的拦截，从而实现一些特殊功能。\n * 例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。\n\n4. 多线程一般用在什么地方？\n * 多线程的作用：充分利用CPU资源，提高CPU使用率，才用多线程的方式去同时完成几件事情而不相互干扰\n * 用在什么地方：大多情况下，用到多线程主要是需要处理大量的IO操作或处理需要耗费大量时间的操作等等。比如：读写文件等。\n\n5. int和Integer的区别？\n * Integer是int的包装类，而int是Java的一种基本数据类型\n * Integer是类，必须实例化之后才能使用，而int变量不需要\n * Integer的默认值是null，而int的默认值是0\n * Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针只想此对象；而int是直接存储数据值\n\n6. 3.2E3F 里面的E/F分别表示什么？\n * E：科学计数法 3.2*10（3）\n * F:表示float类型\n\n7. switch（参数） case的参数可以传哪些数据类型？\n * jdk1.0 char byte short int\n   jdk5.0 enum(枚举)\n   jdk7.0 String\n\n8. do while 和while之间的区别？\n * do while 先执行 然后在判断 保证程序至少执行一次【先斩后奏】\n * while 先判断 符合条件在执行\n\n\n# 第二天\n\n1. list用过哪些？ArrayList如何排序？list和Set的区别？\n * 用过ArrayList、LinkedList、Vector\n   \n * 排序：sort()\n\n> List和Set的区别：\n> \n>  1. List，Set都是继承自Collection接口\n>  2. List特点：元素放入有顺序，元素可以重复。\n>     Set特点：元素放入无顺序，元素不可重复，重复元素会覆盖。\n>  3. Set和List对比：\n>     Set：检索元素效率低下，删除和插入效率高，删除和插入不会引起元素位置的改变。\n>     List：和数组类似，List可以动态增长，查找元素效率高，增删元素效率低，因为增删元素会引起其他元素位置的改变。\n\n2. 异常包括什么？说一下什么是运行时异常、非运行时异常，举例说明。\n\n * 异常是指程序运行过程当中出现的例外情况\n   \n   异常的体系结构：\n   \n   graph TB\n   \tThrowable --\x3e Error\n   \tThrowable --\x3e Exception\n   \tException --\x3e RuntimeException\n   \n   \n   1\n   2\n   3\n   4\n   \n\n异常包括：运行时异常和非运行时异常\n\n * 运行时异常(RuntimeException)：指编译能通过，直到运行的时候才体现出来\n * 非运行时异常(Exception)：指在编译的时候必须明确该如何处理，否则根本无法通过编译\n * Error：描述了Java运行时系统的内部错误或资源耗尽错误。大多数错误与代码编写无关，而表示代码运行时JVM出现的问题。应用程序不应该抛出这种类型的对象。\n\n常见的运行时异常(RuntimeException)有：\n\n 1. IndexOutOfBoundsException（下标越界异常）\n 2. NullPointerException（空指针异常）\n 3. NumberFormatException（String转换为指定的数字异常）\n 4. ArithmeticException（算术异常，如除数为0）\n 5. FileNotFoundException（文件未找到异常）\n 6. IOException（操作输入流和输出流时可能出现的异常，如磁盘损坏等）\n\n3. 线程的实现方式\n\n 1. 继承Thread类，重写run方法 (其实Thread类本身也实现了Runnable接口)\n\n 2. 实现Runnable接口， 重写run方法。（传入Thread类的构造方法中，由Thread的start启用线程）\n\n 3. 实现Callable接口，重写call方法(有抛出异常和有返回值)\n    \n    通过Callable和FutureTask创建线程，将Callable实现类传入FutureTask构造方法中，由FutureTask的start方法启用线程\n\n 4. 通过线程池创建线程\n\n4. 怎么处理异常\n * 抛还上级：throws\n * 自行处理：try catch finally\n\n5. 多态的实现机制\n\nJava中实现多态的机制靠的是： 父类或接口定义的引用变量可以指向子类或具体的实现类的实例对象，而程序调的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。\n\n> 一句话：父类或接口引用指向具体的实例对象\n\n多态的不同表现形式：方法的重写和重载就是Java多态的不同表现\n\n * 重写Overriding是父类与子类之间多态的一种表现\n * 重载OverLoding是一个类中多态的一种表现\n\n6. Java简单运算面试题\n\nshort x = 1;\nx = x + 1;//左边short = 右边int？\nSystem.out.println(x);//报错\n\nshort y = 1;\ny += 1;//y = (short)(y + 1); +=会自动转换\nSystem.out.println(y);//2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n7. StringBuffer和StringBuilder之间的区别？\n * StringBuffer和StringBuilder在创建对象的时候 都会多预留16块缓冲区\n\n 1. StringBuffer 同一时间允许一个线程进行访问，效率较低，但是不会出现并发错误\n 2. StringBuilder 同一时间允许多个线程进行访问，效率较高，但是可能会出现并发错误\n\n8. 为什么不把一个类所有的方法全部定义成静态的呢？\n * 静态方法里面只能直接的访问静态成员\n * 如果想要在静态方法里面访问非静态成员的话，需要先创建对象，拿着对象去调用\n\n\n# 第三天\n\n1. &和&&的区别\n\n&和&&都可以作为逻辑运算符使用\n\n&&有短路特性，当通过前面条件能够得知最终表达式结论的话，后面的条件会短路掉不做判断，所以效率更高。&没有短路特性，两边的条件都会进行判断。\n\n另外&还是按位运算符的按位与运算。当&左右两边连接的是整数类型的时候作为二进制按位与运算，也就是将两个数的二进制位都是1的结果写1。\n\n2. final，finally，finalize的区别\n\n * final是一个修饰符，可以用于修饰类、方法、变量\n   \n   修饰类代表最终类，表示不能被继承\n   修饰方法代表最终方法，表示此方法不能被覆盖（但是可以被继承）\n   修饰表示引用地址或值不能被修改\n\n * finally是异常处理的语法结构，表示无论是否出现异常最终都要执行的操作。\n   \n   通常是释放和关闭资源的操作（如数据库连接和文件io流的关闭）\n\n * finalize是Object类中的一个方法，表示在gc回收对象之前会调用这个方法\n\n3. String和StringBuffer的区别\n\nString和StringBuffer都是Java当中提供的字符串类型，其中String没有预留缓冲空间，而StringBuffer会在原先内容的基础上预留一部分的缓冲空间。\n\n> String： "a" + "b" 相当于创建了一个新对象，返回值是”ab"。\n> StringBuffer： sbuff.append("b")相当于还是在原先的对象上进行修改值。\n\n4. 请说出你所知道的线程同步的方法\n\n * synchronize修饰符\n   \n   修饰代码块\n   修饰方法\n\n * java.util.concurrent.locks.ReentrantLock（并发包中的可重入锁）\n   \n   Lock lock = new ReentrantLock();\n   其中lock.lock()用于上锁，lock.unLock()用于释放锁\n\n5. 在Java中，如何跳出当前的多重循环\n\n 1. break加循环标签，如：\n    \n    example_this:for(int x=0; x<10; x++) {\n        if(...) {\n            break example_this;//结束循环\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 使用return\n\n 3. 使用System.exit(0);结束虚拟机\n\n6. 接口是否可以继承？抽象类时候可以实现接口？抽象类是否可以继承实体类？\n\n接口可以继承接口，而且可以多继承，多个接口之间用,隔开；\n\n抽象类可以实现接口，而且可以暂时不实现接口当中要求的抽象方法，因为抽象类中本身就可以有抽象方法留待子类具体实现；\n\n抽象类可以继承实体类，如果继承的实体类没有默认的无参构造方法，需要写出抽象类的构造方法并在其构造方法的首行使用super()传参来明确指定调用父类的哪个构造方法。\n\n7. 抽象类是类 有构造方法 但是不能创建对象那么要构造方法的作用？\n * 给子类构造方法首行的super去调用的\n\n\n# 第四天\n\n1. ==和equals的区别？\n\n * ==：是一个运算符，用于比较两端的内容是否相等\n   \n   基本数据类型：两端的值是否相等\n   引用类型：内存地址是否相等\n\n * equals：是Object类的一个方法。子类继承这个方法之后可以按照自己的逻辑需求覆盖这个方法，从而描述自己的比较规则。 例如：String类就将equals()方法覆盖为比较字符串的内容\n\n2. 怎么解决死锁？\n * wait()，notify()，notifyAll()\n\n使用 wait() 让当前线程(a)放弃锁标记进入等待池当中阻塞，从而成全另外的线程(b)能够成功获得它(b)需要的锁标记之后再调用 notify() 或者 notifyAll() 唤醒线程(a)，让线程(a)从等待池进入锁池等待获得锁标记\n\n> [注意这三个方法都必须已经持有锁标记才能调用所以他们只能出现在synchronized代码块当中]\n\n3. 线程的生命周期\n\n新生 就绪 运行 消亡 阻塞（等待池 锁池）\n\n4. 线程池\n\n * 可重用的线程池，方法的参数表示同一时间允许多少个线程并发执行，当线程执行完时，线程将被归还给线程池 Executors.newFixedThreadPool(2);\n\n * 带缓存机制的线城池，当线程执行完时，线程将被归还给线程池，如果一分钟之内没有其他线程被提交， 线程将会消亡 Executors.newCachedThreadPool();\n\n * 单一执行器：同一时间仅允许一条线程执行 Executors.newSingleThreadExcutor()\n\n5. 简述JDBC中Statement和PrepareStatement的区别\n 1. 两者同为接口 , PreparedStatement是Statement的子类\n 2. Statement 只能执行静态语句 PreparedStatement存在一个强大缓存区，相同的sql语句执行相同语句结构仅仅编译一次，PreparedStatement仅对改动数据进行修改而不再进行编译，而Statement只要语句发生了改变，则必须重新进行编译\n 3. PreparedStatement支持对sql语句使用 ?占位符，杜绝了 sql注入安全隐患\n 4. 如果sql语句不需要多次执行，或者?过多，则效率可能较Statement低\n\n6. 简述 execute() executeUpdate() executeQuery() executeBatch()的使用场合，返回值?\n\n                  返回类型        使用场合\nexecute()         boolean     执行dql语句返回true，dml语句返回false\nexecuteUpdate()   int         执行dml返回更改记录数，dql立刻报错\nexecuteQuery()    ResultSet   执行dql语句返回结果集\nexecuteBatch()    int[]       只能执行dml语句，返回更改的记录数的数组\n\n\n# 第五天\n\n1. Java当中如何实现数据共享~\n 1. 使用静态变量完成数据共享\n 2. 使用参数传递完成数据共享\n 3. 使用内部类完成数据共享\n\n2. 为什么要使用内部类？\n\n内部类是Java当中 共享数据最最简单的方式之一\n\n3. 内部类都有哪几种？\n\n成员内部类、静态内部类、局部内部类、匿名内部类\n\n4. 如何自定义异常和如何主动制造异常出现的场景？\n\n * 自定义异常\n   \n   自己写一个类型继承Exception => 非运行时异常\n   自己写一个类型继承RuntimeException => 运行时异常\n\n * 如何主动制造异常出现的场景\n   \n   throw new 异常的类型();\n\n5. throw 和 throws 的区别?\n\n * throw 用在方法体当中\n   \n   在没有异常出现的情况下主动制造异常出现的场景 [没事找事型]\n\n * throws 用在方法签名的最后\n   \n   表明本方法当中出现指定种类的异常 本方法不做处理\n   抛还给调用的上级进行处理 [有事甩锅型]\n\n6. 如何控制线程?\n 1. setPriority(int) : 设置线程优先级别 可选范围 1-10 默认5\n    优先级越高 代表抢到时间片的概率越高\n 2. static sleep(long) : 让当前线程休眠指定的毫秒数\n 3. static yield() : 让当前线程直接放弃时间片返回就绪\n 4. join() : 当前线程邀请另一个线程优先执行\n\n7. 如何解决并发错误?\n * synchronized(临界资源){执行操作}\n * 可重入锁java.util.concurrent.locks.ReentrantLock\n\n8. 如何解决死锁?\n\n * 一块空间 : 等待池\n\n * 三个方法 :\n   \n   1. wait() : 让当前线程放弃已经持有的锁标记 并且进入调用方法那个对象等待池当中\n   2. notify() : 从调用方法的那个对象的等待池当中 随机的唤醒一个线程\n   3. notifyAll() : 从调用方法的那个对象的等待池当中 唤醒所有线程\n\n> 这三个方法不是线程类的 是Object类的\n> 这三个方法必须在已经持有锁标记的前提下才能使用，否则不但失败 还会触发异常\n\n9. 锁池和等待池的区别？\n 1. 进入的时候是否需要释放锁标记\n    * 锁池：不需要 所以可能会造成死锁\n    * 等待池：需要 先释放锁标记才能进入等待池\n 2. 离开的时候是否需要调用方法\n    * 锁池：不需要 只要锁标记再度可用\n    * 等待池：需要 必须要notify() 或 notifyAll()\n 3. 离开之后去往何方：\n    * 锁池：就绪\n    * 等待池：锁池\n\n10. 流的分类?\n\n * 按照方向分：输入流 输出流\n   \n   按照单位分：字节流 字符流\n   \n   按照功能分：节点流 处理流（过滤流、包装流）',normalizedContent:'# 第一天\n\n1. 常用的集合有哪些？\n\nmap接口和collection接口是所有集合框架的父接口：\n\n * collection接口的子接口包括：set接口和list接口；\n * map接口的实现类主要有：hashmap、concurrenthashmap、treemap、hashtable以及properties等；\n * set接口的实现类主要有：hashset、linkedhashset、treeset等；\n * list接口的实现类主要有：arraylist、linkedlist、stack、vector等。\n\n2. 静态变量和成员变量的区别？\n * 所属不同： 静态变量属于类，所以也成为类变量；成员变量属于对象，所有也成为实例变量（对象变量）；\n * 在内存中出现的时间不同： 静态变量只在类创建时加载一次，随着类的加载而加载随着类的消失而消失；成员变量随着对象（也叫实例）的创建而存在，随着对象的消失而消失；\n * 在内存中的位置不同： 静态变量存储于方法区里的静态区，成员变量属于对内存；\n * 调用方式不同： 静态变量可以通过类名调用，也可以通过对象调用；成员变量只能通过对象调用；\n\n3. filter过滤器用过吗？一般用在什么地方？\n * 用过\n * 例如实现servlet，jsp或静态html等文件的拦截，从而实现一些特殊功能。\n * 例如实现url级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。\n\n4. 多线程一般用在什么地方？\n * 多线程的作用：充分利用cpu资源，提高cpu使用率，才用多线程的方式去同时完成几件事情而不相互干扰\n * 用在什么地方：大多情况下，用到多线程主要是需要处理大量的io操作或处理需要耗费大量时间的操作等等。比如：读写文件等。\n\n5. int和integer的区别？\n * integer是int的包装类，而int是java的一种基本数据类型\n * integer是类，必须实例化之后才能使用，而int变量不需要\n * integer的默认值是null，而int的默认值是0\n * integer实际是对象的引用，当new一个integer时，实际上是生成一个指针只想此对象；而int是直接存储数据值\n\n6. 3.2e3f 里面的e/f分别表示什么？\n * e：科学计数法 3.2*10（3）\n * f:表示float类型\n\n7. switch（参数） case的参数可以传哪些数据类型？\n * jdk1.0 char byte short int\n   jdk5.0 enum(枚举)\n   jdk7.0 string\n\n8. do while 和while之间的区别？\n * do while 先执行 然后在判断 保证程序至少执行一次【先斩后奏】\n * while 先判断 符合条件在执行\n\n\n# 第二天\n\n1. list用过哪些？arraylist如何排序？list和set的区别？\n * 用过arraylist、linkedlist、vector\n   \n * 排序：sort()\n\n> list和set的区别：\n> \n>  1. list，set都是继承自collection接口\n>  2. list特点：元素放入有顺序，元素可以重复。\n>     set特点：元素放入无顺序，元素不可重复，重复元素会覆盖。\n>  3. set和list对比：\n>     set：检索元素效率低下，删除和插入效率高，删除和插入不会引起元素位置的改变。\n>     list：和数组类似，list可以动态增长，查找元素效率高，增删元素效率低，因为增删元素会引起其他元素位置的改变。\n\n2. 异常包括什么？说一下什么是运行时异常、非运行时异常，举例说明。\n\n * 异常是指程序运行过程当中出现的例外情况\n   \n   异常的体系结构：\n   \n   graph tb\n   \tthrowable --\x3e error\n   \tthrowable --\x3e exception\n   \texception --\x3e runtimeexception\n   \n   \n   1\n   2\n   3\n   4\n   \n\n异常包括：运行时异常和非运行时异常\n\n * 运行时异常(runtimeexception)：指编译能通过，直到运行的时候才体现出来\n * 非运行时异常(exception)：指在编译的时候必须明确该如何处理，否则根本无法通过编译\n * error：描述了java运行时系统的内部错误或资源耗尽错误。大多数错误与代码编写无关，而表示代码运行时jvm出现的问题。应用程序不应该抛出这种类型的对象。\n\n常见的运行时异常(runtimeexception)有：\n\n 1. indexoutofboundsexception（下标越界异常）\n 2. nullpointerexception（空指针异常）\n 3. numberformatexception（string转换为指定的数字异常）\n 4. arithmeticexception（算术异常，如除数为0）\n 5. filenotfoundexception（文件未找到异常）\n 6. ioexception（操作输入流和输出流时可能出现的异常，如磁盘损坏等）\n\n3. 线程的实现方式\n\n 1. 继承thread类，重写run方法 (其实thread类本身也实现了runnable接口)\n\n 2. 实现runnable接口， 重写run方法。（传入thread类的构造方法中，由thread的start启用线程）\n\n 3. 实现callable接口，重写call方法(有抛出异常和有返回值)\n    \n    通过callable和futuretask创建线程，将callable实现类传入futuretask构造方法中，由futuretask的start方法启用线程\n\n 4. 通过线程池创建线程\n\n4. 怎么处理异常\n * 抛还上级：throws\n * 自行处理：try catch finally\n\n5. 多态的实现机制\n\njava中实现多态的机制靠的是： 父类或接口定义的引用变量可以指向子类或具体的实现类的实例对象，而程序调的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。\n\n> 一句话：父类或接口引用指向具体的实例对象\n\n多态的不同表现形式：方法的重写和重载就是java多态的不同表现\n\n * 重写overriding是父类与子类之间多态的一种表现\n * 重载overloding是一个类中多态的一种表现\n\n6. java简单运算面试题\n\nshort x = 1;\nx = x + 1;//左边short = 右边int？\nsystem.out.println(x);//报错\n\nshort y = 1;\ny += 1;//y = (short)(y + 1); +=会自动转换\nsystem.out.println(y);//2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n7. stringbuffer和stringbuilder之间的区别？\n * stringbuffer和stringbuilder在创建对象的时候 都会多预留16块缓冲区\n\n 1. stringbuffer 同一时间允许一个线程进行访问，效率较低，但是不会出现并发错误\n 2. stringbuilder 同一时间允许多个线程进行访问，效率较高，但是可能会出现并发错误\n\n8. 为什么不把一个类所有的方法全部定义成静态的呢？\n * 静态方法里面只能直接的访问静态成员\n * 如果想要在静态方法里面访问非静态成员的话，需要先创建对象，拿着对象去调用\n\n\n# 第三天\n\n1. &和&&的区别\n\n&和&&都可以作为逻辑运算符使用\n\n&&有短路特性，当通过前面条件能够得知最终表达式结论的话，后面的条件会短路掉不做判断，所以效率更高。&没有短路特性，两边的条件都会进行判断。\n\n另外&还是按位运算符的按位与运算。当&左右两边连接的是整数类型的时候作为二进制按位与运算，也就是将两个数的二进制位都是1的结果写1。\n\n2. final，finally，finalize的区别\n\n * final是一个修饰符，可以用于修饰类、方法、变量\n   \n   修饰类代表最终类，表示不能被继承\n   修饰方法代表最终方法，表示此方法不能被覆盖（但是可以被继承）\n   修饰表示引用地址或值不能被修改\n\n * finally是异常处理的语法结构，表示无论是否出现异常最终都要执行的操作。\n   \n   通常是释放和关闭资源的操作（如数据库连接和文件io流的关闭）\n\n * finalize是object类中的一个方法，表示在gc回收对象之前会调用这个方法\n\n3. string和stringbuffer的区别\n\nstring和stringbuffer都是java当中提供的字符串类型，其中string没有预留缓冲空间，而stringbuffer会在原先内容的基础上预留一部分的缓冲空间。\n\n> string： "a" + "b" 相当于创建了一个新对象，返回值是”ab"。\n> stringbuffer： sbuff.append("b")相当于还是在原先的对象上进行修改值。\n\n4. 请说出你所知道的线程同步的方法\n\n * synchronize修饰符\n   \n   修饰代码块\n   修饰方法\n\n * java.util.concurrent.locks.reentrantlock（并发包中的可重入锁）\n   \n   lock lock = new reentrantlock();\n   其中lock.lock()用于上锁，lock.unlock()用于释放锁\n\n5. 在java中，如何跳出当前的多重循环\n\n 1. break加循环标签，如：\n    \n    example_this:for(int x=0; x<10; x++) {\n        if(...) {\n            break example_this;//结束循环\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 使用return\n\n 3. 使用system.exit(0);结束虚拟机\n\n6. 接口是否可以继承？抽象类时候可以实现接口？抽象类是否可以继承实体类？\n\n接口可以继承接口，而且可以多继承，多个接口之间用,隔开；\n\n抽象类可以实现接口，而且可以暂时不实现接口当中要求的抽象方法，因为抽象类中本身就可以有抽象方法留待子类具体实现；\n\n抽象类可以继承实体类，如果继承的实体类没有默认的无参构造方法，需要写出抽象类的构造方法并在其构造方法的首行使用super()传参来明确指定调用父类的哪个构造方法。\n\n7. 抽象类是类 有构造方法 但是不能创建对象那么要构造方法的作用？\n * 给子类构造方法首行的super去调用的\n\n\n# 第四天\n\n1. ==和equals的区别？\n\n * ==：是一个运算符，用于比较两端的内容是否相等\n   \n   基本数据类型：两端的值是否相等\n   引用类型：内存地址是否相等\n\n * equals：是object类的一个方法。子类继承这个方法之后可以按照自己的逻辑需求覆盖这个方法，从而描述自己的比较规则。 例如：string类就将equals()方法覆盖为比较字符串的内容\n\n2. 怎么解决死锁？\n * wait()，notify()，notifyall()\n\n使用 wait() 让当前线程(a)放弃锁标记进入等待池当中阻塞，从而成全另外的线程(b)能够成功获得它(b)需要的锁标记之后再调用 notify() 或者 notifyall() 唤醒线程(a)，让线程(a)从等待池进入锁池等待获得锁标记\n\n> [注意这三个方法都必须已经持有锁标记才能调用所以他们只能出现在synchronized代码块当中]\n\n3. 线程的生命周期\n\n新生 就绪 运行 消亡 阻塞（等待池 锁池）\n\n4. 线程池\n\n * 可重用的线程池，方法的参数表示同一时间允许多少个线程并发执行，当线程执行完时，线程将被归还给线程池 executors.newfixedthreadpool(2);\n\n * 带缓存机制的线城池，当线程执行完时，线程将被归还给线程池，如果一分钟之内没有其他线程被提交， 线程将会消亡 executors.newcachedthreadpool();\n\n * 单一执行器：同一时间仅允许一条线程执行 executors.newsinglethreadexcutor()\n\n5. 简述jdbc中statement和preparestatement的区别\n 1. 两者同为接口 , preparedstatement是statement的子类\n 2. statement 只能执行静态语句 preparedstatement存在一个强大缓存区，相同的sql语句执行相同语句结构仅仅编译一次，preparedstatement仅对改动数据进行修改而不再进行编译，而statement只要语句发生了改变，则必须重新进行编译\n 3. preparedstatement支持对sql语句使用 ?占位符，杜绝了 sql注入安全隐患\n 4. 如果sql语句不需要多次执行，或者?过多，则效率可能较statement低\n\n6. 简述 execute() executeupdate() executequery() executebatch()的使用场合，返回值?\n\n                  返回类型        使用场合\nexecute()         boolean     执行dql语句返回true，dml语句返回false\nexecuteupdate()   int         执行dml返回更改记录数，dql立刻报错\nexecutequery()    resultset   执行dql语句返回结果集\nexecutebatch()    int[]       只能执行dml语句，返回更改的记录数的数组\n\n\n# 第五天\n\n1. java当中如何实现数据共享~\n 1. 使用静态变量完成数据共享\n 2. 使用参数传递完成数据共享\n 3. 使用内部类完成数据共享\n\n2. 为什么要使用内部类？\n\n内部类是java当中 共享数据最最简单的方式之一\n\n3. 内部类都有哪几种？\n\n成员内部类、静态内部类、局部内部类、匿名内部类\n\n4. 如何自定义异常和如何主动制造异常出现的场景？\n\n * 自定义异常\n   \n   自己写一个类型继承exception => 非运行时异常\n   自己写一个类型继承runtimeexception => 运行时异常\n\n * 如何主动制造异常出现的场景\n   \n   throw new 异常的类型();\n\n5. throw 和 throws 的区别?\n\n * throw 用在方法体当中\n   \n   在没有异常出现的情况下主动制造异常出现的场景 [没事找事型]\n\n * throws 用在方法签名的最后\n   \n   表明本方法当中出现指定种类的异常 本方法不做处理\n   抛还给调用的上级进行处理 [有事甩锅型]\n\n6. 如何控制线程?\n 1. setpriority(int) : 设置线程优先级别 可选范围 1-10 默认5\n    优先级越高 代表抢到时间片的概率越高\n 2. static sleep(long) : 让当前线程休眠指定的毫秒数\n 3. static yield() : 让当前线程直接放弃时间片返回就绪\n 4. join() : 当前线程邀请另一个线程优先执行\n\n7. 如何解决并发错误?\n * synchronized(临界资源){执行操作}\n * 可重入锁java.util.concurrent.locks.reentrantlock\n\n8. 如何解决死锁?\n\n * 一块空间 : 等待池\n\n * 三个方法 :\n   \n   1. wait() : 让当前线程放弃已经持有的锁标记 并且进入调用方法那个对象等待池当中\n   2. notify() : 从调用方法的那个对象的等待池当中 随机的唤醒一个线程\n   3. notifyall() : 从调用方法的那个对象的等待池当中 唤醒所有线程\n\n> 这三个方法不是线程类的 是object类的\n> 这三个方法必须在已经持有锁标记的前提下才能使用，否则不但失败 还会触发异常\n\n9. 锁池和等待池的区别？\n 1. 进入的时候是否需要释放锁标记\n    * 锁池：不需要 所以可能会造成死锁\n    * 等待池：需要 先释放锁标记才能进入等待池\n 2. 离开的时候是否需要调用方法\n    * 锁池：不需要 只要锁标记再度可用\n    * 等待池：需要 必须要notify() 或 notifyall()\n 3. 离开之后去往何方：\n    * 锁池：就绪\n    * 等待池：锁池\n\n10. 流的分类?\n\n * 按照方向分：输入流 输出流\n   \n   按照单位分：字节流 字符流\n   \n   按照功能分：节点流 处理流（过滤流、包装流）',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-Java进阶篇",frontmatter:{title:"Q&A宝典-Java进阶篇",date:"2019-04-15T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_java_002.html",relativePath:"views/qaq/sum_java_002.md",key:"v-5cfc5853",path:"/views/qaq/sum_java_002.html",headers:[{level:2,title:"List和Map",slug:"list和map",normalizedTitle:"list和map",charIndex:2},{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:1029}],headersStr:"List和Map 泛型",content:"# List和Map\n\n1. 接口和抽象类之间的区别？\n\n 1. 分别表示的类型不同\n    \n    接口：interface\n    抽象类：class\n\n 2. 里面定义的属性修饰符不同\n    \n    接口：里面定义的属性默认都是静态的最终变量（public static final）\n    抽象类：里面定义的属性默认是（default）\n\n 3. 里面定义的方法不同\n    \n    接口：里面定义的方法默认都是抽象方法（public abstarct）\n    从 jdk8.0开始 接口里面可以定义普通方法\n    抽象类：里面既可以定义抽象方法 又可以定义普通方法\n\n2. ArrayList和Vector之间的区别？\n\n * Vector：同一时间允许单个线程进行访问 效率较低，但是不会出现并发错误\n   ArrayList：同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误\n\n * 从jdk5.0开始 集合的工具类里面提供一个方法(synchronizedList) 可以将线程不安全的ArrayList对象变成线程安全的集合对象，于是Vector渐渐被淘汰\n\n3. ArrayList和LinkedList之间的区别？\n\n * ArrayList：底层基于数组实现的\n   \n   优点：随机访问 遍历查找效率高\n   缺点：添加/删除元素\n\n * LinkedList：底层基于链表实现的\n   \n   优点：添加/删除元素效率高\n   缺点：随机访问/遍历查找效率低\n\n * *：当正常开发的时候 尽量避免使用LinkedList里面的get(下标)方法\n\n4. HashMap和Hashtable之间的区别？\n\n 1. 同步特性不同：\n    \n    * HashMap 同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误\n    * Hashtable 同一时间允许一个线程进行访问 效率较低，但是不会出现并发错误\n    * 从jdk5.0开始，集合的工具类里面提供一个方法（synchronizedList） 可以将线程不安全的HashMap对象变成线程安全的集合对象\n\n 2. 对null的要求不同\n    \n    * HashMap无论主键还是值都可以存放null，但是由于主键唯一 所以主键只能添加一个null\n    * Hashtable无论主键还是值都不能装null，一旦泛型里面装null 都会触发NullPointerException\n\n 3. 底层分组不同：\n    \n    * HashMap底层数组大小默认为16，程序员可以随意的定义，但是最终一定是2的n次方数\n    * Hashtable底层数组大小默认为11，程序员可以随意定义\n\n 4. 出现的版本不同\n    \n    * Hashtable：since jdk1.0\n    * HashMap：since jdk1.2\n\n5. hashmap 红黑树\n\n * 负载因子，代表了table的填充度有多少，默认是0.75\n   \n   加载因子存在的原因，还是因为减缓哈希冲突，提高查询效率。如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。 所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。\n\n * 为何HashMap的数组长度一定是2的次幂（减少hash碰撞）\n   \n   扩容时需要重新计算数组索引index = h&(length-1)，需要进行大量的与运算，保证2的次幂，可以保证在进行与运算时，(length-1)的值的二进制所有的位均为1，这种情况下，Index的结果等于hashCode的最后几位。只要输入的hashCode本身符合均匀分布，Hash算法的结果就是均匀的。\n\n\n# 泛型\n\n1. 泛型中的通配符 T，E，K，V，？\n\n本质上这些个都是通配符，没啥区别，换成 A-Z 之间的任何一个 字母都可以。\n通常情况下，T，E，K，V，？ 是这样约定的：\n\n * ？ 表示不确定的 java 类型\n * T (type) 表示具体的一个java类型\n * K V (key value) 分别代表java键值中的Key Value\n * E (element) 代表Element\n\n> 可参考：掘金",normalizedContent:"# list和map\n\n1. 接口和抽象类之间的区别？\n\n 1. 分别表示的类型不同\n    \n    接口：interface\n    抽象类：class\n\n 2. 里面定义的属性修饰符不同\n    \n    接口：里面定义的属性默认都是静态的最终变量（public static final）\n    抽象类：里面定义的属性默认是（default）\n\n 3. 里面定义的方法不同\n    \n    接口：里面定义的方法默认都是抽象方法（public abstarct）\n    从 jdk8.0开始 接口里面可以定义普通方法\n    抽象类：里面既可以定义抽象方法 又可以定义普通方法\n\n2. arraylist和vector之间的区别？\n\n * vector：同一时间允许单个线程进行访问 效率较低，但是不会出现并发错误\n   arraylist：同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误\n\n * 从jdk5.0开始 集合的工具类里面提供一个方法(synchronizedlist) 可以将线程不安全的arraylist对象变成线程安全的集合对象，于是vector渐渐被淘汰\n\n3. arraylist和linkedlist之间的区别？\n\n * arraylist：底层基于数组实现的\n   \n   优点：随机访问 遍历查找效率高\n   缺点：添加/删除元素\n\n * linkedlist：底层基于链表实现的\n   \n   优点：添加/删除元素效率高\n   缺点：随机访问/遍历查找效率低\n\n * *：当正常开发的时候 尽量避免使用linkedlist里面的get(下标)方法\n\n4. hashmap和hashtable之间的区别？\n\n 1. 同步特性不同：\n    \n    * hashmap 同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误\n    * hashtable 同一时间允许一个线程进行访问 效率较低，但是不会出现并发错误\n    * 从jdk5.0开始，集合的工具类里面提供一个方法（synchronizedlist） 可以将线程不安全的hashmap对象变成线程安全的集合对象\n\n 2. 对null的要求不同\n    \n    * hashmap无论主键还是值都可以存放null，但是由于主键唯一 所以主键只能添加一个null\n    * hashtable无论主键还是值都不能装null，一旦泛型里面装null 都会触发nullpointerexception\n\n 3. 底层分组不同：\n    \n    * hashmap底层数组大小默认为16，程序员可以随意的定义，但是最终一定是2的n次方数\n    * hashtable底层数组大小默认为11，程序员可以随意定义\n\n 4. 出现的版本不同\n    \n    * hashtable：since jdk1.0\n    * hashmap：since jdk1.2\n\n5. hashmap 红黑树\n\n * 负载因子，代表了table的填充度有多少，默认是0.75\n   \n   加载因子存在的原因，还是因为减缓哈希冲突，提高查询效率。如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。 所以加载因子默认为0.75，也就是说大小为16的hashmap，到了第13个元素，就会扩容成32。\n\n * 为何hashmap的数组长度一定是2的次幂（减少hash碰撞）\n   \n   扩容时需要重新计算数组索引index = h&(length-1)，需要进行大量的与运算，保证2的次幂，可以保证在进行与运算时，(length-1)的值的二进制所有的位均为1，这种情况下，index的结果等于hashcode的最后几位。只要输入的hashcode本身符合均匀分布，hash算法的结果就是均匀的。\n\n\n# 泛型\n\n1. 泛型中的通配符 t，e，k，v，？\n\n本质上这些个都是通配符，没啥区别，换成 a-z 之间的任何一个 字母都可以。\n通常情况下，t，e，k，v，？ 是这样约定的：\n\n * ？ 表示不确定的 java 类型\n * t (type) 表示具体的一个java类型\n * k v (key value) 分别代表java键值中的key value\n * e (element) 代表element\n\n> 可参考：掘金",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-试炼篇",frontmatter:{title:"Q&A宝典-试炼篇",date:"2019-01-31T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_ms_001.html",relativePath:"views/qaq/sum_ms_001.md",key:"v-10c74a0d",path:"/views/qaq/sum_ms_001.html",headers:[{level:2,title:"java基础知识",slug:"java基础知识",normalizedTitle:"java基础知识",charIndex:26},{level:2,title:"集合框架",slug:"集合框架",normalizedTitle:"集合框架",charIndex:167},{level:2,title:"多线程",slug:"多线程",normalizedTitle:"多线程",charIndex:351},{level:2,title:"jvm",slug:"jvm",normalizedTitle:"jvm",charIndex:858},{level:2,title:"框架相关问题",slug:"框架相关问题",normalizedTitle:"框架相关问题",charIndex:1086},{level:2,title:"消息中间件",slug:"消息中间件",normalizedTitle:"消息中间件",charIndex:1356},{level:2,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:1188},{level:2,title:"数据库",slug:"数据库",normalizedTitle:"数据库",charIndex:1620},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1814}],excerpt:"<Boxx/>\n<p>此为试炼篇，欲知后事如何，且看下篇分解！！</p>\n",headersStr:"java基础知识 集合框架 多线程 jvm 框架相关问题 消息中间件 缓存 数据库 其他",content:"此为试炼篇，欲知后事如何，且看下篇分解！！\n\n\n# java基础知识\n\n 1. 栈和队列的区别\n 2. 接口和抽象类的区别\n 3. int和Integer的区别\n 4. 常量池的问题\n 5. ==和equals的区别\n 6. 重载和重写的区别\n 7. String和StringBuilder、StringBuffer的区别\n\n\n# 集合框架\n\n 1. ArrayList,LinkedList,HashMap,LinkedHashMap,ConcurrentHashMap的底层实现原理\n 2. 1.7版本和1.8版本的HashMap的区别\n 3. 1.7版本和1.8版本的ConcurrentHashMap的区别\n 4. HashMap能不能排序？HashMap的长度为什么要是2的幂次方\n\n\n# 多线程\n\n 1.  创建线程的几种方式？wait,sleep分别是谁的方法，区别？线程间的通信方式？\n 2.  介绍下什么是死锁，遇见过死锁吗？你是怎么排查的（可以通过jps排查）\n 3.  创建线程池的几种方式，线程池有什么好处\n 4.  线程继承和接口的区别，接口有什么好处\n 5.  synchronized、Lock、ReentrantLock的区别，用法及原理\n 6.  CountDownLatch与CyclicBarrier用法\n 7.  ThreadLocal的用法和原理\n 8.  volatile关键字的作用和原理\n 9.  乐观锁和悲观锁\n 10. 对公平锁，非公平锁，可重入锁，自旋锁，读写锁的理解\n 11. CAS是什么及基层原理\n 12. ArrayBlockQueue，LinkedBlockingQueue，SynchronousQueue等等阻塞队列的理解\n 13. ThreadPoolExecutor的传入参数及内部工作原理\n 14. 给你一个具体的业务场景，让你使用ThreadPoolExecutor创建一个合适的线程池\n 15. 分布式环境下，怎么保证线程安全\n\n\n# jvm\n\n 1. JVM内存机制\n 2. 介绍下垃圾收集机制，垃圾收集有哪些算法，各自的特点\n 3. 聊聊GC，谈谈Major GC，Full GC区别，垃圾收集器有哪些，他们的区别\n 4. OutOfMemoryError这个错误你遇到过吗，你是怎么解决处理的\n 5. JVM调优有哪些参数，介绍下，线上环境上，你是怎么查看JVM的参数并进行调优的\n 6. 能不能自己写一个类叫java. lang. String(类加载的过程，双亲委派模型)\n\n\n# 框架相关问题\n\n 1. Spring用了哪些设计模式？Spring注入bean的方式？对SpringIOC和SpringAOP的理解\n 2. Spring事务的隔离机制和传播机制\n 3. Mybatis的缓存机制（一级缓存和二级缓存），Mybatis的mapper文件中#和$的区别\n 4. SpringMVC的流程\n 5. Spring和SpringBoot的区别\n 6. 对SpringBoot的理解\n 7. RPC框架有哪些，他们的区别\n 8. Dubbo的使用和理解\n 9. SprigCloud的使用和组件，谈谈你得理解\n\n\n# 消息中间件\n\n 1. 你们公司是如何进行消息中间件的技术选型\n 2. 如何保证消息中间件的高可用\n 3. 如何保证消息中间件重复发送消息\n 4. 消息队列积压了大量的消息，你该怎么处理\n 5. 如何保证消费者消费消极是有顺序的\n 6. 让你来开发一个消息中间件，你会怎么架构\n\n\n# 缓存\n\n 1. 你们公司为什么要使用Redis，Redis有几种数据类型\n 2. Redis持久化机制，Redis的过期策略\n 3. 怎么保证Redis的高可用\n 4. 什么是缓存穿透，如何避免，什么是缓存雪崩，如何避免\n 5. 如何保证缓存与数据库的读写一致性\n 6. Redis单线程模型原理，为什么能支撑高并发\n 7. Redis哨兵架构的理解和底层原理\n\n\n# 数据库\n\n 1. 工作中你是怎么优化sql的\n 2. 什么情况下，索引会失效\n 3. 数据库的存储引擎，比如：MySQL的MyISAM和InnoDB区别\n 4. 索引的最左原则\n 5. 索引的底层原理\n 6. 你们公司是怎么进行分库分表，分库分表的方案\n\n\n# 其他\n\n 1. 分布式事务是怎么解决的\n 2. 分布式session方案\n 3. 设计一个秒杀场景\n 4. 怎么防止表单多次提交\n 5. Linux的基本操作命令\n 6. ElasticSearch的使用和原理\n 7. zookeeper的使用和原理",normalizedContent:"此为试炼篇，欲知后事如何，且看下篇分解！！\n\n\n# java基础知识\n\n 1. 栈和队列的区别\n 2. 接口和抽象类的区别\n 3. int和integer的区别\n 4. 常量池的问题\n 5. ==和equals的区别\n 6. 重载和重写的区别\n 7. string和stringbuilder、stringbuffer的区别\n\n\n# 集合框架\n\n 1. arraylist,linkedlist,hashmap,linkedhashmap,concurrenthashmap的底层实现原理\n 2. 1.7版本和1.8版本的hashmap的区别\n 3. 1.7版本和1.8版本的concurrenthashmap的区别\n 4. hashmap能不能排序？hashmap的长度为什么要是2的幂次方\n\n\n# 多线程\n\n 1.  创建线程的几种方式？wait,sleep分别是谁的方法，区别？线程间的通信方式？\n 2.  介绍下什么是死锁，遇见过死锁吗？你是怎么排查的（可以通过jps排查）\n 3.  创建线程池的几种方式，线程池有什么好处\n 4.  线程继承和接口的区别，接口有什么好处\n 5.  synchronized、lock、reentrantlock的区别，用法及原理\n 6.  countdownlatch与cyclicbarrier用法\n 7.  threadlocal的用法和原理\n 8.  volatile关键字的作用和原理\n 9.  乐观锁和悲观锁\n 10. 对公平锁，非公平锁，可重入锁，自旋锁，读写锁的理解\n 11. cas是什么及基层原理\n 12. arrayblockqueue，linkedblockingqueue，synchronousqueue等等阻塞队列的理解\n 13. threadpoolexecutor的传入参数及内部工作原理\n 14. 给你一个具体的业务场景，让你使用threadpoolexecutor创建一个合适的线程池\n 15. 分布式环境下，怎么保证线程安全\n\n\n# jvm\n\n 1. jvm内存机制\n 2. 介绍下垃圾收集机制，垃圾收集有哪些算法，各自的特点\n 3. 聊聊gc，谈谈major gc，full gc区别，垃圾收集器有哪些，他们的区别\n 4. outofmemoryerror这个错误你遇到过吗，你是怎么解决处理的\n 5. jvm调优有哪些参数，介绍下，线上环境上，你是怎么查看jvm的参数并进行调优的\n 6. 能不能自己写一个类叫java. lang. string(类加载的过程，双亲委派模型)\n\n\n# 框架相关问题\n\n 1. spring用了哪些设计模式？spring注入bean的方式？对springioc和springaop的理解\n 2. spring事务的隔离机制和传播机制\n 3. mybatis的缓存机制（一级缓存和二级缓存），mybatis的mapper文件中#和$的区别\n 4. springmvc的流程\n 5. spring和springboot的区别\n 6. 对springboot的理解\n 7. rpc框架有哪些，他们的区别\n 8. dubbo的使用和理解\n 9. sprigcloud的使用和组件，谈谈你得理解\n\n\n# 消息中间件\n\n 1. 你们公司是如何进行消息中间件的技术选型\n 2. 如何保证消息中间件的高可用\n 3. 如何保证消息中间件重复发送消息\n 4. 消息队列积压了大量的消息，你该怎么处理\n 5. 如何保证消费者消费消极是有顺序的\n 6. 让你来开发一个消息中间件，你会怎么架构\n\n\n# 缓存\n\n 1. 你们公司为什么要使用redis，redis有几种数据类型\n 2. redis持久化机制，redis的过期策略\n 3. 怎么保证redis的高可用\n 4. 什么是缓存穿透，如何避免，什么是缓存雪崩，如何避免\n 5. 如何保证缓存与数据库的读写一致性\n 6. redis单线程模型原理，为什么能支撑高并发\n 7. redis哨兵架构的理解和底层原理\n\n\n# 数据库\n\n 1. 工作中你是怎么优化sql的\n 2. 什么情况下，索引会失效\n 3. 数据库的存储引擎，比如：mysql的myisam和innodb区别\n 4. 索引的最左原则\n 5. 索引的底层原理\n 6. 你们公司是怎么进行分库分表，分库分表的方案\n\n\n# 其他\n\n 1. 分布式事务是怎么解决的\n 2. 分布式session方案\n 3. 设计一个秒杀场景\n 4. 怎么防止表单多次提交\n 5. linux的基本操作命令\n 6. elasticsearch的使用和原理\n 7. zookeeper的使用和原理",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-spring基础篇",frontmatter:{title:"Q&A宝典-spring基础篇",date:"2019-12-29T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_spring_002.html",relativePath:"views/qaq/sum_spring_002.md",key:"v-3b409fbd",path:"/views/qaq/sum_spring_002.html",headers:[{level:2,title:"Spring基础",slug:"spring基础",normalizedTitle:"spring基础",charIndex:2},{level:2,title:"SpringMVC",slug:"springmvc",normalizedTitle:"springmvc",charIndex:2945}],headersStr:"Spring基础 SpringMVC",content:'# Spring基础\n\n1. Spring两大核心？\n\nIOC控制反转， AOP面向切面编程\n\n2. IOC控制反转到底反转了什么？\n\n创建对象的过程，形成对象与对象之间依赖关系的操作\n(Martin: 依赖对象的获得被反转了，本来应该是我们自己new， 现在是通过SpringIOC容器注入)\n\n3. 什么是AOP？\n\nAOP即面向切面编程，关注的是非核心业务的处理\n用到的地方：比如日志、网站的访问次数等\n主要目的:：核心业务和非核心业务之间的解耦\n底层使用了动态代理模式\n要素：advice(非核心业务的载体)， pointcut(非核心业务的放置位置)， advisor(建立advice和pointcut之间的联系)\n\n4. 反转之后的好处？\n\n有助于类与类之间的解耦\n\n5. IOC的好处？\n\n将对象的创建和属性的赋值完全转交给Spring， 从而降低类与类之间的依赖关系，达到松散耦合的目的\n\n6. ICO的核心？\n\nIOC容器之所以叫IOC容器， 是因为其中的IOC指的是将主动new变成了被动注入\n从此角度出发， IOC的核心是DI依赖注入\n\n7. DI是什么？\n\n依赖注入，指的是建立每个对象之间关系的方式，也就是对属性赋值的操作\n\n8. Bean的属性都有？\n\nid：(每个IOC容器对象的唯一标识)，\nclass：(当前类对应的类型)，\nscope：(作用范围)，\nlazy-init：(是否 延迟加载)，\nfactory-method：(指定返回返回该对象的方法名称)，\nfactory-bean：(指定工厂实例)，\ninit-method：(对象初始化调用的方法)，\ndestroy-method\n\n9. scope分别有几种情况？如何配置？\n\n * singleton，prototype，request，session，globalSession\n\n * 一般无状态的类的对象都配置成singleton，无状态的类一般指像Service和Dao层这样逻辑处理类\n   有状态的类需要设置成prototype或request，一般指像Action一样存在多实例， 并且其中数据都不同\n\n10. Spring创建对象的方式？\n 1. 构造方法创建(id+class)；\n 2. 静态工厂创建(class+factory-method)；\n 3. 实例工厂创建(factory-bean+factory-method)\n\n11. 完成注入的方式？\n 1. setter注入 <property ...>\n 2. 构造方法注入 <constructor-arg ...>\n\n12. Schema是什么？优势？\n\n * 用来校验xml文件规范的xsd的文件\n   \n   1. 基于xml语法\n   2. 扩充了数据类型\n   3. 支持命名空间\n   * schema最重要的能力之一就是对数据类型的支持\n\n13. 复杂属性如何注入？\n * 数组/List/Set\n   <property><array/list/set><value>value</value>\n * Map\n   <map><entry key="" value=""/>\n * Properties\n   <props><prop key="">vlaue</prop>\n\n14. 常用Spring注解？\n\n@Component， @Repository， @Service， @Controller @Autowired， @Qualifier， @Scope，@Value @Aspect， @Pointcut， @Before， @After， @AfterReturning， @Around， @AfterThrowing\n\n15. 接受文件:\n\n@RequestParam(value="file") MultipartFile file\n\n16. 关于日期、时间\n * 映射类声明变量前，加入此注解:\n   1. @DatetimeFormat是将String转换成Date，一般前台给后台传值时用(springmvc用)\n   2. 将Date转换成String 一般后台传值给前台时设置响应方式为 @JsonFormat(pattern="yyyy-MM-dd")\n   3. @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss"，timezone = "GMT+8")\n      只争对json响应式的处理(中国为东8区)\n   4. @JsonIgnore json响应式忽略这个属性 private Date hiredate;\n\n17. 使用注解完成IOC的流程？\n 1. 添加context命名空间以及schemaLocation\n 2. 配置文件中添加上下文组件扫描<context:component-scan base-package="com"/>\n 3. 给所有需要放入IOC容器中的组件添加注解@Component/@S../@C../@R../@Scope\n 4. 给所有需要注入的属性添加注解@Autowired或@Resource\n\n18. @Resource和@Autowired的区别？\n 1. 来源不同\n    @Autowired来自Spring类库中，@Resource是J2EE官方类库中的\n 2. 底层匹配机制不同\n    @Autowired优先按照类型进行匹配，如果存在一个接口多个实现类， 再去按照属性名匹配， 如果匹配不到，抛出异常NoUniqueBeanDefinitionException， 此时，可通过 Qualifier("对象名") 指定注入对象\n    @Resource优先按照属性名进行匹配，如果匹配不到，再去按照类型进行匹配， 如果匹配到多个类型，抛出异常NoUniqueBeanDefinitionException 此时，可通过 @Resource(name="对象名") 指定注入对象\n\n19. 反射涉及到哪些类？分别对应哪些方法？\n * Class：太多， 比如getDeclaredConstructors()， c.newInstance()\n * Field： get(obj)，set(obj,value)\n * Method： invoke(obj, a.class, b.class, ...)\n * Constructor： newInstance(a.class, b.class ...)，setAccessible(true)\n\n20. 常用设计模式？\n\n单例模式， 工厂模式， 观察者模式(监听器)， 装饰者模式(包装流)， 代理模式(AOP)\n\n21. spring有几种通知(增强)？\n 1. 前置通知 before\n 2. 后置通知 after afterReturnning\n 3. 环绕通知 aroud\n 4. 异常通知 throws\n\n22. 都有哪几种动态代理？\n * jdk 依赖接口\n * cglib 继承关系\n\n\n# SpringMVC\n\n1、什么是Spring MVC ？简单介绍下你对springMVC的理解?\n\nSpring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架，它是Spring的一个模块,无需中间整合层来整合。\n\n它和Struts2一样都属于表现层框架。在web模型中，MVC是一种很流行的框架，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。\n\n2、SpringMVC的流程？\n\n（1）用户发送请求至前端控制器 DispatcherServlet；\n\n（2） DispatcherServlet收到请求后，调用 HandlerMapping 处理器映射器，请求获取Handle；\n\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；\n\n（4）DispatcherServlet通过 HandlerAdapter 处理器适配器调用处理器；\n\n（5）执行处理器(Handler，也叫后端控制器)；\n\n（6）Handler执行完成返回ModelAndView；\n\n（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；\n\n（8）DispatcherServlet将ModelAndView传给 ViewReslover 视图解析器进行解析；\n\n（9）ViewReslover解析后返回具体View；\n\n（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）\n\n（11）DispatcherServlet响应用户。\n\n3、Springmvc的优点:\n\n（1）它是基于组件技术的。全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件，并且和Spring提供的其他基础结构紧密集成\n\n（2）不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于Servlet的)\n\n（3）可以任意使用各种视图技术，而不仅仅局限于JSP\n\n（4）支持各种请求资源的映射策略\n\n（5）它应是易于扩展的\n\n4、Spring MVC的主要组键？\n\n（1）前端控制器DispatcherServlet（不需要程序员开发）\n\n作用：接收请求、响应结果 相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。\n\n（2）处理器映射器HandlerMapping（不需要程序员开发）\n\n作用：根据请求的URL来查找Handler\n\n（3）处理器适配器HandlerAdapter\n\n注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。\n\n（4）处理器Handler（需要程序员开发）\n\n（5）视图解析器 ViewResolver（不需要程序员开发）\n\n作用：进行视图的解析 根据视图逻辑名解析成真正的视图（view）\n\n（6）视图View（需要程序员开发jsp）\n\nView是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）\n\n5、springMVC和struts2的区别有哪些?\n\n（1）入口不同：springmvc的入口是一个servlet即前端控制器（DispatchServlet）\nstruts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。\n\n（2）实现方式不同：springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)\nstruts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\n\n（3）参数解析不同：Struts采用值栈存储请求和响应的数据，通过OGNL存取数据\nspringmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。\n\n6、SpringMVC怎么样设定重定向和转发的？\n\n（1）在返回值前面加"forward:"就可以让结果转发,譬如"forward:user.do?name=method4"\n\n（2）在返回值前面加"redirect:"就可以让返回值重定向,譬如"redirect:http://www.baidu.com"\n\n7、SpringMvc怎么和AJAX相互调用的？\n\n通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：\n\n（1）加入Jackson.jar\n\n（2）在配置文件中配置json的映射\n\n（3）在接受Ajax的方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。\n\n8、SpringMvc里面拦截器是怎么写的：\n\n有两种写法,一种是实现HandlerInterceptor接口,另外一种是继承适配器类,接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可:\n\n\x3c!-- 配置SpringMvc的拦截器 --\x3e\n<mvc:interceptors>\n\t\n    \x3c!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --\x3e\n\t<bean id="myInterceptor" class="com.abc.action.MyHandlerInterceptor"></bean>\n\t\n    \x3c!-- 只针对部分请求拦截 --\x3e\n\t<mvc:interceptor>\n    \t<mvc:mapping path="/modelMap.do" />\n\t\t<bean class="com.abc.action.MyHandlerInterceptorAdapter" />\n\t</mvc:interceptor>\n\n</mvc:interceptors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n9、如何解决POST请求中文乱码问题，GET的又如何处理呢？\n\n（1）解决post请求乱码问题：\n\n在web.xml中加入：\n\n<filter>\n\n  <filter-name>CharacterEncodingFilter</filter-name>\n\n  <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\n  <init-param>\n\n    <param-name>encoding</param-name>\n\n    <param-value>utf-8</param-value>\n\n  </init-param>\n\n</filter>\n\n<filter-mapping>\n\n  <filter-name>CharacterEncodingFilter</filter-name>\n\n  <url-pattern>/*</url-pattern>\n\n</filter-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n（2）解决get请求中文参数出现乱码解决方法有两个：\n\n①修改tomcat配置文件添加编码与工程编码一致，如下：\n\n<ConnectorURIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/>\n\n②另外一种方法对参数进行重新编码：\n\nString userName = new String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8")\n\nISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。\n\n10、Spring MVC的异常处理 ？\n\n可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。\n\n11、SpringMvc的核心入口类是什么,Struts1,Struts2的分别是什么：\n\nSpringMvc的是DispatchServlet\n\nStruts1的是ActionServlet\n\nStruts2的是StrutsPrepareAndExecuteFilter\n\n12、SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n\n是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。\n\n13、SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？\n\n一般用@Conntroller注解,表示是表现层,不能用用别的注解代替。\n\n14、 @RequestMapping注解用在类上面有什么作用？\n\n是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n15、怎么样把某个请求映射到特定的方法上面？\n\n直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径。\n\n16、如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？\n\n可以在@RequestMapping注解里面加上method=RequestMethod.GET。\n\n17、怎么样在方法里面得到Request,或者Session？\n\n直接在方法的形参中声明request,SpringMvc就自动把request对象传入。\n\n18、如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\n\n直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。\n\n19、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n\n直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。\n\n20、SpringMvc中函数的返回值是什么？\n\n返回值可以有很多类型,有String, ModelAndView，但一般用String比较好。\n\n21、SpringMvc用什么对象从后台向前台传递数据的？\n 1. 使用Map、Model和ModelMap的方式\n\n@RequestMapping("/test")\npublic String test(Map<String,Object> map,Model model,ModelMap modelMap,HttpServletRequest request){\n    //1.放在map里  \n    map.put("names", Arrays.asList("caoyc","zhh","cjx"));\n    //2.放在model里 建议使用\n    model.addAttribute("time", new Date());\n    //3.放在request里  \n    request.setAttribute("request", "requestValue");\n    //4.放在modelMap中 \n    modelMap.addAttribute("city", "ChengDu");\n    modelMap.put("gender", "male");\n    return "hello";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nJSP写法:\n\ntime:${requestScope.time}\nnames:${requestScope.names }\ncity:${requestScope.city }\ngender:${requestScope.gender }\nrequest:${requestScope.request}\n\n\n1\n2\n3\n4\n5\n\n 2. 使用ModelAndView的方式:\n\n@RequestMapping(value="/test2.do",method = RequestMethod.POST)  \npublic ModelAndView checknameIsExist2(@RequestParam("sid") String sid,Model model,HttpServletRequest request) {  \n    ModelAndView mav = new ModelAndView();  \n    mav.addObject("ModelAndView", "ModelAndViewValue");  \n    //设置要跳转的页面，与返回值时String时返回success类似，以下跳转到/student/studentList.jsp  \n    mav.setViewName("/student/studentList");  \n    return mav;  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n22、SpringMvc中有个类把视图和数据都合并的一起的,叫什么？\n\n叫ModelAndView。\n\n23、怎么样把ModelMap里面的数据放入Session里面？\n\n可以在类上面加上 @SessionAttributes 注解,里面包含的字符串就是要放入session里面的key。\n\n24、当一个方法向AJAX返回特殊对象,譬如Object,List等,需要做什么处理？\n\n要加上 @ResponseBody 注解。',normalizedContent:'# spring基础\n\n1. spring两大核心？\n\nioc控制反转， aop面向切面编程\n\n2. ioc控制反转到底反转了什么？\n\n创建对象的过程，形成对象与对象之间依赖关系的操作\n(martin: 依赖对象的获得被反转了，本来应该是我们自己new， 现在是通过springioc容器注入)\n\n3. 什么是aop？\n\naop即面向切面编程，关注的是非核心业务的处理\n用到的地方：比如日志、网站的访问次数等\n主要目的:：核心业务和非核心业务之间的解耦\n底层使用了动态代理模式\n要素：advice(非核心业务的载体)， pointcut(非核心业务的放置位置)， advisor(建立advice和pointcut之间的联系)\n\n4. 反转之后的好处？\n\n有助于类与类之间的解耦\n\n5. ioc的好处？\n\n将对象的创建和属性的赋值完全转交给spring， 从而降低类与类之间的依赖关系，达到松散耦合的目的\n\n6. ico的核心？\n\nioc容器之所以叫ioc容器， 是因为其中的ioc指的是将主动new变成了被动注入\n从此角度出发， ioc的核心是di依赖注入\n\n7. di是什么？\n\n依赖注入，指的是建立每个对象之间关系的方式，也就是对属性赋值的操作\n\n8. bean的属性都有？\n\nid：(每个ioc容器对象的唯一标识)，\nclass：(当前类对应的类型)，\nscope：(作用范围)，\nlazy-init：(是否 延迟加载)，\nfactory-method：(指定返回返回该对象的方法名称)，\nfactory-bean：(指定工厂实例)，\ninit-method：(对象初始化调用的方法)，\ndestroy-method\n\n9. scope分别有几种情况？如何配置？\n\n * singleton，prototype，request，session，globalsession\n\n * 一般无状态的类的对象都配置成singleton，无状态的类一般指像service和dao层这样逻辑处理类\n   有状态的类需要设置成prototype或request，一般指像action一样存在多实例， 并且其中数据都不同\n\n10. spring创建对象的方式？\n 1. 构造方法创建(id+class)；\n 2. 静态工厂创建(class+factory-method)；\n 3. 实例工厂创建(factory-bean+factory-method)\n\n11. 完成注入的方式？\n 1. setter注入 <property ...>\n 2. 构造方法注入 <constructor-arg ...>\n\n12. schema是什么？优势？\n\n * 用来校验xml文件规范的xsd的文件\n   \n   1. 基于xml语法\n   2. 扩充了数据类型\n   3. 支持命名空间\n   * schema最重要的能力之一就是对数据类型的支持\n\n13. 复杂属性如何注入？\n * 数组/list/set\n   <property><array/list/set><value>value</value>\n * map\n   <map><entry key="" value=""/>\n * properties\n   <props><prop key="">vlaue</prop>\n\n14. 常用spring注解？\n\n@component， @repository， @service， @controller @autowired， @qualifier， @scope，@value @aspect， @pointcut， @before， @after， @afterreturning， @around， @afterthrowing\n\n15. 接受文件:\n\n@requestparam(value="file") multipartfile file\n\n16. 关于日期、时间\n * 映射类声明变量前，加入此注解:\n   1. @datetimeformat是将string转换成date，一般前台给后台传值时用(springmvc用)\n   2. 将date转换成string 一般后台传值给前台时设置响应方式为 @jsonformat(pattern="yyyy-mm-dd")\n   3. @jsonformat(pattern = "yyyy-mm-dd hh:mm:ss"，timezone = "gmt+8")\n      只争对json响应式的处理(中国为东8区)\n   4. @jsonignore json响应式忽略这个属性 private date hiredate;\n\n17. 使用注解完成ioc的流程？\n 1. 添加context命名空间以及schemalocation\n 2. 配置文件中添加上下文组件扫描<context:component-scan base-package="com"/>\n 3. 给所有需要放入ioc容器中的组件添加注解@component/@s../@c../@r../@scope\n 4. 给所有需要注入的属性添加注解@autowired或@resource\n\n18. @resource和@autowired的区别？\n 1. 来源不同\n    @autowired来自spring类库中，@resource是j2ee官方类库中的\n 2. 底层匹配机制不同\n    @autowired优先按照类型进行匹配，如果存在一个接口多个实现类， 再去按照属性名匹配， 如果匹配不到，抛出异常nouniquebeandefinitionexception， 此时，可通过 qualifier("对象名") 指定注入对象\n    @resource优先按照属性名进行匹配，如果匹配不到，再去按照类型进行匹配， 如果匹配到多个类型，抛出异常nouniquebeandefinitionexception 此时，可通过 @resource(name="对象名") 指定注入对象\n\n19. 反射涉及到哪些类？分别对应哪些方法？\n * class：太多， 比如getdeclaredconstructors()， c.newinstance()\n * field： get(obj)，set(obj,value)\n * method： invoke(obj, a.class, b.class, ...)\n * constructor： newinstance(a.class, b.class ...)，setaccessible(true)\n\n20. 常用设计模式？\n\n单例模式， 工厂模式， 观察者模式(监听器)， 装饰者模式(包装流)， 代理模式(aop)\n\n21. spring有几种通知(增强)？\n 1. 前置通知 before\n 2. 后置通知 after afterreturnning\n 3. 环绕通知 aroud\n 4. 异常通知 throws\n\n22. 都有哪几种动态代理？\n * jdk 依赖接口\n * cglib 继承关系\n\n\n# springmvc\n\n1、什么是spring mvc ？简单介绍下你对springmvc的理解?\n\nspring mvc是一个基于mvc架构的用来简化web应用程序开发的应用开发框架，它是spring的一个模块,无需中间整合层来整合。\n\n它和struts2一样都属于表现层框架。在web模型中，mvc是一种很流行的框架，通过把model，view，controller分离，把较为复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。\n\n2、springmvc的流程？\n\n（1）用户发送请求至前端控制器 dispatcherservlet；\n\n（2） dispatcherservlet收到请求后，调用 handlermapping 处理器映射器，请求获取handle；\n\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给dispatcherservlet；\n\n（4）dispatcherservlet通过 handleradapter 处理器适配器调用处理器；\n\n（5）执行处理器(handler，也叫后端控制器)；\n\n（6）handler执行完成返回modelandview；\n\n（7）handleradapter将handler执行结果modelandview返回给dispatcherservlet；\n\n（8）dispatcherservlet将modelandview传给 viewreslover 视图解析器进行解析；\n\n（9）viewreslover解析后返回具体view；\n\n（10）dispatcherservlet对view进行渲染视图（即将模型数据填充至视图中）\n\n（11）dispatcherservlet响应用户。\n\n3、springmvc的优点:\n\n（1）它是基于组件技术的。全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件，并且和spring提供的其他基础结构紧密集成\n\n（2）不依赖于servlet api(目标虽是如此,但是在实现的时候确实是依赖于servlet的)\n\n（3）可以任意使用各种视图技术，而不仅仅局限于jsp\n\n（4）支持各种请求资源的映射策略\n\n（5）它应是易于扩展的\n\n4、spring mvc的主要组键？\n\n（1）前端控制器dispatcherservlet（不需要程序员开发）\n\n作用：接收请求、响应结果 相当于转发器，有了dispatcherservlet 就减少了其它组件之间的耦合度。\n\n（2）处理器映射器handlermapping（不需要程序员开发）\n\n作用：根据请求的url来查找handler\n\n（3）处理器适配器handleradapter\n\n注意：在编写handler的时候要按照handleradapter要求的规则去编写，这样适配器handleradapter才可以正确的去执行handler。\n\n（4）处理器handler（需要程序员开发）\n\n（5）视图解析器 viewresolver（不需要程序员开发）\n\n作用：进行视图的解析 根据视图逻辑名解析成真正的视图（view）\n\n（6）视图view（需要程序员开发jsp）\n\nview是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）\n\n5、springmvc和struts2的区别有哪些?\n\n（1）入口不同：springmvc的入口是一个servlet即前端控制器（dispatchservlet）\nstruts2入口是一个filter过虑器（strutsprepareandexecutefilter）。\n\n（2）实现方式不同：springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)\nstruts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\n\n（3）参数解析不同：struts采用值栈存储请求和响应的数据，通过ognl存取数据\nspringmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成modelandview对象，最后又将modelandview中的模型数据通过reques域传输到页面。jsp视图解析器默认使用jstl。\n\n6、springmvc怎么样设定重定向和转发的？\n\n（1）在返回值前面加"forward:"就可以让结果转发,譬如"forward:user.do?name=method4"\n\n（2）在返回值前面加"redirect:"就可以让返回值重定向,譬如"redirect:http://www.baidu.com"\n\n7、springmvc怎么和ajax相互调用的？\n\n通过jackson框架就可以把java里面的对象直接转化成js可以识别的json对象。具体步骤如下 ：\n\n（1）加入jackson.jar\n\n（2）在配置文件中配置json的映射\n\n（3）在接受ajax的方法里面可以直接返回object,list等,但方法前面要加上@responsebody注解。\n\n8、springmvc里面拦截器是怎么写的：\n\n有两种写法,一种是实现handlerinterceptor接口,另外一种是继承适配器类,接着在接口方法当中，实现处理逻辑；然后在springmvc的配置文件中配置拦截器即可:\n\n\x3c!-- 配置springmvc的拦截器 --\x3e\n<mvc:interceptors>\n\t\n    \x3c!-- 配置一个拦截器的bean就可以了 默认是对所有请求都拦截 --\x3e\n\t<bean id="myinterceptor" class="com.abc.action.myhandlerinterceptor"></bean>\n\t\n    \x3c!-- 只针对部分请求拦截 --\x3e\n\t<mvc:interceptor>\n    \t<mvc:mapping path="/modelmap.do" />\n\t\t<bean class="com.abc.action.myhandlerinterceptoradapter" />\n\t</mvc:interceptor>\n\n</mvc:interceptors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n9、如何解决post请求中文乱码问题，get的又如何处理呢？\n\n（1）解决post请求乱码问题：\n\n在web.xml中加入：\n\n<filter>\n\n  <filter-name>characterencodingfilter</filter-name>\n\n  <filter-class>org.springframework.web.filter.characterencodingfilter</filter-class>\n\n  <init-param>\n\n    <param-name>encoding</param-name>\n\n    <param-value>utf-8</param-value>\n\n  </init-param>\n\n</filter>\n\n<filter-mapping>\n\n  <filter-name>characterencodingfilter</filter-name>\n\n  <url-pattern>/*</url-pattern>\n\n</filter-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n（2）解决get请求中文参数出现乱码解决方法有两个：\n\n①修改tomcat配置文件添加编码与工程编码一致，如下：\n\n<connectoruriencoding="utf-8" connectiontimeout="20000" port="8080" protocol="http/1.1" redirectport="8443"/>\n\n②另外一种方法对参数进行重新编码：\n\nstring username = new string(request.getparamter("username").getbytes("iso8859-1"),"utf-8")\n\niso8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。\n\n10、spring mvc的异常处理 ？\n\n可以将异常抛给spring框架，由spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。\n\n11、springmvc的核心入口类是什么,struts1,struts2的分别是什么：\n\nspringmvc的是dispatchservlet\n\nstruts1的是actionservlet\n\nstruts2的是strutsprepareandexecutefilter\n\n12、springmvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n\n是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的，解决方案是在控制器里面不能写字段。\n\n13、spingmvc中的控制器的注解一般用那个,有没有别的注解可以替代？\n\n一般用@conntroller注解,表示是表现层,不能用用别的注解代替。\n\n14、 @requestmapping注解用在类上面有什么作用？\n\n是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n15、怎么样把某个请求映射到特定的方法上面？\n\n直接在方法上面加上注解@requestmapping,并且在这个注解里面写上要拦截的路径。\n\n16、如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？\n\n可以在@requestmapping注解里面加上method=requestmethod.get。\n\n17、怎么样在方法里面得到request,或者session？\n\n直接在方法的形参中声明request,springmvc就自动把request对象传入。\n\n18、如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\n\n直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。\n\n19、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n\n直接在方法中声明这个对象,springmvc就自动会把属性赋值到这个对象里面。\n\n20、springmvc中函数的返回值是什么？\n\n返回值可以有很多类型,有string, modelandview，但一般用string比较好。\n\n21、springmvc用什么对象从后台向前台传递数据的？\n 1. 使用map、model和modelmap的方式\n\n@requestmapping("/test")\npublic string test(map<string,object> map,model model,modelmap modelmap,httpservletrequest request){\n    //1.放在map里  \n    map.put("names", arrays.aslist("caoyc","zhh","cjx"));\n    //2.放在model里 建议使用\n    model.addattribute("time", new date());\n    //3.放在request里  \n    request.setattribute("request", "requestvalue");\n    //4.放在modelmap中 \n    modelmap.addattribute("city", "chengdu");\n    modelmap.put("gender", "male");\n    return "hello";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\njsp写法:\n\ntime:${requestscope.time}\nnames:${requestscope.names }\ncity:${requestscope.city }\ngender:${requestscope.gender }\nrequest:${requestscope.request}\n\n\n1\n2\n3\n4\n5\n\n 2. 使用modelandview的方式:\n\n@requestmapping(value="/test2.do",method = requestmethod.post)  \npublic modelandview checknameisexist2(@requestparam("sid") string sid,model model,httpservletrequest request) {  \n    modelandview mav = new modelandview();  \n    mav.addobject("modelandview", "modelandviewvalue");  \n    //设置要跳转的页面，与返回值时string时返回success类似，以下跳转到/student/studentlist.jsp  \n    mav.setviewname("/student/studentlist");  \n    return mav;  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n22、springmvc中有个类把视图和数据都合并的一起的,叫什么？\n\n叫modelandview。\n\n23、怎么样把modelmap里面的数据放入session里面？\n\n可以在类上面加上 @sessionattributes 注解,里面包含的字符串就是要放入session里面的key。\n\n24、当一个方法向ajax返回特殊对象,譬如object,list等,需要做什么处理？\n\n要加上 @responsebody 注解。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-spring入门篇",frontmatter:{title:"Q&A宝典-spring入门篇",date:"2019-12-06T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_spring_001.html",relativePath:"views/qaq/sum_spring_001.md",key:"v-0727fa02",path:"/views/qaq/sum_spring_001.html",headers:[{level:2,title:"综合入门",slug:"综合入门",normalizedTitle:"综合入门",charIndex:2}],headersStr:"综合入门",content:'# 综合入门\n\n1.hibernate 和 mybatis 区别？\n 1. hibernate自动，mybatis半自动\n 2. 日志 hibernate自带\n 3. 移植性 hibernate：hql qbc面向对象,更换数据库,只更换方言即可\n 4. 优化 mybatis自己写sql灵活方便\n 5. 一级缓存\n    hibernate底层是Hashtable 线程安全\n    mybatis底层是HashMap 线程不安全\n\n2.spring容器启动流程、配置\n * 配置spring.xml\n\n 1. 初始化springIOC容器,加载spring.xml\n    ApplicatonContext ac = new ClassPathXmlApplicationContext("spring.xml");\n\n 2. 扫描注解\n    <context:component-scan base-package="com.etoak">\n\n 3. 配置spring加载数据源\n    \n    * DriverManagerDataSource\n\n 4. 配置spring整合mybatis\n    \n    * 注入数据源\n    * 设置别名(包下所有类类名全部小写)\n    * 加载 sql.xml映射文件\n    * 加载 PageHelper等插件\n\n 5. 配置扫描接口(sql.xml文件所在包)\n    \n    * 获得sqlSessionFactory(上一步的3以获得) sqlSessionFactoryBeanName\n    * 实例化接口 basePackage\n\n 6. 配置事务管理器(只需注入数据源)\n    \n    <bean id="tx" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"></property>\n    </bean>\n    \n    \n    1\n    2\n    3\n    \n\n 7. 注解(在需要事务的方法上@Transactional)使用声明事务(底层我们用cglib动态代理)\n    \n    注意属性readOnly="true"为只读，在select时可以设置\n    \n    \n    \x3c!-- 配置事务管理器 --\x3e\n    <bean id="tx" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        \x3c!-- 注入数据源  加入事务   但是没有开启事务 --\x3e\n        <property name="dataSource" ref="dataSource"></property>\n    </bean>\n    \n    \x3c!-- 声明式事务  aop环绕通知--\x3e\n    <tx:annotation-driven proxy-target-class="true" transaction-manager="tx" />\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n3.什么是事务?\n\n多条sql语句作为一个执行单元,要么全部执行,要么全不执行\n\n * 原子性、一致性、隔离性、持久性\n\n4.spring创建事物的方式?(两种)\n 1. 声明式事务 在xml中配置信息\n 2. 编程式事务 在代码中编写\n\n5.软编码硬编码\n * 硬编码：就是在程序中将代码写死,维护不方便\n * 软编码：可以在运行时确定,软编码只支持post请求\n\n6.web.xml文件加载先后顺寻\n 1. listener\n    多个监听器 谁在前 谁先被加载\n 2. filter\n    多个过滤器 谁在前 谁先被加载\n 3. servlet\n    启动不会被加载 当第一个请求发送过来时<url-pattern>*.do</url-pattern> 才会被实例化\n\n7.HttPServlet声明周期\n 1. 实例化\n 2. 初始化方法\n 3. 运行(doGet/doPost)\n 4. 消亡\n\n8.springmvc提供的两种视图类型\n 1. ModelAndView\n 2. String\n\n9.重定向和请求转发\n 1. 请求转发：发送一次请求,跳转后地址栏不发生改变\n 2. 重定向：跳转后地址栏发生改变\n    主要用在防止表单重复提交、 不能使用request范围、 跳转之后肯定执行doGet方法\n\n10.springmvc流程\n\n 1. 新建一个页面,发送第一次请求地址\n\n 2. 到达web.xml，web.xml依次加载\n    \n    * listener：初始化spring容器\n    * filter：设置请求、响应编码\n    * servlet： 默认加载WEB-INF/某某某(注意名字保持一致,可自定义)-servlet.xml配置文件 拦截请求\n\n 3. 加载XXX-servlet.xml配置文件并解析\n    \n    \n    [1] context注解扫描\n    springmvc必须的有@Controller注解(得在这层接收客户端请求)\n    \n    \n    [2] 配置映射器、适配器 、类型转换(底层自动实现)\n    <mvc:acnotation-driven />\n    \n    [3] 实例化视图解析器\n    \n    \n    \x3c!-- 视图解析器 --\x3e\n    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n        \x3c!-- 前缀 --\x3e\n        <property name="prefix"\n                  value="/pages/"></property>\n        \x3c!-- 后缀 --\x3e\n        <property name="suffix"\n                  value=".jsp"></property>\n    </bean>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    [4] 文件上传解析器,id必须是这个\n    \n    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">\n        <property name="defaultEncoding" value="utf-8" />\n        <property name="maxUploadSize" value="3000000000" />\n    </bean>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 通过拦截的请求来匹配@Controller层\n    \n    [1] 映射器匹配拿到的请求 在某个方法上@RequestMappeing(value="/login")\n    \n    [2] 适配器指定执行这个方法\n    \n    [3] 接受请求参数,并经行类型转换 @RequestParam(valeu="前台name")\n    注意日期不能自动转,所以有个注解@DateTimeFormat(pattern="yyyy-MM-dd")\n\n 5. 执行方法里的业务逻辑\n\n 6. ModelAndView跳转视图\n    ModelAndView mv = new ModelAndView("除前后缀页面"); return mv;\n\n 7. 视图解析器渲染视图名称,完成之后跳转视图\n\n11.springmvc组成部分\n 1. 自中央处理器 DispatcherServlet\n    \n 2. 映射器 mvc:annotation-driven @RequestMappeing\n    \n 3. 适配器 mvc:annotation-driven 执行方法\n 4. 处理器 @Controller\n    \n 5. 视图解析器 InternalResourceViewResolver\n    \n 6. 视图 我们看不见，底层动的\n    \n 7. 异常处理器\n    \n 8. 上传解析器\n\n12.spring Bean 声明周期\n\nspring Bean 声明周期\n\n13.如何在src目录加载properties\n\n<context:property-placeholder file-encoding="UTF-8" location="classpath:jdbc.properties"/>\n\n14.将文件存放到数据库中\n\nMYSQL      ORACLE   JAVA     \nlongblob   blob     byte[]   二进制类型\ntext       clob     String   大文本类型\n\n15.springmvc文件上传\n\n有个类MultipartFile、方法transferTo\n\npublic String upload(@RequestParam(value="f") MultipartFile f,HttpSession session){\n\n    //MultipartFile有transferTo()这么一个方法写出文件\n    f.transferTo(new File(path,filenewname));\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n * springmvc文件下载\n   \n   记得设置响应头信息 response.setHeader("Content-Disposition","attachment;filename="+filename);\n\n16，springmvc 提供2种 请求格式\n\n 1. *.do、*.action\n\n 2. / 默认不加载静态资源 js css\n    默认不加载静态资源，要加载的话需要在spring配置文件中配置解析\n    \n    \x3c!-- 静态servlet对象 针对/请求不加载静态资源 js css img  --\x3e\n    <mvc:default-servlet-handler />\n    \n    \n    1\n    2\n    \n\n17.在前端 json 和 js对象的互转\n * JSON.parse(str);\n * JSON.stringify(object);\n\n18.springmvc集成spring,可以使用spring拥有的信息,但只能使用spring的ioc信息,aop不能使用\n\n即：容器启动时,spring先加载,springmvc后加载\nspring 配置事务,事务底层时aop实现的,springmvc没有aop的配置\nspringmvc 没有配置事务,所以会覆盖掉spring配置\n\n\n所以事务会失效，解决办法：\n让springmvc不扫描有事务的层(service层)只扫描Controller层\n让spring扫描除了Controller的其他层\n\n19.数据库建表3范式\n 1. 关系型数据库\n    表、字段、值 有相互关系\n 2. 创建字段\n    所有字段中必须有一个字段是唯一的\n 3. 字段不能冗余\n\n20.disabled和readonly的区别\n * 都是使文本框失效(不能输入)\n   disabled：前端显示为灰色,后台接受值为null\n   readonly：前端显示为白色,后台可以接受到值\n\n21.bootstrap和easyui区别\n * easyui 是js框架,没有响应式布局\n * bootstrap 侧重css的前端框架,有响应式布局\n\n22.js中 == 和 === 的区别\n\n== 只比较内容\n=== 先比较类型，再比较内容\n\n23.过滤器和拦截器的区别\n * 过滤器：\n   在web.xml中配置,由servlet实例化对象,spring不能注入,什么请求都拦截\n * 拦截器：\n   只拦截后台请求, 都是由spring进行管理的,springmvc除了jsp之外都拦截\n\n24.struts2和springmvc的区别\n 1. 入口\n    struts2：web.xml filter元素,容器启动初始化\n    mvc: web.xml servlet元素,第一次触发请求实例化对象\n 2. 创建对象\n    struts2： 基于类开发,发送请求时,每次都会创建对象,多例的\n    mvc: 基于方法开发,一般设计为单例(默认)\n 3. 接受请求参数\n    struts2: 成员变量 依赖类存在\n    mvc: 局部变量 依赖方法存在\n\n25.数据库中的符号\n\nand 相当于 &&\nor 相当于 ||\n&gt; 相当于 >\n&lt; 相当于 <\n\n\n26.事务的 隔离机制和七种传播途径\n\n * 脏读:读到了其他事物未提交的数据\n\n * 不可重复读:一次读取到记录之后其他事物对这条数据进行了修改,再次读取数据不一致\n\n * 幻读:相同的查询条件首次查询后,其他事物添加或删除了新的数据,再次查询不一致\n\n * 隔离机制：(解决脏读,不可重复读,幻读)\n\n                     脏读   不可重复读   幻读\nRead uncommitted :   会    会       会\nRead committed :     不会   会       会\nRepeatable read :    不会   不会      会\nSerializable :       不会   不会      不会\n\n * 传播行为:\n   国内最常用的就是propagation_required 事务的操作有异常是都得向上抛,不能向上抛就自己new一个异常,不要try(非要try的话,就自己在造一个异常)。\n\n27.随便写一个自增编号\n\nCalendar c = Calendar.getInstance();\nString no = "ABC" + c.get(1) + String.format("%04d",(++count));\n\n\n1\n2\n\n28.maven的作用\n * 依赖管理jar包\n * 基于多模块\n\n29.xml和对象的互转\n\njava jaxb\n\n30.网络传输,跨项目访问\n * webService: 既可以当客户端又可以当服务端\n   1. 跨平台 跨语言\n   2. 多用在企业\n   3. soap协议\n   4. http://localhost:8080/SSM/ws/user?wsdl\n * httpclient: 相当于客户端\n   1. 多用在互联网 调接口/新老系统模块的调用\n   2. http协议\n   3. http://localhost:8080/SSM/ws/user\n\n31.webService如何使用\n\n * 服务端：\n   \n   0. 先在web.xml文件中配置\n   1. 配置服务端cxf.xml文件\n   2. 定义一个bean类\n   3. 争对这个bean写一个接口,在接口前加注解@javax.jws.WebService\n   4. 在这个接口里写响应的增删该查(定义方法的参数和返回值时 注意不要使用Map对象)\n   5. 针对接口写实现类\n   6. 在实现类上加@javax.jws.WebService ，@org.springframework.stereotype.Service //这是一个服务层 在类里写响应的实现\n\n * 客户端：\n   \n   0. 新建一个测试项目\n   1. 配置客户端cxf.xml文件 （具体使用见下一题）\n      将生成的文件复制到工程中,新建一个test类测试\n\n32.cxf测试接口的工具如何使用:\n\n 1. 配置cxf环境变量\n    path=E:\\web server\\apache-cxf-3.1.11\\bin\n\n 2. cmd下输入命令\n    wsdl2java -d d:/ws -p com.etoak.client http://localhost:8080/SSM/ws/user?wsdl\n    -d表示生成客户端代码的位置\n    -p表示生成客户端代码的包结构\n\n * 其它方式：soapui工具',normalizedContent:'# 综合入门\n\n1.hibernate 和 mybatis 区别？\n 1. hibernate自动，mybatis半自动\n 2. 日志 hibernate自带\n 3. 移植性 hibernate：hql qbc面向对象,更换数据库,只更换方言即可\n 4. 优化 mybatis自己写sql灵活方便\n 5. 一级缓存\n    hibernate底层是hashtable 线程安全\n    mybatis底层是hashmap 线程不安全\n\n2.spring容器启动流程、配置\n * 配置spring.xml\n\n 1. 初始化springioc容器,加载spring.xml\n    applicatoncontext ac = new classpathxmlapplicationcontext("spring.xml");\n\n 2. 扫描注解\n    <context:component-scan base-package="com.etoak">\n\n 3. 配置spring加载数据源\n    \n    * drivermanagerdatasource\n\n 4. 配置spring整合mybatis\n    \n    * 注入数据源\n    * 设置别名(包下所有类类名全部小写)\n    * 加载 sql.xml映射文件\n    * 加载 pagehelper等插件\n\n 5. 配置扫描接口(sql.xml文件所在包)\n    \n    * 获得sqlsessionfactory(上一步的3以获得) sqlsessionfactorybeanname\n    * 实例化接口 basepackage\n\n 6. 配置事务管理器(只需注入数据源)\n    \n    <bean id="tx" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"></property>\n    </bean>\n    \n    \n    1\n    2\n    3\n    \n\n 7. 注解(在需要事务的方法上@transactional)使用声明事务(底层我们用cglib动态代理)\n    \n    注意属性readonly="true"为只读，在select时可以设置\n    \n    \n    \x3c!-- 配置事务管理器 --\x3e\n    <bean id="tx" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        \x3c!-- 注入数据源  加入事务   但是没有开启事务 --\x3e\n        <property name="datasource" ref="datasource"></property>\n    </bean>\n    \n    \x3c!-- 声明式事务  aop环绕通知--\x3e\n    <tx:annotation-driven proxy-target-class="true" transaction-manager="tx" />\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n3.什么是事务?\n\n多条sql语句作为一个执行单元,要么全部执行,要么全不执行\n\n * 原子性、一致性、隔离性、持久性\n\n4.spring创建事物的方式?(两种)\n 1. 声明式事务 在xml中配置信息\n 2. 编程式事务 在代码中编写\n\n5.软编码硬编码\n * 硬编码：就是在程序中将代码写死,维护不方便\n * 软编码：可以在运行时确定,软编码只支持post请求\n\n6.web.xml文件加载先后顺寻\n 1. listener\n    多个监听器 谁在前 谁先被加载\n 2. filter\n    多个过滤器 谁在前 谁先被加载\n 3. servlet\n    启动不会被加载 当第一个请求发送过来时<url-pattern>*.do</url-pattern> 才会被实例化\n\n7.httpservlet声明周期\n 1. 实例化\n 2. 初始化方法\n 3. 运行(doget/dopost)\n 4. 消亡\n\n8.springmvc提供的两种视图类型\n 1. modelandview\n 2. string\n\n9.重定向和请求转发\n 1. 请求转发：发送一次请求,跳转后地址栏不发生改变\n 2. 重定向：跳转后地址栏发生改变\n    主要用在防止表单重复提交、 不能使用request范围、 跳转之后肯定执行doget方法\n\n10.springmvc流程\n\n 1. 新建一个页面,发送第一次请求地址\n\n 2. 到达web.xml，web.xml依次加载\n    \n    * listener：初始化spring容器\n    * filter：设置请求、响应编码\n    * servlet： 默认加载web-inf/某某某(注意名字保持一致,可自定义)-servlet.xml配置文件 拦截请求\n\n 3. 加载xxx-servlet.xml配置文件并解析\n    \n    \n    [1] context注解扫描\n    springmvc必须的有@controller注解(得在这层接收客户端请求)\n    \n    \n    [2] 配置映射器、适配器 、类型转换(底层自动实现)\n    <mvc:acnotation-driven />\n    \n    [3] 实例化视图解析器\n    \n    \n    \x3c!-- 视图解析器 --\x3e\n    <bean class="org.springframework.web.servlet.view.internalresourceviewresolver">\n        \x3c!-- 前缀 --\x3e\n        <property name="prefix"\n                  value="/pages/"></property>\n        \x3c!-- 后缀 --\x3e\n        <property name="suffix"\n                  value=".jsp"></property>\n    </bean>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    [4] 文件上传解析器,id必须是这个\n    \n    <bean id="multipartresolver" class="org.springframework.web.multipart.commons.commonsmultipartresolver">\n        <property name="defaultencoding" value="utf-8" />\n        <property name="maxuploadsize" value="3000000000" />\n    </bean>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 通过拦截的请求来匹配@controller层\n    \n    [1] 映射器匹配拿到的请求 在某个方法上@requestmappeing(value="/login")\n    \n    [2] 适配器指定执行这个方法\n    \n    [3] 接受请求参数,并经行类型转换 @requestparam(valeu="前台name")\n    注意日期不能自动转,所以有个注解@datetimeformat(pattern="yyyy-mm-dd")\n\n 5. 执行方法里的业务逻辑\n\n 6. modelandview跳转视图\n    modelandview mv = new modelandview("除前后缀页面"); return mv;\n\n 7. 视图解析器渲染视图名称,完成之后跳转视图\n\n11.springmvc组成部分\n 1. 自中央处理器 dispatcherservlet\n    \n 2. 映射器 mvc:annotation-driven @requestmappeing\n    \n 3. 适配器 mvc:annotation-driven 执行方法\n 4. 处理器 @controller\n    \n 5. 视图解析器 internalresourceviewresolver\n    \n 6. 视图 我们看不见，底层动的\n    \n 7. 异常处理器\n    \n 8. 上传解析器\n\n12.spring bean 声明周期\n\nspring bean 声明周期\n\n13.如何在src目录加载properties\n\n<context:property-placeholder file-encoding="utf-8" location="classpath:jdbc.properties"/>\n\n14.将文件存放到数据库中\n\nmysql      oracle   java     \nlongblob   blob     byte[]   二进制类型\ntext       clob     string   大文本类型\n\n15.springmvc文件上传\n\n有个类multipartfile、方法transferto\n\npublic string upload(@requestparam(value="f") multipartfile f,httpsession session){\n\n    //multipartfile有transferto()这么一个方法写出文件\n    f.transferto(new file(path,filenewname));\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n * springmvc文件下载\n   \n   记得设置响应头信息 response.setheader("content-disposition","attachment;filename="+filename);\n\n16，springmvc 提供2种 请求格式\n\n 1. *.do、*.action\n\n 2. / 默认不加载静态资源 js css\n    默认不加载静态资源，要加载的话需要在spring配置文件中配置解析\n    \n    \x3c!-- 静态servlet对象 针对/请求不加载静态资源 js css img  --\x3e\n    <mvc:default-servlet-handler />\n    \n    \n    1\n    2\n    \n\n17.在前端 json 和 js对象的互转\n * json.parse(str);\n * json.stringify(object);\n\n18.springmvc集成spring,可以使用spring拥有的信息,但只能使用spring的ioc信息,aop不能使用\n\n即：容器启动时,spring先加载,springmvc后加载\nspring 配置事务,事务底层时aop实现的,springmvc没有aop的配置\nspringmvc 没有配置事务,所以会覆盖掉spring配置\n\n\n所以事务会失效，解决办法：\n让springmvc不扫描有事务的层(service层)只扫描controller层\n让spring扫描除了controller的其他层\n\n19.数据库建表3范式\n 1. 关系型数据库\n    表、字段、值 有相互关系\n 2. 创建字段\n    所有字段中必须有一个字段是唯一的\n 3. 字段不能冗余\n\n20.disabled和readonly的区别\n * 都是使文本框失效(不能输入)\n   disabled：前端显示为灰色,后台接受值为null\n   readonly：前端显示为白色,后台可以接受到值\n\n21.bootstrap和easyui区别\n * easyui 是js框架,没有响应式布局\n * bootstrap 侧重css的前端框架,有响应式布局\n\n22.js中 == 和 === 的区别\n\n== 只比较内容\n=== 先比较类型，再比较内容\n\n23.过滤器和拦截器的区别\n * 过滤器：\n   在web.xml中配置,由servlet实例化对象,spring不能注入,什么请求都拦截\n * 拦截器：\n   只拦截后台请求, 都是由spring进行管理的,springmvc除了jsp之外都拦截\n\n24.struts2和springmvc的区别\n 1. 入口\n    struts2：web.xml filter元素,容器启动初始化\n    mvc: web.xml servlet元素,第一次触发请求实例化对象\n 2. 创建对象\n    struts2： 基于类开发,发送请求时,每次都会创建对象,多例的\n    mvc: 基于方法开发,一般设计为单例(默认)\n 3. 接受请求参数\n    struts2: 成员变量 依赖类存在\n    mvc: 局部变量 依赖方法存在\n\n25.数据库中的符号\n\nand 相当于 &&\nor 相当于 ||\n&gt; 相当于 >\n&lt; 相当于 <\n\n\n26.事务的 隔离机制和七种传播途径\n\n * 脏读:读到了其他事物未提交的数据\n\n * 不可重复读:一次读取到记录之后其他事物对这条数据进行了修改,再次读取数据不一致\n\n * 幻读:相同的查询条件首次查询后,其他事物添加或删除了新的数据,再次查询不一致\n\n * 隔离机制：(解决脏读,不可重复读,幻读)\n\n                     脏读   不可重复读   幻读\nread uncommitted :   会    会       会\nread committed :     不会   会       会\nrepeatable read :    不会   不会      会\nserializable :       不会   不会      不会\n\n * 传播行为:\n   国内最常用的就是propagation_required 事务的操作有异常是都得向上抛,不能向上抛就自己new一个异常,不要try(非要try的话,就自己在造一个异常)。\n\n27.随便写一个自增编号\n\ncalendar c = calendar.getinstance();\nstring no = "abc" + c.get(1) + string.format("%04d",(++count));\n\n\n1\n2\n\n28.maven的作用\n * 依赖管理jar包\n * 基于多模块\n\n29.xml和对象的互转\n\njava jaxb\n\n30.网络传输,跨项目访问\n * webservice: 既可以当客户端又可以当服务端\n   1. 跨平台 跨语言\n   2. 多用在企业\n   3. soap协议\n   4. http://localhost:8080/ssm/ws/user?wsdl\n * httpclient: 相当于客户端\n   1. 多用在互联网 调接口/新老系统模块的调用\n   2. http协议\n   3. http://localhost:8080/ssm/ws/user\n\n31.webservice如何使用\n\n * 服务端：\n   \n   0. 先在web.xml文件中配置\n   1. 配置服务端cxf.xml文件\n   2. 定义一个bean类\n   3. 争对这个bean写一个接口,在接口前加注解@javax.jws.webservice\n   4. 在这个接口里写响应的增删该查(定义方法的参数和返回值时 注意不要使用map对象)\n   5. 针对接口写实现类\n   6. 在实现类上加@javax.jws.webservice ，@org.springframework.stereotype.service //这是一个服务层 在类里写响应的实现\n\n * 客户端：\n   \n   0. 新建一个测试项目\n   1. 配置客户端cxf.xml文件 （具体使用见下一题）\n      将生成的文件复制到工程中,新建一个test类测试\n\n32.cxf测试接口的工具如何使用:\n\n 1. 配置cxf环境变量\n    path=e:\\web server\\apache-cxf-3.1.11\\bin\n\n 2. cmd下输入命令\n    wsdl2java -d d:/ws -p com.etoak.client http://localhost:8080/ssm/ws/user?wsdl\n    -d表示生成客户端代码的位置\n    -p表示生成客户端代码的包结构\n\n * 其它方式：soapui工具',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-spring进阶篇",frontmatter:{title:"Q&A宝典-spring进阶篇",date:"2020-02-28T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_spring_003.html",relativePath:"views/qaq/sum_spring_003.md",key:"v-7a153c7b",path:"/views/qaq/sum_spring_003.html",headers:[{level:2,title:"Spring进阶",slug:"spring进阶",normalizedTitle:"spring进阶",charIndex:2},{level:2,title:"其它",slug:"其它",normalizedTitle:"其它",charIndex:8735}],headersStr:"Spring进阶 其它",content:'# Spring进阶\n\n1、SpringMVC的流程？\n\n（1）用户发送请求至前端控制器 DispatcherServlet；\n\n（2） DispatcherServlet收到请求后，调用 HandlerMapping 处理器映射器，请求获取Handle；\n\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；\n\n（4）DispatcherServlet通过 HandlerAdapter 处理器适配器调用处理器；\n\n（5）执行处理器(Handler，也叫后端控制器)；\n\n（6）Handler执行完成返回ModelAndView；\n\n（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；\n\n（8）DispatcherServlet将ModelAndView传给 ViewReslover 视图解析器进行解析；\n\n（9）ViewReslover解析后返回具体View；\n\n（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）\n\n（11）DispatcherServlet响应用户。\n\n2. IOC控制反转底层原理\n\n 1. 自定义两个注解\n    \n    @Component：判断是否注入bean容器\n    \n    @Autowired：判断是否依赖注入\n\n 2. 创建ApplicationContext容器类\n    \n    1. private ConcurrentHashMap<String, Object> beans = null; 存放bean的容器\n    \n    2. initBeans(); 根据注解@Component加载所有bean\n       \n       * 利用反射机制，遍历一个包下的所有类，判断类上有注解@Component就放入beans容器中，beans.put(beanId, newInstance);\n    \n    3. initEntryField(); 根据注解@Autowired加载所有依赖注入的对象\n       \n       * 所有bean初始化之后，判断bean的依赖注入关系\n       \n       * 遍历beans容器，利用反射机制，获取bean的所有属性并遍历判断有@Autowired注解的进行依赖注入(利用java反射set注入，private不用写set方法了)\n         \n         //判断当前类属性是否存在注解\n         //declaredFields：利用反射得到的所有属性\n         for (Field field : declaredFields) {\n             SelfAutowired extResource = field.getAnnotation(SelfAutowired.class);\n             if (extResource != null) {\n                 //属性名称：即容器中bean\n                 String beanId = field.getName();\n                 Object bean = getBean(beanId);\n                 if (bean != null) {\n                     //默认使用属性名称，查找bean容器对象 1参数 当前对象 2参数给属性赋值\n                     field.setAccessible(true); //允许访问私有属性,private不用写set()了\n                     field.set(object, bean); //依赖注入\n                 }\n             }\n         }\n         \n         \n         1\n         2\n         3\n         4\n         5\n         6\n         7\n         8\n         9\n         10\n         11\n         12\n         13\n         14\n         15\n         \n\n3. 动态代理底层原理\n * 简书gstansen分析的很好，涉及动态代理比较复杂，我在这里简单概括下吧：\n\n 1. 业务接口（Interface） 业务的抽象表示\n\n 2. 业务具体实现类（concreteManager） 实现业务接口，执行具体的业务操作\n\n 3. 业务代理类（$proxy，在运行的时候动态生成的类） 进行业务代理，调用业务代理操作类\n\n 4. 业务代理操作类（DynamicProxyHandler，实现了InvocationHandler接口的类） 代理方法的直接调用者，通过InvocationHandler中的invoke方法直接发起代理\n    \n    public class DynamicProxyHandler implements InvocationHandler{\n        Object realCookManager;\n        DynamicProxyHandler(ICook realCookManager){\n            this.realCookManager = realCookManager;\n        }\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println("invoke start");\n            System.out.println(method.getName());\n            method.invoke(realCookManager,args);\n            System.out.println("invoke end");\n            return null;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 5. 客户端调用对象（client） 发起业务\n\n * 总体思路：\n   \n   /* 5.客户端调用对象（client）\n    */\n   public class Main {\n       public static void main(String[] args){\n   \t\t//1. 业务实现类\n           CookManager cookManager = new CookManager();\n           //2. 业务代理操作类\n           DynamicProxyHandler dynamicProxyHandler = \n               new DynamicProxyHandler(cookManager);\n           //3. Proxy类中的newProxyInstance()方法利用java反射返回代理类的实例\n           ICook iCook =(ICook)Proxy.newProxyInstance(\n               dynamicProxyHandler.getClass().getClassLoader(),\n               cookManager.getClass().getInterfaces(),\n               dynamicProxyHandler);\n           \n           //打印一下代理类的类名\n           System.out.println(iCook.getClass().getName());\n           iCook.dealWithFoot();\n           iCook.cook();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   \n   > ICook iCook = (ICook)Proxy.newProxyInstance(\n   > \n   > 业务代理操作类.getClass().getClassLoader(),\n   > \n   > 业务具体实现类.getClass().getInterfaces(),\n   > \n   > 业务代理操作类 );\n   \n   1. ClassLoader是一个抽象类，作用是将字节码文件加载进虚拟机并生成相应的class（注意是小写的）\n   2. interfaces就是被实现的那些业务接口\n   3. 业务代理操作类：实现InvocationHandler接口的实例，即DynamicProxyHandler\n   \n   Proxy类中的newProxyInstance()方法利用java反射返回代理类的实例：\n   \n   public static Object newProxyInstance(ClassLoader loader,Class<?>[]\n                                         interfaces,InvocationHandler h){\n        //所有被实现的业务接口\n         final Class<?>[] intfs = interfaces.clone();\n        //寻找或生成指定的代理类\n         Class<?> cl = getProxyClass0(loader, intfs);\n         //通过反射类中的Constructor获取其所有构造方法\n         final Constructor<?> cons = cl.getConstructor(constructorParams);\n         //通过Constructor返回代理类的实例\n         return cons.newInstance(new Object[]{h});\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n4、读过springmvc源码？\n\nSpringmvc入口 请求 映射器 适配器\n\n//前端控制器分派方法 \n\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { \n\n​    HttpServletRequest processedRequest = request; \n\n​    HandlerExecutionChain mappedHandler = null; \n\n​    int interceptorIndex = -1;\n\n​    try { \n\n​      ModelAndView mv; \n\n​      boolean errorView = false;  \n\n​      try { \n\n​    //检查是否是请求是否是multipart（如文件上传），如果是将通过MultipartResolver解析 \n\n​        processedRequest = checkMultipart(request); \n\n​     //步骤2、请求到处理器（页面控制器）的映射，通过HandlerMapping进行映射 \n\n​        mappedHandler = getHandler(processedRequest, false); \n\n​        if (mappedHandler == null || mappedHandler.getHandler() == null) { \n\n​          noHandlerFound(processedRequest, response); \n\n​          return; \n\n​        } \n\n //步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器） \n\n​        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());  \n\n​        // 304 Not Modified缓存支持 \n\n​        //此处省略具体代码  \n\n​        // 执行处理器相关的拦截器的预处理（HandlerInterceptor.preHandle） \n\n​        //此处省略具体代码  \n\n​        // 步骤4、由适配器执行处理器（调用处理器相应功能处理方法） \n\n​        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  \n\n​        // Do we need view name translation? \n\n​        if (mv != null && !mv.hasView()) { \n\n​          mv.setViewName(getDefaultViewName(request)); \n\n​        }  \n\n​        // 执行处理器相关的拦截器的后处理（HandlerInterceptor.postHandle） \n\n​        //此处省略具体代码 \n\n​      } \n\n​      catch (ModelAndViewDefiningException ex) { \n\n​        logger.debug("ModelAndViewDefiningException encountered", ex); \n\n​        mv = ex.getModelAndView(); \n\n​      } \n\n​      catch (Exception ex) { \n\n​        Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); \n\n​        mv = processHandlerException(processedRequest, response, handler, ex); \n\n​        errorView = (mv != null); \n\n​      }  \n\n//步骤5 步骤6、解析视图并进行视图的渲染 \n\n//步骤5 由ViewResolver解析View（viewResolver.resolveViewName(viewName, locale)） \n\n步骤6 视图在渲染时会把Model传入（view.render(mv.getModelInternal(), request, response);） \n\n​      if (mv != null && !mv.wasCleared()) { \n\n​        render(mv, processedRequest, response); \n\n​        if (errorView) { \n\n​          WebUtils.clearErrorRequestAttributes(request); \n\n​        } \n\n​      } \n\n​      else { \n\n​        if (logger.isDebugEnabled()) { \n\n​          logger.debug("Null ModelAndView returned to DispatcherServlet with name \'" + getServletName() + \n\n​              "\': assuming HandlerAdapter completed request handling"); \n\n​        } \n\n​      }  \n\n​      // 执行处理器相关的拦截器的完成后处理（HandlerInterceptor.afterCompletion） \n\n​      //此处省略具体代码  \n\n​    catch (Exception ex) { \n\n​      // Trigger after-completion for thrown exception. \n\n​      triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex)      throw ex; \n\n​    } \n\n​    catch (Error err) { \n\n​      ServletException ex = new NestedServletException("Handler processing failed", err); \n\n​      // Trigger after-completion for thrown exception. \n\n​      triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex); \n\n​      throw ex; \n\n​    }  \n\n​    finally { \n\n​      // Clean up any resources used by a multipart request. \n\n​      if (processedRequest != request) {\n\n​        cleanupMultipart(processedRequest); \n\n​      } \n\n​    } \n\n  } \n\n \n\n \n\nSpringmvc九大组件：\n\nprotected void initStrategies(ApplicationContext context) {\n\n  //用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File.\n\n  initMultipartResolver(context);\n\n  //SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。\n\n  initLocaleResolver(context); \n\n  //用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、\n\n  //如图片、css样式等。SpringMVC的主题也支持国际化， \n\n  initThemeResolver(context);\n\n  //用来查找Handler的。\n\n  initHandlerMappings(context);\n\n  //从名字上看，它就是一个适配器。Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。\n\n  //如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情\n\n  initHandlerAdapters(context);\n\n  //其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？\n\n  //这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。\n\n  initHandlerExceptionResolvers(context);\n\n  //有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，\n\n  //如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。\n\n  initRequestToViewNameTranslator(context);\n\n  //ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。\n\n  //View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。\n\n  initViewResolvers(context);\n\n  //用来管理FlashMap的，FlashMap主要用在redirect重定向中传递参数。\n\n  initFlashMapManager(context); \n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n\n\n\n# 其它\n\n1. 定时任务\n\n就是在xml中配置，具体可以看我的这篇文章\n\n 1. 先配置(实例化)一个业务，就是我们自己写的类\n 2. 再配置一个任务，jobDetailFactoryBean\n    * 在这个任务里name=targetObject 注入我们自己写的那个类\n    * 要用哪个方法的话，就name=tagetMethod 注入那个方法\n    * name=concurrent 设置为false防止并发执行\n 3. 再配置触发器(cron表达式)，CronTriggerBean\n    * name=jobDetail 注入那个任务\n    * name=cronExpression 设置定时触发时间\n 4. 配置一个调度器(只能有一个) SchedulerFactoryBean\n    * name=triggers 注入要调度的哪个触发器\n\n2. dubbo\n\n> 参考 dubbo官网配置\n\n * 提供者：提供方应用信息\n   \n   配置<dubbo:registry>zookeeper注册中心暴露服务地址\n   配置dubbo协议和端口号<dubbo:protocol> dubbo协议\n   <dubbo:service>声明要暴露的服务接口(或者用注解)\n\n * zookeeper：注册中心\n\n * 消费者：消费方应用信息\n   \n   配置zookeeper注册中心暴露服务地址<dubbo:registry>\n   获取注册中心的接口信息<dubbo:reference>\n\n3. httpclient短信验证码\n\n> 参考互亿无线文档\n\n 1. 前端点击获取验证码的时候，ajax访问后台请求，同时倒计时60秒\n 2. 我们在后台拿到短信平台提供的接口地址，然后看他需要什么参数（用户名，密码，手机号，短信验证码），它有文档demo嘛，就根据它的改成我们需要的，然后拼装参数给他返回去\n 3. 然后他呢也会给我们返回一堆参数(是成功还是失败)，我们把这些参数返回给前端\n\n4. webService\n\n> 参考博客简单的webService接口生成\n> 方法上加@WebMentod(exclude=true)后，此方法不被发布\n> 静态方法不会被发布\n\n 1. 配置web.xml文件 设置cxf要拦截的路径\n    cxf服务端必须定义CXFServlet对象\n 2. 配置服务端cxf.xml文件 （暴露访问地址,发布接口）\n    <cxf:endpoint address="/user" implementor="#实现类"/>\n 3. 定义一个bean类\n 4. 争对这个bean类写一个接口，在接口前加注解\n    @javax.jws.WebService(表示一个服务端发布接口)\n 5. 在这个接口的实现类加@javax.jws.WebService、 @Service (服务层)\n 6. 地址栏登陆时：记得\n    http://localhost:8080/工程名/ws(web.xml配置)/自己配置的地址?wsdl\n\n * 如果用cxf测试接口的话\n   1. 配置cxf服务端(以上)\n   2. 配置客户端xml 请求地址，和服务端暴露的接口\n   3. cmd下 一堆命令\n\n5. spring中配置事务\n\n> 声明式事务配置详解\n\n * web.xml加载顺序：\n\n 1. listener 加载spring\n\n \x3c!-- spring start --\x3e\n <listener>\n \t\x3c!-- spring web容器  默认加载spring配置文件路径为 WEB-INF/applicationContext.xml--\x3e\n \t<listener-class>\n \t\torg.springframework.web.context.ContextLoaderListener\n \t</listener-class>\n </listener>\n \n <context-param>\n \t<param-name>contextConfigLocation</param-name>\n \t<param-value>classpath:applicationContext*.xml</param-value>\n </context-param>\n \x3c!-- spring end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. filter\n 3. servlet\n\n\x3c!-- springmvc start --\x3e\n <servlet>\n \t<servlet-name>mvc</servlet-name>\n \t<servlet-class>\n \t\torg.springframework.web.servlet.DispatcherServlet\n \t</servlet-class>\n \t<init-param>\n \t\t<param-name>contextConfigLocation</param-name>\n \t\t<param-value>classpath:springmvc.xml</param-value>\n \t</init-param>\n </servlet>\n \n <servlet-mapping>\n \t<servlet-name>mvc</servlet-name>\n \t<url-pattern>/</url-pattern>\n </servlet-mapping>\n \x3c!-- springmvc end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * web.xml加载的时候先加载spring，后加载springmvc\n\n 1. spring自带aop，spring是父容器\n 2. springmvc没有引入aop，springmvc是子容器\n 3. 子容器的创建依赖于父容器的创建，父容器先于子容器创建；子容器 (springmvc 容器) 可以访问父容器 (spring 容器) 的 bean，父容器 (spring 容器) 不能访问子容器 (springmvc 容器) 的 bean\n 4. 所以一般在子容器springmvc中开启aop配置 <aop:aspectj-autoproxy/>\n 5. 而事务、切面都依赖于aop\n 6. 如果不想aop在Controller生效，则配置的时候可以让springmvc只扫描@Controller注解，spring扫描除了@Controller的其它所有注解，并且在spring中开启aop配置即可\n\n * 以下是具体配置：\n\n\x3c!-- springmvc配置 --\x3e\n\n\x3c!-- use-default-filters="false" 所有注解不被加载 --\x3e\n<context:component-scan base-package="com.xxx" use-default-filters="false">\n    \x3c!-- 只加载@Controller注解 --\x3e\n    <context:include-filter type="annotation" \n                            expression="org.springframework.stereotype.Controller" />\n</context:component-scan>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\x3c!-- spring配置 --\x3e\n\n\x3c!-- spring配置aop --\x3e\n<aop:aspectj-autoproxy/>\n\x3c!-- use-default-filters="true" 默认、加载所有注解 --\x3e\n<context:component-scan base-package="com.xxx">\n    \x3c!-- 加载除了@Controller的其它所有注解 --\x3e\n    <context:exclude-filter type="annotation" \n                            expression="org.springframework.stereotype.Controller"/>\n</context:component-scan>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# spring进阶\n\n1、springmvc的流程？\n\n（1）用户发送请求至前端控制器 dispatcherservlet；\n\n（2） dispatcherservlet收到请求后，调用 handlermapping 处理器映射器，请求获取handle；\n\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给dispatcherservlet；\n\n（4）dispatcherservlet通过 handleradapter 处理器适配器调用处理器；\n\n（5）执行处理器(handler，也叫后端控制器)；\n\n（6）handler执行完成返回modelandview；\n\n（7）handleradapter将handler执行结果modelandview返回给dispatcherservlet；\n\n（8）dispatcherservlet将modelandview传给 viewreslover 视图解析器进行解析；\n\n（9）viewreslover解析后返回具体view；\n\n（10）dispatcherservlet对view进行渲染视图（即将模型数据填充至视图中）\n\n（11）dispatcherservlet响应用户。\n\n2. ioc控制反转底层原理\n\n 1. 自定义两个注解\n    \n    @component：判断是否注入bean容器\n    \n    @autowired：判断是否依赖注入\n\n 2. 创建applicationcontext容器类\n    \n    1. private concurrenthashmap<string, object> beans = null; 存放bean的容器\n    \n    2. initbeans(); 根据注解@component加载所有bean\n       \n       * 利用反射机制，遍历一个包下的所有类，判断类上有注解@component就放入beans容器中，beans.put(beanid, newinstance);\n    \n    3. initentryfield(); 根据注解@autowired加载所有依赖注入的对象\n       \n       * 所有bean初始化之后，判断bean的依赖注入关系\n       \n       * 遍历beans容器，利用反射机制，获取bean的所有属性并遍历判断有@autowired注解的进行依赖注入(利用java反射set注入，private不用写set方法了)\n         \n         //判断当前类属性是否存在注解\n         //declaredfields：利用反射得到的所有属性\n         for (field field : declaredfields) {\n             selfautowired extresource = field.getannotation(selfautowired.class);\n             if (extresource != null) {\n                 //属性名称：即容器中bean\n                 string beanid = field.getname();\n                 object bean = getbean(beanid);\n                 if (bean != null) {\n                     //默认使用属性名称，查找bean容器对象 1参数 当前对象 2参数给属性赋值\n                     field.setaccessible(true); //允许访问私有属性,private不用写set()了\n                     field.set(object, bean); //依赖注入\n                 }\n             }\n         }\n         \n         \n         1\n         2\n         3\n         4\n         5\n         6\n         7\n         8\n         9\n         10\n         11\n         12\n         13\n         14\n         15\n         \n\n3. 动态代理底层原理\n * 简书gstansen分析的很好，涉及动态代理比较复杂，我在这里简单概括下吧：\n\n 1. 业务接口（interface） 业务的抽象表示\n\n 2. 业务具体实现类（concretemanager） 实现业务接口，执行具体的业务操作\n\n 3. 业务代理类（$proxy，在运行的时候动态生成的类） 进行业务代理，调用业务代理操作类\n\n 4. 业务代理操作类（dynamicproxyhandler，实现了invocationhandler接口的类） 代理方法的直接调用者，通过invocationhandler中的invoke方法直接发起代理\n    \n    public class dynamicproxyhandler implements invocationhandler{\n        object realcookmanager;\n        dynamicproxyhandler(icook realcookmanager){\n            this.realcookmanager = realcookmanager;\n        }\n        @override\n        public object invoke(object proxy, method method, object[] args) throws throwable {\n            system.out.println("invoke start");\n            system.out.println(method.getname());\n            method.invoke(realcookmanager,args);\n            system.out.println("invoke end");\n            return null;\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n\n 5. 客户端调用对象（client） 发起业务\n\n * 总体思路：\n   \n   /* 5.客户端调用对象（client）\n    */\n   public class main {\n       public static void main(string[] args){\n   \t\t//1. 业务实现类\n           cookmanager cookmanager = new cookmanager();\n           //2. 业务代理操作类\n           dynamicproxyhandler dynamicproxyhandler = \n               new dynamicproxyhandler(cookmanager);\n           //3. proxy类中的newproxyinstance()方法利用java反射返回代理类的实例\n           icook icook =(icook)proxy.newproxyinstance(\n               dynamicproxyhandler.getclass().getclassloader(),\n               cookmanager.getclass().getinterfaces(),\n               dynamicproxyhandler);\n           \n           //打印一下代理类的类名\n           system.out.println(icook.getclass().getname());\n           icook.dealwithfoot();\n           icook.cook();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   \n   > icook icook = (icook)proxy.newproxyinstance(\n   > \n   > 业务代理操作类.getclass().getclassloader(),\n   > \n   > 业务具体实现类.getclass().getinterfaces(),\n   > \n   > 业务代理操作类 );\n   \n   1. classloader是一个抽象类，作用是将字节码文件加载进虚拟机并生成相应的class（注意是小写的）\n   2. interfaces就是被实现的那些业务接口\n   3. 业务代理操作类：实现invocationhandler接口的实例，即dynamicproxyhandler\n   \n   proxy类中的newproxyinstance()方法利用java反射返回代理类的实例：\n   \n   public static object newproxyinstance(classloader loader,class<?>[]\n                                         interfaces,invocationhandler h){\n        //所有被实现的业务接口\n         final class<?>[] intfs = interfaces.clone();\n        //寻找或生成指定的代理类\n         class<?> cl = getproxyclass0(loader, intfs);\n         //通过反射类中的constructor获取其所有构造方法\n         final constructor<?> cons = cl.getconstructor(constructorparams);\n         //通过constructor返回代理类的实例\n         return cons.newinstance(new object[]{h});\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n4、读过springmvc源码？\n\nspringmvc入口 请求 映射器 适配器\n\n//前端控制器分派方法 \n\nprotected void dodispatch(httpservletrequest request, httpservletresponse response) throws exception { \n\n​    httpservletrequest processedrequest = request; \n\n​    handlerexecutionchain mappedhandler = null; \n\n​    int interceptorindex = -1;\n\n​    try { \n\n​      modelandview mv; \n\n​      boolean errorview = false;  \n\n​      try { \n\n​    //检查是否是请求是否是multipart（如文件上传），如果是将通过multipartresolver解析 \n\n​        processedrequest = checkmultipart(request); \n\n​     //步骤2、请求到处理器（页面控制器）的映射，通过handlermapping进行映射 \n\n​        mappedhandler = gethandler(processedrequest, false); \n\n​        if (mappedhandler == null || mappedhandler.gethandler() == null) { \n\n​          nohandlerfound(processedrequest, response); \n\n​          return; \n\n​        } \n\n //步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器） \n\n​        handleradapter ha = gethandleradapter(mappedhandler.gethandler());  \n\n​        // 304 not modified缓存支持 \n\n​        //此处省略具体代码  \n\n​        // 执行处理器相关的拦截器的预处理（handlerinterceptor.prehandle） \n\n​        //此处省略具体代码  \n\n​        // 步骤4、由适配器执行处理器（调用处理器相应功能处理方法） \n\n​        mv = ha.handle(processedrequest, response, mappedhandler.gethandler());  \n\n​        // do we need view name translation? \n\n​        if (mv != null && !mv.hasview()) { \n\n​          mv.setviewname(getdefaultviewname(request)); \n\n​        }  \n\n​        // 执行处理器相关的拦截器的后处理（handlerinterceptor.posthandle） \n\n​        //此处省略具体代码 \n\n​      } \n\n​      catch (modelandviewdefiningexception ex) { \n\n​        logger.debug("modelandviewdefiningexception encountered", ex); \n\n​        mv = ex.getmodelandview(); \n\n​      } \n\n​      catch (exception ex) { \n\n​        object handler = (mappedhandler != null ? mappedhandler.gethandler() : null); \n\n​        mv = processhandlerexception(processedrequest, response, handler, ex); \n\n​        errorview = (mv != null); \n\n​      }  \n\n//步骤5 步骤6、解析视图并进行视图的渲染 \n\n//步骤5 由viewresolver解析view（viewresolver.resolveviewname(viewname, locale)） \n\n步骤6 视图在渲染时会把model传入（view.render(mv.getmodelinternal(), request, response);） \n\n​      if (mv != null && !mv.wascleared()) { \n\n​        render(mv, processedrequest, response); \n\n​        if (errorview) { \n\n​          webutils.clearerrorrequestattributes(request); \n\n​        } \n\n​      } \n\n​      else { \n\n​        if (logger.isdebugenabled()) { \n\n​          logger.debug("null modelandview returned to dispatcherservlet with name \'" + getservletname() + \n\n​              "\': assuming handleradapter completed request handling"); \n\n​        } \n\n​      }  \n\n​      // 执行处理器相关的拦截器的完成后处理（handlerinterceptor.aftercompletion） \n\n​      //此处省略具体代码  \n\n​    catch (exception ex) { \n\n​      // trigger after-completion for thrown exception. \n\n​      triggeraftercompletion(mappedhandler, interceptorindex, processedrequest, response, ex)      throw ex; \n\n​    } \n\n​    catch (error err) { \n\n​      servletexception ex = new nestedservletexception("handler processing failed", err); \n\n​      // trigger after-completion for thrown exception. \n\n​      triggeraftercompletion(mappedhandler, interceptorindex, processedrequest, response, ex); \n\n​      throw ex; \n\n​    }  \n\n​    finally { \n\n​      // clean up any resources used by a multipart request. \n\n​      if (processedrequest != request) {\n\n​        cleanupmultipart(processedrequest); \n\n​      } \n\n​    } \n\n  } \n\n \n\n \n\nspringmvc九大组件：\n\nprotected void initstrategies(applicationcontext context) {\n\n  //用于处理上传请求。处理方法是将普通的request包装成multiparthttpservletrequest，后者可以直接调用getfile方法获取file.\n\n  initmultipartresolver(context);\n\n  //springmvc主要有两个地方用到了locale：一是viewresolver视图解析的时候；二是用到国际化资源或者主题的时候。\n\n  initlocaleresolver(context); \n\n  //用于解析主题。springmvc中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、\n\n  //如图片、css样式等。springmvc的主题也支持国际化， \n\n  initthemeresolver(context);\n\n  //用来查找handler的。\n\n  inithandlermappings(context);\n\n  //从名字上看，它就是一个适配器。servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。\n\n  //如何让固定的servlet处理方法调用灵活的handler来进行处理呢？这就是handleradapter要做的事情\n\n  inithandleradapters(context);\n\n  //其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？\n\n  //这就需要有一个专门的角色对异常情况进行处理，在springmvc中就是handlerexceptionresolver。\n\n  inithandlerexceptionresolvers(context);\n\n  //有的handler处理完后并没有设置view也没有设置viewname，这时就需要从request获取viewname了，\n\n  //如何从request中获取viewname就是requesttoviewnametranslator要做的事情了。\n\n  initrequesttoviewnametranslator(context);\n\n  //viewresolver用来将string类型的视图名和locale解析为view类型的视图。\n\n  //view是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。\n\n  initviewresolvers(context);\n\n  //用来管理flashmap的，flashmap主要用在redirect重定向中传递参数。\n\n  initflashmapmanager(context); \n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n\n\n\n# 其它\n\n1. 定时任务\n\n就是在xml中配置，具体可以看我的这篇文章\n\n 1. 先配置(实例化)一个业务，就是我们自己写的类\n 2. 再配置一个任务，jobdetailfactorybean\n    * 在这个任务里name=targetobject 注入我们自己写的那个类\n    * 要用哪个方法的话，就name=tagetmethod 注入那个方法\n    * name=concurrent 设置为false防止并发执行\n 3. 再配置触发器(cron表达式)，crontriggerbean\n    * name=jobdetail 注入那个任务\n    * name=cronexpression 设置定时触发时间\n 4. 配置一个调度器(只能有一个) schedulerfactorybean\n    * name=triggers 注入要调度的哪个触发器\n\n2. dubbo\n\n> 参考 dubbo官网配置\n\n * 提供者：提供方应用信息\n   \n   配置<dubbo:registry>zookeeper注册中心暴露服务地址\n   配置dubbo协议和端口号<dubbo:protocol> dubbo协议\n   <dubbo:service>声明要暴露的服务接口(或者用注解)\n\n * zookeeper：注册中心\n\n * 消费者：消费方应用信息\n   \n   配置zookeeper注册中心暴露服务地址<dubbo:registry>\n   获取注册中心的接口信息<dubbo:reference>\n\n3. httpclient短信验证码\n\n> 参考互亿无线文档\n\n 1. 前端点击获取验证码的时候，ajax访问后台请求，同时倒计时60秒\n 2. 我们在后台拿到短信平台提供的接口地址，然后看他需要什么参数（用户名，密码，手机号，短信验证码），它有文档demo嘛，就根据它的改成我们需要的，然后拼装参数给他返回去\n 3. 然后他呢也会给我们返回一堆参数(是成功还是失败)，我们把这些参数返回给前端\n\n4. webservice\n\n> 参考博客简单的webservice接口生成\n> 方法上加@webmentod(exclude=true)后，此方法不被发布\n> 静态方法不会被发布\n\n 1. 配置web.xml文件 设置cxf要拦截的路径\n    cxf服务端必须定义cxfservlet对象\n 2. 配置服务端cxf.xml文件 （暴露访问地址,发布接口）\n    <cxf:endpoint address="/user" implementor="#实现类"/>\n 3. 定义一个bean类\n 4. 争对这个bean类写一个接口，在接口前加注解\n    @javax.jws.webservice(表示一个服务端发布接口)\n 5. 在这个接口的实现类加@javax.jws.webservice、 @service (服务层)\n 6. 地址栏登陆时：记得\n    http://localhost:8080/工程名/ws(web.xml配置)/自己配置的地址?wsdl\n\n * 如果用cxf测试接口的话\n   1. 配置cxf服务端(以上)\n   2. 配置客户端xml 请求地址，和服务端暴露的接口\n   3. cmd下 一堆命令\n\n5. spring中配置事务\n\n> 声明式事务配置详解\n\n * web.xml加载顺序：\n\n 1. listener 加载spring\n\n \x3c!-- spring start --\x3e\n <listener>\n \t\x3c!-- spring web容器  默认加载spring配置文件路径为 web-inf/applicationcontext.xml--\x3e\n \t<listener-class>\n \t\torg.springframework.web.context.contextloaderlistener\n \t</listener-class>\n </listener>\n \n <context-param>\n \t<param-name>contextconfiglocation</param-name>\n \t<param-value>classpath:applicationcontext*.xml</param-value>\n </context-param>\n \x3c!-- spring end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n 2. filter\n 3. servlet\n\n\x3c!-- springmvc start --\x3e\n <servlet>\n \t<servlet-name>mvc</servlet-name>\n \t<servlet-class>\n \t\torg.springframework.web.servlet.dispatcherservlet\n \t</servlet-class>\n \t<init-param>\n \t\t<param-name>contextconfiglocation</param-name>\n \t\t<param-value>classpath:springmvc.xml</param-value>\n \t</init-param>\n </servlet>\n \n <servlet-mapping>\n \t<servlet-name>mvc</servlet-name>\n \t<url-pattern>/</url-pattern>\n </servlet-mapping>\n \x3c!-- springmvc end --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * web.xml加载的时候先加载spring，后加载springmvc\n\n 1. spring自带aop，spring是父容器\n 2. springmvc没有引入aop，springmvc是子容器\n 3. 子容器的创建依赖于父容器的创建，父容器先于子容器创建；子容器 (springmvc 容器) 可以访问父容器 (spring 容器) 的 bean，父容器 (spring 容器) 不能访问子容器 (springmvc 容器) 的 bean\n 4. 所以一般在子容器springmvc中开启aop配置 <aop:aspectj-autoproxy/>\n 5. 而事务、切面都依赖于aop\n 6. 如果不想aop在controller生效，则配置的时候可以让springmvc只扫描@controller注解，spring扫描除了@controller的其它所有注解，并且在spring中开启aop配置即可\n\n * 以下是具体配置：\n\n\x3c!-- springmvc配置 --\x3e\n\n\x3c!-- use-default-filters="false" 所有注解不被加载 --\x3e\n<context:component-scan base-package="com.xxx" use-default-filters="false">\n    \x3c!-- 只加载@controller注解 --\x3e\n    <context:include-filter type="annotation" \n                            expression="org.springframework.stereotype.controller" />\n</context:component-scan>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\x3c!-- spring配置 --\x3e\n\n\x3c!-- spring配置aop --\x3e\n<aop:aspectj-autoproxy/>\n\x3c!-- use-default-filters="true" 默认、加载所有注解 --\x3e\n<context:component-scan base-package="com.xxx">\n    \x3c!-- 加载除了@controller的其它所有注解 --\x3e\n    <context:exclude-filter type="annotation" \n                            expression="org.springframework.stereotype.controller"/>\n</context:component-scan>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"阿里巴巴 Java 开发手册 v1.2.0",frontmatter:{title:"阿里巴巴 Java 开发手册 v1.2.0",date:"2017-05-02T00:00:00.000Z",sidebar:!0,sidebarDepth:5,tags:["开发规范","Java"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/ali.html",relativePath:"views/specification/ali.md",key:"v-b3ebfa12",path:"/views/specification/ali.html",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:50},{level:2,title:"编程规范",slug:"编程规范",normalizedTitle:"编程规范",charIndex:771},{level:3,title:"命名风格",slug:"命名风格",normalizedTitle:"命名风格",charIndex:780},{level:3,title:"常量定义",slug:"常量定义",normalizedTitle:"常量定义",charIndex:3422},{level:3,title:"代码格式",slug:"代码格式",normalizedTitle:"代码格式",charIndex:4446},{level:3,title:"OOP 规约",slug:"oop-规约",normalizedTitle:"oop 规约",charIndex:6524},{level:3,title:"集合处理",slug:"集合处理",normalizedTitle:"集合处理",charIndex:10339},{level:3,title:"并发处理",slug:"并发处理",normalizedTitle:"并发处理",charIndex:14244},{level:3,title:"控制语句",slug:"控制语句",normalizedTitle:"控制语句",charIndex:17330},{level:3,title:"注释规约",slug:"注释规约",normalizedTitle:"注释规约",charIndex:19149},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:20590},{level:2,title:"异常日志",slug:"异常日志",normalizedTitle:"异常日志",charIndex:278},{level:3,title:"异常处理",slug:"异常处理",normalizedTitle:"异常处理",charIndex:21447},{level:3,title:"日志规约",slug:"日志规约",normalizedTitle:"日志规约",charIndex:23656},{level:2,title:"MYSQL 数据库",slug:"mysql-数据库",normalizedTitle:"mysql 数据库",charIndex:25287},{level:3,title:"建表规约",slug:"建表规约",normalizedTitle:"建表规约",charIndex:25301},{level:3,title:"索引规约",slug:"索引规约",normalizedTitle:"索引规约",charIndex:27085},{level:3,title:"SQL 语句",slug:"sql-语句",normalizedTitle:"sql 语句",charIndex:28940},{level:3,title:"ORM 映射",slug:"orm-映射",normalizedTitle:"orm 映射",charIndex:30362},{level:2,title:"工程结构",slug:"工程结构",normalizedTitle:"工程结构",charIndex:216},{level:3,title:"应用分层",slug:"应用分层",normalizedTitle:"应用分层",charIndex:31624},{level:3,title:"二方库依赖",slug:"二方库依赖",normalizedTitle:"二方库依赖",charIndex:6922},{level:3,title:"服务器",slug:"服务器",normalizedTitle:"服务器",charIndex:19043},{level:2,title:"安全规约",slug:"安全规约",normalizedTitle:"安全规约",charIndex:298},{level:2,title:"附 1：版本历史",slug:"附-1-版本历史",normalizedTitle:"附 1：版本历史",charIndex:36332},{level:2,title:"附 2：本手册专有名词",slug:"附-2-本手册专有名词",normalizedTitle:"附 2：本手册专有名词",charIndex:36898}],headersStr:"前言 编程规范 命名风格 常量定义 代码格式 OOP 规约 集合处理 并发处理 控制语句 注释规约 其他 异常日志 异常处理 日志规约 MYSQL 数据库 建表规约 索引规约 SQL 语句 ORM 映射 工程结构 应用分层 二方库依赖 服务器 安全规约 附 1：版本历史 附 2：本手册专有名词",content:'> 最新阿里编码规范： https://edu.aliyun.com/course/417\n\n\n# 前言\n\n《阿里巴巴 Java 开发手册》是阿里巴巴集团技术团队的集体经验总结，经历了多次大规模一线实战的检验及不断的完善，反馈给广大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以 Java 开发者为中心视角，划分为编程规约、异常日志、MySQL 数据库、工程结构、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内容做了引申和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。\n\n本手册的愿景是码出高效、码出质量。代码的字里行间流淌的是软件生命中的血 液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。另外，现代 软件架构都需要协同开发完成，高效协作即降低协同成本，提升沟通效率，所谓无规 矩不成方圆，无规范不能协作。众所周知，制订交通法规表面上是要限制行车权，实 际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，谁还敢上路行驶。对 软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度 个性化，以一种普遍认可的统一方式一起做事，提升协作效率。\n\n《阿里巴巴 Java 开发手册》，开放包容地认真听取社区、博客、论坛的反馈，及时修正，保持与时俱进。请关注手册末页的“阿里技术”和“云栖社区”公众号获取最新版本。\n\n\n# 编程规范\n\n\n# 命名风格\n\n 1.  【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。\n     反例： _name / __name / $Object / name_ / name$ / Object$\n\n 2.  【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。\n     正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。\n     反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3\n\n 3.  【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO\n     正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion\n     反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion\n\n 4.  【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。\n     正例： localValue / getHttpMessage() / inputUserId\n\n 5.  【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n     正例： MAX_STOCK_COUNT\n     反例： MAX_COUNT\n\n 6.  【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。\n\n 7.  【强制】中括号是数组类型的一部分，数组定义如下：String[] args。\n     反例： 使用 String args[] 的方式来定义。\n\n 8.  【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。\n     反例： 定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。\n\n 9.  【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n     正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考 spring 的框架结构）\n\n 10. 【强制】杜绝完全不规范的缩写，避免望文不知义。\n     反例： AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。\n\n 11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。\n     说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。\n     正例：\n\npublic class OrderFactory;\npublic class LoginProxy;\npublic class ResourceObserver;\n\n\n1\n2\n3\n\n\n 12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。\n     正例： 接口方法签名：void f();\n     接口基础常量表示：String COMPANY = "alibaba";\n     反例： 接口方法定义：public abstract void f();\n     说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。\n\n 13. 接口和实现类的命名有两套规则：\n     1） 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。\n     正例： CacheServiceImpl 实现 CacheService 接口。\n     2） 【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。\n     正例： AbstractTranslator 实现 Translatable。\n\n 14. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n     说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。\n     正例： 枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。\n\n 15. 【参考】各层命名规约：\n     \n     1. Service/DAO 层方法命名规约\n        1） 获取单个对象的方法用 get 做前缀。\n        2） 获取多个对象的方法用 list 做前缀。\n        3） 获取统计值的方法用 count 做前缀。\n        4） 插入的方法用 save（推荐）或 insert 做前缀。\n        5） 删除的方法用 remove（推荐）或 delete 做前缀。\n        6） 修改的方法用 update 做前缀。\n     2. 领域模型命名规约\n        1） 数据对象：xxxDO，xxx 即为数据表名。\n        2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n        3） 展示对象：xxxVO，xxx 一般为网页名称。\n        4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。\n\n\n# 常量定义\n\n 1. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。\n    反例：\n\nString key = "Id#taobao_" + tradeId;  \ncache.put(key, value);\n\n\n1\n2\n\n 2. 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。 说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?\n 3. 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。\n    说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。\n 4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。 1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。\n    2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。\n    反例： 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：\n\n类 A 中：public static final String YES = "yes";  \n类 B 中：public static final String YES = "y";  \nA.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。  \n\n\n1\n2\n3\n\n\n3） 子工程内部共享常量：即在当前子工程的 constant 目录下。\n4） 包内共享常量：即在当前包下单独的 constant 目录下。\n5） 类内共享常量：直接在类内部 private static final 定义。\n\n 5. 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。\n    正例： public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}\n\n\n# 代码格式\n\n 1. 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：\n    1） 左大括号前不换行。\n    2） 左大括号后换行。\n    3） 右大括号前换行。\n    4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。\n\n 2. 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。\n    反例： if (空格 a == b 空格)\n\n 3. 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。\n\n 4. 【强制】任何二目、三目运算符的左右两边都需要加一个空格。\n    说明： 运算符包括赋值运算符=、逻辑运算符&&、加减乘除符号等。\n\n 5. 【强制】缩进采用 4 个空格，禁止使用 tab 字符。\n    说明： 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。\n    正例： （涉及 1-5 点）\n\npublic static void main(String[] args) {\n  // 缩进 4 个空格\n  String say = "hello";\n  // 运算符的左右必须有一个空格\n  int flag = 0;\n  // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格\n  if (flag == 0) {\n      System.out.println(say);\n  }\n\n  // 左大括号前加空格且不换行；左大括号后换行\n  if (flag == 1) {\n      System.out.println("world");\n      // 右大括号前换行，右大括号后有 else，不用换行\n  } else {\n      System.out.println("ok");\n      // 在右大括号后直接结束，则必须换行\n  }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 6. 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：\n    1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。\n    2） 运算符与下文一起换行。\n    3） 方法调用的点符号与下文一起换行。\n    4） 在多个参数超长，在逗号后换行。\n    5） 在括号前不要换行，见反例。\n    正例：\n\n StringBuffer sb = new StringBuffer();\n //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行\n sb.append("zi").append("xin")...\n .append("huang")...\n .append("huang")...\n .append("huang");\n\n\n1\n2\n3\n4\n5\n6\n\n\n反例：\n\n StringBuffer sb = new StringBuffer();\n //超过 120 个字符的情况下，不要在括号前换行\n sb.append("zi").append("xin")...append\n ("huang");\n //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行\n method(args1, args2, args3, ...\n , argsX); \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n 7. 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。\n    正例： 下例中实参的"a",后边必须要有一个空格。method("a", "b", "c");\n\n 8. 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。\n\n 9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。\n    正例：\n\n  int a = 3;\n  long b = 4L;\n  float c = 5F;\n  StringBuffer sb = new StringBuffer();\n\n\n1\n2\n3\n4\n\n\n说明： 增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。\n\n 10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。\n     说明： 没有必要插入多个空行进行隔开。\n\n\n# OOP 规约\n\n 1.  【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。\n\n 2.  【强制】所有的覆写方法，必须加@Override 注解。\n     说明： getObject() 与 get0bject() 的问题。一个是字母的 O，一个是数字的 0，加 @Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。\n\n 3.  【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。\n     说明： 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）\n     正例： public User getUsers(String type, Integer... ids) {...}\n\n 4.  【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。\n\n 5.  【强制】不能使用过时的类或方法。\n     说明： java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。\n\n 6.  【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例： "test".equals(object); 反例： object.equals("test"); 说明： 推荐使用 java.util.Objects#equals （JDK7 引入的工具类）\n\n 7.  【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。\n\n 8.  关于基本数据类型与包装数据类型的使用标准如下：\n     1） 【强制】所有的 POJO 类属性必须使用包装数据类型。\n     2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。\n     3） 【推荐】所有的局部变量使用基本数据类型。\n     说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。\n     正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。\n     反例： 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。\n\n 9.  【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。\n     反例： POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具 体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。\n\n 10. 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。\n     说明： 注意 serialVersionUID 不一致会抛出序列化运行时异常。\n\n 11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。\n\n 12. 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source> generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。\n     说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。\n\n 13. 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。\n     说明：\n\nString str = "a,b,c,,";\nString[] ary = str.split(",");\n//预期大于 3，结果是 3\nSystem.out.println(ary.length);\n\n\n1\n2\n3\n4\n\n\n 14. 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。\n\n 15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter 方法。\n     说明： 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。\n\n 16. 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。\n     反例：\n\npublic Integer getData() {\n    if (true) {\n   \t return this.data + 100;\n    } else {\n    \treturn this.data - 100;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 17. 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。\n     说明： 反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。\n     反例：\n\nString str = "start";\nfor (int i = 0; i < 100; i++) {\n   str = str + "hello";\n}\n\n\n1\n2\n3\n4\n\n\n 18. 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：\n     1） 不允许被继承的类，如：String 类。\n     2） 不允许修改引用的域对象，如：POJO 类的域变量。\n     3） 不允许被重写的方法，如：POJO 类的 setter 方法。\n     4） 不允许运行过程中重新赋值的局部变量。\n     5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。\n\n 19. 【推荐】慎用 Object 的 clone 方法来拷贝对象。\n     说明： 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。\n\n 20. 【推荐】类成员与方法访问控制从严：\n     1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。\n     2） 工具类不允许有 public 或 default 构造方法。\n     3） 类非 static 成员变量并且与子类共享，必须是 protected。\n     4） 类非 static 成员变量并且仅在本类使用，必须是 private。\n     5） 类 static 成员变量如果仅在本类使用，必须是 private。\n     6） 若是 static 成员变量，必须考虑是否为 final。\n     7） 类成员方法只供类内部调用，必须是 private。\n     8） 类成员方法只对继承类公开，那么限制为 protected。\n     说明： 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。\n\n\n# 集合处理\n\n 1. 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：\n    1） 只要重写 equals，就必须重写 hashCode。\n    2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。\n    3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。\n    说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。\n\n 2. 【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;\n    说明： subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。\n\n 3. 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增 加、删除均产生 ConcurrentModificationException 异常。\n\n 4. 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。\n    说明： 使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。\n    正例：\n\n List<String> list = new ArrayList<String>(2);\n list.add("guan");\n list.add("bao");\n String[] array = new String[list.size()];\n array = list.toArray(array);\n\n\n1\n2\n3\n4\n5\n\n\n反例： 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。\n\n 5. 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。\n    说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。\n\n  String[] str = new String[] { "a", "b" };\n  List list = Arrays.asList(str);\n\n\n1\n2\n\n\n第一种情况：list.add("c"); 运行时异常。\n第二种情况：str[0] = "gujin"; 那么 list.get(0)也会随之修改。\n\n 6. 【强制】泛型通配符 <? extends T> 来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 <? super T> 不能使用 get 方法，做为接口调用赋值时易出错。\n    说明： 扩展说一下 PECS(Producer Extends Consumer Super) 原则：1）频繁往外读取内容 的，适合用上界 Extends。2）经常往里插入的，适合用下界 Super。\n\n 7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。\n    正例：\n\nIterator<String> it = a.iterator();\nwhile (it.hasNext()) {\n   String temp = it.next();\n   if (删除元素的条件) {\n       it.remove();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n反例：\n\nList<String> a = new ArrayList<String>();\na.add("1");\na.add("2");\nfor (String temp : a) {\n   if ("1".equals(temp)) {\n       a.remove(temp);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明： 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？\n\n 8. 【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。\n    说明：\n    1） x，y 的比较结果和 y，x 的比较结果相反。\n    2） x>y，y>z，则 x>z。\n    3） x=y，则 x，z 比较结果和 y，z 比较结果相同。\n    反例： 下例中没有处理相等的情况，实际使用中可能会出现异常：\n\n new Comparator<Student>() {\n     @Override\n     public int compare(Student o1, Student o2) {\n         return o1.getId() > o2.getId() ? 1 : -1;\n     }\n };\n\n\n1\n2\n3\n4\n5\n6\n\n\n 9.  【推荐】集合初始化时，指定集合初始值大小。\n     说明： HashMap 使用 HashMap(int initialCapacity) 初始化， 正例： initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。\n     反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。\n\n 10. 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。\n     说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。\n     正例： values() 返回的是 V 值集合，是一个 list 集合对象；keySet() 返回的是 K 值集合，是一个 Set 集合对象；entrySet() 返回的是 K-V 值组合集合。\n\n 11. 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：\n\n集合类                 KEY         VALUE       SUPER         说明\nHashTable           不允许为 null   不允许为 null   Dictionary    线程安全\nConcurrentHashMap   不允许为 null   不允许为 null   AbstractMap   分段锁技术\nTreeMap             不允许为 null   允许为 null    AbstractMap   线程不安全\nHashMap             允许为 null    允许为 null    AbstractMap   线程不安全\n\n反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。\n\n 12. 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。\n     说明： 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次 序是一定的。如： ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。\n\n 13. 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。\n\n\n# 并发处理\n\n 1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。\n    说明： 资源驱动类、工具类、单例工厂类都需要注意。\n\n 2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。\n    正例：\n\n public class TimerTaskThread extends Thread {\n     public TimerTaskThread() {\n         super.setName("TimerTaskThread"); ...\n     }\n }\n\n\n1\n2\n3\n4\n5\n\n\n 3. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n    说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n 4. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n    说明： Executors 返回的线程池对象的弊端如下：\n    \n    1. FixedThreadPool 和 SingleThreadPool:\n       允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n    2. CachedThreadPool 和 ScheduledThreadPool:\n       允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n 5. 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。\n    正例： 注意线程安全，使用 DateUtils。亦推荐如下处理：\n\n  private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {\n      @Override\n      protected DateFormat initialValue() {\n          return new SimpleDateFormat("yyyy-MM-dd");\n      }\n  };\n\n\n1\n2\n3\n4\n5\n6\n\n\n说明： 如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。\n\n 6.  【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。\n     说明： 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。\n\n 7.  【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。\n     说明： 线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。\n\n 8.  【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。\n     说明： 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。\n\n 9.  【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。\n\n 10. 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。\n     说明： 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。\n\n 11. 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。\n     说明： Random 实例包括 java.util.Random 的实例或者 Math.random() 的方式。\n     正例： 在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个实例。\n\n 12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)，推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。\n     反例：\n\nclass Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n        if (helper == null) synchronized(this) {\n            if (helper == null)\n                helper = new Helper();\n        }\n        return helper;\n    }\n    // other functions and members...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n 13. 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现： AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。\n\n 14. 【参考】 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。\n\n 15. 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。\n\n\n# 控制语句\n\n 1. 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。\n\n 2. 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;\n\n 3. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：\n\n    if (condition) {\n     ...\n     return obj;\n    }\n    // 接着写 else 的业务逻辑代码;\n\n\n1\n2\n3\n4\n5\n\n\n说明： 如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。\n\n正例： 逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下：\n\n    public void today() {\n        if (isBusy()) {\n            System.out.println(“change time.”);\n            return;\n        }\n        if (isFree()) {\n            System.out.println(“go to travel.”);\n            return;\n        }\n        System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”);\n        return;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 4. 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。\n    说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？\n    正例：\n\n //伪代码如下\n final boolean existed = (file.open(fileName, "w") != null) && (...) || (...);\n if (existed) {\n  ...\n }\n\n\n1\n2\n3\n4\n5\n\n\n反例：\n\n if ((file.open(fileName, "w") != null) && (...) || (...)) {\n  ...\n }\n\n\n1\n2\n3\n\n\n 5. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。\n\n 6. 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。\n\n 7. 【参考】下列情形，需要进行参数校验：\n    1） 调用频次低的方法。\n    2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参 数错误导致中间执行回退，或者错误，那得不偿失。\n    3） 需要极高稳定性和可用性的方法。\n    4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。\n    5） 敏感权限入口。\n\n 8. 【参考】下列情形，不需要进行参数校验：\n    1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。\n    2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底 层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。\n    3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。\n\n\n# 注释规约\n\n 1.  【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用 //xxx 方式。\n     说明： 在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高 阅读效率。\n\n 2.  【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。\n     说明： 对子类的实现要求，或者调用注意事项，请一并说明。\n\n 3.  【强制】所有的类都必须添加创建者和创建日期。\n\n 4.  【强制】方法内部单行注释，在被注释语句上方另起一行，使用 //注释。方法内部多行注释使用/* */注释，注意与代码对齐。\n\n 5.  【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。\n\n 6.  【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。\n     反例： “TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。\n\n 7.  【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。\n     说明： 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。\n\n 8.  【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。\n     说明： 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。\n\n 9.  【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。\n\n 10. 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。\n     反例：\n\n// put elephant into fridge\nput(elephant, fridge);\n\n\n1\n2\n\n\n方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。\n\n 11. 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。\n     1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。\n     2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。\n\n\n# 其他\n\n 1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);\n\n 2. 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。\n    说明： 注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。\n\n 3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。\n    说明： 如果 var=null 或者不存在，那么${var}会直接显示在页面上。\n\n 4. 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。\n\n 5. 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();\n    说明： 如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。\n\n 6. 【推荐】不要在视图模板中加入任何复杂的逻辑。 说明： 根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。\n\n 7. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。\n\n 8. 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。\n\n\n# 异常日志\n\n\n# 异常处理\n\n 1.  【强制】Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： IndexOutOfBoundsException ， NullPointerException 等等。\n     说明： 无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch NumberFormatException 来实现。\n     正例： if (obj != null) {...}\n     反例： try { obj.method() } catch (NullPointerException e) {...}\n\n 2.  【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。\n\n 3.  【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。\n\n 4.  【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。\n\n 5.  【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。\n\n 6.  【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。\n     说明： 如果 JDK7 及以上，可以使用 try-with-resources 方式。\n\n 7.  【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。\n\n 8.  【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。\n     说明： 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。\n\n 9.  【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。\n     说明： 本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。\n\n 10. 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：\n     1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。\n     反例： public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。\n     2） 数据库的查询结果可能为 null。\n     3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。\n     4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。\n     5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。\n     6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。\n     正例： 使用 JDK8 的 Optional 类来防止 NPE 问题。\n\n 11. 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。\n\n 12. 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。\n     说明： 关于 RPC 方法返回方式使用 Result 方式的理由：\n     1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。\n     2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。\n\n 13. 【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。\n     说明： 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。\n     正例： 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkParam(DTO dto) {...}\n\n\n# 日志规约\n\n 1. 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nprivate static final Logger logger = LoggerFactory.getLogger(Abc.class);\n\n\n1\n2\n3\n\n\n 2. 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。\n\n 3. 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。\n    正例： mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log\n    说明： 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。\n\n 4. 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。\n    说明： logger.debug("Processing trade with id: " + id + " symbol: " + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。\n    正例： （条件）\n\nif (logger.isDebugEnabled()) {\n    logger.debug("Processing trade with id: " + id + " symbol: " + symbol);\n}\n\n\n1\n2\n3\n\n\n正例： （占位符）\n\nlogger.debug("Processing trade with id: {} symbol : {} ", id, symbol);\n\n\n1\n\n\n 5. 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。\n    正例： <logger name="com.taobao.dubbo.config" additivity="false">\n\n 6. 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。\n    正例： logger.error(各类参数或者对象 toString + "_" + e.getMessage(), e);\n\n 7. 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。\n    说明： 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？\n\n 8. 【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。\n\n\n# MYSQL 数据库\n\n\n# 建表规约\n\n 1.  【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。\n     说明： 任何字段如果为非负数，必须是 unsigned。\n     正例： 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。\n\n 2.  【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\n     正例： getter_admin，task_config，level3_name\n     反例： GetterAdmin，taskConfig，level_3_name\n\n 3.  【强制】表名不使用复数名词。\n     说明： 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。\n\n 4.  【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。\n\n 5.  【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。\n     说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。\n\n 6.  【强制】小数类型为 decimal，禁止使用 float 和 double。\n     说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。\n\n 7.  【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。\n\n 8.  【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。\n\n 9.  【强制】表必备三字段：id, gmt_create, gmt_modified。 说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。\n\n 10. 【推荐】表的命名最好是加上“业务名称_表的作用”。\n     正例： tiger_task / tiger_reader / mpp_config\n\n 11. 【推荐】库名与应用名称尽量一致。\n\n 12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。\n\n 13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：\n     1）不是频繁修改的字段。\n     2）不是 varchar 超长字段，更不能是 text 字段。\n     正例： 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。\n\n 14. 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。\n     说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\n\n 15. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\n     正例： 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。\n\n对象     年龄区间      类型                  表示范围\n人      150 岁之内   unsigned tinyint    无符号值：0 到 255\n龟      数百岁       unsigned smallint   无符号值：0 到 65535\n恐龙化石   数千万年      unsigned int        无符号值：0 到约 42.9 亿\n太阳     约 50 亿年   unsigned bigint     无符号值：0 到约 10 的 19 次方\n\n\n# 索引规约\n\n 1.  【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\n\n 2.  【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。\n     说明： 即使双表 join 也要注意表索引、SQL 性能。\n\n 3.  【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。\n     说明： 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n\n 4.  【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n     说明： 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\n\n 5.  【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。\n     正例： where a=? and b=? order by c; 索引：a_b_c\n     反例： 索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序。\n\n 6.  【推荐】利用覆盖索引来进行查询操作，避免回表。\n     说明： 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。\n     正例： 能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种 效果，用 explain 的结果，extra 列会出现：using index。\n\n 7.  【推荐】利用延迟关联或者子查询优化超多分页场景。\n     说明： MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。\n     正例： 先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id\n\n 8.  【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。\n     说明：\n     1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。\n     2） ref 指的是使用普通的索引（normal index）。\n     3） range 对索引进行范围检索。\n     反例： explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。\n\n 9.  【推荐】建组合索引的时候，区分度最高的在最左边。\n     正例： 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。\n     说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。\n\n 10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。\n\n 11. 【参考】创建索引时避免有如下极端误解：\n     1）宁滥勿缺。误认为一个查询就需要建一个索引。\n     2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。\n     3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。\n\n\n# SQL 语句\n\n 1.  【强制】不要使用 count(列名)或 count(常量)来替代 count()，count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。\n     说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。\n\n 2.  【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。\n\n 3.  【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。\n     正例： 可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;\n\n 4.  【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。\n     说明：\n     1） NULL<>NULL 的返回结果是 NULL，而不是 false。\n     2） NULL=NULL 的返回结果是 NULL，而不是 true。\n     3） NULL<>1 的返回结果是 NULL，而不是 true。\n\n 5.  【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。\n\n 6.  【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n     说明： （概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。\n\n 7.  【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\n\n 8.  【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。\n\n 9.  【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。\n\n 10. 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。\n     说明： SELECT LENGTH("轻松工作")； 返回为 12\n     SELECT CHARACTER_LENGTH("轻松工作")； 返回为 4\n     如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。\n\n 11. 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。\n     说明： TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。\n\n\n# ORM 映射\n\n 1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。\n    说明： 1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。\n\n 2. 【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。\n    说明： 参见定义 POJO 类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。\n\n 3. 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。\n    说明： 配置映射关系，使字段与 DO 类解耦，方便维护。\n\n 4. 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。\n\n 5. 【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。\n    说明： 其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList 取 start,size 的子集合。\n    正例：\n\n Map<String, Object> map = new HashMap<String, Object>();\n map.put("start", start);\n map.put("size", size);\n\n\n1\n2\n3\n\n\n 6.  【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。\n     说明： resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。\n\n 7.  【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。\n\n 8.  【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。\n\n 9.  【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。\n\n 10. 【参考】<isEqual>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为 null 时执行；<isNotNull>表示不为 null 值时执行。\n\n\n# 工程结构\n\n\n# 应用分层\n\n 1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：\n    \n    \n    \n    * 开放接口层： 可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。\n    * 终端显示层： 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。\n    * Web 层： 主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。\n    * Service 层： 相对具体的业务逻辑服务层。\n    * Manager 层： 通用业务处理层，它有如下特征：\n      1. 对第三方平台封装的层，预处理返回结果及转化异常信息；\n      2. 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；\n      3. 与 DAO 层交互，对多个 DAO 的组合复用。\n    * DAO 层： 数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。\n    * 外部接口或第三方平台： 包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。\n\n 2. 【参考】 （分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印 日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。\n\n 3. 【参考】分层领域模型规约：\n    \n    * DO（Data Object）： 与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。\n    * DTO（Data Transfer Object）： 数据传输对象，Service 和 Manager 向外传输的对象。\n    * BO（Business Object）： 业务对象。可以由 Service 层输出的封装业务逻辑的对象。\n    * Query： 数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。\n    * VO（View Object）： 显示层对象，通常是 Web 向模板渲染引擎层传输的对象。\n\n\n# 二方库依赖\n\n 1.  【强制】定义 GAV 遵从以下规则：\n     1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。\n     说明： {公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。\n     正例： com.taobao.jstorm 或 com.alibaba.dubbo.register\n     2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。\n     正例： dubbo-client / fastjson-api / jstorm-tool\n     3） Version：详细规定参考下方。\n\n 2.  【强制】二方库版本号命名方式：主版本号.次版本号.修订号\n     1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。\n     2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。\n     3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。\n     说明： 注意：起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0\n\n 3.  【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）。\n     说明： 不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。\n\n 4.  【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一 致，那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。\n\n 5.  【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚 举类型或者包含枚举类型的 POJO 对象。\n\n 6.  【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一 个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。\n\n 7.  【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。\n     说明： 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号 出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。\n\n 8.  【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在 <dependencyManagement>语句块中。 说明：<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的 <dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。\n\n 9.  【推荐】二方库不要有配置项，最低限度不要再增加配置项。\n\n 10. 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：\n     1）精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对 象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用 者去依赖具体版本号；无 log 具体实现，只依赖日志框架。\n     2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能 方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。\n\n\n# 服务器\n\n 1. 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。 说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服 务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上 调小此等待值。\n    正例： 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）： net.ipv4.tcp_fin_timeout = 30\n\n 2. 【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。\n    说明： 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对 应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。\n\n 3. 【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。\n    说明： OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错 非常有价值。\n\n 4. 【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则 会带来 URL 维护不一致的问题和潜在的安全风险。\n\n\n# 安全规约\n\n 1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。\n    说明： 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信 内容、修改他人的订单。\n\n 2. 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。\n    说明： 查看个人手机号码会显示成:158****9119，隐藏中间 4 位，防止隐私泄露。\n\n 3. 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入， 禁止字符串拼接 SQL 访问数据库。\n\n 4. 【强制】用户请求传入的任何参数必须做有效性验证。\n    说明： 忽略参数校验可能导致：\n    \n    * page size 过大导致内存溢出\n    * 恶意 order by 导致数据库慢查询\n    * 任意重定向\n    * SQL 注入\n    * 反序列化注入\n    * 正则输入源串拒绝服务 ReDoS\n    \n    说明： Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题， 但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。\n\n 5. 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。\n\n 6. 【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。\n    说明： CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户 不知情情况下对数据库中用户参数进行相应修改。\n\n 7. 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其 它用户，并造成短信平台资源浪费。\n\n 8. 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过 滤等风控策略。\n\n\n# 附 1：版本历史\n\n版本号     更新日期        备注\n1.0.0   2017.2.9    阿里巴巴集团正式对外发布\n1.0.1   2017.2.13   1）修正 String[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。\n1.0.2   2017.2.20   1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final\n                    描述。5）去除 Comparator 部分描述。\n1.1.0   2017.2.27   1）增加前言。2）增加<? extends T>描述和说明。3）增加版本历史。4）增加专有名词解释。\n1.1.1   2017.3.31   修正页码总数和部分示例\n1.2.0   2017.5.20   1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加\n                    final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为\n                    is_deleted\n\n\n# 附 2：本手册专有名词\n\n 1.  POJO（Plain Ordinary Java Object）：在本手册中，POJO 专指只有 setter / getter / toString 的简单类，包括 DO/DTO/BO/VO 等。\n\n 2.  DO（Data Object）：本手册指数据库表一一对应的 POJO 类。\n\n 3.  GAV（GroupId、ArtifactctId、Version）：Maven 坐标，是用来唯一标识 jar 包。\n\n 4.  OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。\n\n 5.  ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换， 本文泛指 iBATIS, mybatis 等框架。\n\n 6.  NPE（java.lang.NullPointerException）: 空指针异常。\n\n 7.  SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散 耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。\n\n 8.  一方库：本工程内部子项目模块依赖的库（jar 包）。\n\n 9.  二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。\n\n 10. 三方库：公司之外的开源库（jar 包）。',normalizedContent:'> 最新阿里编码规范： https://edu.aliyun.com/course/417\n\n\n# 前言\n\n《阿里巴巴 java 开发手册》是阿里巴巴集团技术团队的集体经验总结，经历了多次大规模一线实战的检验及不断的完善，反馈给广大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以 java 开发者为中心视角，划分为编程规约、异常日志、mysql 数据库、工程结构、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内容做了引申和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。\n\n本手册的愿景是码出高效、码出质量。代码的字里行间流淌的是软件生命中的血 液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。另外，现代 软件架构都需要协同开发完成，高效协作即降低协同成本，提升沟通效率，所谓无规 矩不成方圆，无规范不能协作。众所周知，制订交通法规表面上是要限制行车权，实 际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，谁还敢上路行驶。对 软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度 个性化，以一种普遍认可的统一方式一起做事，提升协作效率。\n\n《阿里巴巴 java 开发手册》，开放包容地认真听取社区、博客、论坛的反馈，及时修正，保持与时俱进。请关注手册末页的“阿里技术”和“云栖社区”公众号获取最新版本。\n\n\n# 编程规范\n\n\n# 命名风格\n\n 1.  【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。\n     反例： _name / __name / $object / name_ / name$ / object$\n\n 2.  【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。\n     正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。\n     反例： dazhepromotion [打折] / getpingfenbyname() [评分] / int 某变量 = 3\n\n 3.  【强制】类名使用 uppercamelcase 风格，必须遵从驼峰形式，但以下情形例外：do / bo / dto / vo / ao\n     正例： marcopolo / userdo / xmlservice / tcpudpdeal / tapromotion\n     反例： macropolo / userdo / xmlservice / tcpudpdeal / tapromotion\n\n 4.  【强制】方法名、参数名、成员变量、局部变量都统一使用 lowercamelcase 风格，必须遵从驼峰形式。\n     正例： localvalue / gethttpmessage() / inputuserid\n\n 5.  【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n     正例： max_stock_count\n     反例： max_count\n\n 6.  【强制】抽象类命名使用 abstract 或 base 开头；异常类命名使用 exception 结尾；测试类命名以它要测试的类的名称开始，以 test 结尾。\n\n 7.  【强制】中括号是数组类型的一部分，数组定义如下：string[] args。\n     反例： 使用 string args[] 的方式来定义。\n\n 8.  【强制】pojo 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。\n     反例： 定义为基本数据类型 boolean isdeleted；的属性，它的方法也是 isdeleted()，rpc 框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。\n\n 9.  【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n     正例： 应用工具类包名为 com.alibaba.open.util、类名为 messageutils（此规则参考 spring 的框架结构）\n\n 10. 【强制】杜绝完全不规范的缩写，避免望文不知义。\n     反例： abstractclass “缩写”命名成 absclass；condition “缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。\n\n 11. 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。\n     说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。\n     正例：\n\npublic class orderfactory;\npublic class loginproxy;\npublic class resourceobserver;\n\n\n1\n2\n3\n\n\n 12. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。\n     正例： 接口方法签名：void f();\n     接口基础常量表示：string company = "alibaba";\n     反例： 接口方法定义：public abstract void f();\n     说明： jdk8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。\n\n 13. 接口和实现类的命名有两套规则：\n     1） 【强制】对于 service 和 dao 类，基于 soa 的理念，暴露出来的服务一定是接口，内部的实现类用 impl 的后缀与接口区别。\n     正例： cacheserviceimpl 实现 cacheservice 接口。\n     2） 【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。\n     正例： abstracttranslator 实现 translatable。\n\n 14. 【参考】枚举类名建议带上 enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n     说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。\n     正例： 枚举名字：dealstatusenum，成员名称：success / unkown_reason。\n\n 15. 【参考】各层命名规约：\n     \n     1. service/dao 层方法命名规约\n        1） 获取单个对象的方法用 get 做前缀。\n        2） 获取多个对象的方法用 list 做前缀。\n        3） 获取统计值的方法用 count 做前缀。\n        4） 插入的方法用 save（推荐）或 insert 做前缀。\n        5） 删除的方法用 remove（推荐）或 delete 做前缀。\n        6） 修改的方法用 update 做前缀。\n     2. 领域模型命名规约\n        1） 数据对象：xxxdo，xxx 即为数据表名。\n        2） 数据传输对象：xxxdto，xxx 为业务领域相关的名称。\n        3） 展示对象：xxxvo，xxx 一般为网页名称。\n        4） pojo 是 do/dto/bo/vo 的统称，禁止命名成 xxxpojo。\n\n\n# 常量定义\n\n 1. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。\n    反例：\n\nstring key = "id#taobao_" + tradeid;  \ncache.put(key, value);\n\n\n1\n2\n\n 2. 【强制】long 或者 long 初始赋值时，必须使用大写的 l，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。 说明：long a = 2l; 写的是数字的 21，还是 long 型的 2?\n 3. 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：cacheconsts 下；系统配置相关的常量放在类：configconsts 下。\n    说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。\n 4. 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。 1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。\n    2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。\n    反例： 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：\n\n类 a 中：public static final string yes = "yes";  \n类 b 中：public static final string yes = "y";  \na.yes.equals(b.yes)，预期是 true，但实际返回为 false，导致线上问题。  \n\n\n1\n2\n3\n\n\n3） 子工程内部共享常量：即在当前子工程的 constant 目录下。\n4） 包内共享常量：即在当前包下单独的 constant 目录下。\n5） 类内共享常量：直接在类内部 private static final 定义。\n\n 5. 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。\n    正例： public enum { monday(1), tuesday(2), wednesday(3), thursday(4), friday(5), saturday(6), sunday(7);}\n\n\n# 代码格式\n\n 1. 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：\n    1） 左大括号前不换行。\n    2） 左大括号后换行。\n    3） 右大括号前换行。\n    4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。\n\n 2. 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。\n    反例： if (空格 a == b 空格)\n\n 3. 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。\n\n 4. 【强制】任何二目、三目运算符的左右两边都需要加一个空格。\n    说明： 运算符包括赋值运算符=、逻辑运算符&&、加减乘除符号等。\n\n 5. 【强制】缩进采用 4 个空格，禁止使用 tab 字符。\n    说明： 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。idea 设置 tab 为 4 个空格时，请勿勾选 use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。\n    正例： （涉及 1-5 点）\n\npublic static void main(string[] args) {\n  // 缩进 4 个空格\n  string say = "hello";\n  // 运算符的左右必须有一个空格\n  int flag = 0;\n  // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格\n  if (flag == 0) {\n      system.out.println(say);\n  }\n\n  // 左大括号前加空格且不换行；左大括号后换行\n  if (flag == 1) {\n      system.out.println("world");\n      // 右大括号前换行，右大括号后有 else，不用换行\n  } else {\n      system.out.println("ok");\n      // 在右大括号后直接结束，则必须换行\n  }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 6. 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：\n    1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。\n    2） 运算符与下文一起换行。\n    3） 方法调用的点符号与下文一起换行。\n    4） 在多个参数超长，在逗号后换行。\n    5） 在括号前不要换行，见反例。\n    正例：\n\n stringbuffer sb = new stringbuffer();\n //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行\n sb.append("zi").append("xin")...\n .append("huang")...\n .append("huang")...\n .append("huang");\n\n\n1\n2\n3\n4\n5\n6\n\n\n反例：\n\n stringbuffer sb = new stringbuffer();\n //超过 120 个字符的情况下，不要在括号前换行\n sb.append("zi").append("xin")...append\n ("huang");\n //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行\n method(args1, args2, args3, ...\n , argsx); \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n 7. 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。\n    正例： 下例中实参的"a",后边必须要有一个空格。method("a", "b", "c");\n\n 8. 【强制】ide 的 text file encoding 设置为 utf-8; ide 中文件的换行符使用 unix 格式，不要使用 windows 格式。\n\n 9. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。\n    正例：\n\n  int a = 3;\n  long b = 4l;\n  float c = 5f;\n  stringbuffer sb = new stringbuffer();\n\n\n1\n2\n3\n4\n\n\n说明： 增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。\n\n 10. 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。\n     说明： 没有必要插入多个空行进行隔开。\n\n\n# oop 规约\n\n 1.  【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。\n\n 2.  【强制】所有的覆写方法，必须加@override 注解。\n     说明： getobject() 与 get0bject() 的问题。一个是字母的 o，一个是数字的 0，加 @override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。\n\n 3.  【强制】相同参数类型，相同业务含义，才可以使用 java 的可变参数，避免使用 object。\n     说明： 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）\n     正例： public user getusers(string type, integer... ids) {...}\n\n 4.  【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。\n\n 5.  【强制】不能使用过时的类或方法。\n     说明： java.net.urldecoder 中的方法 decode(string encodestr) 这个方法已经过时，应该使用双参数 decode(string source, string encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。\n\n 6.  【强制】object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例： "test".equals(object); 反例： object.equals("test"); 说明： 推荐使用 java.util.objects#equals （jdk7 引入的工具类）\n\n 7.  【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 integer var = ? 在-128 至 127 范围内的赋值，integer 对象是在 integercache.cache 产生，会复用已有对象，这个区间内的 integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。\n\n 8.  关于基本数据类型与包装数据类型的使用标准如下：\n     1） 【强制】所有的 pojo 类属性必须使用包装数据类型。\n     2） 【强制】rpc 方法的返回值和参数必须使用包装数据类型。\n     3） 【推荐】所有的局部变量使用基本数据类型。\n     说明： pojo 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 npe 问题，或者入库检查，都由使用者来保证。\n     正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 npe 风险。\n     反例： 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 rpc 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。\n\n 9.  【强制】定义 do/dto/vo 等 pojo 类时，不要设定任何属性默认值。\n     反例： pojo 类的 gmtcreate 默认值为 new date();但是这个属性在数据提取时并没有置入具 体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。\n\n 10. 【强制】序列化类新增属性时，请不要修改 serialversionuid 字段，避免反序列失败；如 果完全不兼容升级，避免反序列化混乱，那么请修改 serialversionuid 值。\n     说明： 注意 serialversionuid 不一致会抛出序列化运行时异常。\n\n 11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。\n\n 12. 【强制】pojo 类必须写 tostring 方法。使用 ide 的中工具：source> generate tostring 时，如果继承了另一个 pojo 类，注意在前面加一下 super.tostring。\n     说明： 在方法执行抛出异常时，可以直接调用 pojo 的 tostring()方法打印其属性值，便于排查问题。\n\n 13. 【推荐】使用索引访问用 string 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 indexoutofboundsexception 的风险。\n     说明：\n\nstring str = "a,b,c,,";\nstring[] ary = str.split(",");\n//预期大于 3，结果是 3\nsystem.out.println(ary.length);\n\n\n1\n2\n3\n4\n\n\n 14. 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。\n\n 15. 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter 方法。\n     说明： 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 service 和 dao 的 getter/setter 方法放在类体最后。\n\n 16. 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。\n     反例：\n\npublic integer getdata() {\n    if (true) {\n   \t return this.data + 100;\n    } else {\n    \treturn this.data - 100;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 17. 【推荐】循环体内，字符串的连接方式，使用 stringbuilder 的 append 方法进行扩展。\n     说明： 反编译出的字节码文件显示每次循环都会 new 出一个 stringbuilder 对象，然后进行 append 操作，最后通过 tostring 方法返回 string 对象，造成内存资源浪费。\n     反例：\n\nstring str = "start";\nfor (int i = 0; i < 100; i++) {\n   str = str + "hello";\n}\n\n\n1\n2\n3\n4\n\n\n 18. 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：\n     1） 不允许被继承的类，如：string 类。\n     2） 不允许修改引用的域对象，如：pojo 类的域变量。\n     3） 不允许被重写的方法，如：pojo 类的 setter 方法。\n     4） 不允许运行过程中重新赋值的局部变量。\n     5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。\n\n 19. 【推荐】慎用 object 的 clone 方法来拷贝对象。\n     说明： 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。\n\n 20. 【推荐】类成员与方法访问控制从严：\n     1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。\n     2） 工具类不允许有 public 或 default 构造方法。\n     3） 类非 static 成员变量并且与子类共享，必须是 protected。\n     4） 类非 static 成员变量并且仅在本类使用，必须是 private。\n     5） 类 static 成员变量如果仅在本类使用，必须是 private。\n     6） 若是 static 成员变量，必须考虑是否为 final。\n     7） 类成员方法只供类内部调用，必须是 private。\n     8） 类成员方法只对继承类公开，那么限制为 protected。\n     说明： 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。\n\n\n# 集合处理\n\n 1. 【强制】关于 hashcode 和 equals 的处理，遵循如下规则：\n    1） 只要重写 equals，就必须重写 hashcode。\n    2） 因为 set 存储的是不重复的对象，依据 hashcode 和 equals 进行判断，所以 set 存储的对象必须重写这两个方法。\n    3） 如果自定义对象做为 map 的键，那么必须重写 hashcode 和 equals。\n    说明： string 重写了 hashcode 和 equals 方法，所以我们可以非常愉快地使用 string 对象作为 key 来使用。\n\n 2. 【强制】arraylist 的 sublist 结果不可强转成 arraylist，否则会抛出 classcastexception 异常：java.util.randomaccesssublist cannot be cast to java.util.arraylist ;\n    说明： sublist 返回的是 arraylist 的内部类 sublist，并不是 arraylist ，而是 arraylist 的一个视图，对于 sublist 子列表的所有操作最终会反映到原列表上。\n\n 3. 【强制】 在 sublist 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增 加、删除均产生 concurrentmodificationexception 异常。\n\n 4. 【强制】使用集合转数组的方法，必须使用集合的 toarray(t[] array)，传入的是类型完全一样的数组，大小就是 list.size()。\n    说明： 使用 toarray 带参方法，入参分配的数组空间不够大时，toarray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。\n    正例：\n\n list<string> list = new arraylist<string>(2);\n list.add("guan");\n list.add("bao");\n string[] array = new string[list.size()];\n array = list.toarray(array);\n\n\n1\n2\n3\n4\n5\n\n\n反例： 直接使用 toarray 无参方法存在问题，此方法返回值只能是 object[]类，若强转其它类型数组将出现 classcastexception 错误。\n\n 5. 【强制】使用工具类 arrays.aslist()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 unsupportedoperationexception 异常。\n    说明： aslist 的返回对象是一个 arrays 内部类，并没有实现集合的修改方法。arrays.aslist 体现的是适配器模式，只是转换接口，后台的数据仍是数组。\n\n  string[] str = new string[] { "a", "b" };\n  list list = arrays.aslist(str);\n\n\n1\n2\n\n\n第一种情况：list.add("c"); 运行时异常。\n第二种情况：str[0] = "gujin"; 那么 list.get(0)也会随之修改。\n\n 6. 【强制】泛型通配符 <? extends t> 来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 <? super t> 不能使用 get 方法，做为接口调用赋值时易出错。\n    说明： 扩展说一下 pecs(producer extends consumer super) 原则：1）频繁往外读取内容 的，适合用上界 extends。2）经常往里插入的，适合用下界 super。\n\n 7. 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 iterator 方式，如果并发操作，需要对 iterator 对象加锁。\n    正例：\n\niterator<string> it = a.iterator();\nwhile (it.hasnext()) {\n   string temp = it.next();\n   if (删除元素的条件) {\n       it.remove();\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n反例：\n\nlist<string> a = new arraylist<string>();\na.add("1");\na.add("2");\nfor (string temp : a) {\n   if ("1".equals(temp)) {\n       a.remove(temp);\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明： 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？\n\n 8. 【强制】 在 jdk7 版本及以上，comparator 要满足如下三个条件，不然 arrays.sort，collections.sort 会报 illegalargumentexception 异常。\n    说明：\n    1） x，y 的比较结果和 y，x 的比较结果相反。\n    2） x>y，y>z，则 x>z。\n    3） x=y，则 x，z 比较结果和 y，z 比较结果相同。\n    反例： 下例中没有处理相等的情况，实际使用中可能会出现异常：\n\n new comparator<student>() {\n     @override\n     public int compare(student o1, student o2) {\n         return o1.getid() > o2.getid() ? 1 : -1;\n     }\n };\n\n\n1\n2\n3\n4\n5\n6\n\n\n 9.  【推荐】集合初始化时，指定集合初始值大小。\n     说明： hashmap 使用 hashmap(int initialcapacity) 初始化， 正例： initialcapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。\n     反例： hashmap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。\n\n 10. 【推荐】使用 entryset 遍历 map 类集合 kv，而不是 keyset 方式进行遍历。\n     说明： keyset 其实是遍历了 2 次，一次是转为 iterator 对象，另一次是从 hashmap 中取出 key 所对应的 value。而 entryset 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 jdk8，使用 map.foreach 方法。\n     正例： values() 返回的是 v 值集合，是一个 list 集合对象；keyset() 返回的是 k 值集合，是一个 set 集合对象；entryset() 返回的是 k-v 值组合集合。\n\n 11. 【推荐】高度注意 map 类集合 k/v 能不能存储 null 值的情况，如下表格：\n\n集合类                 key         value       super         说明\nhashtable           不允许为 null   不允许为 null   dictionary    线程安全\nconcurrenthashmap   不允许为 null   不允许为 null   abstractmap   分段锁技术\ntreemap             不允许为 null   允许为 null    abstractmap   线程不安全\nhashmap             允许为 null    允许为 null    abstractmap   线程不安全\n\n反例： 由于 hashmap 的干扰，很多人认为 concurrenthashmap 是可以置入 null 值，而事实上，存储 null 值时会抛出 npe 异常。\n\n 12. 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。\n     说明： 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次 序是一定的。如： arraylist 是 order/unsort；hashmap 是 unorder/unsort；treeset 是 order/sort。\n\n 13. 【参考】利用 set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 list 的 contains 方法进行遍历、对比、去重操作。\n\n\n# 并发处理\n\n 1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。\n    说明： 资源驱动类、工具类、单例工厂类都需要注意。\n\n 2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。\n    正例：\n\n public class timertaskthread extends thread {\n     public timertaskthread() {\n         super.setname("timertaskthread"); ...\n     }\n }\n\n\n1\n2\n3\n4\n5\n\n\n 3. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n    说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资 源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n 4. 【强制】线程池不允许使用 executors 去创建，而是通过 threadpoolexecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n    说明： executors 返回的线程池对象的弊端如下：\n    \n    1. fixedthreadpool 和 singlethreadpool:\n       允许的请求队列长度为 integer.max_value，可能会堆积大量的请求，从而导致 oom。\n    2. cachedthreadpool 和 scheduledthreadpool:\n       允许的创建线程数量为 integer.max_value，可能会创建大量的线程，从而导致 oom。\n\n 5. 【强制】simpledateformat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 dateutils 工具类。\n    正例： 注意线程安全，使用 dateutils。亦推荐如下处理：\n\n  private static final threadlocal<dateformat> df = new threadlocal<dateformat>() {\n      @override\n      protected dateformat initialvalue() {\n          return new simpledateformat("yyyy-mm-dd");\n      }\n  };\n\n\n1\n2\n3\n4\n5\n6\n\n\n说明： 如果是 jdk8 的应用，可以使用 instant 代替 date，localdatetime 代替 calendar，datetimeformatter 代替 simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe。\n\n 6.  【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。\n     说明： 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 rpc 方法。\n\n 7.  【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。\n     说明： 线程一需要对表 a、b、c 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 a、b、c，否则可能出现死锁。\n\n 8.  【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。\n     说明： 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。\n\n 9.  【强制】多线程并行处理定时任务时，timer 运行多个 timetask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 scheduledexecutorservice 则没有这个问题。\n\n 10. 【推荐】使用 countdownlatch 进行异步转同步操作，每个线程退出前必须调用 countdown 方法，线程执行代码注意 catch 异常，确保 countdown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。\n     说明： 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。\n\n 11. 【推荐】避免 random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。\n     说明： random 实例包括 java.util.random 的实例或者 math.random() 的方式。\n     正例： 在 jdk7 之后，可以直接使用 api threadlocalrandom，而在 jdk7 之前，需要编码保证每个线程持有一个实例。\n\n 12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 the "double-checked locking is broken" declaration)，推荐问题解决方案中较为简单一种（适用于 jdk5 及以上版本），将目标属性声明为 volatile 型。\n     反例：\n\nclass foo {\n    private helper helper = null;\n    public helper gethelper() {\n        if (helper == null) synchronized(this) {\n            if (helper == null)\n                helper = new helper();\n        }\n        return helper;\n    }\n    // other functions and members...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n 13. 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现： atomicinteger count = new atomicinteger(); count.addandget(1); 如果是 jdk8，推荐使用 longadder 对象，比 atomiclong 性能更好（减少乐观锁的重试次数）。\n\n 14. 【参考】 在容量不够进行 resize 时由于高并发可能出现死链，导致 cpu 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。\n\n 15. 【参考】threadlocal 无法解决共享对象的更新问题，threadlocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。\n\n\n# 控制语句\n\n 1. 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。\n\n 2. 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;\n\n 3. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：\n\n    if (condition) {\n     ...\n     return obj;\n    }\n    // 接着写 else 的业务逻辑代码;\n\n\n1\n2\n3\n4\n5\n\n\n说明： 如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。\n\n正例： 逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下：\n\n    public void today() {\n        if (isbusy()) {\n            system.out.println(“change time.”);\n            return;\n        }\n        if (isfree()) {\n            system.out.println(“go to travel.”);\n            return;\n        }\n        system.out.println(“stay at home to learn alibaba java coding guideline.”);\n        return;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 4. 【推荐】除常用方法（如 getxxx/isxxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。\n    说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？\n    正例：\n\n //伪代码如下\n final boolean existed = (file.open(filename, "w") != null) && (...) || (...);\n if (existed) {\n  ...\n }\n\n\n1\n2\n3\n4\n5\n\n\n反例：\n\n if ((file.open(filename, "w") != null) && (...) || (...)) {\n  ...\n }\n\n\n1\n2\n3\n\n\n 5. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。\n\n 6. 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。\n\n 7. 【参考】下列情形，需要进行参数校验：\n    1） 调用频次低的方法。\n    2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参 数错误导致中间执行回退，或者错误，那得不偿失。\n    3） 需要极高稳定性和可用性的方法。\n    4） 对外提供的开放接口，不管是 rpc/api/http 接口。\n    5） 敏感权限入口。\n\n 8. 【参考】下列情形，不需要进行参数校验：\n    1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。\n    2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底 层才会暴露问题。一般 dao 层与 service 层都在同一个应用中，部署在同一台服务器中，所以 dao 的参数校验，可以省略。\n    3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。\n\n\n# 注释规约\n\n 1.  【强制】类、类属性、类方法的注释必须使用 javadoc 规范，使用/**内容*/格式，不得使用 //xxx 方式。\n     说明： 在 ide 编辑窗口中，javadoc 方式会提示相关注释，生成 javadoc 可以正确输出相应注释；在 ide 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高 阅读效率。\n\n 2.  【强制】所有的抽象方法（包括接口中的方法）必须要用 javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。\n     说明： 对子类的实现要求，或者调用注意事项，请一并说明。\n\n 3.  【强制】所有的类都必须添加创建者和创建日期。\n\n 4.  【强制】方法内部单行注释，在被注释语句上方另起一行，使用 //注释。方法内部多行注释使用/* */注释，注意与代码对齐。\n\n 5.  【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。\n\n 6.  【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。\n     反例： “tcp 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。\n\n 7.  【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。\n     说明： 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。\n\n 8.  【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。\n     说明： 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。\n\n 9.  【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。\n\n 10. 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。\n     反例：\n\n// put elephant into fridge\nput(elephant, fridge);\n\n\n1\n2\n\n\n方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。\n\n 11. 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。\n     1） 待办事宜（todo）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 javadoc 的标签，目前的 javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 javadoc 标签）。\n     2） 错误，不能工作（fixme）:（标记人，标记时间，[预计处理时间]）在注释中用 fixme 标记某代码是错误的，而且不能工作，需要及时纠正的情况。\n\n\n# 其他\n\n 1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明：不要在方法体内定义：pattern pattern = pattern.compile(规则);\n\n 2. 【强制】velocity 调用 pojo 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 pojo 的 getxxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isxxx()方法。\n    说明： 注意如果是 boolean 包装类对象，优先调用 getxxx()的方法。\n\n 3. 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。\n    说明： 如果 var=null 或者不存在，那么${var}会直接显示在页面上。\n\n 4. 【强制】注意 math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 random 对象的 nextint 或者 nextlong 方法。\n\n 5. 【强制】获取当前毫秒数 system.currenttimemillis(); 而不是 new date().gettime();\n    说明： 如果想获取更加精确的纳秒级时间值，使用 system.nanotime()的方式。在 jdk8 中，针对统计时间等场景，推荐使用 instant 类。\n\n 6. 【推荐】不要在视图模板中加入任何复杂的逻辑。 说明： 根据 mvc 理论，视图的职责是展示，不要抢模型和控制器的活。\n\n 7. 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。\n\n 8. 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。\n\n\n# 异常日志\n\n\n# 异常处理\n\n 1.  【强制】java 类库中定义的一类 runtimeexception 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： indexoutofboundsexception ， nullpointerexception 等等。\n     说明： 无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch numberformatexception 来实现。\n     正例： if (obj != null) {...}\n     反例： try { obj.method() } catch (nullpointerexception e) {...}\n\n 2.  【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。\n\n 3.  【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。\n\n 4.  【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。\n\n 5.  【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。\n\n 6.  【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。\n     说明： 如果 jdk7 及以上，可以使用 try-with-resources 方式。\n\n 7.  【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。\n\n 8.  【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。\n     说明： 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。\n\n 9.  【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 npe 问题。\n     说明： 本手册明确防止 npe 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。\n\n 10. 【推荐】防止 npe，是程序员的基本修养，注意 npe 产生的场景：\n     1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 npe。\n     反例： public int f() { return integer 对象}， 如果为 null，自动解箱抛 npe。\n     2） 数据库的查询结果可能为 null。\n     3） 集合里的元素即使 isnotempty，取出的数据元素也可能为 null。\n     4） 远程调用返回对象时，一律要求进行空指针判断，防止 npe。\n     5） 对于 session 中获取的数据，建议 npe 检查，避免空指针。\n     6） 级联调用 obj.geta().getb().getc()；一连串调用，易产生 npe。\n     正例： 使用 jdk8 的 optional 类来防止 npe 问题。\n\n 11. 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new runtimeexception()，更不允许抛出 exception 或者 throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：daoexception / serviceexception 等。\n\n 12. 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 rpc 调用优先考虑使用 result 方式，封装 issuccess()方法、“错误码”、“错误简短信息”。\n     说明： 关于 rpc 方法返回方式使用 result 方式的理由：\n     1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。\n     2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。\n\n 13. 【参考】避免出现重复的代码（don’t repeat yourself），即 dry 原则。\n     说明： 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。\n     正例： 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkparam(dto dto) {...}\n\n\n# 日志规约\n\n 1. 【强制】应用中不可直接使用日志系统（log4j、logback）中的 api，而应依赖使用日志框架 slf4j 中的 api，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nprivate static final logger logger = loggerfactory.getlogger(abc.class);\n\n\n1\n2\n3\n\n\n 2. 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。\n\n 3. 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appname_logtype_logname.log。logtype:日志类型，推荐分类有 stats/desc/monitor/visit 等；logname:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。\n    正例： mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timezoneconvert.log\n    说明： 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。\n\n 4. 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。\n    说明： logger.debug("processing trade with id: " + id + " symbol: " + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 tostring() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。\n    正例： （条件）\n\nif (logger.isdebugenabled()) {\n    logger.debug("processing trade with id: " + id + " symbol: " + symbol);\n}\n\n\n1\n2\n3\n\n\n正例： （占位符）\n\nlogger.debug("processing trade with id: {} symbol : {} ", id, symbol);\n\n\n1\n\n\n 5. 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。\n    正例： <logger name="com.taobao.dubbo.config" additivity="false">\n\n 6. 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。\n    正例： logger.error(各类参数或者对象 tostring + "_" + e.getmessage(), e);\n\n 7. 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。\n    说明： 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？\n\n 8. 【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。\n\n\n# mysql 数据库\n\n\n# 建表规约\n\n 1.  【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。\n     说明： 任何字段如果为非负数，必须是 unsigned。\n     正例： 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。\n\n 2.  【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\n     正例： getter_admin，task_config，level3_name\n     反例： getteradmin，taskconfig，level_3_name\n\n 3.  【强制】表名不使用复数名词。\n     说明： 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 do 类名也是单数形式，符合表达习惯。\n\n 4.  【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 mysql 官方保留字。\n\n 5.  【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。\n     说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。\n\n 6.  【强制】小数类型为 decimal，禁止使用 float 和 double。\n     说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。\n\n 7.  【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。\n\n 8.  【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。\n\n 9.  【强制】表必备三字段：id, gmt_create, gmt_modified。 说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。\n\n 10. 【推荐】表的命名最好是加上“业务名称_表的作用”。\n     正例： tiger_task / tiger_reader / mpp_config\n\n 11. 【推荐】库名与应用名称尽量一致。\n\n 12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。\n\n 13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：\n     1）不是频繁修改的字段。\n     2）不是 varchar 超长字段，更不能是 text 字段。\n     正例： 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。\n\n 14. 【推荐】单表行数超过 500 万行或者单表容量超过 2gb，才推荐进行分库分表。\n     说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\n\n 15. 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\n     正例： 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。\n\n对象     年龄区间      类型                  表示范围\n人      150 岁之内   unsigned tinyint    无符号值：0 到 255\n龟      数百岁       unsigned smallint   无符号值：0 到 65535\n恐龙化石   数千万年      unsigned int        无符号值：0 到约 42.9 亿\n太阳     约 50 亿年   unsigned bigint     无符号值：0 到约 10 的 19 次方\n\n\n# 索引规约\n\n 1.  【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\n\n 2.  【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。\n     说明： 即使双表 join 也要注意表索引、sql 性能。\n\n 3.  【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。\n     说明： 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n\n 4.  【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n     说明： 索引文件具有 b-tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\n\n 5.  【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。\n     正例： where a=? and b=? order by c; 索引：a_b_c\n     反例： 索引中有范围查找，那么索引有序性无法利用，如：where a>10 order by b; 索引 a_b 无法排序。\n\n 6.  【推荐】利用覆盖索引来进行查询操作，避免回表。\n     说明： 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。\n     正例： 能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种 效果，用 explain 的结果，extra 列会出现：using index。\n\n 7.  【推荐】利用延迟关联或者子查询优化超多分页场景。\n     说明： mysql 并不是跳过 offset 行，而是取 offset+n 行，然后返回放弃前 offset 行，返回 n 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 sql 改写。\n     正例： 先快速定位需要获取的 id 段，然后再关联： select a.* from 表 1 a, (select id from 表 1 where 条件 limit 100000,20 ) b where a.id=b.id\n\n 8.  【推荐】sql 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。\n     说明：\n     1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。\n     2） ref 指的是使用普通的索引（normal index）。\n     3） range 对索引进行范围检索。\n     反例： explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。\n\n 9.  【推荐】建组合索引的时候，区分度最高的在最左边。\n     正例： 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。\n     说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。\n\n 10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。\n\n 11. 【参考】创建索引时避免有如下极端误解：\n     1）宁滥勿缺。误认为一个查询就需要建一个索引。\n     2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。\n     3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。\n\n\n# sql 语句\n\n 1.  【强制】不要使用 count(列名)或 count(常量)来替代 count()，count()是 sql92 定义的标准统计行数的语法，跟数据库无关，跟 null 和非 null 无关。\n     说明： count(*)会统计值为 null 的行，而 count(列名)不会统计此列为 null 值的行。\n\n 2.  【强制】count(distinct col) 计算该列除 null 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 null，那么即使另一列有不同的值，也返回为 0。\n\n 3.  【强制】当某一列的值全是 null 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 null，因此使用 sum()时需注意 npe 问题。\n     正例： 可以使用如下方式来避免 sum 的 npe 问题：select if(isnull(sum(g)),0,sum(g)) from table;\n\n 4.  【强制】使用 isnull()来判断是否为 null 值。注意：null 与任何值的直接比较都为 null。\n     说明：\n     1） null<>null 的返回结果是 null，而不是 false。\n     2） null=null 的返回结果是 null，而不是 true。\n     3） null<>1 的返回结果是 null，而不是 true。\n\n 5.  【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。\n\n 6.  【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n     说明： （概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。\n\n 7.  【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\n\n 8.  【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。\n\n 9.  【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。\n\n 10. 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。\n     说明： select length("轻松工作")； 返回为 12\n     select character_length("轻松工作")； 返回为 4\n     如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。\n\n 11. 【参考】truncate table 比 delete 速度快，且使用的系统和事务日志资源少，但 truncate 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。\n     说明： truncate table 在功能上与不带 where 子句的 delete 语句相同。\n\n\n# orm 映射\n\n 1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。\n    说明： 1）增加查询分析器解析成本。2）增减字段容易与 resultmap 配置不一致。\n\n 2. 【强制】pojo 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultmap 中进行字段与属性之间的映射。\n    说明： 参见定义 pojo 类以及数据库字段定义规定，在<resultmap>中增加映射，是必须的。在 mybatis generator 生成的代码中，需要进行对应的修改。\n\n 3. 【强制】不要用 resultclass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。\n    说明： 配置映射关系，使字段与 do 类解耦，方便维护。\n\n 4. 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 sql 注入。\n\n 5. 【强制】ibatis 自带的 queryforlist(string statementname,int start,int size)不推荐使用。\n    说明： 其实现方式是在数据库取到statementname对应的sql语句的所有记录，再通过sublist 取 start,size 的子集合。\n    正例：\n\n map<string, object> map = new hashmap<string, object>();\n map.put("start", start);\n map.put("size", size);\n\n\n1\n2\n3\n\n\n 6.  【强制】不允许直接拿 hashmap 与 hashtable 作为查询结果集的输出。\n     说明： resultclass=”hashtable”，会置入字段名和属性值，但是值的类型不可控。\n\n 7.  【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。\n\n 8.  【推荐】不要写一个大而全的数据更新接口，传入为 pojo 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 sql 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。\n\n 9.  【参考】@transactional 事务不要滥用。事务会影响数据库的 qps，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。\n\n 10. 【参考】<isequal>中的 comparevalue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isnotempty>表示不为空且不为 null 时执行；<isnotnull>表示不为 null 值时执行。\n\n\n# 工程结构\n\n\n# 应用分层\n\n 1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 web 层，也可以直接依赖于 service 层，依此类推：\n    \n    \n    \n    * 开放接口层： 可直接封装 service 方法暴露成 rpc 接口；通过 web 封装成 http 接口；进行网关安全控制、流量控制等。\n    * 终端显示层： 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，js 渲染，jsp 渲染，移动端展示等。\n    * web 层： 主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。\n    * service 层： 相对具体的业务逻辑服务层。\n    * manager 层： 通用业务处理层，它有如下特征：\n      1. 对第三方平台封装的层，预处理返回结果及转化异常信息；\n      2. 对 service 层通用能力的下沉，如缓存方案、中间件通用处理；\n      3. 与 dao 层交互，对多个 dao 的组合复用。\n    * dao 层： 数据访问层，与底层 mysql、oracle、hbase 进行数据交互。\n    * 外部接口或第三方平台： 包括其它部门 rpc 开放接口，基础平台，其它公司的 http 接口。\n\n 2. 【参考】 （分层异常处理规约）在 dao 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(exception e)方式，并 throw new daoexception(e)，不需要打印 日志，因为日志在 manager/service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 manager 层与 service 同机部署，日志方式与 dao 层处理一致，如果是单独部署，则采用与 service 一致的处理方式。web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。\n\n 3. 【参考】分层领域模型规约：\n    \n    * do（data object）： 与数据库表结构一一对应，通过 dao 层向上传输数据源对象。\n    * dto（data transfer object）： 数据传输对象，service 和 manager 向外传输的对象。\n    * bo（business object）： 业务对象。可以由 service 层输出的封装业务逻辑的对象。\n    * query： 数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 map 类来传输。\n    * vo（view object）： 显示层对象，通常是 web 向模板渲染引擎层传输的对象。\n\n\n# 二方库依赖\n\n 1.  【强制】定义 gav 遵从以下规则：\n     1） groupid 格式：com.{公司/bu }.业务线.[子业务线]，最多 4 级。\n     说明： {公司/bu} 例如：alibaba/taobao/tmall/aliexpress 等 bu 一级；子业务线可选。\n     正例： com.taobao.jstorm 或 com.alibaba.dubbo.register\n     2） artifactid 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。\n     正例： dubbo-client / fastjson-api / jstorm-tool\n     3） version：详细规定参考下方。\n\n 2.  【强制】二方库版本号命名方式：主版本号.次版本号.修订号\n     1） 主版本号：当做了不兼容的 api 修改，或者增加了能改变产品方向的新功能。\n     2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。\n     3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 api 兼容性。\n     说明： 注意：起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0\n\n 3.  【强制】线上应用不要依赖 snapshot 版本（安全包除外）。\n     说明： 不依赖 snapshot 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。\n\n 4.  【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一 致，那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。\n\n 5.  【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚 举类型或者包含枚举类型的 pojo 对象。\n\n 6.  【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一 个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。\n\n 7.  【强制】禁止在子项目的 pom 依赖中出现相同的 groupid，相同的 artifactid，但是不同的 version。\n     说明： 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号 出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。\n\n 8.  【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在 <dependencymanagement>语句块中。 说明：<dependencymanagement>里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的 <dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。\n\n 9.  【推荐】二方库不要有配置项，最低限度不要再增加配置项。\n\n 10. 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：\n     1）精简可控原则。移除一切不必要的 api 和依赖，只包含 service api、必要的领域模型对 象、utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用 者去依赖具体版本号；无 log 具体实现，只依赖日志框架。\n     2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能 方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。\n\n\n# 服务器\n\n 1. 【推荐】高并发服务器建议调小 tcp 协议的 time_wait 超时时间。 说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服 务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上 调小此等待值。\n    正例： 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）： net.ipv4.tcp_fin_timeout = 30\n\n 2. 【推荐】调大服务器所支持的最大文件句柄数（file descriptor，简写为 fd）。\n    说明： 主流操作系统的设计是将 tcp/udp 连接采用与文件一样的方式去管理，即一个连接对 应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。\n\n 3. 【推荐】给 jvm 设置-xx:+heapdumponoutofmemoryerror 参数，让 jvm 碰到 oom 场景时输出 dump 信息。\n    说明： oom 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错 非常有价值。\n\n 4. 【参考】服务器内部重定向使用 forward；外部重定向地址使用 url 拼装工具类来生成，否则 会带来 url 维护不一致的问题和潜在的安全风险。\n\n\n# 安全规约\n\n 1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。\n    说明： 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信 内容、修改他人的订单。\n\n 2. 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。\n    说明： 查看个人手机号码会显示成:158****9119，隐藏中间 4 位，防止隐私泄露。\n\n 3. 【强制】用户输入的 sql 参数严格使用参数绑定或者 metadata 字段值限定，防止 sql 注入， 禁止字符串拼接 sql 访问数据库。\n\n 4. 【强制】用户请求传入的任何参数必须做有效性验证。\n    说明： 忽略参数校验可能导致：\n    \n    * page size 过大导致内存溢出\n    * 恶意 order by 导致数据库慢查询\n    * 任意重定向\n    * sql 注入\n    * 反序列化注入\n    * 正则输入源串拒绝服务 redos\n    \n    说明： java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题， 但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。\n\n 5. 【强制】禁止向 html 页面输出未经安全过滤或未正确转义的用户数据。\n\n 6. 【强制】表单、ajax 提交必须执行 csrf 安全过滤。\n    说明： csrf(cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 csrf 漏洞的应用/网站，攻击者可以事先构造好 url，只要受害者用户一访问，后台便在用户 不知情情况下对数据库中用户参数进行相应修改。\n\n 7. 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其 它用户，并造成短信平台资源浪费。\n\n 8. 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过 滤等风控策略。\n\n\n# 附 1：版本历史\n\n版本号     更新日期        备注\n1.0.0   2017.2.9    阿里巴巴集团正式对外发布\n1.0.1   2017.2.13   1）修正 string[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。\n1.0.2   2017.2.20   1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final\n                    描述。5）去除 comparator 部分描述。\n1.1.0   2017.2.27   1）增加前言。2）增加<? extends t>描述和说明。3）增加版本历史。4）增加专有名词解释。\n1.1.1   2017.3.31   修正页码总数和部分示例\n1.2.0   2017.5.20   1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加\n                    final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为\n                    is_deleted\n\n\n# 附 2：本手册专有名词\n\n 1.  pojo（plain ordinary java object）：在本手册中，pojo 专指只有 setter / getter / tostring 的简单类，包括 do/dto/bo/vo 等。\n\n 2.  do（data object）：本手册指数据库表一一对应的 pojo 类。\n\n 3.  gav（groupid、artifactctid、version）：maven 坐标，是用来唯一标识 jar 包。\n\n 4.  oop（object oriented programming）: 本手册泛指类、对象的编程处理方式。\n\n 5.  orm（object relation mapping）: 对象关系映射，对象领域模型与底层数据之间的转换， 本文泛指 ibatis, mybatis 等框架。\n\n 6.  npe（java.lang.nullpointerexception）: 空指针异常。\n\n 7.  soa（service-oriented architecture）: 面向服务架构，它可以根据需求通过网络对松散 耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。\n\n 8.  一方库：本工程内部子项目模块依赖的库（jar 包）。\n\n 9.  二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。\n\n 10. 三方库：公司之外的开源库（jar 包）。',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Git常用命令清单",frontmatter:{title:"Git常用命令清单",date:"2018-03-12T00:00:00.000Z",sidebar:!0,sidebarDepth:5,tags:["开发规范","git"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/git.html",relativePath:"views/specification/git.md",key:"v-b9441912",path:"/views/specification/git.html",headers:[{level:2,title:"架构",slug:"架构",normalizedTitle:"架构",charIndex:2},{level:2,title:"一、新建代码库",slug:"一、新建代码库",normalizedTitle:"一、新建代码库",charIndex:128},{level:2,title:"二、配置",slug:"二、配置",normalizedTitle:"二、配置",charIndex:275},{level:2,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:546},{level:2,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:946},{level:2,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:1347},{level:2,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:2140},{level:2,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:2557},{level:2,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:3666},{level:2,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:4088},{level:2,title:"切换分支暂存未提交的commit",slug:"切换分支暂存未提交的commit",normalizedTitle:"切换分支暂存未提交的commit",charIndex:4683},{level:2,title:"十、其他",slug:"十、其他",normalizedTitle:"十、其他",charIndex:5095}],excerpt:'<p><img src="/znote/img/other/git_001.png" alt="" /></p>\n',headersStr:"架构 一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 切换分支暂存未提交的commit 十、其他",content:'# 架构\n\n * git有四个个工作区：\n   1. 工作区（workspace）\n   2. 暂存区（index/stage）\n   3. 本地仓库（local repository）\n   4. 远程仓库（remote repository）\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 切换分支暂存未提交的commit\n\nstash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。\n\n切换分支时先用git stash, 从另一个分支切换到本分支用git stash apply, 即可恢复代码。\n\n# 保存当前未commit的代码\ngit stash\n\n# 保存当前未commit的代码并添加备注\ngit stash save "备注的内容"\n\n# 列出stash的所有记录\ngit stash list\n\n# 删除stash的所有记录\ngit stash clear\n\n# 应用最近一次的stash\ngit stash apply\n\n# 应用最近一次的stash，随后删除该记录\ngit stash pop\n\n# 删除最近的一次stash\ngit stash drop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 十、其他\n\n# 生成一个可供发布的压缩包\n$ git archive\n\n\n1\n2\n\n\n参考自阮一峰老师： 常用 Git 命令清单',normalizedContent:'# 架构\n\n * git有四个个工作区：\n   1. 工作区（workspace）\n   2. 暂存区（index/stage）\n   3. 本地仓库（local repository）\n   4. 远程仓库（remote repository）\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个git代码库\n$ git init\n\n# 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的git配置\n$ git config --list\n\n# 编辑git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 切换分支暂存未提交的commit\n\nstash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。\n\n切换分支时先用git stash, 从另一个分支切换到本分支用git stash apply, 即可恢复代码。\n\n# 保存当前未commit的代码\ngit stash\n\n# 保存当前未commit的代码并添加备注\ngit stash save "备注的内容"\n\n# 列出stash的所有记录\ngit stash list\n\n# 删除stash的所有记录\ngit stash clear\n\n# 应用最近一次的stash\ngit stash apply\n\n# 应用最近一次的stash，随后删除该记录\ngit stash pop\n\n# 删除最近的一次stash\ngit stash drop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 十、其他\n\n# 生成一个可供发布的压缩包\n$ git archive\n\n\n1\n2\n\n\n参考自阮一峰老师： 常用 git 命令清单',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"ZNOTE GUIDE",frontmatter:{title:"ZNOTE GUIDE",date:"2020-03-26T00:00:00.000Z",tags:["vuepress"],categories:["规范 Standard"],isShowComments:!0,sidebar:!1,publish:!0,sticky:1},regularPath:"/views/specification/guide.html",relativePath:"views/specification/guide.md",key:"v-309fb177",path:"/views/specification/guide.html",headers:[{level:2,title:"项目介绍",slug:"项目介绍",normalizedTitle:"项目介绍",charIndex:25},{level:2,title:"项目运行",slug:"项目运行",normalizedTitle:"项目运行",charIndex:33},{level:2,title:"项目架构",slug:"项目架构",normalizedTitle:"项目架构",charIndex:41},{level:2,title:"如何使用",slug:"如何使用",normalizedTitle:"如何使用",charIndex:49},{level:2,title:"写在最后",slug:"写在最后",normalizedTitle:"写在最后",charIndex:57},{level:2,title:"关于友链",slug:"关于友链",normalizedTitle:"关于友链",charIndex:65}],excerpt:'<Boxx/>\n<p>开始使用此博客的一些注意事项和说明。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n',headersStr:"项目介绍 项目运行 项目架构 如何使用 写在最后 关于友链",content:"开始使用此博客的一些注意事项和说明。\n\n\n\n * 项目介绍\n * 项目运行\n * 项目架构\n * 如何使用\n * 写在最后\n * 关于友链\n\n\n\n\n# znote\n\n * 积丝成寸，积寸成尺；寸尺水已，遂成丈匹。\n\n\n\n\n\n\n * 本仓库代码使用 MIT 协议进行开源，但是全部文档内容使用 CC 4.0 BY-SA 协议进行发布\n\n * 已全局适配手机模式和暗黑模式（iOS自适应）请自行体验\n\n * 国内访问：https://zpj80231.gitee.io/znote/ 速度加载会快一点（自Gitee实名认证后已不再同步更新，现在访问还是之前的旧版本）\n   \n   推荐访问：https://zpj80231.github.io/znote/\n\n\n\n\n# 项目介绍\n\n * 记录生产级别问题排查处理（工作经验）\n\n * 技术栈知识点笔记总结（知识小结）\n\n * 个人牢骚发布（生活随笔）\n\n * 其它（欢迎入队）...\n\n\n# 项目运行\n\n * 克隆项目，在项目文件夹下执行命令，加载依赖：npm install\n\n * 在项目文件夹下（node 16及以下）执行命令，运行项目：npm run dev\n   \n   Windows（node 17+）版本以上运行：npm run dev:win\n   \n   Mac（node 17+）版本以上运行：npm run dev:mac\n\n * 待启动成功后打开地址即可：http://localhost:8080/znote/\n\n\n# 项目架构\n\n * 采用 vuepress 和 主题reco 二次构建\n\n## 需要自己写主题样式的话，在.vuepress/ 下新建theme文件夹并按如下目录布局\nDev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme  // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles  // 样式\n│   │    │   ├── util \t // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopModule.js // 依赖注入\n│   │    │   ├── package.json  // 主题依赖\n│   │    │   ├── README.md     // 主题说明\n│   │    └── config.js\n│   ├── about   // 项目模块\n│   ├── other   // 项目模块\n│   ├── views   // 项目模块\n│   └── README.md   // 首页\n└── package.json //项目依赖\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 如何使用\n\n对准备发布的文章（Markdown 格式），放置在项目docs/views/目录下，并在 Markdown 文件头部添加以下元素，项目发布后会自动识别文章标题、标签、分类、是否开启评论、是否加密、是否置顶、是否发布等一系列状态。\n\n下面是关键字说明及参考示例：\n\n 1. 关键字说明\n\n序号   关键字              注释\n1    title            文章标题\n2    date             日期，如：2020-02-02\n3    tags             标签\n4    categories       分类\n5    keys             文章加密密码\n6    sticky           文章置顶 1, 2, 3, ...\n7    isShowComments   是否开启评论\n8    publish          文章是否发布\n9    <Boxx/>          只需引入这个标签即可，随机展示名人名言\n10   [[toc]]          生成目录及链接\n11   \x3c!-- more --\x3e    在\x3c!-- more --\x3e之前的内容会展示为文章摘要\n\n 2. 参考示例：\n\n---\ntitle: 文章标题\ndate: 2020-02-02\ntags:\n  - 标签\ncategories:\n  - 分类\nkeys:\n  - '123456'\nsticky: 1\nisShowComments: false\npublish: true\n---\n\n  <Boxx/>\n\n  [ [ toc ] ]\n\n  - 这里可以写`摘要`等其它\n\n    \x3c!-- more --\x3e\n\n  ## 正式开始你的markdown\n\n  - To be or not to be, ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 写在最后\n\n在 Blog 搭建中遇到问题，推荐先去以下几个网址找答案：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n如果在博客中遇到什么问题，不要一上来就问我，最好先查下相关资料，实在解决不了的可以找我咨询哈（减少无效沟通嘛），毕竟只有自己淌过的坑才能深入理解、印象深刻！\n\n当然，遇到一些有价值的问题，还是欢迎来找我共同探讨的😉~~\n\n关于如何提问，在 Github 中这个项目可以说是相当 nice 了，可以的话一定要过一遍，于人于己都有莫大的好处：提问的智慧\n\n\n# 关于友链\n\n近期也发现有好些人要加 友链 的，在这里我也说一下吧：\n\n你可以复用我的 Blog，但是需要在你的 Blog 创新一些东西，比如添加你具有独立见解的文章，或者在其他方面体现自己独特的创意或价值（改改样式、优化一下功能等等），然后我给你加友链。毕竟千篇一律的友链没有必要是吧！\n\nThanks for you!",normalizedContent:"开始使用此博客的一些注意事项和说明。\n\n\n\n * 项目介绍\n * 项目运行\n * 项目架构\n * 如何使用\n * 写在最后\n * 关于友链\n\n\n\n\n# znote\n\n * 积丝成寸，积寸成尺；寸尺水已，遂成丈匹。\n\n\n\n\n\n\n * 本仓库代码使用 mit 协议进行开源，但是全部文档内容使用 cc 4.0 by-sa 协议进行发布\n\n * 已全局适配手机模式和暗黑模式（ios自适应）请自行体验\n\n * 国内访问：https://zpj80231.gitee.io/znote/ 速度加载会快一点（自gitee实名认证后已不再同步更新，现在访问还是之前的旧版本）\n   \n   推荐访问：https://zpj80231.github.io/znote/\n\n\n\n\n# 项目介绍\n\n * 记录生产级别问题排查处理（工作经验）\n\n * 技术栈知识点笔记总结（知识小结）\n\n * 个人牢骚发布（生活随笔）\n\n * 其它（欢迎入队）...\n\n\n# 项目运行\n\n * 克隆项目，在项目文件夹下执行命令，加载依赖：npm install\n\n * 在项目文件夹下（node 16及以下）执行命令，运行项目：npm run dev\n   \n   windows（node 17+）版本以上运行：npm run dev:win\n   \n   mac（node 17+）版本以上运行：npm run dev:mac\n\n * 待启动成功后打开地址即可：http://localhost:8080/znote/\n\n\n# 项目架构\n\n * 采用 vuepress 和 主题reco 二次构建\n\n## 需要自己写主题样式的话，在.vuepress/ 下新建theme文件夹并按如下目录布局\ndev\n├─── docs\n│   └── .vuepress   // 配置目录\n│   │    ├── public // 静态资源\n│   │    ├── theme  // 主题\n│   │    │   ├── components // 组件\n│   │    │   ├── global-components // 全局组件\n│   │    │   ├── layouts // 布局(包括首页在内)\n│   │    │   ├── styles  // 样式\n│   │    │   ├── util \t // 工具\n│   │    │   ├── index.js // 入口配置\n│   │    │   ├── noopmodule.js // 依赖注入\n│   │    │   ├── package.json  // 主题依赖\n│   │    │   ├── readme.md     // 主题说明\n│   │    └── config.js\n│   ├── about   // 项目模块\n│   ├── other   // 项目模块\n│   ├── views   // 项目模块\n│   └── readme.md   // 首页\n└── package.json //项目依赖\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 如何使用\n\n对准备发布的文章（markdown 格式），放置在项目docs/views/目录下，并在 markdown 文件头部添加以下元素，项目发布后会自动识别文章标题、标签、分类、是否开启评论、是否加密、是否置顶、是否发布等一系列状态。\n\n下面是关键字说明及参考示例：\n\n 1. 关键字说明\n\n序号   关键字              注释\n1    title            文章标题\n2    date             日期，如：2020-02-02\n3    tags             标签\n4    categories       分类\n5    keys             文章加密密码\n6    sticky           文章置顶 1, 2, 3, ...\n7    isshowcomments   是否开启评论\n8    publish          文章是否发布\n9    <boxx/>          只需引入这个标签即可，随机展示名人名言\n10   [[toc]]          生成目录及链接\n11   \x3c!-- more --\x3e    在\x3c!-- more --\x3e之前的内容会展示为文章摘要\n\n 2. 参考示例：\n\n---\ntitle: 文章标题\ndate: 2020-02-02\ntags:\n  - 标签\ncategories:\n  - 分类\nkeys:\n  - '123456'\nsticky: 1\nisshowcomments: false\npublish: true\n---\n\n  <boxx/>\n\n  [ [ toc ] ]\n\n  - 这里可以写`摘要`等其它\n\n    \x3c!-- more --\x3e\n\n  ## 正式开始你的markdown\n\n  - to be or not to be, ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 写在最后\n\n在 blog 搭建中遇到问题，推荐先去以下几个网址找答案：\n\n * vuepress官网：https://vuepress.vuejs.org/zh/\n * vuepress自定义开发主题：https://vuepress.vuejs.org/zh/theme/writing-a-theme.html\n * vuepress-theme-reco官网：https://vuepress-theme-reco.recoluan.com/\n\n如果在博客中遇到什么问题，不要一上来就问我，最好先查下相关资料，实在解决不了的可以找我咨询哈（减少无效沟通嘛），毕竟只有自己淌过的坑才能深入理解、印象深刻！\n\n当然，遇到一些有价值的问题，还是欢迎来找我共同探讨的😉~~\n\n关于如何提问，在 github 中这个项目可以说是相当 nice 了，可以的话一定要过一遍，于人于己都有莫大的好处：提问的智慧\n\n\n# 关于友链\n\n近期也发现有好些人要加 友链 的，在这里我也说一下吧：\n\n你可以复用我的 blog，但是需要在你的 blog 创新一些东西，比如添加你具有独立见解的文章，或者在其他方面体现自己独特的创意或价值（改改样式、优化一下功能等等），然后我给你加友链。毕竟千篇一律的友链没有必要是吧！\n\nthanks for you!",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Java 命名规范",frontmatter:{title:"Java 命名规范",date:"2021-03-02T00:00:00.000Z",tags:["开发规范","Java"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/javaNamingConvention.html",relativePath:"views/specification/javaNamingConvention.md",key:"v-2830159a",path:"/views/specification/javaNamingConvention.html",headers:[{level:2,title:"1. 包命名规范",slug:"_1-包命名规范",normalizedTitle:"1. 包命名规范",charIndex:153},{level:2,title:"2. 类命名规范",slug:"_2-类命名规范",normalizedTitle:"2. 类命名规范",charIndex:165},{level:3,title:"2.1 接口命名规范",slug:"_2-1-接口命名规范",normalizedTitle:"2.1 接口命名规范",charIndex:179},{level:3,title:"2.2 抽象类命名规范",slug:"_2-2-抽象类命名规范",normalizedTitle:"2.2 抽象类命名规范",charIndex:195},{level:3,title:"2.3 异常类命名规范",slug:"_2-3-异常类命名规范",normalizedTitle:"2.3 异常类命名规范",charIndex:212},{level:2,title:"3.方法命名规范",slug:"_3-方法命名规范",normalizedTitle:"3.方法命名规范",charIndex:227},{level:3,title:"3.1 表述获取",slug:"_3-1-表述获取",normalizedTitle:"3.1 表述获取",charIndex:241},{level:3,title:"3.2 表述查询",slug:"_3-2-表述查询",normalizedTitle:"3.2 表述查询",charIndex:255},{level:3,title:"3.3 表述条件",slug:"_3-3-表述条件",normalizedTitle:"3.3 表述条件",charIndex:269},{level:3,title:"3.4 表述设置",slug:"_3-4-表述设置",normalizedTitle:"3.4 表述设置",charIndex:283},{level:3,title:"3.5 其他规范",slug:"_3-5-其他规范",normalizedTitle:"3.5 其他规范",charIndex:297},{level:2,title:"4. 变量命名规范",slug:"_4-变量命名规范",normalizedTitle:"4. 变量命名规范",charIndex:309},{level:2,title:"5. 常量命名规范",slug:"_5-常量命名规范",normalizedTitle:"5. 常量命名规范",charIndex:322},{level:2,title:"6. 枚举命名规范",slug:"_6-枚举命名规范",normalizedTitle:"6. 枚举命名规范",charIndex:335},{level:2,title:"7. 其他命名规范",slug:"_7-其他命名规范",normalizedTitle:"7. 其他命名规范",charIndex:348},{level:3,title:"7.1 数组",slug:"_7-1-数组",normalizedTitle:"7.1 数组",charIndex:363},{level:3,title:"7.2 表述复数或者集合",slug:"_7-2-表述复数或者集合",normalizedTitle:"7.2 表述复数或者集合",charIndex:375},{level:3,title:"7.3 泛型类",slug:"_7-3-泛型类",normalizedTitle:"7.3 泛型类",charIndex:393},{level:3,title:"7.4 接口实现类",slug:"_7-4-接口实现类",normalizedTitle:"7.4 接口实现类",charIndex:406},{level:3,title:"7.5 测试类和测试方法",slug:"_7-5-测试类和测试方法",normalizedTitle:"7.5 测试类和测试方法",charIndex:421},{level:2,title:"8 扩展：速记Java开发中的各种O",slug:"_8-扩展-速记java开发中的各种o",normalizedTitle:"8 扩展：速记java开发中的各种o",charIndex:437}],excerpt:"<Boxx/>\n<p>在本文中，将从大到小，从外到内，总结Java编程中的命名规范。文中将会涉及到日常工作中常见的命名示例，如包命名，类命名，接口命名，方法命名，变量命名，常类命名，抽象类命名，异常类命名以及扩展类命名等。我将按照项目工程目录结构，从包，类(接口，抽象类，异常类)，方法，变量和常量的顺序展开介绍。</p>\n",headersStr:"1. 包命名规范 2. 类命名规范 2.1 接口命名规范 2.2 抽象类命名规范 2.3 异常类命名规范 3.方法命名规范 3.1 表述获取 3.2 表述查询 3.3 表述条件 3.4 表述设置 3.5 其他规范 4. 变量命名规范 5. 常量命名规范 6. 枚举命名规范 7. 其他命名规范 7.1 数组 7.2 表述复数或者集合 7.3 泛型类 7.4 接口实现类 7.5 测试类和测试方法 8 扩展：速记Java开发中的各种O",content:'在本文中，将从大到小，从外到内，总结Java编程中的命名规范。文中将会涉及到日常工作中常见的命名示例，如包命名，类命名，接口命名，方法命名，变量命名，常类命名，抽象类命名，异常类命名以及扩展类命名等。我将按照项目工程目录结构，从包，类(接口，抽象类，异常类)，方法，变量和常量的顺序展开介绍。\n\n\n\n * 1. 包命名规范\n * 2. 类命名规范\n   * 2.1 接口命名规范\n   * 2.2 抽象类命名规范\n   * 2.3 异常类命名规范\n * 3.方法命名规范\n   * 3.1 表述获取\n   * 3.2 表述查询\n   * 3.3 表述条件\n   * 3.4 表述设置\n   * 3.5 其他规范\n * 4. 变量命名规范\n * 5. 常量命名规范\n * 6. 枚举命名规范\n * 7. 其他命名规范\n   * 7.1 数组\n   * 7.2 表述复数或者集合\n   * 7.3 泛型类\n   * 7.4 接口实现类\n   * 7.5 测试类和测试方法\n * 8 扩展：速记Java开发中的各种O\n\n\n\n\n# 1. 包命名规范\n\n包(Package)的作用是将功能相似或相关的类或者接口进行分组管理，便于类的定位和查找，同时也可以使用包来避免类名的冲突和访问控制，使代码更容易维护。通常，包命使用小写英文字母进行命名，并使用“.”进行分割，每个被分割的单元只能包含一个名词。一般地，包命名常采用顶级域名作为前缀，例如com，net，org，edu，gov，cn，io等，随后紧跟公司/组织/个人名称以及功能模块名称。下面是一些包命名示例：\n\npackage org.springframework.boot.autoconfigure.cloud\npackage org.springframework.boot.util\npackage org.hibernate.action\npackage org.hibernate.cfg\npackage com.alibaba.druid\npackage com.alibaba.druid.filter\npackage com.alibaba.nacos.client.config\npackage com.ramostear.blog.web\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面是Oracle Java的一些常见包命名例子：\n\npackage java.beans\npackage java.io\npackage java.lang\npackage java.net\npackage java.util\npackage javax.annotation\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 类命名规范\n\n类(Class)通常采用名词进行命名，且首字母大写，如果一个类名包含两个以上名词，建议使用驼峰命名(Camel-Case)法书写类名,每个名词首字母也应该大写。一般地，类名的书写尽量使其保持简单和描述的完整性，因此在书写类名时不建议使用缩写(一些约定俗成的命名除外，例如Internationalization and Localization缩写成i18n，Uniform Resource Identifier缩写成URI，Data Access Object缩写成DAO，JSON Web Token缩写成JWT，HyperText Markup Language缩写成HTML等等)。下列是一些常见的类命名示例：\n\npublic class UserDTO{\n    //TODO...\n}\nclass EmployeeService{\n    //TODO...\n}\nclass StudentDAO{\n    //TODO...\n}\nclass OrderItemEntity{\n    //TODO...\n}\npublic class UserServiceImpl{\n    //TODO...\n}\npublic class OrderItemController{\n    //TODO...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n下面是Oracle Java中的一些标准命名示例：\n\npublic class HTMLEditorKit{\n    //...\n}\npublic abstract class HttpContext{\n    //...\n}\npublic interface ImageObserver{\n    //...\n}\npublic class ArrayIndexOutOfBoundsException{\n    //...\n}\npublic class enum Thread.State{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.1 接口命名规范\n\n首先，接口(Interface)是一种表述某一类型对象动作的特殊类；简单来说，接口也是类(不太严谨)，所以，接口的名称的书写也应该符合类名书写规范，首字母应该大写，与普通类名不同的是，接口命名时通常采用形容词或动词来描述接口的动作行为。下列是Oracle Java中一些标准库的接口使用形容词命名示例：\n\npublic interface Closeable{\n    //...\n}\npublic interface Cloneable{\n    //...\n}\npublic interface Runnable{\n    //...\n}\npublic interface Comparable<T>{\n    //...\n}\npublic interface CompletionService<V>{\n    //...\n}\npublic interface Iterable<T>{\n    //...\n}\npublic interface EventListener{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在Spring Framework标准库中，通常采用名词+动词/形容词的组合方式来命名接口，下列是Spring Framework中一些接口命名示例：\n\npublic interface AfterAdvice{\n    //...\n}\npublic interface TargetClassAware{\n    //...\n}\npublic interface ApplicationContextAware{\n    //...\n}\npublic interface MessageSourceResolvable{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.2 抽象类命名规范\n\n抽象类(Abstract Class)是一种特殊的类，其命名与普通类的命名规范相当。一般地，为了将抽象类与普通类和接口做出区别，提高抽象类的可读性，在命名抽象类时，会以“Abstract”/“Base”作为类命的前缀。下面是编程中一些常规的命名示例：\n\npublic abstract class AbstractRepository<T>{\n    //...\n}\npublic abstract class AbstractController{\n    //...\n}\npublic abstract class BaseDao<T,ID>{\n    //...\n}\npublic abstract class AbstractCommonService<T>{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n以下是Spring Framework中常见的抽象类示例：\n\npublic abstract class AbstractAspectJAdvice{\n    //...\n}\npublic abstract class AbstractSingletonProxyFactoryBean{\n    //...\n}\npublic abstract class AbstractBeanFactoryPointcutAdvisor{\n    //...\n}\npublic abstract class AbstractCachingConfiguration{\n    //...\n}\npublic abstract class AbstractContextLoaderInitializer{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.3 异常类命名规范\n\n异常类(Exception Class)也是类的一种，但与普通类命名不同的是，异常类在命名时需要使用“Exception”作为其后缀。下面是常见的异常类命名示例：\n\npublic class FileNotFoundException{\n    //...\n}\npublic class UserAlreadyExistException{\n    //...\n}\npublic class TransactionException{\n    //...\n}\npublic class ClassNotFoundException{\n    //...\n}\npublic class IllegalArgumentException{\n    //...\n}\npublic class IndexOutOfBoundsException{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n另外，在Java中还有另外一类异常类，它们属于系统异常，这一类异常类的命名使用“Error”作为其后缀，以区分Exception(编码，环境，操作等异常)。下面是系统异常(非检查异常)的命名示例：\n\npublic abstract class VirtualMachineError{\n    //...\n}\npublic class StackOverflowError{\n    //...\n}\npublic class OutOfMemoryError{\n    //...\n}\npublic class IllegalAccessError{\n    //...\n}\npublic class NoClassDefFoundError{\n    //...\n}\npublic class NoSuchFieldError{\n    //...\n}\npublic class NoSuchMethodError{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.方法命名规范\n\n方法(Method)命名时,其首字母应该小写，如果方法签名由多个单词组成，则从第二个单词起，使用驼峰命名法进行书写。一般地，在对方法进行命名时，通常采用动词/动词+名词的组合，下面是方法命名的一些常见示例。\n\n\n# 3.1 表述获取\n\n如果一个方法用于获取某个值，通常使用“get”作为其前缀，例如：\n\npublic String getUserName(){\n    //...\n}\npublic List<Integer> getUserIds(){\n    //...\n}\npublic User getOne(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.2 表述查询\n\n如果方法需要通过查询或筛选的方式获取某个数据，通常使用“find”/“query”作为其前缀，例如：\n\npublic List<User> findOne(Integer id){\n    //...\n}\npublic List<Integer> findAll(){\n    //...\n} \npublic List<String> queryOrders(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.3 表述条件\n\n如果一个方法需要一些条件参数，则可以使用“by”/“with”等字符作为方法名中条件的连接符，例如：\n\npublic User findByUsername(String username){\n    //...\n}\npublic List<Integer> getUserIdsWithState(boolean state){\n    //...\n}\npublic List<User> findAllByUsernameOrderByIdDesc(String username){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.4 表述设置\n\n如果一个方法是要设置，插入，修改，删除等操作，应该将对应的动词(set,insert,update,delete)作为其名词的前缀，例如：\n\npublic void setName(String name){\n    //...\n}\npublic User insert(User user){\n    //...\n}\npublic void update(User user){\n    //...\n}\npublic void clearAll(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.5 其他规范\n\n如果一个方法用于获取某组数据的长度或数量，则该方法应该使用length或size命名；如果方法的返回值为布尔类型(Boolean)，则该方法应该使用“is”或”has”作为前缀；如果方法用于将一种类型的数据转换为另一种数据数类型，则可以使用“to”作为前缀。下面是综合示例：\n\npublic long length(){\n    //...\n}\npublic int size(){\n    //...\n}\npublic boolean isOpen(){\n    //...\n}\npublic boolean isNotEmpty(){\n    //...\n}\npublic boolean hasLength(){\n    //...\n}\npublic Set<Integer> mapToSet(Map map){\n    //...\n}\npublic UserDto convertTo(User user){\n    //...\n}\npublic String toString(Object obj){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 4. 变量命名规范\n\n变量(Variable)命名包括参数名称，成员变量和局部变量。变量命名通常以小写字母开头，如果变量名由多个单词构成，则从第二个单词起首字母需要大写，在变量命名过程中，不建议使用“_”作为前缀或者单词之间的分割符号。下面是一些常见的变量命名示例：\n\nprivate String nickName;\nprivate String mobileNumber;\nprivate Long id;\nprivate String username;\nprivate Long orderId;\nprivate Long orderItemId;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5. 常量命名规范\n\n一般地，常量名称采用全部大写的英文单词书写，如果常量名称由多个单词组成，则单词之间统一使用“_”进行分割，下面是常量命名示例：\n\npublic static final String LOGIN_USER_SESSION_KEY = "current_login_user";\npublic static final int MAX_AGE_VALUE = 120;\npublic static final int DEFAULT_PAGE_NO = 1;\npublic static final long MAX_PAGE_SIZE = 1000;\npublic static final boolean HAS_LICENSE = false;\npublic static final boolean IS_CHECKED = false;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 6. 枚举命名规范\n\n枚举(Enum)类是一种特殊的类，其命名规范遵循普通类的命名约束条件，首字母大写，采用驼峰命名法；枚举类中定义的值的名称遵循常量的命名规范，且枚举值的名称需要与类名有一定的关联性，下面是枚举的一些示例：\n\npublic enum Color{\n    RED,YELLOW,BLUE,GREEN,WHITE;\n}\npublic enum PhysicalSize{\n    TINY,SMALL,MEDIUM,LARGE,HUGE,GIGANTIC;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是Oracle Java标准库中的一个示例：\n\npublic enum ElementType{\n    TYPE,\n    FIELD,\n    METHOD,\n    PARAMETER,\n    CONSTRUCTOR,\n    LOCAL_VARIABLE,\n    ANNOTATION_TYPE,\n    PACKAGE,\n    TYPE_PARAMETER,\n    TYPE_USE;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 7. 其他命名规范\n\n\n# 7.1 数组\n\n在定义数组时，为了便于阅读，尽量保持以下的书写规范：\n\nint[] array = new int[10];\nint[] idArray ={1,2,3,4,5};\nString[] nameArray = {"First","Yellow","Big"}\n\npublic List<String> getNameById(Integer[] ids){\n    //...\n}\n//或者\npublic List<String> getNameById(Integer...ids){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7.2 表述复数或者集合\n\n如果一个变量用于描述多个数据时，尽量使用单词的复数形式进行书写，例如：\n\nCollection<Order> orders;\nint[] values;\nList<Item> items;\n\n\n1\n2\n3\n\n\n另外，如果表述的是一个Map数据，则应使用“map”作为其后缀，例如：\n\nMap<String,User> userMap;\nMap<String,List<Object>> listMap;\n\n\n1\n2\n\n\n\n# 7.3 泛型类\n\n在书写泛型类时，通常做以下的约定：\n\n * E表示Element，通常用在集合中；\n * ID用于表示对象的唯一标识符类型\n * T表示Type(类型)，通常指代类；\n * K表示Key(键),通常用于Map中；\n * V表示Value(值),通常用于Map中，与K结对出现；\n * N表示Number,通常用于表示数值类型；\n * ？表示不确定的Java类型；\n * X用于表示异常；\n * U,S表示任意的类型。\n\n下面时泛型类的书写示例：\n\npublic class HashSet<E> extends AbstractSet<E>{\n    //...\n}\npublic class HashMap<K,V> extends AbstractMap<K,V>{\n    //...\n}\npublic class ThreadLocal<T>{\n    //...\n}\npublic interface Functor<T,X extends Throwable>{\n    T val() throws X;\n}\npublic class Container<K,V>{\n    private K key;\n    private V value;\n    Container(K key,V value){\n        this.key = key;\n        this.value = value;\n    }\n    //getter and setter ...\n}\n\npublic interface BaseRepository<T,ID>{\n    T findById(ID id);\n\n    void update(T t);\n\n    List<T> findByIds(ID...ids);\n}\n\npublic static <T> List<T> methodName(Class<T> clz){\n    List<T> dataList = getByClz(clz);\n    return dataList;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 7.4 接口实现类\n\n为了便于阅读，在通常情况下，建议接口实现类使用“Impl作为后缀”，不建议使用大写的“I”作为接口前缀，下面是接口和接口实现类的书写示例。\n\n推荐写法：\n\npublic interface OrderService{\n    //...\n}\npublic class OrderServiceImpl implements OrderService{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n不建议的写法：\n\npublic interface IOrderService{\n    //...\n}\npublic class OrderService implements IOrderService{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.5 测试类和测试方法\n\n在项目中，测试类采用被测试业务模块名/被测试接口/被测试类+“Test”的方法进行书写，测试类中的测试函数采用“test”+用例操作_状态的组合方式进行书写，例如：\n\npublic class UserServiceTest{\n\n    public void testFindByUsernameAndPassword(){\n        //...\n    }\n\n    public void testUsernameExist_notExist(){\n        //...\n    }\n\n    public void testDeleteById_isOk(){\n        //...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 8 扩展：速记Java开发中的各种O\n\n最后，通过一张表和图快速对Java中的BO,DTO,DAO,PO,POJO,VO之间的含义，区别以及联系进行梳理。\n\n名称     使用范围                                  解释说明\nBO     用于Service,Manager,Business等业务相关类的命名   Business Object业务处理对象，主要作用是把业务逻辑封装成一个对象。\nDTO    经过加工后的PO对象，其内部属性可能增加或减少               Data Transfer\n                                             Object数据传输对象，主要用于远程调用等需要大量传输数据的地方，例如，可以将一个或多个PO类的部分或全部属性封装为DTO进行传输\nDAO    用于对数据库进行读写操作的类进行命名                    Data Access\n                                             Object数据访问对象，主要用来封装对数据库的访问，通过DAO可以将POJO持久化为PO，也可以利用PO封装出VO和DTO\nPO     Bean,Entity等类的命名                      Persistant\n                                             Object持久化对象，数据库表中的数据在Java对象中的映射状态，可以简单的理解为一个PO对象即为数据库表中的一条记录\nPOJO   POJO是DO/DTO/BO/VO的统称                  Plain Ordinary Java Object\n                                             简单Java对象，它是一个简单的普通Java对象，禁止将类命名为XxxxPOJO\nVO     通常是视图控制层和模板引擎之间传递的数据对象                Value Object\n                                             值对象，主要用于视图层，视图控制器将视图层所需的属性封装成一个对象，然后用一个VO对象在视图控制器和视图之间进行数据传输。\nAO     应用层对象                                 Application Object，在Web层与Service层之间抽象的复用对象模型，很少用。\n\n下面将通过一张图来理解上述几种O之间相互转换的关系：\n\n\n\n来源：https://www.ramostear.com/blog/2020/03/20/2vxdaqjq.html',normalizedContent:'在本文中，将从大到小，从外到内，总结java编程中的命名规范。文中将会涉及到日常工作中常见的命名示例，如包命名，类命名，接口命名，方法命名，变量命名，常类命名，抽象类命名，异常类命名以及扩展类命名等。我将按照项目工程目录结构，从包，类(接口，抽象类，异常类)，方法，变量和常量的顺序展开介绍。\n\n\n\n * 1. 包命名规范\n * 2. 类命名规范\n   * 2.1 接口命名规范\n   * 2.2 抽象类命名规范\n   * 2.3 异常类命名规范\n * 3.方法命名规范\n   * 3.1 表述获取\n   * 3.2 表述查询\n   * 3.3 表述条件\n   * 3.4 表述设置\n   * 3.5 其他规范\n * 4. 变量命名规范\n * 5. 常量命名规范\n * 6. 枚举命名规范\n * 7. 其他命名规范\n   * 7.1 数组\n   * 7.2 表述复数或者集合\n   * 7.3 泛型类\n   * 7.4 接口实现类\n   * 7.5 测试类和测试方法\n * 8 扩展：速记java开发中的各种o\n\n\n\n\n# 1. 包命名规范\n\n包(package)的作用是将功能相似或相关的类或者接口进行分组管理，便于类的定位和查找，同时也可以使用包来避免类名的冲突和访问控制，使代码更容易维护。通常，包命使用小写英文字母进行命名，并使用“.”进行分割，每个被分割的单元只能包含一个名词。一般地，包命名常采用顶级域名作为前缀，例如com，net，org，edu，gov，cn，io等，随后紧跟公司/组织/个人名称以及功能模块名称。下面是一些包命名示例：\n\npackage org.springframework.boot.autoconfigure.cloud\npackage org.springframework.boot.util\npackage org.hibernate.action\npackage org.hibernate.cfg\npackage com.alibaba.druid\npackage com.alibaba.druid.filter\npackage com.alibaba.nacos.client.config\npackage com.ramostear.blog.web\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面是oracle java的一些常见包命名例子：\n\npackage java.beans\npackage java.io\npackage java.lang\npackage java.net\npackage java.util\npackage javax.annotation\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 类命名规范\n\n类(class)通常采用名词进行命名，且首字母大写，如果一个类名包含两个以上名词，建议使用驼峰命名(camel-case)法书写类名,每个名词首字母也应该大写。一般地，类名的书写尽量使其保持简单和描述的完整性，因此在书写类名时不建议使用缩写(一些约定俗成的命名除外，例如internationalization and localization缩写成i18n，uniform resource identifier缩写成uri，data access object缩写成dao，json web token缩写成jwt，hypertext markup language缩写成html等等)。下列是一些常见的类命名示例：\n\npublic class userdto{\n    //todo...\n}\nclass employeeservice{\n    //todo...\n}\nclass studentdao{\n    //todo...\n}\nclass orderitementity{\n    //todo...\n}\npublic class userserviceimpl{\n    //todo...\n}\npublic class orderitemcontroller{\n    //todo...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n下面是oracle java中的一些标准命名示例：\n\npublic class htmleditorkit{\n    //...\n}\npublic abstract class httpcontext{\n    //...\n}\npublic interface imageobserver{\n    //...\n}\npublic class arrayindexoutofboundsexception{\n    //...\n}\npublic class enum thread.state{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.1 接口命名规范\n\n首先，接口(interface)是一种表述某一类型对象动作的特殊类；简单来说，接口也是类(不太严谨)，所以，接口的名称的书写也应该符合类名书写规范，首字母应该大写，与普通类名不同的是，接口命名时通常采用形容词或动词来描述接口的动作行为。下列是oracle java中一些标准库的接口使用形容词命名示例：\n\npublic interface closeable{\n    //...\n}\npublic interface cloneable{\n    //...\n}\npublic interface runnable{\n    //...\n}\npublic interface comparable<t>{\n    //...\n}\npublic interface completionservice<v>{\n    //...\n}\npublic interface iterable<t>{\n    //...\n}\npublic interface eventlistener{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在spring framework标准库中，通常采用名词+动词/形容词的组合方式来命名接口，下列是spring framework中一些接口命名示例：\n\npublic interface afteradvice{\n    //...\n}\npublic interface targetclassaware{\n    //...\n}\npublic interface applicationcontextaware{\n    //...\n}\npublic interface messagesourceresolvable{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.2 抽象类命名规范\n\n抽象类(abstract class)是一种特殊的类，其命名与普通类的命名规范相当。一般地，为了将抽象类与普通类和接口做出区别，提高抽象类的可读性，在命名抽象类时，会以“abstract”/“base”作为类命的前缀。下面是编程中一些常规的命名示例：\n\npublic abstract class abstractrepository<t>{\n    //...\n}\npublic abstract class abstractcontroller{\n    //...\n}\npublic abstract class basedao<t,id>{\n    //...\n}\npublic abstract class abstractcommonservice<t>{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n以下是spring framework中常见的抽象类示例：\n\npublic abstract class abstractaspectjadvice{\n    //...\n}\npublic abstract class abstractsingletonproxyfactorybean{\n    //...\n}\npublic abstract class abstractbeanfactorypointcutadvisor{\n    //...\n}\npublic abstract class abstractcachingconfiguration{\n    //...\n}\npublic abstract class abstractcontextloaderinitializer{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.3 异常类命名规范\n\n异常类(exception class)也是类的一种，但与普通类命名不同的是，异常类在命名时需要使用“exception”作为其后缀。下面是常见的异常类命名示例：\n\npublic class filenotfoundexception{\n    //...\n}\npublic class useralreadyexistexception{\n    //...\n}\npublic class transactionexception{\n    //...\n}\npublic class classnotfoundexception{\n    //...\n}\npublic class illegalargumentexception{\n    //...\n}\npublic class indexoutofboundsexception{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n另外，在java中还有另外一类异常类，它们属于系统异常，这一类异常类的命名使用“error”作为其后缀，以区分exception(编码，环境，操作等异常)。下面是系统异常(非检查异常)的命名示例：\n\npublic abstract class virtualmachineerror{\n    //...\n}\npublic class stackoverflowerror{\n    //...\n}\npublic class outofmemoryerror{\n    //...\n}\npublic class illegalaccesserror{\n    //...\n}\npublic class noclassdeffounderror{\n    //...\n}\npublic class nosuchfielderror{\n    //...\n}\npublic class nosuchmethoderror{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.方法命名规范\n\n方法(method)命名时,其首字母应该小写，如果方法签名由多个单词组成，则从第二个单词起，使用驼峰命名法进行书写。一般地，在对方法进行命名时，通常采用动词/动词+名词的组合，下面是方法命名的一些常见示例。\n\n\n# 3.1 表述获取\n\n如果一个方法用于获取某个值，通常使用“get”作为其前缀，例如：\n\npublic string getusername(){\n    //...\n}\npublic list<integer> getuserids(){\n    //...\n}\npublic user getone(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.2 表述查询\n\n如果方法需要通过查询或筛选的方式获取某个数据，通常使用“find”/“query”作为其前缀，例如：\n\npublic list<user> findone(integer id){\n    //...\n}\npublic list<integer> findall(){\n    //...\n} \npublic list<string> queryorders(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.3 表述条件\n\n如果一个方法需要一些条件参数，则可以使用“by”/“with”等字符作为方法名中条件的连接符，例如：\n\npublic user findbyusername(string username){\n    //...\n}\npublic list<integer> getuseridswithstate(boolean state){\n    //...\n}\npublic list<user> findallbyusernameorderbyiddesc(string username){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.4 表述设置\n\n如果一个方法是要设置，插入，修改，删除等操作，应该将对应的动词(set,insert,update,delete)作为其名词的前缀，例如：\n\npublic void setname(string name){\n    //...\n}\npublic user insert(user user){\n    //...\n}\npublic void update(user user){\n    //...\n}\npublic void clearall(){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.5 其他规范\n\n如果一个方法用于获取某组数据的长度或数量，则该方法应该使用length或size命名；如果方法的返回值为布尔类型(boolean)，则该方法应该使用“is”或”has”作为前缀；如果方法用于将一种类型的数据转换为另一种数据数类型，则可以使用“to”作为前缀。下面是综合示例：\n\npublic long length(){\n    //...\n}\npublic int size(){\n    //...\n}\npublic boolean isopen(){\n    //...\n}\npublic boolean isnotempty(){\n    //...\n}\npublic boolean haslength(){\n    //...\n}\npublic set<integer> maptoset(map map){\n    //...\n}\npublic userdto convertto(user user){\n    //...\n}\npublic string tostring(object obj){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 4. 变量命名规范\n\n变量(variable)命名包括参数名称，成员变量和局部变量。变量命名通常以小写字母开头，如果变量名由多个单词构成，则从第二个单词起首字母需要大写，在变量命名过程中，不建议使用“_”作为前缀或者单词之间的分割符号。下面是一些常见的变量命名示例：\n\nprivate string nickname;\nprivate string mobilenumber;\nprivate long id;\nprivate string username;\nprivate long orderid;\nprivate long orderitemid;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5. 常量命名规范\n\n一般地，常量名称采用全部大写的英文单词书写，如果常量名称由多个单词组成，则单词之间统一使用“_”进行分割，下面是常量命名示例：\n\npublic static final string login_user_session_key = "current_login_user";\npublic static final int max_age_value = 120;\npublic static final int default_page_no = 1;\npublic static final long max_page_size = 1000;\npublic static final boolean has_license = false;\npublic static final boolean is_checked = false;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 6. 枚举命名规范\n\n枚举(enum)类是一种特殊的类，其命名规范遵循普通类的命名约束条件，首字母大写，采用驼峰命名法；枚举类中定义的值的名称遵循常量的命名规范，且枚举值的名称需要与类名有一定的关联性，下面是枚举的一些示例：\n\npublic enum color{\n    red,yellow,blue,green,white;\n}\npublic enum physicalsize{\n    tiny,small,medium,large,huge,gigantic;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n下面是oracle java标准库中的一个示例：\n\npublic enum elementtype{\n    type,\n    field,\n    method,\n    parameter,\n    constructor,\n    local_variable,\n    annotation_type,\n    package,\n    type_parameter,\n    type_use;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 7. 其他命名规范\n\n\n# 7.1 数组\n\n在定义数组时，为了便于阅读，尽量保持以下的书写规范：\n\nint[] array = new int[10];\nint[] idarray ={1,2,3,4,5};\nstring[] namearray = {"first","yellow","big"}\n\npublic list<string> getnamebyid(integer[] ids){\n    //...\n}\n//或者\npublic list<string> getnamebyid(integer...ids){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7.2 表述复数或者集合\n\n如果一个变量用于描述多个数据时，尽量使用单词的复数形式进行书写，例如：\n\ncollection<order> orders;\nint[] values;\nlist<item> items;\n\n\n1\n2\n3\n\n\n另外，如果表述的是一个map数据，则应使用“map”作为其后缀，例如：\n\nmap<string,user> usermap;\nmap<string,list<object>> listmap;\n\n\n1\n2\n\n\n\n# 7.3 泛型类\n\n在书写泛型类时，通常做以下的约定：\n\n * e表示element，通常用在集合中；\n * id用于表示对象的唯一标识符类型\n * t表示type(类型)，通常指代类；\n * k表示key(键),通常用于map中；\n * v表示value(值),通常用于map中，与k结对出现；\n * n表示number,通常用于表示数值类型；\n * ？表示不确定的java类型；\n * x用于表示异常；\n * u,s表示任意的类型。\n\n下面时泛型类的书写示例：\n\npublic class hashset<e> extends abstractset<e>{\n    //...\n}\npublic class hashmap<k,v> extends abstractmap<k,v>{\n    //...\n}\npublic class threadlocal<t>{\n    //...\n}\npublic interface functor<t,x extends throwable>{\n    t val() throws x;\n}\npublic class container<k,v>{\n    private k key;\n    private v value;\n    container(k key,v value){\n        this.key = key;\n        this.value = value;\n    }\n    //getter and setter ...\n}\n\npublic interface baserepository<t,id>{\n    t findbyid(id id);\n\n    void update(t t);\n\n    list<t> findbyids(id...ids);\n}\n\npublic static <t> list<t> methodname(class<t> clz){\n    list<t> datalist = getbyclz(clz);\n    return datalist;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 7.4 接口实现类\n\n为了便于阅读，在通常情况下，建议接口实现类使用“impl作为后缀”，不建议使用大写的“i”作为接口前缀，下面是接口和接口实现类的书写示例。\n\n推荐写法：\n\npublic interface orderservice{\n    //...\n}\npublic class orderserviceimpl implements orderservice{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n不建议的写法：\n\npublic interface iorderservice{\n    //...\n}\npublic class orderservice implements iorderservice{\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.5 测试类和测试方法\n\n在项目中，测试类采用被测试业务模块名/被测试接口/被测试类+“test”的方法进行书写，测试类中的测试函数采用“test”+用例操作_状态的组合方式进行书写，例如：\n\npublic class userservicetest{\n\n    public void testfindbyusernameandpassword(){\n        //...\n    }\n\n    public void testusernameexist_notexist(){\n        //...\n    }\n\n    public void testdeletebyid_isok(){\n        //...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 8 扩展：速记java开发中的各种o\n\n最后，通过一张表和图快速对java中的bo,dto,dao,po,pojo,vo之间的含义，区别以及联系进行梳理。\n\n名称     使用范围                                  解释说明\nbo     用于service,manager,business等业务相关类的命名   business object业务处理对象，主要作用是把业务逻辑封装成一个对象。\ndto    经过加工后的po对象，其内部属性可能增加或减少               data transfer\n                                             object数据传输对象，主要用于远程调用等需要大量传输数据的地方，例如，可以将一个或多个po类的部分或全部属性封装为dto进行传输\ndao    用于对数据库进行读写操作的类进行命名                    data access\n                                             object数据访问对象，主要用来封装对数据库的访问，通过dao可以将pojo持久化为po，也可以利用po封装出vo和dto\npo     bean,entity等类的命名                      persistant\n                                             object持久化对象，数据库表中的数据在java对象中的映射状态，可以简单的理解为一个po对象即为数据库表中的一条记录\npojo   pojo是do/dto/bo/vo的统称                  plain ordinary java object\n                                             简单java对象，它是一个简单的普通java对象，禁止将类命名为xxxxpojo\nvo     通常是视图控制层和模板引擎之间传递的数据对象                value object\n                                             值对象，主要用于视图层，视图控制器将视图层所需的属性封装成一个对象，然后用一个vo对象在视图控制器和视图之间进行数据传输。\nao     应用层对象                                 application object，在web层与service层之间抽象的复用对象模型，很少用。\n\n下面将通过一张图来理解上述几种o之间相互转换的关系：\n\n\n\n来源：https://www.ramostear.com/blog/2020/03/20/2vxdaqjq.html',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"k8s基本命令与pod管理",frontmatter:{title:"k8s基本命令与pod管理",date:"2022-01-17T00:00:00.000Z",tags:["分布式","k8s"],categories:["后端 Back-end"],isShowComments:!1},regularPath:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html",relativePath:"views/specification/k8s基本命令与pod管理.md",key:"v-5d6482c8",path:"/views/specification/k8s%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%B8%8Epod%E7%AE%A1%E7%90%86.html",headers:[{level:2,title:"查看指定命名空间下的所有节点",slug:"查看指定命名空间下的所有节点",normalizedTitle:"查看指定命名空间下的所有节点",charIndex:29},{level:2,title:"进入某一节点",slug:"进入某一节点",normalizedTitle:"进入某一节点",charIndex:47},{level:2,title:"删除某一节点",slug:"删除某一节点",normalizedTitle:"删除某一节点",charIndex:57},{level:2,title:"查看pod暴露的端口号",slug:"查看pod暴露的端口号",normalizedTitle:"查看pod暴露的端口号",charIndex:67},{level:2,title:"移动文件至pod内部",slug:"移动文件至pod内部",normalizedTitle:"移动文件至pod内部",charIndex:82},{level:2,title:"修改ConfigMap",slug:"修改configmap",normalizedTitle:"修改configmap",charIndex:96},{level:2,title:"其他参考",slug:"其他参考",normalizedTitle:"其他参考",charIndex:111}],excerpt:"<Boxx/>\n<p>工作中常用到的 k8s 命令备份，方便查看。</p>\n",headersStr:"查看指定命名空间下的所有节点 进入某一节点 删除某一节点 查看pod暴露的端口号 移动文件至pod内部 修改ConfigMap 其他参考",content:"工作中常用到的 k8s 命令备份，方便查看。\n\n\n\n * 查看指定命名空间下的所有节点\n * 进入某一节点\n * 删除某一节点\n * 查看pod暴露的端口号\n * 移动文件至pod内部\n * 修改ConfigMap\n * 其他参考\n\n\n\n\n# 查看指定命名空间下的所有节点\n\nkubectl get pod -n znote\n\n\n1\n\n\n\n# 进入某一节点\n\nkubectl exec -it test-pod-statefulset-1 /bin/bash -n znote\n\n\n1\n\n\n\n# 删除某一节点\n\nkubectl delete test-pod-statefulset-1 -n znote\n\n\n1\n\n\n\n# 查看pod暴露的端口号\n\nkubectl get svc -n znote\n\n\n1\n\n\n\n# 移动文件至pod内部\n\n移到文件到容器中pod的pvc目录下后重启pod，pvc目录中的文件不会丢失\n\nkubectl -n znote cp ./aaa test-pod-statefulset-1:/bbb/sdf\n\n\n1\n\n\n\n# 修改ConfigMap\n\n同理修改：pod、svc、statefulset、cm（cm代表ConfigMap）\n\n# 查看ConfigMap\nkubectl get cm -n obp\n# 编辑\nkubectl edit cm test-pod-config -n znote\n# 删除\nkubectl delete cm test-pod-config -n znote\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 其他参考\n\nk8s中部署发布应用",normalizedContent:"工作中常用到的 k8s 命令备份，方便查看。\n\n\n\n * 查看指定命名空间下的所有节点\n * 进入某一节点\n * 删除某一节点\n * 查看pod暴露的端口号\n * 移动文件至pod内部\n * 修改configmap\n * 其他参考\n\n\n\n\n# 查看指定命名空间下的所有节点\n\nkubectl get pod -n znote\n\n\n1\n\n\n\n# 进入某一节点\n\nkubectl exec -it test-pod-statefulset-1 /bin/bash -n znote\n\n\n1\n\n\n\n# 删除某一节点\n\nkubectl delete test-pod-statefulset-1 -n znote\n\n\n1\n\n\n\n# 查看pod暴露的端口号\n\nkubectl get svc -n znote\n\n\n1\n\n\n\n# 移动文件至pod内部\n\n移到文件到容器中pod的pvc目录下后重启pod，pvc目录中的文件不会丢失\n\nkubectl -n znote cp ./aaa test-pod-statefulset-1:/bbb/sdf\n\n\n1\n\n\n\n# 修改configmap\n\n同理修改：pod、svc、statefulset、cm（cm代表configmap）\n\n# 查看configmap\nkubectl get cm -n obp\n# 编辑\nkubectl edit cm test-pod-config -n znote\n# 删除\nkubectl delete cm test-pod-config -n znote\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 其他参考\n\nk8s中部署发布应用",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{frontmatter:{},regularPath:"/views/specification/wildcard.html",relativePath:"views/specification/wildcard.md",key:"v-516caef5",path:"/views/specification/wildcard.html",headersStr:null,content:" 1. 泛型中的通配符 T，E，K，V，？\n\n本质上这些个都是通配符，没啥区别，换成 A-Z 之间的任何一个 字母都可以。 通常情况下，T，E，K，V，？ 是这样约定的：\n\n * ？ 表示不确定的 java 类型\n * T (type) 表示具体的一个 java 类型\n * K V (key value) 分别代表 java 键值中的 Key Value\n * E (element) 代表 Element",normalizedContent:" 1. 泛型中的通配符 t，e，k，v，？\n\n本质上这些个都是通配符，没啥区别，换成 a-z 之间的任何一个 字母都可以。 通常情况下，t，e，k，v，？ 是这样约定的：\n\n * ？ 表示不确定的 java 类型\n * t (type) 表示具体的一个 java 类型\n * k v (key value) 分别代表 java 键值中的 key value\n * e (element) 代表 element",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"linux自用命令",frontmatter:{title:"linux自用命令",date:"2020-03-26T00:00:00.000Z",tags:["linux"],categories:["规范 Standard"],isShowComments:!0,publish:!0},regularPath:"/views/specification/linux01.html",relativePath:"views/specification/linux01.md",key:"v-90c76f52",path:"/views/specification/linux01.html",headers:[{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:29},{level:2,title:"文件内容查找",slug:"文件内容查找",normalizedTitle:"文件内容查找",charIndex:35},{level:2,title:"根据pid查程序目录",slug:"根据pid查程序目录",normalizedTitle:"根据pid查程序目录",charIndex:45},{level:2,title:"Tomcat",slug:"tomcat",normalizedTitle:"tomcat",charIndex:59},{level:2,title:"权限",slug:"权限",normalizedTitle:"权限",charIndex:69},{level:2,title:"文件复制/移动/大小",slug:"文件复制-移动-大小",normalizedTitle:"文件复制/移动/大小",charIndex:75},{level:2,title:"上传下载",slug:"上传下载",normalizedTitle:"上传下载",charIndex:89},{level:2,title:"压缩解压",slug:"压缩解压",normalizedTitle:"压缩解压",charIndex:97},{level:2,title:"建立软链接",slug:"建立软链接",normalizedTitle:"建立软链接",charIndex:105},{level:2,title:"更改环境变量",slug:"更改环境变量",normalizedTitle:"更改环境变量",charIndex:114},{level:2,title:"端口/防火墙",slug:"端口-防火墙",normalizedTitle:"端口/防火墙",charIndex:124},{level:2,title:"禁IP",slug:"禁ip",normalizedTitle:"禁ip",charIndex:134}],excerpt:'<Boxx/>\n<p>工作中常用到的linux命令备份，方便查看。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n',headersStr:"工具 文件内容查找 根据pid查程序目录 Tomcat 权限 文件复制/移动/大小 上传下载 压缩解压 建立软链接 更改环境变量 端口/防火墙 禁IP",content:"工作中常用到的linux命令备份，方便查看。\n\n\n\n * 工具\n * 文件内容查找\n * 根据pid查程序目录\n * Tomcat\n * 权限\n * 文件复制/移动/大小\n * 上传下载\n * 压缩解压\n * 建立软链接\n * 更改环境变量\n * 端口/防火墙\n * 禁IP\n\n\n\n\n# 工具\n\n自我备份：Xshell + Xftp（已破解）\n\n\n# 文件内容查找\n\n# 查找文件夹下或某个文件包含某字符的所有文件\n# -r 是递归查找\n# -n 是显示行号\n# -C 5 显示file文件里匹配字串那行以及上下5行\n# -B 5 显示前5行\n# -A 5 显示后5行\n# --include '*.html' 指定后缀名\ngrep -rn \"message\" ./\n# 实时显示日志记录\ntail -100f a.log\n# 查找包含 2020 的 catalina.out文件所在的行\nfind ./ -name catalina.out | xargs grep 2020\n# grep之后，按行统计行数 wc -l\nfind ./ -name catalina.out | xargs grep 2020 | wc -l\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 根据pid查程序目录\n\nps -ef | grep redis\n# root     14145     1  0 Jul08 ?        00:17:14 ./redis-server *:6379\nls -al /proc/14145/exe\n# lrwxrwxrwx. 1 root root 0 7月 31 05:10 /proc/14145/exe -> /usr/local/bin/redis-server\n\n\n1\n2\n3\n4\n\n\n\n# Tomcat\n\n# 查看tomcat是否启动，并查看tomcat端口号\nps -ef| grep tomcat\nsudo netstat -apn | grep 7507  \nnetstat –pan | grep XXXX  (此处XXXX为pid)\n# 重启tomcat\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/bin\nsh shutdown.sh\nsh startup.sh\n# 有时关闭服务操作不成功，强制删掉后台进程\nkill -9 7010\n# 实时查看tomcat运行日志\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/logs\ntail -f -n 500 catalina.out #查看日志，同样Ctrl+c退出\n# 清缓存\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/work\nrm -rf Catalina\n# 截取日志 （前提是 catalina.out 日志中的每行都是以日期格式开头的）\nsed -n '/^2012-05-15/,/^2012-05-16/p' catalina.out > catalina_20120515.out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 权限\n\n#给文件的所有者加上 x 权限,即可使用:\nchmod   u+x   文件\n#查看文件权限\nls  -l   文件\n\n\n1\n2\n3\n4\n\n\n> 参考： 白小黑..\n\n\n# 文件复制/移动/大小\n\n#复制文件夹 -r\ncp -r a文件夹 b新文件夹\n#将/test1目录下的file1复制到/test3 目录，并将文件名改为file2\nmv /test1/file1 /test3/file2\n# 查看当前路径下各个目录大小(后面也可以跟指定目录)， -h 以K，M，G为单位，提高信息的可读性。\ndu -sh *\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 上传下载\n\nyum -y install lrzsz #安装\nrz #上传\nsz #下载\n\n\n1\n2\n3\n\n\n\n# 压缩解压\n\n#压缩指定文件夹为 tar.bz2\n[root@db phantomjs]# tar -cjf echarts-convert.tar.bz2 echarts-convert/\n#解压 tar.bz2\n[root@db yx_zb]# tar -xjvf echarts-convert.tar.bz2\n\n\n1\n2\n3\n4\n\n\n\n# 建立软链接\n\nln -s /usr/PhantomJS/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/bin/phantomjs\n\n\n1\n\n\n\n# 更改环境变量\n\nvim /etc/profile #编辑\nsource /etc/profile #重启使环境变量生效\n\n\n1\n2\n\n\n\n# 端口/防火墙\n\nnetstat -ntlp   #查看当前所有tcp端口\nnetstat -ntulp |grep 80   #查看所有80端口使用情况\n\n#开放端口： 1.修改 /etc/sysconfig/iptables 文件\n# 2.如开放80端口,ACCEPT为开启、DROP为关闭\niptables -A INPUT -p tcp --dport 80 -j ACCEPT #当数据从外部进入服务器为目标端口\niptables -A OUTPUT -p tcp --sport 80 -j ACCEPT #数据从服务器出去\nservice iptables save #保证重启服务器后也不会失效\n\nservice iptables restart #改完后重启防火墙\n/sbin/iptables -L -n #查看开放的端口\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 禁IP\n\niptables -A INPUT -p tcp -s 192.168.1.2 -j DROP\n\n\n1\n",normalizedContent:"工作中常用到的linux命令备份，方便查看。\n\n\n\n * 工具\n * 文件内容查找\n * 根据pid查程序目录\n * tomcat\n * 权限\n * 文件复制/移动/大小\n * 上传下载\n * 压缩解压\n * 建立软链接\n * 更改环境变量\n * 端口/防火墙\n * 禁ip\n\n\n\n\n# 工具\n\n自我备份：xshell + xftp（已破解）\n\n\n# 文件内容查找\n\n# 查找文件夹下或某个文件包含某字符的所有文件\n# -r 是递归查找\n# -n 是显示行号\n# -c 5 显示file文件里匹配字串那行以及上下5行\n# -b 5 显示前5行\n# -a 5 显示后5行\n# --include '*.html' 指定后缀名\ngrep -rn \"message\" ./\n# 实时显示日志记录\ntail -100f a.log\n# 查找包含 2020 的 catalina.out文件所在的行\nfind ./ -name catalina.out | xargs grep 2020\n# grep之后，按行统计行数 wc -l\nfind ./ -name catalina.out | xargs grep 2020 | wc -l\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 根据pid查程序目录\n\nps -ef | grep redis\n# root     14145     1  0 jul08 ?        00:17:14 ./redis-server *:6379\nls -al /proc/14145/exe\n# lrwxrwxrwx. 1 root root 0 7月 31 05:10 /proc/14145/exe -> /usr/local/bin/redis-server\n\n\n1\n2\n3\n4\n\n\n\n# tomcat\n\n# 查看tomcat是否启动，并查看tomcat端口号\nps -ef| grep tomcat\nsudo netstat -apn | grep 7507  \nnetstat –pan | grep xxxx  (此处xxxx为pid)\n# 重启tomcat\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/bin\nsh shutdown.sh\nsh startup.sh\n# 有时关闭服务操作不成功，强制删掉后台进程\nkill -9 7010\n# 实时查看tomcat运行日志\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/logs\ntail -f -n 500 catalina.out #查看日志，同样ctrl+c退出\n# 清缓存\ncd /home/yx/server8.5.50/apache-tomcat-8.5.40/work\nrm -rf catalina\n# 截取日志 （前提是 catalina.out 日志中的每行都是以日期格式开头的）\nsed -n '/^2012-05-15/,/^2012-05-16/p' catalina.out > catalina_20120515.out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 权限\n\n#给文件的所有者加上 x 权限,即可使用:\nchmod   u+x   文件\n#查看文件权限\nls  -l   文件\n\n\n1\n2\n3\n4\n\n\n> 参考： 白小黑..\n\n\n# 文件复制/移动/大小\n\n#复制文件夹 -r\ncp -r a文件夹 b新文件夹\n#将/test1目录下的file1复制到/test3 目录，并将文件名改为file2\nmv /test1/file1 /test3/file2\n# 查看当前路径下各个目录大小(后面也可以跟指定目录)， -h 以k，m，g为单位，提高信息的可读性。\ndu -sh *\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 上传下载\n\nyum -y install lrzsz #安装\nrz #上传\nsz #下载\n\n\n1\n2\n3\n\n\n\n# 压缩解压\n\n#压缩指定文件夹为 tar.bz2\n[root@db phantomjs]# tar -cjf echarts-convert.tar.bz2 echarts-convert/\n#解压 tar.bz2\n[root@db yx_zb]# tar -xjvf echarts-convert.tar.bz2\n\n\n1\n2\n3\n4\n\n\n\n# 建立软链接\n\nln -s /usr/phantomjs/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/bin/phantomjs\n\n\n1\n\n\n\n# 更改环境变量\n\nvim /etc/profile #编辑\nsource /etc/profile #重启使环境变量生效\n\n\n1\n2\n\n\n\n# 端口/防火墙\n\nnetstat -ntlp   #查看当前所有tcp端口\nnetstat -ntulp |grep 80   #查看所有80端口使用情况\n\n#开放端口： 1.修改 /etc/sysconfig/iptables 文件\n# 2.如开放80端口,accept为开启、drop为关闭\niptables -a input -p tcp --dport 80 -j accept #当数据从外部进入服务器为目标端口\niptables -a output -p tcp --sport 80 -j accept #数据从服务器出去\nservice iptables save #保证重启服务器后也不会失效\n\nservice iptables restart #改完后重启防火墙\n/sbin/iptables -l -n #查看开放的端口\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 禁ip\n\niptables -a input -p tcp -s 192.168.1.2 -j drop\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Linux 系统内存不足导致 Java 进程被杀掉",frontmatter:{title:"Linux 系统内存不足导致 Java 进程被杀掉",date:"2023-01-12T00:00:00.000Z",tags:["linux"],categories:["规范 Standard"],isShowComments:!0,publish:!0},regularPath:"/views/specification/linux02.html",relativePath:"views/specification/linux02.md",key:"v-660e1712",path:"/views/specification/linux02.html",headers:[{level:2,title:"问题排查",slug:"问题排查",normalizedTitle:"问题排查",charIndex:54},{level:2,title:"原因分析",slug:"原因分析",normalizedTitle:"原因分析",charIndex:62},{level:2,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:70}],excerpt:'<Boxx/>\n<p>查看java系统错误日志、gc日志都没有发现任何问题，服务器应用总是隔三岔五莫名其妙被停掉。。</p>\n<p><div class="table-of-contents"><ul></ul></div></p>\n',headersStr:"问题排查 原因分析 解决方法",content:"查看java系统错误日志、gc日志都没有发现任何问题，服务器应用总是隔三岔五莫名其妙被停掉。。\n\n\n\n * 问题排查\n * 原因分析\n * 解决方法\n\n\n\nLinux内存使用量超过阈值，使得Java应用程序无可用内存，最终导致程序崩溃。即使在程序没有挂掉时把程序停掉，系统内存也不会被释放。\n\n\n# 问题排查\n\n查看 Linux 的系统日志 /var/log/message 出现如下日志，说明 Linux 系统自身把 Java 进程杀掉了\n\n# grep 'Out of memory' messages*\nDec 14 11:21:59 ecs-web kernel: Out of memory: Kill process 17873 (java) score 67 or sacrifice child\n\n\n1\n2\n\n\n当 Linux 系统内存不足时，系统会把当前系统占用系统内存过高的进程当做流氓进程，然后系统发出信号将这个流氓进程杀掉，最后导致 Java 应用服务不能使用\n\n\n# 原因分析\n\nLinux 内核有个机制叫OOM killer(Out Of Memory killer)，该机制会监控那些占用内存过大，尤其是瞬间占用内存很快的进程，然后防止内存耗尽而自动把该进程杀掉。\n\n内核检测到系统内存不足、挑选并杀掉某个进程的过程可以参考内核源代码linux/mm/oom_kill.c，当系统内存不足的时候，out_of_memory()被触发，然后调用select_bad_process()选择一个”bad”进程杀掉。\n\n如何判断和选择一个”bad进程呢？linux选择”bad”进程是通过调用oom_badness()，挑选的算法和想法都很简单很朴实：最bad的那个进程就是那个最占用内存的进程。\n\nLinux下这个选择策略也一直在不断的演化。作为用户，我们可以通过设置一些值来影响OOM killer做出决策。Linux下每个进程都有个OOM权重，在/proc//oom_adj里面，取值是-17到+15，取值越高，越容易被干掉。\n\n最终OOM killer是通过/proc//oom_score这个值来决定哪个进程被干掉的。这个值是系统综合进程的内存消耗量、CPU时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高，存活时间越长分越低。总之，总的策略是：损失最少的工作，释放最大的内存同时不伤及无辜的用了很大内存的进程，并且杀掉的进程数尽量少。\n\n\n# 解决方法\n\n方法1：通过调整 JVM 参数限制最大可使用内存\n\n-Xmx2g\n\n\n1\n\n\n方法2：启用 swap 分区 参考https://help.aliyun.com/knowledge_detail/42534.html\n\n方法3：增加物理内存或增加机器\n\n方法4：将应用分配到压力较小的服务器上",normalizedContent:"查看java系统错误日志、gc日志都没有发现任何问题，服务器应用总是隔三岔五莫名其妙被停掉。。\n\n\n\n * 问题排查\n * 原因分析\n * 解决方法\n\n\n\nlinux内存使用量超过阈值，使得java应用程序无可用内存，最终导致程序崩溃。即使在程序没有挂掉时把程序停掉，系统内存也不会被释放。\n\n\n# 问题排查\n\n查看 linux 的系统日志 /var/log/message 出现如下日志，说明 linux 系统自身把 java 进程杀掉了\n\n# grep 'out of memory' messages*\ndec 14 11:21:59 ecs-web kernel: out of memory: kill process 17873 (java) score 67 or sacrifice child\n\n\n1\n2\n\n\n当 linux 系统内存不足时，系统会把当前系统占用系统内存过高的进程当做流氓进程，然后系统发出信号将这个流氓进程杀掉，最后导致 java 应用服务不能使用\n\n\n# 原因分析\n\nlinux 内核有个机制叫oom killer(out of memory killer)，该机制会监控那些占用内存过大，尤其是瞬间占用内存很快的进程，然后防止内存耗尽而自动把该进程杀掉。\n\n内核检测到系统内存不足、挑选并杀掉某个进程的过程可以参考内核源代码linux/mm/oom_kill.c，当系统内存不足的时候，out_of_memory()被触发，然后调用select_bad_process()选择一个”bad”进程杀掉。\n\n如何判断和选择一个”bad进程呢？linux选择”bad”进程是通过调用oom_badness()，挑选的算法和想法都很简单很朴实：最bad的那个进程就是那个最占用内存的进程。\n\nlinux下这个选择策略也一直在不断的演化。作为用户，我们可以通过设置一些值来影响oom killer做出决策。linux下每个进程都有个oom权重，在/proc//oom_adj里面，取值是-17到+15，取值越高，越容易被干掉。\n\n最终oom killer是通过/proc//oom_score这个值来决定哪个进程被干掉的。这个值是系统综合进程的内存消耗量、cpu时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高，存活时间越长分越低。总之，总的策略是：损失最少的工作，释放最大的内存同时不伤及无辜的用了很大内存的进程，并且杀掉的进程数尽量少。\n\n\n# 解决方法\n\n方法1：通过调整 jvm 参数限制最大可使用内存\n\n-xmx2g\n\n\n1\n\n\n方法2：启用 swap 分区 参考https://help.aliyun.com/knowledge_detail/42534.html\n\n方法3：增加物理内存或增加机器\n\n方法4：将应用分配到压力较小的服务器上",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"版本控制提交规范你会了吗？",frontmatter:{title:"版本控制提交规范你会了吗？",date:"2020-09-07T00:00:00.000Z",tags:["开发规范","Java"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html",relativePath:"views/specification/提交规范.md",key:"v-1f63dd63",path:"/views/specification/%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html",headers:[{level:2,title:"提交规范的作用",slug:"提交规范的作用",normalizedTitle:"提交规范的作用",charIndex:3},{level:2,title:"提交规范",slug:"提交规范",normalizedTitle:"提交规范",charIndex:3},{level:2,title:"提交类别",slug:"提交类别",normalizedTitle:"提交类别",charIndex:22},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:30}],excerpt:"<Boxx/>\n",headersStr:"提交规范的作用 提交规范 提交类别 示例：",content:" * 提交规范的作用\n * 提交规范\n * 提交类别\n * 示例：\n\n\n\n\n# 提交规范的作用\n\n * 提供更多的信息，方便排查与回退\n * 过滤关键字，迅速定位\n * 方便生成文档\n\n\n# 提交规范\n\n规范版本记录提交信息，在提交信息中描述新特性、bug 修复和破坏性变更。\n\n提交 message 格式如下:\n\n&lt;类型>[可选的作用域]: &lt;描述>\n\n[可选的正文]\n\n[可选的脚注]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 提交类别\n\ncommit 的类型，包涵以下几种：\n\nCODE            INFO\nfeat: msg       新功能 feature\nfix: msg        修复 bug\nmerge: msg      merge\ndocs: msg       文档修改\nstyle: msg      更改了前端样式\njs: msg         更改了前端代码\nrefactor: msg   重构：即不是新增功能，也不是修改 bug 的代码变动\ntest: msg       增加测试\nchore: msg      构建过程或辅助工具的变动\nrm: msg         删除文件或代码\n\n\n# 示例：\n\nfeat($browser): onUrlChange event (popstate/hashchange/polling)\n\nAdded new event to $browser:\n- forward popstate event if available\n- forward hashchange event if popstate not available\n- do polling when neither popstate nor hashchange available\n\nBreaks $browser.onHashChange, which was removed (use onUrlChange instead)\n\n---------\n\nfix($compile): couple of unit tests for IE9\n\nOlder IEs serialize html uppercased, but IE9 does not...\nWould be better to expect case insensitive, unfortunately jasmine does\nnot allow to user regexps for throw expectations.\n\nCloses #392\nBreaks foo.bar api, foo.baz should be used instead\n\n---------\n\neat(directive): ng:disabled, ng:checked, ng:multiple, ng:readonly, ng:selected\n\nNew directives for proper binding these attributes in older browsers (IE).\nAdded coresponding description, live examples and e2e tests.\n\nCloses #351\n\n---------\n\nfeat($compile): simplify isolate scope bindings\n\nChanged the isolate scope binding options to:\n  - @attr - attribute binding (including interpolation)\n  - =model - by-directional model binding\n  - &expr - expression execution binding\n\nThis change simplifies the terminology as well as\nnumber of choices available to the developer. It\nalso supports local name aliasing from the parent.\n\nBREAKING CHANGE: isolate scope bindings definition has changed and\nthe inject option for the directive controller injection was removed.\n\nTo migrate the code follow the example below:\n\nBefore:\n\nscope: {\n  myAttr: 'attribute',\n  myBind: 'bind',\n  myExpression: 'expression',\n  myEval: 'evaluate',\n  myAccessor: 'accessor'\n}\n\nAfter:\n\nscope: {\n  myAttr: '@',\n  myBind: '@',\n  myExpression: '&',\n  // myEval - usually not useful, but in cases where the expression is assignable, you can use '='\n  myAccessor: '=' // in directive's template change myAccessor() to myAccessor\n}\n\nThe removed `inject` wasn't generaly useful for directives so there should be no code using it.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n当然，我们一般不用书写这么详细，在工作中简明扼要即可，如：\n\nfeat($theme-default): add code group and code block components\n\n\n1\n",normalizedContent:" * 提交规范的作用\n * 提交规范\n * 提交类别\n * 示例：\n\n\n\n\n# 提交规范的作用\n\n * 提供更多的信息，方便排查与回退\n * 过滤关键字，迅速定位\n * 方便生成文档\n\n\n# 提交规范\n\n规范版本记录提交信息，在提交信息中描述新特性、bug 修复和破坏性变更。\n\n提交 message 格式如下:\n\n&lt;类型>[可选的作用域]: &lt;描述>\n\n[可选的正文]\n\n[可选的脚注]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 提交类别\n\ncommit 的类型，包涵以下几种：\n\ncode            info\nfeat: msg       新功能 feature\nfix: msg        修复 bug\nmerge: msg      merge\ndocs: msg       文档修改\nstyle: msg      更改了前端样式\njs: msg         更改了前端代码\nrefactor: msg   重构：即不是新增功能，也不是修改 bug 的代码变动\ntest: msg       增加测试\nchore: msg      构建过程或辅助工具的变动\nrm: msg         删除文件或代码\n\n\n# 示例：\n\nfeat($browser): onurlchange event (popstate/hashchange/polling)\n\nadded new event to $browser:\n- forward popstate event if available\n- forward hashchange event if popstate not available\n- do polling when neither popstate nor hashchange available\n\nbreaks $browser.onhashchange, which was removed (use onurlchange instead)\n\n---------\n\nfix($compile): couple of unit tests for ie9\n\nolder ies serialize html uppercased, but ie9 does not...\nwould be better to expect case insensitive, unfortunately jasmine does\nnot allow to user regexps for throw expectations.\n\ncloses #392\nbreaks foo.bar api, foo.baz should be used instead\n\n---------\n\neat(directive): ng:disabled, ng:checked, ng:multiple, ng:readonly, ng:selected\n\nnew directives for proper binding these attributes in older browsers (ie).\nadded coresponding description, live examples and e2e tests.\n\ncloses #351\n\n---------\n\nfeat($compile): simplify isolate scope bindings\n\nchanged the isolate scope binding options to:\n  - @attr - attribute binding (including interpolation)\n  - =model - by-directional model binding\n  - &expr - expression execution binding\n\nthis change simplifies the terminology as well as\nnumber of choices available to the developer. it\nalso supports local name aliasing from the parent.\n\nbreaking change: isolate scope bindings definition has changed and\nthe inject option for the directive controller injection was removed.\n\nto migrate the code follow the example below:\n\nbefore:\n\nscope: {\n  myattr: 'attribute',\n  mybind: 'bind',\n  myexpression: 'expression',\n  myeval: 'evaluate',\n  myaccessor: 'accessor'\n}\n\nafter:\n\nscope: {\n  myattr: '@',\n  mybind: '@',\n  myexpression: '&',\n  // myeval - usually not useful, but in cases where the expression is assignable, you can use '='\n  myaccessor: '=' // in directive's template change myaccessor() to myaccessor\n}\n\nthe removed `inject` wasn't generaly useful for directives so there should be no code using it.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n当然，我们一般不用书写这么详细，在工作中简明扼要即可，如：\n\nfeat($theme-default): add code group and code block components\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"项目中的各种 O对象模型 到底是什么",frontmatter:{title:"项目中的各种 O对象模型 到底是什么",date:"2020-05-21T00:00:00.000Z",tags:["开发规范","Java"],categories:["规范 Standard"],isShowComments:!0},regularPath:"/views/specification/objectModel.html",relativePath:"views/specification/objectModel.md",key:"v-0008eb77",path:"/views/specification/objectModel.html",headers:[{level:2,title:"VO",slug:"vo",normalizedTitle:"vo",charIndex:9},{level:2,title:"DTO",slug:"dto",normalizedTitle:"dto",charIndex:39},{level:2,title:"PO",slug:"po",normalizedTitle:"po",charIndex:17},{level:2,title:"DAO",slug:"dao",normalizedTitle:"dao",charIndex:52},{level:2,title:"BO",slug:"bo",normalizedTitle:"bo",charIndex:21},{level:2,title:"规范",slug:"规范",normalizedTitle:"规范",charIndex:65}],excerpt:"<Boxx/>\n<p>简单介绍工作中各种VO, TO, PO, BO...</p>\n",headersStr:"VO DTO PO DAO BO 规范",content:"简单介绍工作中各种VO, TO, PO, BO...\n\n\n\n * VO\n * DTO\n * PO\n * DAO\n * BO\n * 规范\n\n\n\n\n# VO\n\nVO：值对象、视图对象\n\n项目中经常用到，主要对应界面显示的数据对象。\n\n在一个 web 页面中，一般用一个 VO 对象对应整个界面的值。\n\n\n# DTO\n\nDTO：Data Transfer Object 数据传输对象\n\n项目中较少用到，主要用于远程调用等需要大量传输对象的地方。\n\n比如我们一张表有 100 个字段，那么对应的 PO 就有 100 个属性。 但是我们界面上只要显示 10 个字段， 客户端用 webService 来获取数据，没有必要把整个 PO 对象传递到客户端， 这时我们就可以用只有这 10 个属性的 DTO 来传递结果到客户端，这样也不会暴露服务端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为 VO\n\n\n# PO\n\nPO：persistant object 持久对象\n\n项目中经常用到，可以看成是与数据库中的表相映射的 java 对象。\n\n最简单的 PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。PO 中应该不包含任何对数据库的操作。\n\n\n# DAO\n\nDAO：数据访问对象\n\n项目中经常用到，主要用来封装对数据库的访问。\n\n\n# BO\n\nBO：business object 业务对象\n\n项目中较少用到，封装业务逻辑的 java 对象，通过调用 DAO 方法，结合 PO，VO 进行业务操作。\n\n\n# 规范\n\n> 阿里巴巴 Java 开发手册中的 DO、DTO、BO、AO、VO、POJO 定义\n\n * 分层领域模型规约：\n\nDO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。\n\nDTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。\n\nBO（ Business Object）：业务对象。 由 Service 层输出的封装业务逻辑的对象。\n\nAO（ Application Object）：应用对象。 在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。\n\nVO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。\n\nPOJO（ Plain Ordinary Java Object）：在本手册中， POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。\n\nQuery：数据查询对象，各层接收上层的查询请求。 注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。\n\n * 领域模型命名规约：\n\n数据对象：xxxDO，xxx 即为数据表名。\n\n数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n\n展示对象：xxxVO，xxx 一般为网页名称。\n\nPOJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。",normalizedContent:"简单介绍工作中各种vo, to, po, bo...\n\n\n\n * vo\n * dto\n * po\n * dao\n * bo\n * 规范\n\n\n\n\n# vo\n\nvo：值对象、视图对象\n\n项目中经常用到，主要对应界面显示的数据对象。\n\n在一个 web 页面中，一般用一个 vo 对象对应整个界面的值。\n\n\n# dto\n\ndto：data transfer object 数据传输对象\n\n项目中较少用到，主要用于远程调用等需要大量传输对象的地方。\n\n比如我们一张表有 100 个字段，那么对应的 po 就有 100 个属性。 但是我们界面上只要显示 10 个字段， 客户端用 webservice 来获取数据，没有必要把整个 po 对象传递到客户端， 这时我们就可以用只有这 10 个属性的 dto 来传递结果到客户端，这样也不会暴露服务端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为 vo\n\n\n# po\n\npo：persistant object 持久对象\n\n项目中经常用到，可以看成是与数据库中的表相映射的 java 对象。\n\n最简单的 po 就是对应数据库中某个表中的一条记录，多个记录可以用 po 的集合。po 中应该不包含任何对数据库的操作。\n\n\n# dao\n\ndao：数据访问对象\n\n项目中经常用到，主要用来封装对数据库的访问。\n\n\n# bo\n\nbo：business object 业务对象\n\n项目中较少用到，封装业务逻辑的 java 对象，通过调用 dao 方法，结合 po，vo 进行业务操作。\n\n\n# 规范\n\n> 阿里巴巴 java 开发手册中的 do、dto、bo、ao、vo、pojo 定义\n\n * 分层领域模型规约：\n\ndo（ data object）：与数据库表结构一一对应，通过 dao 层向上传输数据源对象。\n\ndto（ data transfer object）：数据传输对象，service 或 manager 向外传输的对象。\n\nbo（ business object）：业务对象。 由 service 层输出的封装业务逻辑的对象。\n\nao（ application object）：应用对象。 在 web 层与 service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。\n\nvo（ view object）：显示层对象，通常是 web 向模板渲染引擎层传输的对象。\n\npojo（ plain ordinary java object）：在本手册中， pojo 专指只有 setter/getter/tostring 的简单类，包括 do/dto/bo/vo 等。\n\nquery：数据查询对象，各层接收上层的查询请求。 注意超过 2 个参数的查询封装，禁止使用 map 类来传输。\n\n * 领域模型命名规约：\n\n数据对象：xxxdo，xxx 即为数据表名。\n\n数据传输对象：xxxdto，xxx 为业务领域相关的名称。\n\n展示对象：xxxvo，xxx 一般为网页名称。\n\npojo 是 do/dto/bo/vo 的统称，禁止命名成 xxxpojo。",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"ECharts常用图表",frontmatter:{title:"ECharts常用图表",date:"2019-08-03T17:37:25.000Z",tags:["ECharts"],categories:["前端 Front-end"],isShowComments:!1},regularPath:"/views/frontend/EChartsStudy.html",relativePath:"views/frontend/EChartsStudy.md",key:"v-4789f531",path:"/views/frontend/EChartsStudy.html",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:3},{level:2,title:"常用网址",slug:"常用网址",normalizedTitle:"常用网址",charIndex:9},{level:2,title:"图表展示如下",slug:"图表展示如下",normalizedTitle:"图表展示如下",charIndex:17},{level:2,title:"使用服务端返回数据的异步加载和更新",slug:"使用服务端返回数据的异步加载和更新",normalizedTitle:"使用服务端返回数据的异步加载和更新",charIndex:27}],headersStr:"介绍 常用网址 图表展示如下 使用服务端返回数据的异步加载和更新",content:" * 介绍\n * 常用网址\n * 图表展示如下\n * 使用服务端返回数据的异步加载和更新\n\n\n\n\n# 介绍\n\n 1. 把常用的ECharts图表整理一下，方便日后的使用\n\n 2. 图表实例可见：http://zpj80231.gitee.io/echartsstudy/\n\n\n# 常用网址\n\n * 在ECharts官网运行编辑实例：\n   \n   * https://www.echartsjs.com/gallery/editor.html?c=doc-example/getting-started\n\n * EChartsoption中各参数详细配置项：\n   \n   * https://echarts.baidu.com/option.html#grid\n\n\n# 图表展示如下\n\n * 柱+折线图\n\n\n\n * 饼图\n\n\n\n * 迁徙图\n\n\n\n * 接入百度地图\n\n\n\n\n# 使用服务端返回数据的异步加载和更新\n\n详见官网：异步数据加载和更新\n\nfunction method(init的char,option参数,查询条件1,查询条件2,查询条件3){\n\t//ECharts 默认有提供了一个简单的加载动画。只需要调用 showLoading 方法显示。数据加载完成后再调用 hideLoading 方法隐藏加载动画。\n    chart.showLoading({\n\t\ttext: '加载中...'\n\t});\n    \n\t$.ajax({\n\t\ttype:\"POST\",\n\t\tdata:{\"查询条件1\":查询条件1,'查询条件2':查询条件2,'查询条件3':查询条件3},\n        url:\"/zhidinglianjie\",\n        success:function(data){\n           if(data){\n               \t/*注意填入数据的格式：\n               \tseries: [{\n                    // 根据名字对应到相应的系列\n                    name: '销量',\n                    data: [53, 25, 26, 20, 32, 25]\n        \t\t}]*/\n\t\t\t\toption.series[0].data =  data.data\n\t\t\t\toption.series[1].data = data.categories\n\t\t\t\tchart.setOption(option);\n           }else{\n                \n           }\n            //数据加载完成后再调用 hideLoading 方法隐藏加载动画。\n\t\t\tchart.hideLoading();\n        },\n        error:function(jqXHR){\n\t\t\tchart.hideLoading();\n        }\n\t});\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n",normalizedContent:" * 介绍\n * 常用网址\n * 图表展示如下\n * 使用服务端返回数据的异步加载和更新\n\n\n\n\n# 介绍\n\n 1. 把常用的echarts图表整理一下，方便日后的使用\n\n 2. 图表实例可见：http://zpj80231.gitee.io/echartsstudy/\n\n\n# 常用网址\n\n * 在echarts官网运行编辑实例：\n   \n   * https://www.echartsjs.com/gallery/editor.html?c=doc-example/getting-started\n\n * echartsoption中各参数详细配置项：\n   \n   * https://echarts.baidu.com/option.html#grid\n\n\n# 图表展示如下\n\n * 柱+折线图\n\n\n\n * 饼图\n\n\n\n * 迁徙图\n\n\n\n * 接入百度地图\n\n\n\n\n# 使用服务端返回数据的异步加载和更新\n\n详见官网：异步数据加载和更新\n\nfunction method(init的char,option参数,查询条件1,查询条件2,查询条件3){\n\t//echarts 默认有提供了一个简单的加载动画。只需要调用 showloading 方法显示。数据加载完成后再调用 hideloading 方法隐藏加载动画。\n    chart.showloading({\n\t\ttext: '加载中...'\n\t});\n    \n\t$.ajax({\n\t\ttype:\"post\",\n\t\tdata:{\"查询条件1\":查询条件1,'查询条件2':查询条件2,'查询条件3':查询条件3},\n        url:\"/zhidinglianjie\",\n        success:function(data){\n           if(data){\n               \t/*注意填入数据的格式：\n               \tseries: [{\n                    // 根据名字对应到相应的系列\n                    name: '销量',\n                    data: [53, 25, 26, 20, 32, 25]\n        \t\t}]*/\n\t\t\t\toption.series[0].data =  data.data\n\t\t\t\toption.series[1].data = data.categories\n\t\t\t\tchart.setoption(option);\n           }else{\n                \n           }\n            //数据加载完成后再调用 hideloading 方法隐藏加载动画。\n\t\t\tchart.hideloading();\n        },\n        error:function(jqxhr){\n\t\t\tchart.hideloading();\n        }\n\t});\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"Q&A宝典-前端进阶篇",frontmatter:{title:"Q&A宝典-前端进阶篇",date:"2019-05-24T00:00:00.000Z",tags:["复习"],categories:["知识晶体 Q&A"],isShowComments:!1},regularPath:"/views/qaq/sum_fe_002.html",relativePath:"views/qaq/sum_fe_002.md",key:"v-7d39c359",path:"/views/qaq/sum_fe_002.html",headers:[{level:2,title:"Servlet(单实例多线程)",slug:"servlet-单实例多线程",normalizedTitle:"servlet(单实例多线程)",charIndex:2},{level:2,title:"偏后端",slug:"偏后端",normalizedTitle:"偏后端",charIndex:1185}],headersStr:"Servlet(单实例多线程) 偏后端",content:'# Servlet(单实例多线程)\n\n1.Servlet的生命周期\n 1. 构造方法\n 2. 初始化方法init()\n 3. service方法(由容器帮我们调用,不建议重写)\n 4. doGet/doPost方法(需要我们来进行逻辑处理)\n 5. 销毁方法destory()\n\n2. Servlet的四个范围及其局限性\n\n> 因为可以通过这四个对象setAttribute()传值。\n\n 1. pageContext：第一范围,页面跳转立即失效\n 2. HttpServletRequest：第二范围,重定向失效\n 3. HttpSession：第三范围,默认有效期到或者浏览器关闭失效\n 4. ServletContext：第四范围,只要tomcat开着一直有效\n\n3. 两种跳转方式\n\n 1. 请求转发\n    跳转之后浏览器地址栏不发生改变；\n    跳转之前执行的是doGet/doPost，跳转之后还是执行的这个方法\n\n 2. 重定向\n    跳转之后浏览器地址栏发生改变；\n    跳转之后肯定执行doGet方法；\n    request第二范围失效(因为浏览器发送的不是同一个请求了)\n\n4. session保存信息及删除\n * 保存信息：\n   session.setAttribute("n",name);\n   String name = (String)sessin.getAttribute("n");\n * 删除信息：\n   session.removeAttribute("n");\n   session.invalidate()是把session内的所有属性都清除;\n\n5. Cookie HttpSession两种会话机制比较\n * Cookie:\n   浏览器提供的会话信息,安全性较低；\n   Cookie cookie = new Cookie(String,String)；\n   cookie仅支持字符串，默认不支持中文，是将信息保存到客户端本地\n * session:\n   服务器提供的会话信息，安全性较高；\n   session的信息当默认时间到期(期间没有任何操作!!)或者关闭浏览器或者调用invalidate() 之后失效\n\n> 不过现在一般都用基于客户端的JWT，轻便安全高效\n\n6. Cookie和Session之间有什么联系,如果有,请说出他们的联系\n 1. session默认依靠cookie维持，如果cookie被禁用，那么session会话机制失效\n 2. session是由servlet容器创建的\n    当用户getSession()时，web容器会先去cookie查找有没有这个session的id，如果没有，那么cookie就会分配一个就jsessionid并且保存在cookie中\n\n\n# 偏后端\n\n1. Servlet核心的API？\n\nJavax.servlet.Servlet\n\nJavax.servlet.ServletConfig\n\nJavax.servlet.http.HttpServlet\n\nHttpServletRequest，HttpServletResponse\n\n2. Servlet/jsp中的对象的创建、实现和调用？\n\n                创建者   实现者   调用者\nServlet         容器    我们    容器\nServletConfig   容器    容器    我们\nCookie          我们    容器    我们\nSession         容器    容器    我们',normalizedContent:'# servlet(单实例多线程)\n\n1.servlet的生命周期\n 1. 构造方法\n 2. 初始化方法init()\n 3. service方法(由容器帮我们调用,不建议重写)\n 4. doget/dopost方法(需要我们来进行逻辑处理)\n 5. 销毁方法destory()\n\n2. servlet的四个范围及其局限性\n\n> 因为可以通过这四个对象setattribute()传值。\n\n 1. pagecontext：第一范围,页面跳转立即失效\n 2. httpservletrequest：第二范围,重定向失效\n 3. httpsession：第三范围,默认有效期到或者浏览器关闭失效\n 4. servletcontext：第四范围,只要tomcat开着一直有效\n\n3. 两种跳转方式\n\n 1. 请求转发\n    跳转之后浏览器地址栏不发生改变；\n    跳转之前执行的是doget/dopost，跳转之后还是执行的这个方法\n\n 2. 重定向\n    跳转之后浏览器地址栏发生改变；\n    跳转之后肯定执行doget方法；\n    request第二范围失效(因为浏览器发送的不是同一个请求了)\n\n4. session保存信息及删除\n * 保存信息：\n   session.setattribute("n",name);\n   string name = (string)sessin.getattribute("n");\n * 删除信息：\n   session.removeattribute("n");\n   session.invalidate()是把session内的所有属性都清除;\n\n5. cookie httpsession两种会话机制比较\n * cookie:\n   浏览器提供的会话信息,安全性较低；\n   cookie cookie = new cookie(string,string)；\n   cookie仅支持字符串，默认不支持中文，是将信息保存到客户端本地\n * session:\n   服务器提供的会话信息，安全性较高；\n   session的信息当默认时间到期(期间没有任何操作!!)或者关闭浏览器或者调用invalidate() 之后失效\n\n> 不过现在一般都用基于客户端的jwt，轻便安全高效\n\n6. cookie和session之间有什么联系,如果有,请说出他们的联系\n 1. session默认依靠cookie维持，如果cookie被禁用，那么session会话机制失效\n 2. session是由servlet容器创建的\n    当用户getsession()时，web容器会先去cookie查找有没有这个session的id，如果没有，那么cookie就会分配一个就jsessionid并且保存在cookie中\n\n\n# 偏后端\n\n1. servlet核心的api？\n\njavax.servlet.servlet\n\njavax.servlet.servletconfig\n\njavax.servlet.http.httpservlet\n\nhttpservletrequest，httpservletresponse\n\n2. servlet/jsp中的对象的创建、实现和调用？\n\n                创建者   实现者   调用者\nservlet         容器    我们    容器\nservletconfig   容器    容器    我们\ncookie          我们    容器    我们\nsession         容器    容器    我们',charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{title:"中台",frontmatter:{title:"中台",date:"2021-12-16T00:00:00.000Z",tags:["随笔"],categories:["随笔 Essay"],isShowComments:!0},regularPath:"/views/essay/20211216.html",relativePath:"views/essay/20211216.md",key:"v-011bc3d7",path:"/views/essay/20211216.html",headers:[{level:2,title:"中台由来",slug:"中台由来",normalizedTitle:"中台由来",charIndex:208},{level:2,title:"聊聊架构",slug:"聊聊架构",normalizedTitle:"聊聊架构",charIndex:868},{level:2,title:"单体架构的时代",slug:"单体架构的时代",normalizedTitle:"单体架构的时代",charIndex:910},{level:2,title:"SOA(Service-Oriented Architecture)",slug:"soa-service-oriented-architecture",normalizedTitle:"soa(service-oriented architecture)",charIndex:1574},{level:2,title:"微服务架构",slug:"微服务架构",normalizedTitle:"微服务架构",charIndex:2606},{level:2,title:"服务共享",slug:"服务共享",normalizedTitle:"服务共享",charIndex:3068},{level:2,title:"服务拆分",slug:"服务拆分",normalizedTitle:"服务拆分",charIndex:3583},{level:2,title:"交易中台",slug:"交易中台",normalizedTitle:"交易中台",charIndex:108},{level:2,title:"金融中台",slug:"金融中台",normalizedTitle:"金融中台",charIndex:113},{level:2,title:"去中台化",slug:"去中台化",normalizedTitle:"去中台化",charIndex:6036}],excerpt:"<Boxx/>\n<p>今天给大家分享一下关于架构和中台的一些东西。</p>\n<p>主要会介绍一下中台的来源，这个大家可能都比较清楚，网上的文章和视频啊一大堆。</p>\n<p>还有就是关于架构的发展过程不得不在中间说明一下，由此引申出来中台的诞生。</p>\n<p>最后会就关于交易中台和金融中台做一个介绍，因为我最近两年在其他公司做的一个是交易中台，还有一个就是金融中台相关的业务。</p>\n",headersStr:"中台由来 聊聊架构 单体架构的时代 SOA(Service-Oriented Architecture) 微服务架构 服务共享 服务拆分 交易中台 金融中台 去中台化",content:"今天给大家分享一下关于架构和中台的一些东西。\n\n主要会介绍一下中台的来源，这个大家可能都比较清楚，网上的文章和视频啊一大堆。\n\n还有就是关于架构的发展过程不得不在中间说明一下，由此引申出来中台的诞生。\n\n最后会就关于交易中台和金融中台做一个介绍，因为我最近两年在其他公司做的一个是交易中台，还有一个就是金融中台相关的业务。\n\n> 公司内做的一个简单的分享，文章内容是我根据自己讲的还有录像又手撸了一遍，累。\n\n\n# 中台由来\n\n首先，来看一下中台的由来。\n\n中台的来源主要是阿里，他们在15年拜访在芬兰的一家游戏公司，也就是SuperCell。\n\n这家公司非常牛逼，号称是世界上最成功的的移动游戏公司，做出的游戏也非常有名，肯定很多人也玩过。\n\n比如部落战争、海岛奇兵等等。\n\n我也玩过一下他们的那个游戏，不过觉得没啥意思。\n\n这家公司的规模只有不到200人，公司的开发模式通常都会由2-7个人的小团队进行开发，这个在他们内部叫做cell，这也是他们公司名字的由来。\n\n开发过程通常是团队内部决定，然后用最快的时间开发出测试版本，如果受欢迎就继续干，否则的话就迅速放弃。\n\n产品失败之后，不光不会受到惩罚，他们还会搞个party来庆祝，庆祝自己学到了新的东西。\n\n不过我觉得挺奇葩的，要是都按照他们这个模式来，早期腾讯、阿里这些大公司都该死绝了。\n\n我们都知道，腾讯早期的时候想卖100万都没人要，马总实在没辙才只能硬着头皮继续做下去。\n\n但是，就是这样一家小公司，2015年的净利润达到了15亿美元，而且在2016年的时候被腾讯86亿美元收购。\n\n这些都不是重点哈，重点我们今天要讲的是他们的开发模式，为什么能快速开发一个新游戏出来？\n\n本来在我们想象中，开发一个新的游戏是一个很耗费时间精力的东西，几周开发一个还不错的游戏应该是很有难度的事情。\n\n重点就在于他们的”中台“，也是他们多年游戏沉淀下来的东西。\n\n他们在前面的很多年时间里对通用的游戏素材、算法等等做了很多沉淀。\n\n这也就是后面马云回来阿里之后大力搞的中台了。\n\n\n# 聊聊架构\n\n讲完中台的来历，在将中台之前，我们还是要先说说架构的发展过程。\n\n\n# 单体架构的时代\n\n在我刚刚上班的时候，大概是11年、12年基本上我接触到的项目都是这个样子。\n\n一个团队的所有东西都在一块，什么用户注册登录、支付啊、订单都在一起，经常是改一个小东西一个大项目都要跟着发布。\n\n一般单体的架构都是单进程的，这也是针对我们现在的微服务来说的，就是打个jar包或者war包上传就完事儿了，所有模块都在一个进程里，如果要升级或者重启，那整个应用服务都要重启。\n\n当然了，简单的项目划分模块分层还是有的，比如我们那时候常用的MVC模式。\n\n\n\n简单是很简单，但是同样缺点也是很明显的。\n\n第一点就是团队协同合作的成本高，如果说小公司没几个人还好，一旦业务快速发展起来，代码量感人，刚开始上班那会儿我的电脑经常就只能跑的动一个项目，不过好像也没有别的项目了。\n\n经常改一个简单的东西可能到处是冲突，更不要说一个大服务的发版问题。\n\n第二点，项目太复杂了，什么东西都是大杂烩，全在里面。\n\n第三点，数据库连接的问题，一个服务太大了，就一个数据库的集群，业务越来越多，服务器越来越多，到后面单机可能只搞个个位数的连接都要不够用了。\n\n所以，一般伴随拆分服务，数据库也会做拆分，独立的服务拥有独立的数据库。\n\n最后一点，拓展性的问题，所有的功能都在一个服务里，可能实际情况是某几个功能模块负载非常高，比如订单或者库存的服务，频繁的读写，这时候想要扩展很难搞。\n\n更严重的问题就是，如果一个模块出了问题，整个应用都不能用了。\n\n这时候没有办法了，只能拆分。\n\n因此就到了我们第二个架构模式，SOA的时代。\n\n\n# SOA(Service-Oriented Architecture)\n\n我在饿了么工作那会儿，里面就有一大堆的SOA的称呼，并且一直都是。\n\nSOA是什么意思呢，全名是这个Service-Oriented Architecture，意思就是面向服务的架构，基本上和我们现在的微服务差不多一样。\n\nSOA的核心在于：松耦合和服务重用，当单体架构出现瓶颈的时候，首先想到的都是拆，SOA时代的话，其实也已经就有了服务注册发现、服务治理这些概念了，和微服务可以说从认知上没有任何区别。\n\nSOA其实有两种模式，一种是中心化，一种是去中心化，下图中表示的就是中心化的服务调用方式。\n\n\n\n服务调用之间都通过ESB服务总线，调用方之间屏蔽了接口的修改，ESB要做服务请求路由、数据格式转换，各种HTTP SOCKET适配和接入，所有脏活累活都归他干了。\n\n这样很明显的看出来问题了。\n\n第一个就是请求，同样的请求次数是通常去中心化的2倍，本来A调用B，现在要通过ESB。\n\n第二个是肉眼可见的问题，这个ESB的压力会非常大，可以通过集群解决，但是ESB的性能瓶颈会导致所有服务的瓶颈。\n\n但是，这个模式在当初非常受欢迎，主要原因是什么呢？\n\n就是烟囱式架构引发出来的问题。\n\n烟囱式架构是什么？\n\n\n\n就像这张图描述的，你有好几个业务，因为时间或者说团队、公司各种原因，搞成了好几套独立的服务，开发和运维都没啥关系，大多数公司之前的发展过程中都会存在这样的问题。\n\n比如我之前的公司先做酒店业务、然后又有外卖、还有餐饮店、还要卖咖啡。\n\n如果说来一个业务就重头搞一套用户体系、订单体系、库存体系，最终的结果就是像矗立起来的一个个烟囱，也就是烟囱式架构。\n\n烟囱的现象很普遍，大家各玩各的，先把业务跑起来再说，但是缺陷有很多。\n\n首先，重复建设开发，不用说都能看出来，每次重头搞一套，不说开发成本，就说服务器和运维成本都够头疼的。\n\n第二点，就是系统之间交互协作成本直线上升，业务发展了，可能要做一些精确营销活动，设计用户画像，对数据分析之类的啦，这都很正常。\n\n哦豁，这时候你发现用户在好几个系统里，这个交互打通的成本就太高了。\n\n要做个数据统计，还要调好几个系统接口，可能数据结构还不一样，搞都搞死你。\n\n还有就是业务沉淀和发展，这也是后面要说的中台了。\n\n难道这些系统之间就没有通用的能抽象的能力可以共用吗？\n\n这也就是中台的发展的方向，抽象、沉淀和共用。\n\n\n\n\n# 微服务架构\n\n最后就是说到我们的微服务时代了，这个大家都很熟悉，不需要说太多东西。\n\n至于现在还有Serverless、云原生什么低代码这里就不展开了，等后面的话有机会再说。\n\n回到微服务的话题，微服务和SOA有什么区别。\n\n个人认为其实很接近，微服务就是更加自由和更细粒度的SOA。\n\n微服务没有那么多框架约束，我们想用啥用啥，虽然在SOA也可以实现，比如通信我们可以用Dubbo，可以用Feign，Thrift，GRPC，想用啥用啥。\n\n举个例子用 spring cloud 来说，eureka可以帮我们做服务注册和发现，打个@enableEurekaClient就可以成为客户端连接到Eureka了。\n\n路由直接用zuul，限流熔断用hystrix，负载均衡用ribbon，远程调用用feign。\n\n非常方便，当然还可以选择用Spring Cloud Alibaba，这个我认为可能会是将来一段时间的趋势，更新维护的非常勤快。\n\nDubbo Nacos Sentinel这一套整起来明显更符合国内的使用习惯。\n\n\n# 服务共享\n\n说完架构的发展，可以回到我们之前的中台话题。\n\n那其实中台的作用已经不言而喻了，就是共享。\n\n以现在比较主流的一些电商来说，几个共享服务中心的划分。\n\n\n\n首先用户中心必不可少，用户是基础服务，用户中心集成用户通用的能力，包括注册登录，SSO单点登录，还要和大数据配合用户打标签，用户画像等。\n\n营销中心这个也很重要，包含各种优惠活动、优惠券、红包、卡券、积分、会员等级、返佣之类的和营销相关的东西。\n\n交易中心处理用户下订单，如果下单有返佣，积分之类的话，这个叫做履约，后面再说，关于交易中台是我后面要说的。\n\n支付中心负责支付，退款，三方支付、银行对接、预算管控等等。\n\n数据中心，这个其实和业务中台是两块方向，今天我要说的都是业务中台，针对业务系统的沉淀和共享，数据中台则是更偏向大数据方向的，不在这里赘述。\n\n最底层服务是我们的基础设施和中间件的能力，比如数据库、消息服务Kafka、Rabbitmq、数仓、文件系统。\n\n这张图画出来好像除了中台和前台没别的东西了，并不是这样，我只是想表达说共享服务是作为支撑上层业务的核心，下层还有后台的服务并没有画出来而已，也就是顺应着大中台、小前台的架构来说。\n\n\n# 服务拆分\n\n讲到这个服务抽象和共享就顺便说说服务拆分的原则，这个说法太多了，见仁见智，更多的是遵循原有的一些经验去做处理。\n\n总的来说，现在我们主流的拆分都是根据业务角度去拆分。\n\n高内聚、低耦合，这个没啥说的，所有的服务都应该遵循这个原则，否则你要拆那就是瞎几把拆。\n\n高内聚说的是比如交易中台，只围绕交易相关的、依赖性非常高的进行拆分。\n\n低耦合则是说不同的服务，业务之间要隔离，不要耦合在一起，但是这个得有过程。\n\n举个例子来说一开始的业务没什么人，用户地址这些信息就放在用户的服务里，好像也没什么问题。\n\n随着业务的发展，这个地址信息和物流的服务好像关联越来越大，是不是就可以拆到物流服务里。\n\n所以，这个要用发展的眼光去看待问题，不能一刀切。\n\n回头去个小公司，别人就几万用户，几个程序员，就一个服务，你非要干微服务，拆几十个服务出来，这就不对是不是。\n\n数据完整性\n\n其实也类似，业务相关数据一定要完整，比如你做拆分，拆分完了之后用户名字拆到别的系统里去了，那就不太合理了。\n\n持续迭代\n\n也就是说要可持续性地做架构升级的调整和拆分，这个还是要跟着业务的发展走，不能一下拆的太细，也不能一下子太粗。。\n\n你能明白我的意思吧，我没有在开车。。\n\n\n# 交易中台\n\n说了好久，总算说到交易中台了，我之前干交易中台干了差不多两年时间，自认为还算比较了解，除了一些东西没有实现之外，由于公司发展和时间的关系。\n\n交易中台上面也提到过，主要就是从用户看到商品，然后到订单确认页，最后下订单，支付，配送，签收，这样一个整个过程都是交易中台在做的事情。\n\n交易的定义就是买卖双方对有价物品和服务进行互通有无的行为，可以是以货币为交易媒介的过程，也可以是以物易物。\n\n而交易过程，现在一般都是分为订约和履约两个，这基本是所有的交易中台的规则了。\n\n某某在什么时间做了什么事情，这是订约。\n\n举个例子来说，买方给卖方提供了有价物品，比如钱，卖方需要给买方提供服务。\n\n而履约的则是某某在约定的时间完成约定的事情，比如交付货币、物品或者服务。\n\n整个流程大致就是这个样子，当然一般我们都会分为正向和逆向两个方向去处理，正向完成交易的过程，逆向你可以理解为取消、退款这个环节。\n\n\n\n既然是中台，那么就要能适应各类的交易场景。\n\n比如酒店行业你去预订房间，这是正向交易，最后你去入住、离店，这是你履约的过程。\n\n供应链要采购，然后商家会发货，最后你签收，这也是订约和履约的过程。\n\n点外卖也是同样的道理。\n\n这些所有的场景，那么我们都可以用通用的流程来归纳起来，就是上面提到的通用的交易流程。\n\n\n\n抽象的概念说完了，需要再形象一点的来描述一下。\n\n上面我们说到了一些现在比较常见的服务拆分和服务的划分，下面根据实际场景看看我们服务到底是怎么划分的。\n\n这张图是美团的订单确认页，一般也叫做提单页。图太长，我拆分为3个小图来描述。\n\n可以一起来分析一下这个页面应该由哪些服务来构成，由谁来聚合这么多服务的接口？\n\n\n\n首先地址信息上面也提到过了， 这个由用户服务或者说是物流服务来提供比较合适。\n\n那配送时间这方面就应该由物流的算法来提供，他们会根据运力、天气、骑手一堆信息来计算一个比较合理的送达时间。\n\n\n\n中间这一部分商品的详细信息肯定由商品服务来提供。\n\n至于配送费啊、各种补贴、红包优惠券是不是该由营销来提供，这里其实会很复杂， 因为要计算各种条件的价格，计算出最终应该支付的金额，这个一般我们会由价格服务来输出。\n\n\n\n最下面这一部分叫做搭售，可以在下单的同时去购买会员，这个其实就相当于下了两个订单，一单是外卖单，另外一个订单就是搭售订单，购买会员的订单，最终两个订单合并支付，保持最终一致性就行了，下单成功，同时会员购买成功。\n\n最终下单成功之后发送消息，物流团队根据消息去履约配送，营销根据下单消息该送积分、送红包就怎么送，另外如果有搭售会员的话，还需要进行会员升级，这也是属于履约的一部分。\n\n这个地方还有两个挺有意思的点。\n\n第一个是扣库存的问题，应该是下单成功扣库存，还是支付成功扣库存（不用太考虑保存订单和扣库存分布式事务的问题，这个会保证最终一致性）。\n\n一般所有的业务都会下单就扣库存，但是这样会有一个问题。\n\n之前我们做活动，会把很多房间拿出来做优惠活动，单价就会便宜，但是库存有限，这个叫做尾房甩卖。\n\n很多黄牛就先去下单把库存占住，然后再卖给用户，马上取消订单，帮用户下单。\n\n所以我们之前有两种模式，针对这种类型的特殊情况会支付成功后才扣库存，普通模式像电商外卖一般没这种问题，都是下单就扣。\n\n还有一个就是这个券的问题，不知道大家发现了没有，买了会员送券，可以立刻使用，下面还标注了，本单可用。\n\n你肯定能想到这个问题，一般我们是券发给用户了才能用，这里下单成功后发消息->履约->发券，这个券都还没有怎么提前用。\n\n这又是一个交易系统里比较常见的，早两年应该是没有这个玩法的，也算是一个优化，一般会叫做虚拟券。\n\n下单的时候去核销优惠券，一般会给营销传一个特殊的标记和参数，营销根据这个判断做特殊的处理，至于具体的逻辑，我也不是很清楚，搞的挺复杂的就是了。\n\n再结合全景图看一下就清晰了和架构图看一下就清晰多了。\n\n\n\n\n# 金融中台\n\n金融中台不够纯粹，与其说是中台，不如说是事业部更合适一点，一般现在国内很多公司的金融中台基本都逃脱不了这几块的内容，很多都非常类似，就是根据不同的业务有点出入而已。\n\n\n\n支付是整个金融中台的核心，跳转的统一收银台又是支付的核心。\n\n清结算也很核心，非常重要，这个我也干过一段时间，预算，活动、券这是营销的角度，预算则是财务金融的角度。\n\n一般创建活动的时候一定要申请预算，活动创建设置库存数量，同时申请财务预算，一般情况都是1：1，创建成功不可以修改，库存可以临时改，但是预算改不了，除非重新申请。\n\n金融中台自己领会好吧。\n\n\n# 去中台化\n\n这一段我不能放，涉及到一些公司隐私的东西，但是可以聊聊其他的。\n\n比如开发流程，就我经历过的，中台这种部门一旦起来了，很容易一家独大，话语权太强，并且对于稳定性的要求太高，一定程度上阻碍了业务的开发。\n\n其次对于业务的支撑和快速发展，其实可能没有想象中的那么好，经历过的大家应该也都会有体会的。\n\n再者，中台这种产品必然涉及了太多的政治层面的博弈，我觉得SuperCell那种小公司玩得转确实可以，但是体量太大的公司玩的好挺难的，那体量不大的公司又没有太大必要搞什么鬼中台，你又不是啥游戏公司对不对，毕竟还是互联网公司为主，做业务开发为主。\n\n好了，言尽于此吧，文章来源于艾小仙。\n\nhttps://juejin.cn/post/7028151090654904333",normalizedContent:"今天给大家分享一下关于架构和中台的一些东西。\n\n主要会介绍一下中台的来源，这个大家可能都比较清楚，网上的文章和视频啊一大堆。\n\n还有就是关于架构的发展过程不得不在中间说明一下，由此引申出来中台的诞生。\n\n最后会就关于交易中台和金融中台做一个介绍，因为我最近两年在其他公司做的一个是交易中台，还有一个就是金融中台相关的业务。\n\n> 公司内做的一个简单的分享，文章内容是我根据自己讲的还有录像又手撸了一遍，累。\n\n\n# 中台由来\n\n首先，来看一下中台的由来。\n\n中台的来源主要是阿里，他们在15年拜访在芬兰的一家游戏公司，也就是supercell。\n\n这家公司非常牛逼，号称是世界上最成功的的移动游戏公司，做出的游戏也非常有名，肯定很多人也玩过。\n\n比如部落战争、海岛奇兵等等。\n\n我也玩过一下他们的那个游戏，不过觉得没啥意思。\n\n这家公司的规模只有不到200人，公司的开发模式通常都会由2-7个人的小团队进行开发，这个在他们内部叫做cell，这也是他们公司名字的由来。\n\n开发过程通常是团队内部决定，然后用最快的时间开发出测试版本，如果受欢迎就继续干，否则的话就迅速放弃。\n\n产品失败之后，不光不会受到惩罚，他们还会搞个party来庆祝，庆祝自己学到了新的东西。\n\n不过我觉得挺奇葩的，要是都按照他们这个模式来，早期腾讯、阿里这些大公司都该死绝了。\n\n我们都知道，腾讯早期的时候想卖100万都没人要，马总实在没辙才只能硬着头皮继续做下去。\n\n但是，就是这样一家小公司，2015年的净利润达到了15亿美元，而且在2016年的时候被腾讯86亿美元收购。\n\n这些都不是重点哈，重点我们今天要讲的是他们的开发模式，为什么能快速开发一个新游戏出来？\n\n本来在我们想象中，开发一个新的游戏是一个很耗费时间精力的东西，几周开发一个还不错的游戏应该是很有难度的事情。\n\n重点就在于他们的”中台“，也是他们多年游戏沉淀下来的东西。\n\n他们在前面的很多年时间里对通用的游戏素材、算法等等做了很多沉淀。\n\n这也就是后面马云回来阿里之后大力搞的中台了。\n\n\n# 聊聊架构\n\n讲完中台的来历，在将中台之前，我们还是要先说说架构的发展过程。\n\n\n# 单体架构的时代\n\n在我刚刚上班的时候，大概是11年、12年基本上我接触到的项目都是这个样子。\n\n一个团队的所有东西都在一块，什么用户注册登录、支付啊、订单都在一起，经常是改一个小东西一个大项目都要跟着发布。\n\n一般单体的架构都是单进程的，这也是针对我们现在的微服务来说的，就是打个jar包或者war包上传就完事儿了，所有模块都在一个进程里，如果要升级或者重启，那整个应用服务都要重启。\n\n当然了，简单的项目划分模块分层还是有的，比如我们那时候常用的mvc模式。\n\n\n\n简单是很简单，但是同样缺点也是很明显的。\n\n第一点就是团队协同合作的成本高，如果说小公司没几个人还好，一旦业务快速发展起来，代码量感人，刚开始上班那会儿我的电脑经常就只能跑的动一个项目，不过好像也没有别的项目了。\n\n经常改一个简单的东西可能到处是冲突，更不要说一个大服务的发版问题。\n\n第二点，项目太复杂了，什么东西都是大杂烩，全在里面。\n\n第三点，数据库连接的问题，一个服务太大了，就一个数据库的集群，业务越来越多，服务器越来越多，到后面单机可能只搞个个位数的连接都要不够用了。\n\n所以，一般伴随拆分服务，数据库也会做拆分，独立的服务拥有独立的数据库。\n\n最后一点，拓展性的问题，所有的功能都在一个服务里，可能实际情况是某几个功能模块负载非常高，比如订单或者库存的服务，频繁的读写，这时候想要扩展很难搞。\n\n更严重的问题就是，如果一个模块出了问题，整个应用都不能用了。\n\n这时候没有办法了，只能拆分。\n\n因此就到了我们第二个架构模式，soa的时代。\n\n\n# soa(service-oriented architecture)\n\n我在饿了么工作那会儿，里面就有一大堆的soa的称呼，并且一直都是。\n\nsoa是什么意思呢，全名是这个service-oriented architecture，意思就是面向服务的架构，基本上和我们现在的微服务差不多一样。\n\nsoa的核心在于：松耦合和服务重用，当单体架构出现瓶颈的时候，首先想到的都是拆，soa时代的话，其实也已经就有了服务注册发现、服务治理这些概念了，和微服务可以说从认知上没有任何区别。\n\nsoa其实有两种模式，一种是中心化，一种是去中心化，下图中表示的就是中心化的服务调用方式。\n\n\n\n服务调用之间都通过esb服务总线，调用方之间屏蔽了接口的修改，esb要做服务请求路由、数据格式转换，各种http socket适配和接入，所有脏活累活都归他干了。\n\n这样很明显的看出来问题了。\n\n第一个就是请求，同样的请求次数是通常去中心化的2倍，本来a调用b，现在要通过esb。\n\n第二个是肉眼可见的问题，这个esb的压力会非常大，可以通过集群解决，但是esb的性能瓶颈会导致所有服务的瓶颈。\n\n但是，这个模式在当初非常受欢迎，主要原因是什么呢？\n\n就是烟囱式架构引发出来的问题。\n\n烟囱式架构是什么？\n\n\n\n就像这张图描述的，你有好几个业务，因为时间或者说团队、公司各种原因，搞成了好几套独立的服务，开发和运维都没啥关系，大多数公司之前的发展过程中都会存在这样的问题。\n\n比如我之前的公司先做酒店业务、然后又有外卖、还有餐饮店、还要卖咖啡。\n\n如果说来一个业务就重头搞一套用户体系、订单体系、库存体系，最终的结果就是像矗立起来的一个个烟囱，也就是烟囱式架构。\n\n烟囱的现象很普遍，大家各玩各的，先把业务跑起来再说，但是缺陷有很多。\n\n首先，重复建设开发，不用说都能看出来，每次重头搞一套，不说开发成本，就说服务器和运维成本都够头疼的。\n\n第二点，就是系统之间交互协作成本直线上升，业务发展了，可能要做一些精确营销活动，设计用户画像，对数据分析之类的啦，这都很正常。\n\n哦豁，这时候你发现用户在好几个系统里，这个交互打通的成本就太高了。\n\n要做个数据统计，还要调好几个系统接口，可能数据结构还不一样，搞都搞死你。\n\n还有就是业务沉淀和发展，这也是后面要说的中台了。\n\n难道这些系统之间就没有通用的能抽象的能力可以共用吗？\n\n这也就是中台的发展的方向，抽象、沉淀和共用。\n\n\n\n\n# 微服务架构\n\n最后就是说到我们的微服务时代了，这个大家都很熟悉，不需要说太多东西。\n\n至于现在还有serverless、云原生什么低代码这里就不展开了，等后面的话有机会再说。\n\n回到微服务的话题，微服务和soa有什么区别。\n\n个人认为其实很接近，微服务就是更加自由和更细粒度的soa。\n\n微服务没有那么多框架约束，我们想用啥用啥，虽然在soa也可以实现，比如通信我们可以用dubbo，可以用feign，thrift，grpc，想用啥用啥。\n\n举个例子用 spring cloud 来说，eureka可以帮我们做服务注册和发现，打个@enableeurekaclient就可以成为客户端连接到eureka了。\n\n路由直接用zuul，限流熔断用hystrix，负载均衡用ribbon，远程调用用feign。\n\n非常方便，当然还可以选择用spring cloud alibaba，这个我认为可能会是将来一段时间的趋势，更新维护的非常勤快。\n\ndubbo nacos sentinel这一套整起来明显更符合国内的使用习惯。\n\n\n# 服务共享\n\n说完架构的发展，可以回到我们之前的中台话题。\n\n那其实中台的作用已经不言而喻了，就是共享。\n\n以现在比较主流的一些电商来说，几个共享服务中心的划分。\n\n\n\n首先用户中心必不可少，用户是基础服务，用户中心集成用户通用的能力，包括注册登录，sso单点登录，还要和大数据配合用户打标签，用户画像等。\n\n营销中心这个也很重要，包含各种优惠活动、优惠券、红包、卡券、积分、会员等级、返佣之类的和营销相关的东西。\n\n交易中心处理用户下订单，如果下单有返佣，积分之类的话，这个叫做履约，后面再说，关于交易中台是我后面要说的。\n\n支付中心负责支付，退款，三方支付、银行对接、预算管控等等。\n\n数据中心，这个其实和业务中台是两块方向，今天我要说的都是业务中台，针对业务系统的沉淀和共享，数据中台则是更偏向大数据方向的，不在这里赘述。\n\n最底层服务是我们的基础设施和中间件的能力，比如数据库、消息服务kafka、rabbitmq、数仓、文件系统。\n\n这张图画出来好像除了中台和前台没别的东西了，并不是这样，我只是想表达说共享服务是作为支撑上层业务的核心，下层还有后台的服务并没有画出来而已，也就是顺应着大中台、小前台的架构来说。\n\n\n# 服务拆分\n\n讲到这个服务抽象和共享就顺便说说服务拆分的原则，这个说法太多了，见仁见智，更多的是遵循原有的一些经验去做处理。\n\n总的来说，现在我们主流的拆分都是根据业务角度去拆分。\n\n高内聚、低耦合，这个没啥说的，所有的服务都应该遵循这个原则，否则你要拆那就是瞎几把拆。\n\n高内聚说的是比如交易中台，只围绕交易相关的、依赖性非常高的进行拆分。\n\n低耦合则是说不同的服务，业务之间要隔离，不要耦合在一起，但是这个得有过程。\n\n举个例子来说一开始的业务没什么人，用户地址这些信息就放在用户的服务里，好像也没什么问题。\n\n随着业务的发展，这个地址信息和物流的服务好像关联越来越大，是不是就可以拆到物流服务里。\n\n所以，这个要用发展的眼光去看待问题，不能一刀切。\n\n回头去个小公司，别人就几万用户，几个程序员，就一个服务，你非要干微服务，拆几十个服务出来，这就不对是不是。\n\n数据完整性\n\n其实也类似，业务相关数据一定要完整，比如你做拆分，拆分完了之后用户名字拆到别的系统里去了，那就不太合理了。\n\n持续迭代\n\n也就是说要可持续性地做架构升级的调整和拆分，这个还是要跟着业务的发展走，不能一下拆的太细，也不能一下子太粗。。\n\n你能明白我的意思吧，我没有在开车。。\n\n\n# 交易中台\n\n说了好久，总算说到交易中台了，我之前干交易中台干了差不多两年时间，自认为还算比较了解，除了一些东西没有实现之外，由于公司发展和时间的关系。\n\n交易中台上面也提到过，主要就是从用户看到商品，然后到订单确认页，最后下订单，支付，配送，签收，这样一个整个过程都是交易中台在做的事情。\n\n交易的定义就是买卖双方对有价物品和服务进行互通有无的行为，可以是以货币为交易媒介的过程，也可以是以物易物。\n\n而交易过程，现在一般都是分为订约和履约两个，这基本是所有的交易中台的规则了。\n\n某某在什么时间做了什么事情，这是订约。\n\n举个例子来说，买方给卖方提供了有价物品，比如钱，卖方需要给买方提供服务。\n\n而履约的则是某某在约定的时间完成约定的事情，比如交付货币、物品或者服务。\n\n整个流程大致就是这个样子，当然一般我们都会分为正向和逆向两个方向去处理，正向完成交易的过程，逆向你可以理解为取消、退款这个环节。\n\n\n\n既然是中台，那么就要能适应各类的交易场景。\n\n比如酒店行业你去预订房间，这是正向交易，最后你去入住、离店，这是你履约的过程。\n\n供应链要采购，然后商家会发货，最后你签收，这也是订约和履约的过程。\n\n点外卖也是同样的道理。\n\n这些所有的场景，那么我们都可以用通用的流程来归纳起来，就是上面提到的通用的交易流程。\n\n\n\n抽象的概念说完了，需要再形象一点的来描述一下。\n\n上面我们说到了一些现在比较常见的服务拆分和服务的划分，下面根据实际场景看看我们服务到底是怎么划分的。\n\n这张图是美团的订单确认页，一般也叫做提单页。图太长，我拆分为3个小图来描述。\n\n可以一起来分析一下这个页面应该由哪些服务来构成，由谁来聚合这么多服务的接口？\n\n\n\n首先地址信息上面也提到过了， 这个由用户服务或者说是物流服务来提供比较合适。\n\n那配送时间这方面就应该由物流的算法来提供，他们会根据运力、天气、骑手一堆信息来计算一个比较合理的送达时间。\n\n\n\n中间这一部分商品的详细信息肯定由商品服务来提供。\n\n至于配送费啊、各种补贴、红包优惠券是不是该由营销来提供，这里其实会很复杂， 因为要计算各种条件的价格，计算出最终应该支付的金额，这个一般我们会由价格服务来输出。\n\n\n\n最下面这一部分叫做搭售，可以在下单的同时去购买会员，这个其实就相当于下了两个订单，一单是外卖单，另外一个订单就是搭售订单，购买会员的订单，最终两个订单合并支付，保持最终一致性就行了，下单成功，同时会员购买成功。\n\n最终下单成功之后发送消息，物流团队根据消息去履约配送，营销根据下单消息该送积分、送红包就怎么送，另外如果有搭售会员的话，还需要进行会员升级，这也是属于履约的一部分。\n\n这个地方还有两个挺有意思的点。\n\n第一个是扣库存的问题，应该是下单成功扣库存，还是支付成功扣库存（不用太考虑保存订单和扣库存分布式事务的问题，这个会保证最终一致性）。\n\n一般所有的业务都会下单就扣库存，但是这样会有一个问题。\n\n之前我们做活动，会把很多房间拿出来做优惠活动，单价就会便宜，但是库存有限，这个叫做尾房甩卖。\n\n很多黄牛就先去下单把库存占住，然后再卖给用户，马上取消订单，帮用户下单。\n\n所以我们之前有两种模式，针对这种类型的特殊情况会支付成功后才扣库存，普通模式像电商外卖一般没这种问题，都是下单就扣。\n\n还有一个就是这个券的问题，不知道大家发现了没有，买了会员送券，可以立刻使用，下面还标注了，本单可用。\n\n你肯定能想到这个问题，一般我们是券发给用户了才能用，这里下单成功后发消息->履约->发券，这个券都还没有怎么提前用。\n\n这又是一个交易系统里比较常见的，早两年应该是没有这个玩法的，也算是一个优化，一般会叫做虚拟券。\n\n下单的时候去核销优惠券，一般会给营销传一个特殊的标记和参数，营销根据这个判断做特殊的处理，至于具体的逻辑，我也不是很清楚，搞的挺复杂的就是了。\n\n再结合全景图看一下就清晰了和架构图看一下就清晰多了。\n\n\n\n\n# 金融中台\n\n金融中台不够纯粹，与其说是中台，不如说是事业部更合适一点，一般现在国内很多公司的金融中台基本都逃脱不了这几块的内容，很多都非常类似，就是根据不同的业务有点出入而已。\n\n\n\n支付是整个金融中台的核心，跳转的统一收银台又是支付的核心。\n\n清结算也很核心，非常重要，这个我也干过一段时间，预算，活动、券这是营销的角度，预算则是财务金融的角度。\n\n一般创建活动的时候一定要申请预算，活动创建设置库存数量，同时申请财务预算，一般情况都是1：1，创建成功不可以修改，库存可以临时改，但是预算改不了，除非重新申请。\n\n金融中台自己领会好吧。\n\n\n# 去中台化\n\n这一段我不能放，涉及到一些公司隐私的东西，但是可以聊聊其他的。\n\n比如开发流程，就我经历过的，中台这种部门一旦起来了，很容易一家独大，话语权太强，并且对于稳定性的要求太高，一定程度上阻碍了业务的开发。\n\n其次对于业务的支撑和快速发展，其实可能没有想象中的那么好，经历过的大家应该也都会有体会的。\n\n再者，中台这种产品必然涉及了太多的政治层面的博弈，我觉得supercell那种小公司玩得转确实可以，但是体量太大的公司玩的好挺难的，那体量不大的公司又没有太大必要搞什么鬼中台，你又不是啥游戏公司对不对，毕竟还是互联网公司为主，做业务开发为主。\n\n好了，言尽于此吧，文章来源于艾小仙。\n\nhttps://juejin.cn/post/7028151090654904333",charsets:{cjk:!0},lastUpdated:"2023/08/08, 19:24:46",lastUpdatedTimestamp:1691493886e3},{frontmatter:{layout:"Tags",title:"Tags"},regularPath:"/tag/",key:"v-b1564aac",path:"/tag/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"FrontmatterKey",title:"Categories"},regularPath:"/categories/",key:"v-ef9325c4",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"TimeLines",title:"Timeline"},regularPath:"/timeline/",key:"v-6319eb4e",path:"/timeline/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"源码分析 Tags"},regularPath:"/tag/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/",key:"v-70487ef8",path:"/tag/源码分析/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Java Tags"},regularPath:"/tag/Java/",key:"v-18082c7a",path:"/tag/Java/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"多线程 Tags"},regularPath:"/tag/%E5%A4%9A%E7%BA%BF%E7%A8%8B/",key:"v-75682621",path:"/tag/多线程/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"poi Tags"},regularPath:"/tag/poi/",key:"v-322fe662",path:"/tag/poi/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"分布式 Tags"},regularPath:"/tag/%E5%88%86%E5%B8%83%E5%BC%8F/",key:"v-08174efe",path:"/tag/分布式/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"SPI Tags"},regularPath:"/tag/SPI/",key:"v-324b3466",path:"/tag/SPI/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"定时任务 Tags"},regularPath:"/tag/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/",key:"v-63814eec",path:"/tag/定时任务/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"网关 Tags"},regularPath:"/tag/%E7%BD%91%E5%85%B3/",key:"v-3cf63429",path:"/tag/网关/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"日志 Tags"},regularPath:"/tag/%E6%97%A5%E5%BF%97/",key:"v-231b917c",path:"/tag/日志/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"pdf Tags"},regularPath:"/tag/pdf/",key:"v-323039b2",path:"/tag/pdf/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Docker Tags"},regularPath:"/tag/Docker/",key:"v-83bebff6",path:"/tag/Docker/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"IO模型 Tags"},regularPath:"/tag/IO%E6%A8%A1%E5%9E%8B/",key:"v-f11be80a",path:"/tag/IO模型/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"jvm Tags"},regularPath:"/tag/jvm/",key:"v-32352550",path:"/tag/jvm/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"jwt Tags"},regularPath:"/tag/jwt/",key:"v-32351c1c",path:"/tag/jwt/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"MyBatis Tags"},regularPath:"/tag/MyBatis/",key:"v-f5f3b4b4",path:"/tag/MyBatis/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"sql优化 Tags"},regularPath:"/tag/sql%E4%BC%98%E5%8C%96/",key:"v-71925cf6",path:"/tag/sql优化/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"RabbitMQ Tags"},regularPath:"/tag/RabbitMQ/",key:"v-3c438db2",path:"/tag/RabbitMQ/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Redis Tags"},regularPath:"/tag/Redis/",key:"v-cd4f2d44",path:"/tag/Redis/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Spring Security Tags"},regularPath:"/tag/Spring%20Security/",key:"v-4c97ede3",path:"/tag/Spring Security/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Swagger2 Tags"},regularPath:"/tag/Swagger2/",key:"v-36fc09bd",path:"/tag/Swagger2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Spring Boot Tags"},regularPath:"/tag/Spring%20Boot/",key:"v-29013a71",path:"/tag/Spring Boot/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"ZooKeeper Tags"},regularPath:"/tag/ZooKeeper/",key:"v-d3c816e6",path:"/tag/ZooKeeper/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"单元测试 Tags"},regularPath:"/tag/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",key:"v-46031d55",path:"/tag/单元测试/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"随笔 Tags"},regularPath:"/tag/%E9%9A%8F%E7%AC%94/",key:"v-1eedfa34",path:"/tag/随笔/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"网络协议 Tags"},regularPath:"/tag/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/",key:"v-3c2760d0",path:"/tag/网络协议/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"JavaScript Tags"},regularPath:"/tag/JavaScript/",key:"v-7a5f6990",path:"/tag/JavaScript/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"json Tags"},regularPath:"/tag/json/",key:"v-14722046",path:"/tag/json/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"vuepress Tags"},regularPath:"/tag/vuepress/",key:"v-dfb71430",path:"/tag/vuepress/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Via Tags"},regularPath:"/tag/Via/",key:"v-3247b8aa",path:"/tag/Via/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Vue Tags"},regularPath:"/tag/Vue/",key:"v-32475d9a",path:"/tag/Vue/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"复习 Tags"},regularPath:"/tag/%E5%A4%8D%E4%B9%A0/",key:"v-5acc93b2",path:"/tag/复习/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"开发规范 Tags"},regularPath:"/tag/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/",key:"v-4a5e8070",path:"/tag/开发规范/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"git Tags"},regularPath:"/tag/git/",key:"v-32383f72",path:"/tag/git/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"k8s Tags"},regularPath:"/tag/k8s/",key:"v-32360c9a",path:"/tag/k8s/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"linux Tags"},regularPath:"/tag/linux/",key:"v-7418fe36",path:"/tag/linux/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"ECharts Tags"},regularPath:"/tag/ECharts/",key:"v-5e43a71f",path:"/tag/ECharts/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"后端 Back-end Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/",key:"v-c2a8e576",path:"/categories/后端 Back-end/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"随笔 Essay Categories"},regularPath:"/categories/%E9%9A%8F%E7%AC%94%20Essay/",key:"v-ab316f34",path:"/categories/随笔 Essay/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"前端 Front-end Categories"},regularPath:"/categories/%E5%89%8D%E7%AB%AF%20Front-end/",key:"v-60e851e2",path:"/categories/前端 Front-end/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"规范 Standard Categories"},regularPath:"/categories/%E8%A7%84%E8%8C%83%20Standard/",key:"v-e09e3912",path:"/categories/规范 Standard/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"知识晶体 Q&A Categories"},regularPath:"/categories/%E7%9F%A5%E8%AF%86%E6%99%B6%E4%BD%93%20Q&A/",key:"v-eaa23b1a",path:"/categories/知识晶体 Q&A/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 源码分析 | Tags"},regularPath:"/tag/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/page/2/",key:"v-04bd0e8e",path:"/tag/源码分析/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - Java | Tags"},regularPath:"/tag/Java/page/2/",key:"v-e3c98acc",path:"/tag/Java/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - Java | Tags"},regularPath:"/tag/Java/page/3/",key:"v-e3c98a8e",path:"/tag/Java/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 4 - Java | Tags"},regularPath:"/tag/Java/page/4/",key:"v-e3c98a50",path:"/tag/Java/page/4/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 随笔 | Tags"},regularPath:"/tag/%E9%9A%8F%E7%AC%94/page/2/",key:"v-7c1bf909",path:"/tag/随笔/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/2/",key:"v-707700d8",path:"/categories/后端 Back-end/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 3 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/3/",key:"v-707700f7",path:"/categories/后端 Back-end/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 4 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/4/",key:"v-70770116",path:"/categories/后端 Back-end/page/4/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 5 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/5/",key:"v-70770135",path:"/categories/后端 Back-end/page/5/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 6 - 后端 Back-end | Categories"},regularPath:"/categories/%E5%90%8E%E7%AB%AF%20Back-end/page/6/",key:"v-70770154",path:"/categories/后端 Back-end/page/6/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 随笔 Essay | Categories"},regularPath:"/categories/%E9%9A%8F%E7%AC%94%20Essay/page/2/",key:"v-a7aca2d2",path:"/categories/随笔 Essay/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}}],themeConfig:{nav:[{text:"主页",link:"/index.html",icon:"reco-home"},{text:"其它",icon:"reco-document",items:[{text:"Projects🎈",items:[{text:"✔ My Project ✨",link:"/other/project"},{text:"✔ 友 情 链 接 🎃",link:"/other/friends"}]},{text:"Common sites🎈",items:[{text:"Java SE API Documentation",link:"https://docs.oracle.com/javase/8/docs/api/index.html"},{text:"Program Creek",link:"https://www.programcreek.com/"},{text:"Spring",link:"https://spring.io/"},{text:"Stackoverflow",link:"https://stackoverflow.com/"},{text:"LeetCode",link:"https://leetcode-cn.com/"},{text:"Vue.js",link:"https://cn.vuejs.org/v2/guide/"},{text:"BootCDN",link:"https://www.bootcdn.cn/"},{text:"Linux命令大全",link:"https://www.linuxcool.com/"},{text:"编程语言排行榜",link:"https://www.tiobe.com/tiobe-index/"}]}]},{text:"时间线",link:"/timeline/",icon:"reco-date"},{text:"关于我",link:"/about/",icon:"reco-message"}],sidebar:{"/views/":["",{title:"知识晶体 Q&A",collapsable:!0,children:["qaq/sum_fe_001","qaq/sum_fe_002","qaq/sum_java_001","qaq/sum_java_002","qaq/sum_db_001","qaq/sum_spring_001","qaq/sum_spring_002","qaq/sum_spring_003","qaq/sum_ms_001"]},{title:"规范 Standard",collapsable:!0,children:["specification/ali","specification/git","specification/linux01","specification/linux02","specification/objectModel","specification/提交规范","specification/javaNamingConvention","specification/k8s基本命令与pod管理"]},{title:"前端 Front-end",collapsable:!0,children:["frontend/EChartsStudy","frontend/js-json","frontend/viaStart","frontend/vue-demo","frontend/reco-info","frontend/vuepress-plugin-boxx","frontend/TCP&UDP"]},{title:"后端 Back-end",collapsable:!0,children:["backend/spring-source-01","backend/spring-source-02","backend/spring-source-03","backend/spring-source-04","backend/spring-source-05","backend/spring-source-06","backend/ArrayList","backend/HashMap","backend/docker","backend/itext","backend/poi","backend/quartz","backend/单元测试1","backend/单元测试2","backend/单元测试3","backend/rabbitmq001","backend/rabbitmq002","backend/redis01","backend/redis02","backend/redis使用场景","backend/SSH","backend/jwt","backend/swagger2","backend/thread","backend/ThreadLocal","backend/ThreadPool","backend/ThreadPool2","backend/annotationLog","backend/jvm","backend/JUC","backend/javaLock","backend/mysql_explain","backend/mybatis一二级缓存","backend/ReentrantLock","backend/CountDownLatch","backend/zookeeper","backend/分布式系统概述","backend/API网关概述","backend/spring-security-01","backend/spring-security-02","backend/SchedulingConfigurer","backend/ThreadTopCPU","backend/OOM分类及排查","backend/EasyExcel","backend/java_io模型","backend/SPI_JdkDubboSpring","backend/spring_application_json","backend/springboot配置文件加载顺序","backend/动态代理和静态代理区别","backend/zk选举和一致性","backend/超时取消分析","backend/mini-ioc","backend/Spring的IOC源码以及流程分析"]},{title:"随笔 Essay",collapsable:!0,children:["essay/20190928","essay/20191109","essay/20191116","essay/20191130","essay/20200227","essay/20200301","essay/20200703","essay/20200715","essay/20200813","essay/20201012","essay/20201119","essay/20211216"]}]},authorAvatar:"/vuepress/head-fish.jpg",search:!0,searchMaxSuggestions:10,smoothScroll:!0,sidebarDepth:2,blogConfig:{category:{location:2,text:"分类"},tag:{location:3,text:"标签"}},lastUpdated:"上次更新",author:"zhāngpéngjūn",record:"京ICP备17067634号-1",startYear:"2019",repo:"zpj80231/znote",docsDir:"docs",editLinks:!0,editLinkText:"在 GitHub 上编辑此页！",valineConfig:{appId:"xbT4pPXCWQju5T7GXC5fUFlF-gzGzoHsz",appKey:"bofA5chNQ60p37Ih9sMffSI0",placeholder:"填写邮箱可以收到回复哦!",notify:!0,verify:!0,recordIP:!0}}};t(288),t(13);var Oe=t(27),_e={computed:{$recoPosts(){const{$categories:{list:n}}=this;let e=n.reduce((n,e)=>[...n,...e.pages],[]);return e=Object(Oe.a)(e),Object(Oe.c)(e),e},$recoPostsForTimeline(){let n=this.$recoPosts;const e={},t=[];n=Object(Oe.a)(n,!0),this.pages=0==n.length?[]:n;for(let t=0,r=n.length;t<r;t++){const r=n[t],a=Le(r.frontmatter.date,"year");e[a]?e[a].push(r):e[a]=[r]}for(const n in e){const r=e[n];Object(Oe.b)(r),t.unshift({year:n,data:r})}return t}}};function Le(n,e){n=function(n){var e=new Date(n).toJSON();return new Date(+new Date(e)+288e5).toISOString().replace(/T/g," ").replace(/\.[\d]{3}Z/,"").replace(/-/g,"/")}(n);const t=new Date(n),r=t.getFullYear(),a=t.getMonth()+1,o=t.getDate();return"year"==e?r:`${a}-${o}`}t(289);r.a.component("CanvasNest",()=>t.e(21).then(t.bind(null,484))),r.a.component("Clock",()=>Promise.all([t.e(0),t.e(12)]).then(t.bind(null,485))),r.a.component("Clock02",()=>Promise.all([t.e(0),t.e(13)]).then(t.bind(null,486))),r.a.component("Copyright",()=>Promise.resolve().then(t.bind(null,146))),r.a.component("ProjectItem",()=>Promise.all([t.e(0),t.e(14)]).then(t.bind(null,414))),r.a.component("Projects",()=>Promise.all([t.e(0),t.e(2),t.e(1),t.e(8)]).then(t.bind(null,475))),r.a.component("Reward",()=>Promise.all([t.e(0),t.e(15)]).then(t.bind(null,487))),r.a.component("ToDoList",()=>Promise.all([t.e(0),t.e(16)]).then(t.bind(null,488))),r.a.component("Badge",()=>Promise.all([t.e(0),t.e(17)]).then(t.bind(null,582)));var Fe={name:"BackToTop",data:()=>({visible:!1,customStyle:{right:"1rem",bottom:"6rem",width:"2.5rem",height:"2.5rem","border-radius":".25rem","line-height":"2.5rem",backgroundColor:"rgba(231, 234, 241,.5)"},visibilityHeight:400}),mounted(){window.addEventListener("scroll",this.throttle(this.handleScroll,500))},beforeDestroy(){window.removeEventListener("scroll",this.throttle(this.handleScroll,500))},methods:{handleScroll(){this.visible=window.pageYOffset>this.visibilityHeight},backToTop(){window.scrollTo(0,0)},throttle(n,e){let t=null,r=Date.now();return function(){const a=Date.now(),o=e-(a-r),i=this,s=arguments;clearTimeout(t),o<=0?(n.apply(i,s),r=Date.now()):t=setTimeout(n,o)}}}},Me=(t(290),Object(Ce.a)(Fe,(function(){var n=this._self._c;return n("transition",{attrs:{name:"fade"}},[n("div",{directives:[{name:"show",rawName:"v-show",value:this.visible,expression:"visible"}],staticClass:"back-to-ceiling",style:this.customStyle,on:{click:this.backToTop}},[n("svg",{staticClass:"icon",attrs:{t:"1574745035067",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"5404"}},[n("path",{attrs:{d:"M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z","p-id":"5405"}}),n("path",{attrs:{d:"M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z","p-id":"5406"}})])])])}),[],!1,null,"c6073ba8",null).exports);t(291),t(296);const Re={prev:"上一页",next:"下一页",go:"前往",jump:"跳转至"},Ne={prev:"上壹頁",next:"下壹頁",go:"前往",jump:"跳轉至"},qe={prev:"Prev",next:"Next",go:"Go",jump:"Jump To"},Ue={prev:"前のページ",next:"次のページ",go:"へ",jump:"ジャンプ"},He={prev:"이전 페이지",next:"다음 페이지",go:"행",jump:"건너뛰기"};var $e={data:()=>({changePage:"",pageSize:10}),props:{total:{type:Number,default:10},perPage:{type:Number,default:10},currentPage:{type:Number,default:1}},computed:{pages(){return Math.ceil(this.total/this.pageSize)},efont:function(){return this.pages>7},indexes:function(){var n=1,e=this.pages,t=[];for(this.pages>=7&&(this.currentPage>5&&this.currentPage<this.pages-4?(n=Number(this.currentPage)-3,e=Number(this.currentPage)+3):this.currentPage<=5?(n=1,e=7):(e=this.pages,n=this.pages-6));n<=e;)t.push(n),n++;return t},pagationLocales(){return function(n){const{$lang:e,$recoLocales:{pagation:t}={}}=n;return t||(/^zh\-(CN|SG)$/.test(e)?Re:/^zh\-(HK|MO|TW)$/.test(e)?Ne:/^ja\-JP$/.test(e)?Ue:/^ko\-KR$/.test(e)?He:qe)}(this)},showStartFakePageNum:function(){return this.efont&&!this.indexes.includes(1)},showLastFakePageNum:function(){return this.efont&&!this.indexes.includes(this.pages)}},methods:{goPrev(){let n=this.currentPage;this.currentPage>1&&this.emit(--n)},goNext(){let n=this.currentPage;n<this.pages&&this.emit(++n)},jumpPage:function(n){const e=parseInt(n);e<=this.pages&&e>0?this.emit(e):alert(`请输入大于0，并且小于等于${this.pages}的页码！`)},emit(n){this.$emit("getCurrentPage",n)}}},Je=(t(297),Object(Ce.a)($e,(function(){var n=this,e=n._self._c;return e("div",{directives:[{name:"show",rawName:"v-show",value:n.pages>1,expression:"pages > 1"}],staticClass:"pagation"},[e("div",{staticClass:"pagation-list"},[e("span",{directives:[{name:"show",rawName:"v-show",value:n.currentPage>1,expression:"currentPage > 1"}],staticClass:"jump",attrs:{unselectable:"on"},on:{click:n.goPrev}},[n._v(n._s(n.pagationLocales.prev))]),n._v(" "),n.showStartFakePageNum?e("span",{staticClass:"jump",on:{click:function(e){return n.jumpPage(1)}}},[n._v("1")]):n._e(),n._v(" "),n.showStartFakePageNum&&n.indexes[0]>2?e("span",{staticClass:"ellipsis"},[n._v("...")]):n._e(),n._v(" "),n._l(n.indexes,(function(t){return e("span",{key:t,staticClass:"jump",class:{bgprimary:n.currentPage==t},on:{click:function(e){return n.jumpPage(t)}}},[n._v(n._s(t))])})),n._v(" "),n.showLastFakePageNum&&n.pages-n.indexes.at(-1)>1?e("span",{staticClass:"ellipsis"},[n._v("...")]):n._e(),n._v(" "),n.showLastFakePageNum?e("span",{staticClass:"jump",on:{click:function(e){return n.jumpPage(n.pages)}}},[n._v(n._s(n.pages))]):n._e(),n._v(" "),n.currentPage<n.pages?e("span",{staticClass:"jump",on:{click:n.goNext}},[n._v(n._s(n.pagationLocales.next))]):n._e(),n._v(" "),e("span",{staticClass:"jumppoint"},[n._v(n._s(n.pagationLocales.jump))]),n._v(" "),e("span",{staticClass:"jumpinp"},[e("input",{directives:[{name:"model",rawName:"v-model",value:n.changePage,expression:"changePage"}],attrs:{type:"text"},domProps:{value:n.changePage},on:{input:function(e){e.target.composing||(n.changePage=e.target.value)}}})]),n._v(" "),e("span",{staticClass:"jump gobtn",on:{click:function(e){return n.jumpPage(n.changePage)}}},[n._v(n._s(n.pagationLocales.go))])],2)])}),[],!1,null,"22b6649c",null).exports),Ve={name:"Valine",props:{options:{type:Object,default:()=>({})}},mounted:function(){this.initValine()},methods:{initValine(){new(t(298))({el:"#valine",placeholder:"just go go",notify:!1,verify:!1,avatar:"retro",visitor:!0,recordIP:!1,path:window.location.pathname,...this.options})}},watch:{$route(n,e){n.path!==e.path&&setTimeout(()=>{this.initValine()},300)}}},We=(t(299),Object(Ce.a)(Ve,(function(){this._self._c;return this._m(0)}),[function(){var n=this._self._c;return n("div",{staticClass:"valine-wrapper"},[n("div",{attrs:{id:"valine"}})])}],!1,null,null,null).exports);
/**
  * vue-class-component v7.2.6
  * (c) 2015-present Evan You
  * @license MIT
  */
function Qe(n){return(Qe="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function Ke(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function Ge(n){return function(n){if(Array.isArray(n)){for(var e=0,t=new Array(n.length);e<n.length;e++)t[e]=n[e];return t}}(n)||function(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function Xe(){return"undefined"!=typeof Reflect&&Reflect.defineMetadata&&Reflect.getOwnMetadataKeys}function Ze(n,e){Ye(n,e),Object.getOwnPropertyNames(e.prototype).forEach((function(t){Ye(n.prototype,e.prototype,t)})),Object.getOwnPropertyNames(e).forEach((function(t){Ye(n,e,t)}))}function Ye(n,e,t){(t?Reflect.getOwnMetadataKeys(e,t):Reflect.getOwnMetadataKeys(e)).forEach((function(r){var a=t?Reflect.getOwnMetadata(r,e,t):Reflect.getOwnMetadata(r,e);t?Reflect.defineMetadata(r,a,n,t):Reflect.defineMetadata(r,a,n)}))}var nt={__proto__:[]}instanceof Array;function et(n){return function(e,t,r){var a="function"==typeof e?e:e.constructor;a.__decorators__||(a.__decorators__=[]),"number"!=typeof r&&(r=void 0),a.__decorators__.push((function(e){return n(e,t,r)}))}}function tt(n,e){var t=e.prototype._init;e.prototype._init=function(){var e=this,t=Object.getOwnPropertyNames(n);if(n.$options.props)for(var r in n.$options.props)n.hasOwnProperty(r)||t.push(r);t.forEach((function(t){Object.defineProperty(e,t,{get:function(){return n[t]},set:function(e){n[t]=e},configurable:!0})}))};var r=new e;e.prototype._init=t;var a={};return Object.keys(r).forEach((function(n){void 0!==r[n]&&(a[n]=r[n])})),a}var rt=["data","beforeCreate","created","beforeMount","mounted","beforeDestroy","destroyed","beforeUpdate","updated","activated","deactivated","render","errorCaptured","serverPrefetch"];function at(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.name=e.name||n._componentTag||n.name;var t=n.prototype;Object.getOwnPropertyNames(t).forEach((function(n){if("constructor"!==n)if(rt.indexOf(n)>-1)e[n]=t[n];else{var r=Object.getOwnPropertyDescriptor(t,n);void 0!==r.value?"function"==typeof r.value?(e.methods||(e.methods={}))[n]=r.value:(e.mixins||(e.mixins=[])).push({data:function(){return Ke({},n,r.value)}}):(r.get||r.set)&&((e.computed||(e.computed={}))[n]={get:r.get,set:r.set})}})),(e.mixins||(e.mixins=[])).push({data:function(){return tt(this,n)}});var a=n.__decorators__;a&&(a.forEach((function(n){return n(e)})),delete n.__decorators__);var o=Object.getPrototypeOf(n.prototype),i=o instanceof r.a?o.constructor:r.a,s=i.extend(e);return it(s,n,i),Xe()&&Ze(s,n),s}var ot={prototype:!0,arguments:!0,callee:!0,caller:!0};function it(n,e,t){Object.getOwnPropertyNames(e).forEach((function(r){if(!ot[r]){var a=Object.getOwnPropertyDescriptor(n,r);if(!a||a.configurable){var o,i,s=Object.getOwnPropertyDescriptor(e,r);if(!nt){if("cid"===r)return;var c=Object.getOwnPropertyDescriptor(t,r);if(o=s.value,i=Qe(o),null!=o&&("object"===i||"function"===i)&&c&&c.value===s.value)return}0,Object.defineProperty(n,r,s)}}}))}function st(n){return"function"==typeof n?at(n):function(e){return at(e,n)}}st.registerHooks=function(n){rt.push.apply(rt,Ge(n))};var ct=st;function lt(n){return et((function(e,t){void 0===e.inject&&(e.inject={}),Array.isArray(e.inject)||(e.inject[t]=n||t)}))}function pt(n){return"function"!=typeof n||!n.managed&&!n.managedReactive}function ut(n){var e=function(){var t=this,r="function"==typeof n?n.call(this):n;for(var a in(r=Object.create(r||null))[dt]=Object.create(this[dt]||{}),e.managed)r[e.managed[a]]=this[a];var o=function(n){r[e.managedReactive[n]]=i[n],Object.defineProperty(r[dt],e.managedReactive[n],{enumerable:!0,configurable:!0,get:function(){return t[n]}})},i=this;for(var a in e.managedReactive)o(a);return r};return e.managed={},e.managedReactive={},e}var dt="__reactiveInject__";function mt(n){Array.isArray(n.inject)||(n.inject=n.inject||{},n.inject[dt]={from:dt,default:{}})}var ht="undefined"!=typeof Reflect&&void 0!==Reflect.getMetadata;function gt(n,e,t){if(ht&&!Array.isArray(n)&&"function"!=typeof n&&!n.hasOwnProperty("type")&&void 0===n.type){var r=Reflect.getMetadata("design:type",e,t);r!==Object&&(n.type=r)}}function ft(n){return void 0===n&&(n={}),function(e,t){gt(n,e,t),et((function(e,t){(e.props||(e.props={}))[t]=n}))(e,t)}}function bt(n,e){void 0===e&&(e={});var t=e.deep,r=void 0!==t&&t,a=e.immediate,o=void 0!==a&&a;return et((function(e,t){"object"!=typeof e.watch&&(e.watch=Object.create(null));var a=e.watch;"object"!=typeof a[n]||Array.isArray(a[n])?void 0===a[n]&&(a[n]=[]):a[n]=[a[n]],a[n].push({handler:t,deep:r,immediate:o})}))}var vt=t(20);const yt=n=>Object(vt.stringify)(n),xt=(n,e)=>`${n}${Object(vt.stringify)(e,{addQueryPrefix:!0})}`,wt=(n,e)=>`${n.replace(/\/$/,"")}/${e.replace(/^\//,"")}`;var kt=t(136),St=t.n(kt);const Ct=n=>St()(n,"YYYY-MM-DD HH:mm:ss"),jt=n=>(n.split("#")[0]||"").split("?")[0]||"",At=n=>Object(vt.parse)(n,{ignoreQueryPrefix:!0})
/*!
 * vue-i18n v8.28.2 
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */;var Tt=["compactDisplay","currency","currencyDisplay","currencySign","localeMatcher","notation","numberingSystem","signDisplay","style","unit","unitDisplay","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","minimumSignificantDigits","maximumSignificantDigits"],Et=["dateStyle","timeStyle","calendar","localeMatcher","hour12","hourCycle","timeZone","formatMatcher","weekday","era","year","month","day","hour","minute","second","timeZoneName"];function Pt(n,e){"undefined"!=typeof console&&(console.warn("[vue-i18n] "+n),e&&console.warn(e.stack))}var Dt=Array.isArray;function zt(n){return null!==n&&"object"==typeof n}function Bt(n){return"string"==typeof n}var It=Object.prototype.toString;function Ot(n){return"[object Object]"===It.call(n)}function _t(n){return null==n}function Lt(n){return"function"==typeof n}function Ft(){for(var n=[],e=arguments.length;e--;)n[e]=arguments[e];var t=null,r=null;return 1===n.length?zt(n[0])||Dt(n[0])?r=n[0]:"string"==typeof n[0]&&(t=n[0]):2===n.length&&("string"==typeof n[0]&&(t=n[0]),(zt(n[1])||Dt(n[1]))&&(r=n[1])),{locale:t,params:r}}function Mt(n){return JSON.parse(JSON.stringify(n))}function Rt(n,e){return!!~n.indexOf(e)}var Nt=Object.prototype.hasOwnProperty;function qt(n,e){return Nt.call(n,e)}function Ut(n){for(var e=arguments,t=Object(n),r=1;r<arguments.length;r++){var a=e[r];if(null!=a){var o=void 0;for(o in a)qt(a,o)&&(zt(a[o])?t[o]=Ut(t[o],a[o]):t[o]=a[o])}}return t}function Ht(n,e){if(n===e)return!0;var t=zt(n),r=zt(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Dt(n),o=Dt(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return Ht(n,e[t])}));if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return Ht(n[t],e[t])}))}catch(n){return!1}}function $t(n){return null!=n&&Object.keys(n).forEach((function(e){"string"==typeof n[e]&&(n[e]=n[e].replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;"))})),n}var Jt={name:"i18n",functional:!0,props:{tag:{type:[String,Boolean,Object],default:"span"},path:{type:String,required:!0},locale:{type:String},places:{type:[Array,Object]}},render:function(n,e){var t=e.data,r=e.parent,a=e.props,o=e.slots,i=r.$i18n;if(i){var s=a.path,c=a.locale,l=a.places,p=o(),u=i.i(s,c,function(n){var e;for(e in n)if("default"!==e)return!1;return Boolean(e)}(p)||l?function(n,e){var t=e?function(n){0;return Array.isArray(n)?n.reduce(Wt,{}):Object.assign({},n)}(e):{};if(!n)return t;var r=(n=n.filter((function(n){return n.tag||""!==n.text.trim()}))).every(Qt);0;return n.reduce(r?Vt:Wt,t)}(p.default,l):p),d=a.tag&&!0!==a.tag||!1===a.tag?a.tag:"span";return d?n(d,t,u):u}}};function Vt(n,e){return e.data&&e.data.attrs&&e.data.attrs.place&&(n[e.data.attrs.place]=e),n}function Wt(n,e,t){return n[t]=e,n}function Qt(n){return Boolean(n.data&&n.data.attrs&&n.data.attrs.place)}var Kt,Gt={name:"i18n-n",functional:!0,props:{tag:{type:[String,Boolean,Object],default:"span"},value:{type:Number,required:!0},format:{type:[String,Object]},locale:{type:String}},render:function(n,e){var t=e.props,r=e.parent,a=e.data,o=r.$i18n;if(!o)return null;var i=null,s=null;Bt(t.format)?i=t.format:zt(t.format)&&(t.format.key&&(i=t.format.key),s=Object.keys(t.format).reduce((function(n,e){var r;return Rt(Tt,e)?Object.assign({},n,((r={})[e]=t.format[e],r)):n}),null));var c=t.locale||o.locale,l=o._ntp(t.value,c,i,s),p=l.map((function(n,e){var t,r=a.scopedSlots&&a.scopedSlots[n.type];return r?r(((t={})[n.type]=n.value,t.index=e,t.parts=l,t)):n.value})),u=t.tag&&!0!==t.tag||!1===t.tag?t.tag:"span";return u?n(u,{attrs:a.attrs,class:a.class,staticClass:a.staticClass},p):p}};function Xt(n,e,t){nr(n,t)&&er(n,e,t)}function Zt(n,e,t,r){if(nr(n,t)){var a=t.context.$i18n;(function(n,e){var t=e.context;return n._locale===t.$i18n.locale})(n,t)&&Ht(e.value,e.oldValue)&&Ht(n._localeMessage,a.getLocaleMessage(a.locale))||er(n,e,t)}}function Yt(n,e,t,r){if(t.context){var a=t.context.$i18n||{};e.modifiers.preserve||a.preserveDirectiveContent||(n.textContent=""),n._vt=void 0,delete n._vt,n._locale=void 0,delete n._locale,n._localeMessage=void 0,delete n._localeMessage}else Pt("Vue instance does not exists in VNode context")}function nr(n,e){var t=e.context;return t?!!t.$i18n||(Pt("VueI18n instance does not exists in Vue instance"),!1):(Pt("Vue instance does not exists in VNode context"),!1)}function er(n,e,t){var r,a,o=function(n){var e,t,r,a;Bt(n)?e=n:Ot(n)&&(e=n.path,t=n.locale,r=n.args,a=n.choice);return{path:e,locale:t,args:r,choice:a}}(e.value),i=o.path,s=o.locale,c=o.args,l=o.choice;if(i||s||c)if(i){var p=t.context;n._vt=n.textContent=null!=l?(r=p.$i18n).tc.apply(r,[i,l].concat(tr(s,c))):(a=p.$i18n).t.apply(a,[i].concat(tr(s,c))),n._locale=p.$i18n.locale,n._localeMessage=p.$i18n.getLocaleMessage(p.$i18n.locale)}else Pt("`path` is required in v-t directive");else Pt("value type not supported")}function tr(n,e){var t=[];return n&&t.push(n),e&&(Array.isArray(e)||Ot(e))&&t.push(e),t}function rr(n,e){void 0===e&&(e={bridge:!1}),rr.installed=!0;var t;(Kt=n).version&&Number(Kt.version.split(".")[0]);(t=Kt).prototype.hasOwnProperty("$i18n")||Object.defineProperty(t.prototype,"$i18n",{get:function(){return this._i18n}}),t.prototype.$t=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var r=this.$i18n;return r._t.apply(r,[n,r.locale,r._getMessages(),this].concat(e))},t.prototype.$tc=function(n,e){for(var t=[],r=arguments.length-2;r-- >0;)t[r]=arguments[r+2];var a=this.$i18n;return a._tc.apply(a,[n,a.locale,a._getMessages(),this,e].concat(t))},t.prototype.$te=function(n,e){var t=this.$i18n;return t._te(n,t.locale,t._getMessages(),e)},t.prototype.$d=function(n){for(var e,t=[],r=arguments.length-1;r-- >0;)t[r]=arguments[r+1];return(e=this.$i18n).d.apply(e,[n].concat(t))},t.prototype.$n=function(n){for(var e,t=[],r=arguments.length-1;r-- >0;)t[r]=arguments[r+1];return(e=this.$i18n).n.apply(e,[n].concat(t))},Kt.mixin(function(n){function e(){this!==this.$root&&this.$options.__INTLIFY_META__&&this.$el&&this.$el.setAttribute("data-intlify",this.$options.__INTLIFY_META__)}return void 0===n&&(n=!1),n?{mounted:e}:{beforeCreate:function(){var n=this.$options;if(n.i18n=n.i18n||(n.__i18nBridge||n.__i18n?{}:null),n.i18n)if(n.i18n instanceof yr){if(n.__i18nBridge||n.__i18n)try{var e=n.i18n&&n.i18n.messages?n.i18n.messages:{};(n.__i18nBridge||n.__i18n).forEach((function(n){e=Ut(e,JSON.parse(n))})),Object.keys(e).forEach((function(t){n.i18n.mergeLocaleMessage(t,e[t])}))}catch(n){0}this._i18n=n.i18n,this._i18nWatcher=this._i18n.watchI18nData()}else if(Ot(n.i18n)){var t=this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof yr?this.$root.$i18n:null;if(t&&(n.i18n.root=this.$root,n.i18n.formatter=t.formatter,n.i18n.fallbackLocale=t.fallbackLocale,n.i18n.formatFallbackMessages=t.formatFallbackMessages,n.i18n.silentTranslationWarn=t.silentTranslationWarn,n.i18n.silentFallbackWarn=t.silentFallbackWarn,n.i18n.pluralizationRules=t.pluralizationRules,n.i18n.preserveDirectiveContent=t.preserveDirectiveContent),n.__i18nBridge||n.__i18n)try{var r=n.i18n&&n.i18n.messages?n.i18n.messages:{};(n.__i18nBridge||n.__i18n).forEach((function(n){r=Ut(r,JSON.parse(n))})),n.i18n.messages=r}catch(n){0}var a=n.i18n.sharedMessages;a&&Ot(a)&&(n.i18n.messages=Ut(n.i18n.messages,a)),this._i18n=new yr(n.i18n),this._i18nWatcher=this._i18n.watchI18nData(),(void 0===n.i18n.sync||n.i18n.sync)&&(this._localeWatcher=this.$i18n.watchLocale()),t&&t.onComponentInstanceCreated(this._i18n)}else 0;else this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof yr?this._i18n=this.$root.$i18n:n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof yr&&(this._i18n=n.parent.$i18n)},beforeMount:function(){var n=this.$options;n.i18n=n.i18n||(n.__i18nBridge||n.__i18n?{}:null),n.i18n?(n.i18n instanceof yr||Ot(n.i18n))&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0):(this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof yr||n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof yr)&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0)},mounted:e,beforeDestroy:function(){if(this._i18n){var n=this;this.$nextTick((function(){n._subscribing&&(n._i18n.unsubscribeDataChanging(n),delete n._subscribing),n._i18nWatcher&&(n._i18nWatcher(),n._i18n.destroyVM(),delete n._i18nWatcher),n._localeWatcher&&(n._localeWatcher(),delete n._localeWatcher)}))}}}}(e.bridge)),Kt.directive("t",{bind:Xt,update:Zt,unbind:Yt}),Kt.component(Jt.name,Jt),Kt.component(Gt.name,Gt),Kt.config.optionMergeStrategies.i18n=function(n,e){return void 0===e?n:e}}var ar=function(){this._caches=Object.create(null)};ar.prototype.interpolate=function(n,e){if(!e)return[n];var t=this._caches[n];return t||(t=function(n){var e=[],t=0,r="";for(;t<n.length;){var a=n[t++];if("{"===a){r&&e.push({type:"text",value:r}),r="";var o="";for(a=n[t++];void 0!==a&&"}"!==a;)o+=a,a=n[t++];var i="}"===a,s=or.test(o)?"list":i&&ir.test(o)?"named":"unknown";e.push({value:o,type:s})}else"%"===a?"{"!==n[t]&&(r+=a):r+=a}return r&&e.push({type:"text",value:r}),e}(n),this._caches[n]=t),function(n,e){var t=[],r=0,a=Array.isArray(e)?"list":zt(e)?"named":"unknown";if("unknown"===a)return t;for(;r<n.length;){var o=n[r];switch(o.type){case"text":t.push(o.value);break;case"list":t.push(e[parseInt(o.value,10)]);break;case"named":"named"===a&&t.push(e[o.value]);break;case"unknown":0}r++}return t}(t,e)};var or=/^(?:\d)+/,ir=/^(?:\w)+/;var sr=[];sr[0]={ws:[0],ident:[3,0],"[":[4],eof:[7]},sr[1]={ws:[1],".":[2],"[":[4],eof:[7]},sr[2]={ws:[2],ident:[3,0],0:[3,0],number:[3,0]},sr[3]={ident:[3,0],0:[3,0],number:[3,0],ws:[1,1],".":[2,1],"[":[4,1],eof:[7,1]},sr[4]={"'":[5,0],'"':[6,0],"[":[4,2],"]":[1,3],eof:8,else:[4,0]},sr[5]={"'":[4,0],eof:8,else:[5,0]},sr[6]={'"':[4,0],eof:8,else:[6,0]};var cr=/^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;function lr(n){if(null==n)return"eof";switch(n.charCodeAt(0)){case 91:case 93:case 46:case 34:case 39:return n;case 95:case 36:case 45:return"ident";case 9:case 10:case 13:case 160:case 65279:case 8232:case 8233:return"ws"}return"ident"}function pr(n){var e,t,r,a=n.trim();return("0"!==n.charAt(0)||!isNaN(n))&&(r=a,cr.test(r)?(t=(e=a).charCodeAt(0))!==e.charCodeAt(e.length-1)||34!==t&&39!==t?e:e.slice(1,-1):"*"+a)}var ur=function(){this._cache=Object.create(null)};ur.prototype.parsePath=function(n){var e=this._cache[n];return e||(e=function(n){var e,t,r,a,o,i,s,c=[],l=-1,p=0,u=0,d=[];function m(){var e=n[l+1];if(5===p&&"'"===e||6===p&&'"'===e)return l++,r="\\"+e,d[0](),!0}for(d[1]=function(){void 0!==t&&(c.push(t),t=void 0)},d[0]=function(){void 0===t?t=r:t+=r},d[2]=function(){d[0](),u++},d[3]=function(){if(u>0)u--,p=4,d[0]();else{if(u=0,void 0===t)return!1;if(!1===(t=pr(t)))return!1;d[1]()}};null!==p;)if(l++,"\\"!==(e=n[l])||!m()){if(a=lr(e),8===(o=(s=sr[p])[a]||s.else||8))return;if(p=o[0],(i=d[o[1]])&&(r=void 0===(r=o[2])?e:r,!1===i()))return;if(7===p)return c}}(n))&&(this._cache[n]=e),e||[]},ur.prototype.getPathValue=function(n,e){if(!zt(n))return null;var t=this.parsePath(e);if(0===t.length)return null;for(var r=t.length,a=n,o=0;o<r;){var i=a[t[o]];if(null==i)return null;a=i,o++}return a};var dr,mr=/<\/?[\w\s="/.':;#-\/]+>/,hr=/(?:@(?:\.[a-zA-Z]+)?:(?:[\w\-_|./]+|\([\w\-_:|./]+\)))/g,gr=/^@(?:\.([a-zA-Z]+))?:/,fr=/[()]/g,br={upper:function(n){return n.toLocaleUpperCase()},lower:function(n){return n.toLocaleLowerCase()},capitalize:function(n){return""+n.charAt(0).toLocaleUpperCase()+n.substr(1)}},vr=new ar,yr=function(n){var e=this;void 0===n&&(n={}),!Kt&&"undefined"!=typeof window&&window.Vue&&rr(window.Vue);var t=n.locale||"en-US",r=!1!==n.fallbackLocale&&(n.fallbackLocale||"en-US"),a=n.messages||{},o=n.dateTimeFormats||n.datetimeFormats||{},i=n.numberFormats||{};this._vm=null,this._formatter=n.formatter||vr,this._modifiers=n.modifiers||{},this._missing=n.missing||null,this._root=n.root||null,this._sync=void 0===n.sync||!!n.sync,this._fallbackRoot=void 0===n.fallbackRoot||!!n.fallbackRoot,this._fallbackRootWithEmptyString=void 0===n.fallbackRootWithEmptyString||!!n.fallbackRootWithEmptyString,this._formatFallbackMessages=void 0!==n.formatFallbackMessages&&!!n.formatFallbackMessages,this._silentTranslationWarn=void 0!==n.silentTranslationWarn&&n.silentTranslationWarn,this._silentFallbackWarn=void 0!==n.silentFallbackWarn&&!!n.silentFallbackWarn,this._dateTimeFormatters={},this._numberFormatters={},this._path=new ur,this._dataListeners=new Set,this._componentInstanceCreatedListener=n.componentInstanceCreatedListener||null,this._preserveDirectiveContent=void 0!==n.preserveDirectiveContent&&!!n.preserveDirectiveContent,this.pluralizationRules=n.pluralizationRules||{},this._warnHtmlInMessage=n.warnHtmlInMessage||"off",this._postTranslation=n.postTranslation||null,this._escapeParameterHtml=n.escapeParameterHtml||!1,"__VUE_I18N_BRIDGE__"in n&&(this.__VUE_I18N_BRIDGE__=n.__VUE_I18N_BRIDGE__),this.getChoiceIndex=function(n,t){var r=Object.getPrototypeOf(e);if(r&&r.getChoiceIndex)return r.getChoiceIndex.call(e,n,t);var a,o;return e.locale in e.pluralizationRules?e.pluralizationRules[e.locale].apply(e,[n,t]):(a=n,o=t,a=Math.abs(a),2===o?a?a>1?1:0:1:a?Math.min(a,2):0)},this._exist=function(n,t){return!(!n||!t)&&(!_t(e._path.getPathValue(n,t))||!!n[t])},"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||Object.keys(a).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,a[n])})),this._initVM({locale:t,fallbackLocale:r,messages:a,dateTimeFormats:o,numberFormats:i})},xr={vm:{configurable:!0},messages:{configurable:!0},dateTimeFormats:{configurable:!0},numberFormats:{configurable:!0},availableLocales:{configurable:!0},locale:{configurable:!0},fallbackLocale:{configurable:!0},formatFallbackMessages:{configurable:!0},missing:{configurable:!0},formatter:{configurable:!0},silentTranslationWarn:{configurable:!0},silentFallbackWarn:{configurable:!0},preserveDirectiveContent:{configurable:!0},warnHtmlInMessage:{configurable:!0},postTranslation:{configurable:!0},sync:{configurable:!0}};yr.prototype._checkLocaleMessage=function(n,e,t){var r=function(n,e,t,a){if(Ot(t))Object.keys(t).forEach((function(o){var i=t[o];Ot(i)?(a.push(o),a.push("."),r(n,e,i,a),a.pop(),a.pop()):(a.push(o),r(n,e,i,a),a.pop())}));else if(Dt(t))t.forEach((function(t,o){Ot(t)?(a.push("["+o+"]"),a.push("."),r(n,e,t,a),a.pop(),a.pop()):(a.push("["+o+"]"),r(n,e,t,a),a.pop())}));else if(Bt(t)){if(mr.test(t)){var o="Detected HTML in message '"+t+"' of keypath '"+a.join("")+"' at '"+e+"'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";"warn"===n?Pt(o):"error"===n&&function(n,e){"undefined"!=typeof console&&(console.error("[vue-i18n] "+n),e&&console.error(e.stack))}(o)}}};r(e,n,t,[])},yr.prototype._initVM=function(n){var e=Kt.config.silent;Kt.config.silent=!0,this._vm=new Kt({data:n,__VUE18N__INSTANCE__:!0}),Kt.config.silent=e},yr.prototype.destroyVM=function(){this._vm.$destroy()},yr.prototype.subscribeDataChanging=function(n){this._dataListeners.add(n)},yr.prototype.unsubscribeDataChanging=function(n){!function(n,e){if(n.delete(e));}(this._dataListeners,n)},yr.prototype.watchI18nData=function(){var n=this;return this._vm.$watch("$data",(function(){for(var e,t,r=(e=n._dataListeners,t=[],e.forEach((function(n){return t.push(n)})),t),a=r.length;a--;)Kt.nextTick((function(){r[a]&&r[a].$forceUpdate()}))}),{deep:!0})},yr.prototype.watchLocale=function(n){if(n){if(!this.__VUE_I18N_BRIDGE__)return null;var e=this,t=this._vm;return this.vm.$watch("locale",(function(r){t.$set(t,"locale",r),e.__VUE_I18N_BRIDGE__&&n&&(n.locale.value=r),t.$forceUpdate()}),{immediate:!0})}if(!this._sync||!this._root)return null;var r=this._vm;return this._root.$i18n.vm.$watch("locale",(function(n){r.$set(r,"locale",n),r.$forceUpdate()}),{immediate:!0})},yr.prototype.onComponentInstanceCreated=function(n){this._componentInstanceCreatedListener&&this._componentInstanceCreatedListener(n,this)},xr.vm.get=function(){return this._vm},xr.messages.get=function(){return Mt(this._getMessages())},xr.dateTimeFormats.get=function(){return Mt(this._getDateTimeFormats())},xr.numberFormats.get=function(){return Mt(this._getNumberFormats())},xr.availableLocales.get=function(){return Object.keys(this.messages).sort()},xr.locale.get=function(){return this._vm.locale},xr.locale.set=function(n){this._vm.$set(this._vm,"locale",n)},xr.fallbackLocale.get=function(){return this._vm.fallbackLocale},xr.fallbackLocale.set=function(n){this._localeChainCache={},this._vm.$set(this._vm,"fallbackLocale",n)},xr.formatFallbackMessages.get=function(){return this._formatFallbackMessages},xr.formatFallbackMessages.set=function(n){this._formatFallbackMessages=n},xr.missing.get=function(){return this._missing},xr.missing.set=function(n){this._missing=n},xr.formatter.get=function(){return this._formatter},xr.formatter.set=function(n){this._formatter=n},xr.silentTranslationWarn.get=function(){return this._silentTranslationWarn},xr.silentTranslationWarn.set=function(n){this._silentTranslationWarn=n},xr.silentFallbackWarn.get=function(){return this._silentFallbackWarn},xr.silentFallbackWarn.set=function(n){this._silentFallbackWarn=n},xr.preserveDirectiveContent.get=function(){return this._preserveDirectiveContent},xr.preserveDirectiveContent.set=function(n){this._preserveDirectiveContent=n},xr.warnHtmlInMessage.get=function(){return this._warnHtmlInMessage},xr.warnHtmlInMessage.set=function(n){var e=this,t=this._warnHtmlInMessage;if(this._warnHtmlInMessage=n,t!==n&&("warn"===n||"error"===n)){var r=this._getMessages();Object.keys(r).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,r[n])}))}},xr.postTranslation.get=function(){return this._postTranslation},xr.postTranslation.set=function(n){this._postTranslation=n},xr.sync.get=function(){return this._sync},xr.sync.set=function(n){this._sync=n},yr.prototype._getMessages=function(){return this._vm.messages},yr.prototype._getDateTimeFormats=function(){return this._vm.dateTimeFormats},yr.prototype._getNumberFormats=function(){return this._vm.numberFormats},yr.prototype._warnDefault=function(n,e,t,r,a,o){if(!_t(t))return t;if(this._missing){var i=this._missing.apply(null,[n,e,r,a]);if(Bt(i))return i}else 0;if(this._formatFallbackMessages){var s=Ft.apply(void 0,a);return this._render(e,o,s.params,e)}return e},yr.prototype._isFallbackRoot=function(n){return(this._fallbackRootWithEmptyString?!n:_t(n))&&!_t(this._root)&&this._fallbackRoot},yr.prototype._isSilentFallbackWarn=function(n){return this._silentFallbackWarn instanceof RegExp?this._silentFallbackWarn.test(n):this._silentFallbackWarn},yr.prototype._isSilentFallback=function(n,e){return this._isSilentFallbackWarn(e)&&(this._isFallbackRoot()||n!==this.fallbackLocale)},yr.prototype._isSilentTranslationWarn=function(n){return this._silentTranslationWarn instanceof RegExp?this._silentTranslationWarn.test(n):this._silentTranslationWarn},yr.prototype._interpolate=function(n,e,t,r,a,o,i){if(!e)return null;var s,c=this._path.getPathValue(e,t);if(Dt(c)||Ot(c))return c;if(_t(c)){if(!Ot(e))return null;if(!Bt(s=e[t])&&!Lt(s))return null}else{if(!Bt(c)&&!Lt(c))return null;s=c}return Bt(s)&&(s.indexOf("@:")>=0||s.indexOf("@.")>=0)&&(s=this._link(n,e,s,r,"raw",o,i)),this._render(s,a,o,t)},yr.prototype._link=function(n,e,t,r,a,o,i){var s=t,c=s.match(hr);for(var l in c)if(c.hasOwnProperty(l)){var p=c[l],u=p.match(gr),d=u[0],m=u[1],h=p.replace(d,"").replace(fr,"");if(Rt(i,h))return s;i.push(h);var g=this._interpolate(n,e,h,r,"raw"===a?"string":a,"raw"===a?void 0:o,i);if(this._isFallbackRoot(g)){if(!this._root)throw Error("unexpected error");var f=this._root.$i18n;g=f._translate(f._getMessages(),f.locale,f.fallbackLocale,h,r,a,o)}g=this._warnDefault(n,h,g,r,Dt(o)?o:[o],a),this._modifiers.hasOwnProperty(m)?g=this._modifiers[m](g):br.hasOwnProperty(m)&&(g=br[m](g)),i.pop(),s=g?s.replace(p,g):s}return s},yr.prototype._createMessageContext=function(n,e,t,r){var a=this,o=Dt(n)?n:[],i=zt(n)?n:{},s=this._getMessages(),c=this.locale;return{list:function(n){return o[n]},named:function(n){return i[n]},values:n,formatter:e,path:t,messages:s,locale:c,linked:function(n){return a._interpolate(c,s[c]||{},n,null,r,void 0,[n])}}},yr.prototype._render=function(n,e,t,r){if(Lt(n))return n(this._createMessageContext(t,this._formatter||vr,r,e));var a=this._formatter.interpolate(n,t,r);return a||(a=vr.interpolate(n,t,r)),"string"!==e||Bt(a)?a:a.join("")},yr.prototype._appendItemToChain=function(n,e,t){var r=!1;return Rt(n,e)||(r=!0,e&&(r="!"!==e[e.length-1],e=e.replace(/!/g,""),n.push(e),t&&t[e]&&(r=t[e]))),r},yr.prototype._appendLocaleToChain=function(n,e,t){var r,a=e.split("-");do{var o=a.join("-");r=this._appendItemToChain(n,o,t),a.splice(-1,1)}while(a.length&&!0===r);return r},yr.prototype._appendBlockToChain=function(n,e,t){for(var r=!0,a=0;a<e.length&&"boolean"==typeof r;a++){var o=e[a];Bt(o)&&(r=this._appendLocaleToChain(n,o,t))}return r},yr.prototype._getLocaleChain=function(n,e){if(""===n)return[];this._localeChainCache||(this._localeChainCache={});var t=this._localeChainCache[n];if(!t){e||(e=this.fallbackLocale),t=[];for(var r,a=[n];Dt(a);)a=this._appendBlockToChain(t,a,e);(a=Bt(r=Dt(e)?e:zt(e)?e.default?e.default:null:e)?[r]:r)&&this._appendBlockToChain(t,a,null),this._localeChainCache[n]=t}return t},yr.prototype._translate=function(n,e,t,r,a,o,i){for(var s,c=this._getLocaleChain(e,t),l=0;l<c.length;l++){var p=c[l];if(!_t(s=this._interpolate(p,n[p],r,a,o,i,[r])))return s}return null},yr.prototype._t=function(n,e,t,r){for(var a,o=[],i=arguments.length-4;i-- >0;)o[i]=arguments[i+4];if(!n)return"";var s=Ft.apply(void 0,o);this._escapeParameterHtml&&(s.params=$t(s.params));var c=s.locale||e,l=this._translate(t,c,this.fallbackLocale,n,r,"string",s.params);if(this._isFallbackRoot(l)){if(!this._root)throw Error("unexpected error");return(a=this._root).$t.apply(a,[n].concat(o))}return l=this._warnDefault(c,n,l,r,o,"string"),this._postTranslation&&null!=l&&(l=this._postTranslation(l,n)),l},yr.prototype.t=function(n){for(var e,t=[],r=arguments.length-1;r-- >0;)t[r]=arguments[r+1];return(e=this)._t.apply(e,[n,this.locale,this._getMessages(),null].concat(t))},yr.prototype._i=function(n,e,t,r,a){var o=this._translate(t,e,this.fallbackLocale,n,r,"raw",a);if(this._isFallbackRoot(o)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.i(n,e,a)}return this._warnDefault(e,n,o,r,[a],"raw")},yr.prototype.i=function(n,e,t){return n?(Bt(e)||(e=this.locale),this._i(n,e,this._getMessages(),null,t)):""},yr.prototype._tc=function(n,e,t,r,a){for(var o,i=[],s=arguments.length-5;s-- >0;)i[s]=arguments[s+5];if(!n)return"";void 0===a&&(a=1);var c={count:a,n:a},l=Ft.apply(void 0,i);return l.params=Object.assign(c,l.params),i=null===l.locale?[l.params]:[l.locale,l.params],this.fetchChoice((o=this)._t.apply(o,[n,e,t,r].concat(i)),a)},yr.prototype.fetchChoice=function(n,e){if(!n||!Bt(n))return null;var t=n.split("|");return t[e=this.getChoiceIndex(e,t.length)]?t[e].trim():n},yr.prototype.tc=function(n,e){for(var t,r=[],a=arguments.length-2;a-- >0;)r[a]=arguments[a+2];return(t=this)._tc.apply(t,[n,this.locale,this._getMessages(),null,e].concat(r))},yr.prototype._te=function(n,e,t){for(var r=[],a=arguments.length-3;a-- >0;)r[a]=arguments[a+3];var o=Ft.apply(void 0,r).locale||e;return this._exist(t[o],n)},yr.prototype.te=function(n,e){return this._te(n,this.locale,this._getMessages(),e)},yr.prototype.getLocaleMessage=function(n){return Mt(this._vm.messages[n]||{})},yr.prototype.setLocaleMessage=function(n,e){"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||this._checkLocaleMessage(n,this._warnHtmlInMessage,e),this._vm.$set(this._vm.messages,n,e)},yr.prototype.mergeLocaleMessage=function(n,e){"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||this._checkLocaleMessage(n,this._warnHtmlInMessage,e),this._vm.$set(this._vm.messages,n,Ut(void 0!==this._vm.messages[n]&&Object.keys(this._vm.messages[n]).length?Object.assign({},this._vm.messages[n]):{},e))},yr.prototype.getDateTimeFormat=function(n){return Mt(this._vm.dateTimeFormats[n]||{})},yr.prototype.setDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,e),this._clearDateTimeFormat(n,e)},yr.prototype.mergeDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,Ut(this._vm.dateTimeFormats[n]||{},e)),this._clearDateTimeFormat(n,e)},yr.prototype._clearDateTimeFormat=function(n,e){for(var t in e){var r=n+"__"+t;this._dateTimeFormatters.hasOwnProperty(r)&&delete this._dateTimeFormatters[r]}},yr.prototype._localizeDateTime=function(n,e,t,r,a,o){for(var i=e,s=r[i],c=this._getLocaleChain(e,t),l=0;l<c.length;l++){var p=c[l];if(i=p,!_t(s=r[p])&&!_t(s[a]))break}if(_t(s)||_t(s[a]))return null;var u,d=s[a];if(o)u=new Intl.DateTimeFormat(i,Object.assign({},d,o));else{var m=i+"__"+a;(u=this._dateTimeFormatters[m])||(u=this._dateTimeFormatters[m]=new Intl.DateTimeFormat(i,d))}return u.format(n)},yr.prototype._d=function(n,e,t,r){if(!t)return(r?new Intl.DateTimeFormat(e,r):new Intl.DateTimeFormat(e)).format(n);var a=this._localizeDateTime(n,e,this.fallbackLocale,this._getDateTimeFormats(),t,r);if(this._isFallbackRoot(a)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.d(n,t,e)}return a||""},yr.prototype.d=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var r=this.locale,a=null,o=null;return 1===e.length?(Bt(e[0])?a=e[0]:zt(e[0])&&(e[0].locale&&(r=e[0].locale),e[0].key&&(a=e[0].key)),o=Object.keys(e[0]).reduce((function(n,t){var r;return Rt(Et,t)?Object.assign({},n,((r={})[t]=e[0][t],r)):n}),null)):2===e.length&&(Bt(e[0])&&(a=e[0]),Bt(e[1])&&(r=e[1])),this._d(n,r,a,o)},yr.prototype.getNumberFormat=function(n){return Mt(this._vm.numberFormats[n]||{})},yr.prototype.setNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,e),this._clearNumberFormat(n,e)},yr.prototype.mergeNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,Ut(this._vm.numberFormats[n]||{},e)),this._clearNumberFormat(n,e)},yr.prototype._clearNumberFormat=function(n,e){for(var t in e){var r=n+"__"+t;this._numberFormatters.hasOwnProperty(r)&&delete this._numberFormatters[r]}},yr.prototype._getNumberFormatter=function(n,e,t,r,a,o){for(var i=e,s=r[i],c=this._getLocaleChain(e,t),l=0;l<c.length;l++){var p=c[l];if(i=p,!_t(s=r[p])&&!_t(s[a]))break}if(_t(s)||_t(s[a]))return null;var u,d=s[a];if(o)u=new Intl.NumberFormat(i,Object.assign({},d,o));else{var m=i+"__"+a;(u=this._numberFormatters[m])||(u=this._numberFormatters[m]=new Intl.NumberFormat(i,d))}return u},yr.prototype._n=function(n,e,t,r){if(!yr.availabilities.numberFormat)return"";if(!t)return(r?new Intl.NumberFormat(e,r):new Intl.NumberFormat(e)).format(n);var a=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,r),o=a&&a.format(n);if(this._isFallbackRoot(o)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.n(n,Object.assign({},{key:t,locale:e},r))}return o||""},yr.prototype.n=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var r=this.locale,a=null,o=null;return 1===e.length?Bt(e[0])?a=e[0]:zt(e[0])&&(e[0].locale&&(r=e[0].locale),e[0].key&&(a=e[0].key),o=Object.keys(e[0]).reduce((function(n,t){var r;return Rt(Tt,t)?Object.assign({},n,((r={})[t]=e[0][t],r)):n}),null)):2===e.length&&(Bt(e[0])&&(a=e[0]),Bt(e[1])&&(r=e[1])),this._n(n,r,a,o)},yr.prototype._ntp=function(n,e,t,r){if(!yr.availabilities.numberFormat)return[];if(!t)return(r?new Intl.NumberFormat(e,r):new Intl.NumberFormat(e)).formatToParts(n);var a=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,r),o=a&&a.formatToParts(n);if(this._isFallbackRoot(o)){if(!this._root)throw Error("unexpected error");return this._root.$i18n._ntp(n,e,t,r)}return o||[]},Object.defineProperties(yr.prototype,xr),Object.defineProperty(yr,"availabilities",{get:function(){if(!dr){var n="undefined"!=typeof Intl;dr={dateTimeFormat:n&&void 0!==Intl.DateTimeFormat,numberFormat:n&&void 0!==Intl.NumberFormat}}return dr}}),yr.install=rr,yr.version="8.28.2";var wr=yr;
/*!
 * vssue - A vue-powered issue-based comment plugin
 *
 * @version v1.4.8
 * @link https://vssue.js.org
 * @license MIT
 * @copyright 2018-2021 meteorlxy
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function kr(n,e,t,r){var a,o=arguments.length,i=o<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(i=(o<3?a(i):o>3?a(e,t,i):a(e,t))||i);return o>3&&i&&Object.defineProperty(e,t,i),i}var Sr=r.a.extend({name:"Iconfont"});function Cr(n,e,t,r,a,o,i,s,c,l){"boolean"!=typeof i&&(c=s,s=i,i=!1);const p="function"==typeof t?t.options:t;let u;if(n&&n.render&&(p.render=n.render,p.staticRenderFns=n.staticRenderFns,p._compiled=!0,a&&(p.functional=!0)),r&&(p._scopeId=r),o?(u=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),e&&e.call(this,c(n)),n&&n._registeredComponents&&n._registeredComponents.add(o)},p._ssrRegister=u):e&&(u=i?function(n){e.call(this,l(n,this.$root.$options.shadowRoot))}:function(n){e.call(this,s(n))}),u)if(p.functional){const n=p.render;p.render=function(e,t){return u.call(t),n(e,t)}}else{const n=p.beforeCreate;p.beforeCreate=n?[].concat(n,u):[u]}return t}"undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());const jr=Cr({render:function(n,e){var t=e._c;return t("svg",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}]},[t("symbol",{attrs:{id:"vssue-icon-bitbucket",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M579.5522464 489.45249493q4.8371808 38.38537173-30.81752427 61.55702827t-67.95459093 3.66689493q-23.79580907-10.37653333-32.6119616-35.34262826t-0.31207573-50.01020907 31.67573333-35.34262827q21.92335253-11.00068587 44.1587808-7.33379093t39.00952427 21.61127573 16.77409493 41.1160384zM647.19476053 476.65737173q-8.50407573-65.22392427-68.8908192-99.9424t-120.07131413-7.9579424q-38.38537173 17.08617173-61.24495253 53.9111616t-21.0651424 78.95527574q2.41859093 55.4715424 47.20152426 94.48106666t100.87862827 34.1723424q55.4715424-4.8371808 92.60860907-51.18049493t30.50544746-102.43900907zM792.93434133 146.32472427q-12.17097173-16.4620192-34.1723424-27.15062827t-35.34262826-13.41927573-43.30057174-7.64586667q-177.33729493-28.63299093-345.00022826 1.24830507-26.2144 4.29104747-40.25782827 7.33379093t-33.54819093 13.41927573-30.50544747 26.2144q18.2564576 17.08617173 46.34331413 27.6967616t44.78293334 13.41927574 53.36502826 7.02171413q138.95192427 17.71032427 273.06666667 0.62415253 38.38537173-4.8371808 54.53531413-7.33379093t44.1587808-13.1072 45.7191616-28.32091413zM827.65281813 777.10872427q-4.8371808 15.83786667-9.44030506 46.65539093t-8.50407574 51.18049493-17.39824746 42.6764192-35.34262827 34.4064q-52.4288 29.2571424-115.46819093 43.61264747t-123.1140576 13.41927573-122.8019808-11.3127616q-28.0088384-4.8371808-49.69813334-11.00068586t-46.65539093-16.4620192-44.4708576-26.52647574-31.67573333-37.4491424q-15.21371413-58.51428587-34.71847574-177.96144746l3.66689494-9.7523808 11.00068586-5.46133334q135.9091808 90.1900192 308.72137174 90.1900192t309.34552426-90.1900192q12.79512427 3.66689493 14.5895616 14.04342827t-3.0427424 27.46270507-4.8371808 22.54750506zM937.97175147 191.41973333q-15.83786667 101.8148576-67.64251414 399.22346667-3.0427424 18.2564576-16.4620192 34.1723424t-26.52647573 24.3419424-33.23611413 18.88060907q-153.61950507 76.7707424-371.8387808 53.67710506-151.12289493-16.4620192-240.14262827-84.72868586-9.12822827-7.33379093-15.52579093-16.1499424t-10.37653334-21.2992-5.46133333-20.75306667-3.66689493-24.10788587-3.3548192-21.2992q-5.46133333-30.50544747-16.1499424-91.43832426t-17.08617174-98.4600384-14.35550506-89.8779424-13.41927574-96.27550507q1.7944384-15.83786667 10.68860907-29.5692192t19.19268587-22.8595808 27.46270506-18.2564576 28.0088384-13.73135253 29.2571424-11.3127616q76.22460907-28.0088384 190.75657174-39.00952427 231.0144-22.54750507 412.01859093 30.50544747 94.48106667 28.0088384 131.072 74.35215253 9.7523808 12.17097173 10.0644576 31.0515808t-3.3548192 32.9240384z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitea",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M184.31868985 236.10860742C106.94832667 235.94086648 3.32655508 285.13080468 9.02973665 408.46209936c8.93218827 192.65010787 206.32096845 210.5144844 285.20099725 212.06608453 8.63864186 36.14810496 101.48307766 160.77938883 170.21479898 167.32127321h301.09442177c180.57278288-11.99345499 315.77172611-546.07960359 215.54670217-548.09249109-165.7696721 7.79993906-264.02374305 11.74184405-348.27147151 12.41280591v166.69224585l-26.25140843-11.61603761-0.16773997-154.99233728c-96.70246985-0.04193548-181.83083757-4.52899687-343.4069947-12.49667687-20.21274496-0.12580547-48.39316992-3.5644886-78.67035236-3.64835859z m10.94507577 68.14462849h9.22573371c10.98701124 98.75729283 28.85138778 156.50200291 64.99949274 244.73357185-92.25734394-10.90314029-170.75995634-37.69970509-185.18564974-137.75698809-7.46445813-51.78991757 17.69663558-105.84433456 110.96042329-107.01851827z m358.83913087 97.07988723c6.29027343 0.08386999 12.70635233 1.25805468 18.74501482 4.02577499l31.40943263 13.54505513-22.51917887 41.05451824a28.18042496 25.03528825 0 0 0-10.10637297 1.59353561 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 4.69673781 7.29671718l-38.83195528 70.70267333a28.18042496 25.03528825 0 0 0-9.30960467 1.59353659 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 36.06423497 15.09665623 28.18042496 25.03528825 0 0 0 16.94180276-32.08039449 28.18042496 25.03528825 0 0 0-6.62575434-9.22573468l37.82551056-68.85752581a28.18042496 25.03528825 0 0 0 12.28700044-1.25805469 28.18042496 25.03528825 0 0 0 8.93218826-4.69673783c14.59343435 6.12253248 26.54495386 11.11281671 35.14166122 15.34826717 12.91602778 6.37414341 17.48696012 10.60959485 18.87082027 15.30633169 1.38386015 4.61286685-0.12580547 13.50312062-7.42252263 29.10299872-5.45157063 11.61603859-14.46762889 28.09655497-25.11915823 47.51253164a28.18042496 25.03528825 0 0 0-10.52572486 1.59353659 28.18042496 25.03528825 0 0 0-16.98373826 32.038459 28.18042496 25.03528825 0 0 0 36.06423498 15.09665623 28.18042496 25.03528825 0 0 0 16.94180278-32.03845901 28.18042496 25.03528825 0 0 0-5.74511608-8.47090188c10.52572388-19.20630122 19.58371762-35.72875308 25.41270465-48.14155897 7.88380904-16.85793279 11.99345499-29.39654416 8.38703091-41.51580463-3.60642311-12.11926046-14.67730434-20.0030695-29.35460966-27.25785217-9.6450856-4.73867233-21.68047607-9.77089106-36.06423399-15.80955357a28.18042496 25.03528825 0 0 0-1.59353562-10.022502 28.18042496 25.03528825 0 0 0-6.08059796-8.7644483l22.14176246-40.38355541 122.61839638 52.96410227c22.14176247 9.6031511 31.2836262 33.12877372 20.54822685 52.8382968l-84.28966393 154.32137544c-10.77733482 19.66758857-37.23841869 27.80300855-59.38018118 18.24179293l-173.48574115-74.98005927c-22.14176247-9.5612156-31.32556167-33.12877372-20.54822687-52.83829679l84.28966395-154.27943995c7.38058716-13.54505513 22.22563246-21.59660511 37.951317-22.22563246h2.68384935z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitee",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M978.404275 409.561604H455.061338c-25.117645 0-45.499734 20.382089-45.499734 45.499734l-0.031997 113.781333c0 25.117645 20.350092 45.499734 45.499734 45.531731h318.594132c25.117645 0 45.499734 20.382089 45.499734 45.499735v22.749867a136.5312 136.5312 0 0 1-136.5312 136.5312H250.248539a45.499734 45.499734 0 0 1-45.499734-45.499734V341.343999a136.5312 136.5312 0 0 1 136.5312-136.5312L978.308284 204.780802c25.117645 0 45.499734-20.350092 45.499734-45.467738L1023.904009 45.531731h0.031997A45.499734 45.499734 0 0 0 978.468269 0h-0.031997L341.343999 0.031997C152.84967 0.031997 0.031997 152.84967 0.031997 341.343999v637.092273c0 25.117645 20.382089 45.499734 45.499734 45.499734h671.233072a307.171203 307.171203 0 0 0 307.171203-307.171203v-261.671468c0-25.117645-20.382089-45.499734-45.499734-45.499734z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-github",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 20.4425c-278.334 0-504 225.6345-504 504 0 222.6735 144.4275 411.6105 344.673 478.233 25.2 4.662 34.461-10.9305 34.461-24.255 0-12.0015-0.4725-51.723-0.693-93.8385-140.238 30.492-169.8165-59.472-169.8165-59.472-22.932-58.2435-55.944-73.7415-55.944-73.7415-45.738-31.2795 3.465-30.6495 3.465-30.6495 50.589 3.5595 77.238 51.9435 77.238 51.9435 44.9505 77.049 117.9045 54.7785 146.664 41.895 4.5045-32.571 17.577-54.81 32.004-67.41-111.951-12.726-229.635-55.9755-229.635-249.0705 0-55.0305 19.6875-99.981 51.9435-135.2925-5.229-12.6945-22.491-63.945 4.8825-133.371 0 0 42.336-13.545 138.6315 51.66 40.194-11.1825 83.3175-16.758 126.1575-16.9785 42.8085 0.189 85.9635 5.796 126.252 16.9785 96.201-65.205 138.4425-51.66 138.4425-51.66 27.4365 69.426 10.1745 120.6765 4.9455 133.371 32.319 35.28 51.8805 80.262 51.8805 135.2925 0 193.5675-117.9045 236.187-230.139 248.6925 18.081 15.6555 34.1775 46.305 34.1775 93.3345 0 67.4415-0.5985 121.716-0.5985 138.3165 0 13.419 9.072 29.1375 34.6185 24.192 200.151-66.717 344.3895-255.5595 344.3895-478.17 0-278.3655-225.666-504-504-504z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitlab",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M66.61375986 405.11600042L512.11376028 976.03999972 23.84576 621.65599958a39.312 39.312 0 0 1-14.07600042-43.30799944l56.8080007-173.26800028z m259.88400014 0h371.26800014L512.14975986 976.03999972zM215.11376 60.88400042l111.384 344.232H66.61375986l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z m742.49999972 344.232l56.8080007 173.2679993a39.23999986 39.23999986 0 0 1-14.07600042 43.30800042l-488.26800028 354.38400014 445.50000042-570.92400028z m0 0h-259.88400014l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-loading",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M843.307 742.24c0 3.217 2.607 5.824 5.824 5.824s5.824-2.607 5.824-5.824a5.823 5.823 0 0 0-5.824-5.824 5.823 5.823 0 0 0-5.824 5.824zM714.731 874.912c0 6.398 5.186 11.584 11.584 11.584s11.584-5.186 11.584-11.584-5.186-11.584-11.584-11.584-11.584 5.186-11.584 11.584zM541.419 943.2c0 9.614 7.794 17.408 17.408 17.408s17.408-7.794 17.408-17.408-7.794-17.408-17.408-17.408-17.408 7.794-17.408 17.408z m-186.56-9.152c0 12.795 10.373 23.168 23.168 23.168s23.168-10.373 23.168-23.168-10.373-23.168-23.168-23.168-23.168 10.373-23.168 23.168zM189.355 849.12c0 16.012 12.98 28.992 28.992 28.992s28.992-12.98 28.992-28.992-12.98-28.992-28.992-28.992-28.992 12.98-28.992 28.992zM74.731 704.736c0 19.228 15.588 34.816 34.816 34.816s34.816-15.588 34.816-34.816-15.588-34.816-34.816-34.816-34.816 15.588-34.816 34.816z m-43.008-177.28c0 22.41 18.166 40.576 40.576 40.576s40.576-18.166 40.576-40.576-18.166-40.576-40.576-40.576-40.576 18.166-40.576 40.576z m35.392-176.128c0 25.626 20.774 46.4 46.4 46.4s46.4-20.774 46.4-46.4c0-25.626-20.774-46.4-46.4-46.4-25.626 0-46.4 20.774-46.4 46.4z m106.176-142.016c0 28.843 23.381 52.224 52.224 52.224s52.224-23.381 52.224-52.224c0-28.843-23.381-52.224-52.224-52.224-28.843 0-52.224 23.381-52.224 52.224z m155.904-81.344c0 32.024 25.96 57.984 57.984 57.984s57.984-25.96 57.984-57.984-25.96-57.984-57.984-57.984-57.984 25.96-57.984 57.984z m175.104-5.056c0 35.24 28.568 63.808 63.808 63.808s63.808-28.568 63.808-63.808c0-35.24-28.568-63.808-63.808-63.808-35.24 0-63.808 28.568-63.808 63.808z m160.32 72.128c0 38.421 31.147 69.568 69.568 69.568s69.568-31.147 69.568-69.568-31.147-69.568-69.568-69.568-69.568 31.147-69.568 69.568z m113.92 135.488c0 41.638 33.754 75.392 75.392 75.392s75.392-33.754 75.392-75.392-33.754-75.392-75.392-75.392-75.392 33.754-75.392 75.392z m45.312 175.488c0 44.854 36.362 81.216 81.216 81.216s81.216-36.362 81.216-81.216c0-44.854-36.362-81.216-81.216-81.216-44.854 0-81.216 36.362-81.216 81.216z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-like",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 533.7c16.8-22.2 26.1-49.4 26.1-77.7 0-44.9-25.1-87.4-65.5-111.1a67.67 67.67 0 0 0-34.3-9.3H572.4l6-122.9c1.4-29.7-9.1-57.9-29.5-79.4-20.5-21.5-48.1-33.4-77.9-33.4-52 0-98 35-111.8 85.1l-85.9 311H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h601.3c9.2 0 18.2-1.8 26.5-5.4 47.6-20.3 78.3-66.8 78.3-118.4 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7-0.2-12.6-2-25.1-5.6-37.1zM184 852V568h81v284h-81z m636.4-353l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 22.4-13.2 42.6-33.6 51.8H329V564.8l99.5-360.5c5.2-18.9 22.5-32.2 42.2-32.3 7.6 0 15.1 2.2 21.1 6.7 9.9 7.4 15.2 18.6 14.6 30.5l-9.6 198.4h314.4C829 418.5 840 436.9 840 456c0 16.5-7.2 32.1-19.6 43z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-unlike",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 490.3c3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-51.6-30.7-98.1-78.3-118.4-8.3-3.6-17.2-5.4-26.5-5.4H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h129.3l85.8 310.8C372.9 889 418.9 924 470.9 924c29.7 0 57.4-11.8 77.9-33.4 20.5-21.5 31-49.7 29.5-79.4l-6-122.9h239.9c12.1 0 23.9-3.2 34.3-9.3 40.4-23.5 65.5-66.1 65.5-111 0-28.3-9.3-55.5-26.1-77.7zM184 456V172h81v284h-81z m627.2 160.4H496.8l9.6 198.4c0.6 11.9-4.7 23.1-14.6 30.5-6.1 4.5-13.6 6.8-21.1 6.7-19.6-0.1-36.9-13.4-42.2-32.3L329 459.2V172h415.4c20.4 9.2 33.6 29.4 33.6 51.8 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-14 25.5 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 19.1-11 37.5-28.8 48.4z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-heart",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M923 283.6c-13.4-31.1-32.6-58.9-56.9-82.8-24.3-23.8-52.5-42.4-84-55.5-32.5-13.5-66.9-20.3-102.4-20.3-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5-24.4 23.9-43.5 51.7-56.9 82.8-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3 0.1-35.3-7-69.6-20.9-101.9zM512 814.8S156 586.7 156 385.5C156 283.6 240.3 201 344.3 201c73.1 0 136.5 40.8 167.7 100.4C543.2 241.8 606.6 201 679.7 201c104 0 188.3 82.6 188.3 184.5 0 201.2-356 429.3-356 429.3z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-edit",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M723.2 917.76H286.72c-65.28 0-118.4-51.2-118.4-113.92V261.76C168.32 198.4 221.44 147.2 286.72 147.2h375.04c17.92 0 32 14.08 32 32s-14.08 32-32 32H286.72c-30.08 0-54.4 22.4-54.4 49.92v542.08c0 27.52 24.32 49.92 54.4 49.92H723.2c30.08 0 54.4-22.4 54.4-49.92V440.32c0-17.92 14.08-32 32-32s32 14.08 32 32v363.52c0 62.72-53.12 113.92-118.4 113.92z"}}),e._v(" "),t("path",{attrs:{d:"M499.84 602.24c-7.68 0-14.72-2.56-21.12-7.68-13.44-11.52-14.72-32-3.2-45.44L780.16 198.4c11.52-13.44 32-14.72 45.44-3.2s14.72 32 3.2 45.44L524.16 591.36c-6.4 7.04-15.36 10.88-24.32 10.88z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-delete",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M677.647059 256l0-90.352941c0-37.436235-23.461647-60.235294-61.771294-60.235294L408.094118 105.411765c-38.249412 0-61.741176 22.799059-61.741176 60.235294l0 90.352941-180.705882 0 0 60.235294 60.235294 0 0 512c0 54.272 33.972706 90.352941 90.352941 90.352941l391.529412 0c55.085176 0 90.352941-33.490824 90.352941-90.352941l0-512 60.235294 0 0-60.235294L677.647059 256zM406.588235 165.647059l210.823529 0-1.264941 90.352941L406.588235 256 406.588235 165.647059zM737.882353 858.352941l-451.764706 0 0-542.117647 451.764706 0L737.882353 858.352941zM466.823529 376.470588l-58.729412 0-1.505882 391.529412 60.235294 0L466.823529 376.470588zM617.411765 376.470588l-60.235294 0 0 391.529412 60.235294 0L617.411765 376.470588z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-reply",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M426.666667 384 426.666667 213.333333 128 512 426.666667 810.666667 426.666667 635.733333C640 635.733333 789.333333 704 896 853.333333 853.333333 640 725.333333 426.666667 426.666667 384Z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-error",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 720m-48 0a48 48 0 1 0 96 0 48 48 0 1 0-96 0Z"}}),e._v(" "),t("path",{attrs:{d:"M480 416v184c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V416c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8z"}}),e._v(" "),t("path",{attrs:{d:"M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48z m-783.5-27.9L512 239.9l339.8 588.2H172.2z"}})])])},staticRenderFns:[]},void 0,Sr,void 0,!0,void 0,!1,void 0,void 0,void 0);const Ar=Cr({},void 0,r.a.extend({name:"TransitionFade",functional:!0,props:{group:{type:Boolean,required:!1,default:!1},tag:{type:String,required:!1,default:"div"}},render:(n,{props:e,children:t})=>n(e.group?"TransitionGroup":"Transition",{props:{name:"fade",mode:"out-in",appear:!0,tag:e.tag}},t)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);const Tr=Cr({},void 0,r.a.extend({name:"VssueIcon",functional:!0,props:{name:{type:String,required:!0},title:{type:String,required:!1,default:null}},render:(n,{props:e,data:t})=>n("svg",Object.assign(Object.assign({},t),{class:["vssue-icon","vssue-icon-"+e.name],attrs:{"aria-hidden":"true"}}),[n("title",e.title),n("use",{attrs:{"xlink:href":"#vssue-icon-"+e.name}})])}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let Er=class extends r.a{constructor(){super(...arguments),this.editMode=!1,this.editContent=this.comment.contentRaw,this.creatingReactions=[],this.isPutingComment=!1,this.isDeletingComment=!1}get currentUser(){return this.vssue.user?this.vssue.user.username:null}get content(){return this.comment.content}get author(){return this.comment.author}get createdAt(){return Ct(this.comment.createdAt)}get updatedAt(){return Ct(this.comment.updatedAt)}get showReactions(){return Boolean(this.vssue.API&&this.vssue.API.platform.meta.reactable&&this.comment.reactions&&!this.editMode)}get reactionKeys(){return["heart","like","unlike"]}get editContentRows(){return this.editContent.split("\n").length-1}get editInputRows(){return this.editContentRows<3?5:this.editContentRows+2}async postReaction({reaction:n}){try{if(this.creatingReactions.includes(n))return;this.creatingReactions.push(n);await this.vssue.postCommentReaction({commentId:this.comment.id,reaction:n})||this.vssue.$emit("error",new Error(this.vssue.$t("reactionGiven",{reaction:this.vssue.$t(n)})));const e=await this.vssue.getCommentReactions({commentId:this.comment.id});e&&(this.comment.reactions=e)}finally{this.creatingReactions.splice(this.creatingReactions.findIndex(e=>e===n),1)}}enterEdit(){this.editMode=!0,this.$nextTick(()=>{this.$refs.input.focus()})}resetEdit(){this.editMode=!1,this.editContent=this.comment.contentRaw}async putComment(){try{if(this.vssue.isPending)return;if(this.editContent!==this.comment.contentRaw){this.isPutingComment=!0,this.vssue.isUpdatingComment=!0;const n=await this.vssue.putComment({commentId:this.comment.id,content:this.editContent});n&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1,n)}this.editMode=!1}finally{this.isPutingComment=!1,this.vssue.isUpdatingComment=!1}}async deleteComment(){try{if(this.vssue.isPending)return;if(!window.confirm(this.vssue.$t("deleteConfirm")))return;this.isDeletingComment=!0,this.vssue.isUpdatingComment=!0;await this.vssue.deleteComment({commentId:this.comment.id})?(this.vssue.comments.count-=1,this.vssue.comments.data.length>1&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1),this.vssue.query.page>1&&this.vssue.query.page>Math.ceil(this.vssue.comments.count/this.vssue.query.perPage)?this.vssue.query.page-=1:await this.vssue.getComments()):this.vssue.$emit("error",new Error(this.vssue.$t("deleteFailed")))}finally{this.isDeletingComment=!1,this.vssue.isUpdatingComment=!1}}};kr([ft({type:Object,required:!0})],Er.prototype,"comment",void 0),kr([lt()],Er.prototype,"vssue",void 0),Er=kr([ct({components:{VssueIcon:Tr}})],Er);const Pr=Cr({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-comment",class:{"vssue-comment-edit-mode":n.editMode,"vssue-comment-disabled":n.isDeletingComment||n.isPutingComment}},[t("div",{staticClass:"vssue-comment-avatar"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:n.author.avatar,alt:n.author.username}})])]),n._v(" "),t("div",{staticClass:"vssue-comment-body"},[n._t("body",[t("div",{staticClass:"vssue-comment-header"},[t("span",{staticClass:"vssue-comment-author"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n            "+n._s(n.author.username)+"\n          ")])]),n._v(" "),t("span",{staticClass:"vssue-comment-created-at"},[n._v("\n          "+n._s(n.createdAt)+"\n        ")])]),n._v(" "),t("div",{staticClass:"vssue-comment-main"},[n.editMode?t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.editContent,expression:"editContent"}],ref:"input",staticClass:"vssue-edit-comment-input",attrs:{rows:n.editInputRows},domProps:{value:n.editContent},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.putComment():null},input:function(e){e.target.composing||(n.editContent=e.target.value)}}}):t("article",{staticClass:"markdown-body",domProps:{innerHTML:n._s(n.content)}})]),n._v(" "),t("div",{staticClass:"vssue-comment-footer"},[n.editMode?t("span",{staticClass:"vssue-comment-hint"},[n._v("\n          "+n._s(n.vssue.$t("editMode"))+"\n        ")]):n._e(),n._v(" "),n.showReactions?t("span",{staticClass:"vssue-comment-reactions"},n._l(n.reactionKeys,(function(e){return t("span",{key:e,staticClass:"vssue-comment-reaction",attrs:{title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)},on:{click:function(t){return n.postReaction({reaction:e})}}},[t("VssueIcon",{attrs:{name:n.creatingReactions.includes(e)?"loading":e,title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)}}),n._v(" "),t("span",{staticClass:"vssue-comment-reaction-number"},[n._v("\n              "+n._s(n.comment.reactions[e])+"\n            ")])],1)})),0):n._e(),n._v(" "),t("span",{staticClass:"vssue-comment-operations"},[n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation",class:{"vssue-comment-operation-muted":n.isPutingComment},attrs:{title:n.vssue.$t(n.isPutingComment?"loading":"submit")},on:{click:function(e){return n.putComment()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.isPutingComment,expression:"isPutingComment"}],attrs:{name:"loading",title:n.vssue.$t("loading")}}),n._v("\n\n            "+n._s(n.vssue.$t("submit"))+"\n          ")],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation vssue-comment-operation-muted",attrs:{title:n.vssue.$t("cancel")},on:{click:function(e){return n.resetEdit()}}},[n._v("\n            "+n._s(n.vssue.$t("cancel"))+"\n          ")]):n._e(),n._v(" "),n.comment.author.username===n.currentUser?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.enterEdit()}}},[t("VssueIcon",{attrs:{name:"edit",title:n.vssue.$t("edit")}})],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser||n.vssue.isAdmin?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.deleteComment()}}},[t("VssueIcon",{attrs:{name:n.isDeletingComment?"loading":"delete",title:n.vssue.$t(n.isDeletingComment?"loading":"delete")}})],1):n._e(),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.vssue.$emit("reply-comment",n.comment)}}},[t("VssueIcon",{attrs:{name:"reply",title:n.vssue.$t("reply")}})],1)])])])],2)])},staticRenderFns:[]},void 0,Er,void 0,!1,void 0,!1,void 0,void 0,void 0);let Dr=class extends r.a{get disabled(){return this.vssue.isPending}get pageCount(){const n=Math.ceil(this.vssue.comments.count/this.vssue.comments.perPage);return n>1?n:1}get perPageOptions(){const n=[5,10,20,50];return!n.includes(this.vssue.options.perPage)&&this.vssue.options.perPage<100&&n.push(this.vssue.options.perPage),n.sort((n,e)=>n-e)}get page(){return this.vssue.query.page>this.pageCount?this.pageCount:this.vssue.query.page}set page(n){n>0&&n<=this.pageCount&&(this.vssue.query.page=n)}get perPage(){return this.vssue.query.perPage}set perPage(n){this.perPageOptions.includes(n)&&(this.vssue.query.perPage=n)}};kr([lt()],Dr.prototype,"vssue",void 0),Dr=kr([ct({components:{VssueIcon:Tr}})],Dr);const zr=Cr({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-pagination"},[t("div",{staticClass:"vssue-pagination-per-page"},[t("label",[t("select",{directives:[{name:"model",rawName:"v-model",value:n.perPage,expression:"perPage"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.perPage=e.target.multiple?t:t[0]}}},n._l(n.perPageOptions,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n          "+n._s(e)+"\n        ")])})),0),n._v(" "),t("span",[n._v("\n        "+n._s(n.vssue.$t("perPage"))+"\n      ")])]),n._v(" "),n.vssue.API.platform.meta.sortable?t("span",{class:{"vssue-pagination-link":!0,disabled:n.disabled},attrs:{title:n.vssue.$t("sort")},on:{click:function(e){n.vssue.query.sort="asc"===n.vssue.query.sort?"desc":"asc"}}},[n._v("\n      "+n._s("asc"===n.vssue.query.sort?"↑":"↓")+"\n    ")]):n._e()]),n._v(" "),t("div",{staticClass:"vssue-pagination-page"},[t("span",{class:{"vssue-pagination-link":!0,disabled:1===n.page||n.disabled},attrs:{title:n.vssue.$t("prev")},domProps:{textContent:n._s("<")},on:{click:function(e){n.page-=1}}}),n._v(" "),t("label",[t("span",[n._v("\n        "+n._s(n.vssue.$t("page"))+"\n      ")]),n._v(" "),t("select",{directives:[{name:"show",rawName:"v-show",value:n.pageCount>1,expression:"pageCount > 1"},{name:"model",rawName:"v-model",value:n.page,expression:"page"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.page=e.target.multiple?t:t[0]}}},n._l(n.pageCount,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n          "+n._s(e)+"\n        ")])})),0),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.pageCount<2,expression:"pageCount < 2"}],domProps:{textContent:n._s(n.page)}}),n._v(" "),t("span",{domProps:{textContent:n._s(" / "+n.pageCount+" ")}})]),n._v(" "),t("span",{class:{"vssue-pagination-link":!0,disabled:n.page===n.pageCount||n.disabled},attrs:{title:n.vssue.$t("next")},domProps:{textContent:n._s(">")},on:{click:function(e){n.page+=1}}})])])},staticRenderFns:[]},void 0,Dr,void 0,!1,void 0,!1,void 0,void 0,void 0);let Br=class extends r.a{};kr([lt()],Br.prototype,"vssue",void 0),Br=kr([ct({components:{TransitionFade:Ar,VssueComment:Pr,VssuePagination:zr}})],Br);const Ir=Cr({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue-comments"},[e("VssuePagination"),this._v(" "),e("TransitionFade",{attrs:{group:""}},this._l(this.vssue.comments.data,(function(n){return e("VssueComment",{key:n.id,attrs:{comment:n}})})),1),this._v(" "),e("VssuePagination",{directives:[{name:"show",rawName:"v-show",value:this.vssue.comments.data.length>5,expression:"vssue.comments.data.length > 5"}]})],1)},staticRenderFns:[]},void 0,Br,void 0,!1,void 0,!1,void 0,void 0,void 0);const Or=Cr({},void 0,r.a.extend({name:"VssueIcon",functional:!0,props:{type:{type:String,required:!1,default:"default"}},render:(n,{props:e,data:t,children:r})=>n("button",Object.assign(Object.assign({},t),{class:["vssue-button","vssue-button-"+e.type]}),r)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let _r=class extends r.a{constructor(){super(...arguments),this.content=""}get user(){return this.vssue.user}get platform(){return this.vssue.API&&this.vssue.API.platform.name}get isInputDisabled(){return this.loading||null===this.user||null===this.vssue.issue}get isSubmitDisabled(){return""===this.content||this.vssue.isPending||null===this.vssue.issue}get loading(){return this.vssue.isCreatingComment}get contentRows(){return this.content.split("\n").length-1}get inputRows(){return this.contentRows<3?5:this.contentRows+2}created(){this.vssue.$on("reply-comment",n=>{const e=n.contentRaw.replace(/\n/g,"\n> "),t=`@${n.author.username}\n\n> ${e}\n\n`;this.content=this.content.concat(t),this.focus()})}beforeDestroy(){this.vssue.$off("reply-comment")}focus(){this.$refs.input.focus()}async submit(){this.isSubmitDisabled||(await this.vssue.postComment({content:this.content}),this.content="",await this.vssue.getComments())}};kr([lt()],_r.prototype,"vssue",void 0),_r=kr([ct({components:{VssueButton:Or,VssueIcon:Tr}})],_r);const Lr=Cr({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-new-comment"},[t("div",{staticClass:"vssue-comment-avatar"},[n.user?t("a",{attrs:{href:n.user.homepage,title:n.user.username,target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:n.user.avatar,alt:n.user.username}})]):t("VssueIcon",{attrs:{name:n.platform.toLowerCase(),title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}})],1),n._v(" "),t("div",{staticClass:"vssue-new-comment-body"},[t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.content,expression:"content"}],ref:"input",staticClass:"vssue-new-comment-input",attrs:{rows:n.inputRows,disabled:n.isInputDisabled,placeholder:n.vssue.$t(n.user?"placeholder":"noLoginPlaceHolder"),spellcheck:!1,"aria-label":"leave a comment"},domProps:{value:n.content},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.submit():null},input:function(e){e.target.composing||(n.content=e.target.value)}}})]),n._v(" "),t("div",{staticClass:"vssue-new-comment-footer"},[n.user?t("span",{staticClass:"vssue-current-user"},[t("span",[n._v(n._s(n.vssue.$t("currentUser"))+" - "+n._s(n.user.username)+" - ")]),n._v(" "),t("a",{staticClass:"vssue-logout",on:{click:function(e){return n.vssue.logout()}}},[n._v("\n        "+n._s(n.vssue.$t("logout"))+"\n      ")])]):t("span",{staticClass:"vssue-current-user"},[n._v("\n      "+n._s(n.vssue.$t("loginToComment",{platform:n.platform}))+"\n    ")]),n._v(" "),t("div",{staticClass:"vssue-new-comment-operations"},[n.user?t("VssueButton",{staticClass:"vssue-button-submit-comment",attrs:{type:"primary",disabled:n.isSubmitDisabled},on:{click:function(e){return n.submit()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.loading,expression:"loading"}],attrs:{name:"loading"}}),n._v("\n\n        "+n._s(n.vssue.$t(n.loading?"submitting":"submitComment"))+"\n      ")],1):t("VssueButton",{staticClass:"vssue-button-login",attrs:{type:"primary",title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}},[n._v("\n        "+n._s(n.vssue.$t("login",{platform:n.platform}))+"\n      ")])],1)])])},staticRenderFns:[]},void 0,_r,void 0,!1,void 0,!1,void 0,void 0,void 0);let Fr=class extends r.a{constructor(){super(...arguments),this.progress={show:!1,percent:0,timer:null,speed:200},this.alert={show:!1,message:null,timer:null}}onLoadingCommentsChange(n){this.vssue.comments&&(n?this.progressStart():this.progressDone())}created(){this.vssue.$on("error",n=>this.alertShow(n.message))}beforeDestroy(){this.vssue.$off("error"),null!==this.progress.timer&&window.clearTimeout(this.progress.timer),null!==this.alert.timer&&window.clearTimeout(this.alert.timer)}progressStart(){this.progress.show=!0,this.progress.percent=0,this.progress.timer=window.setInterval(()=>{this.progress.percent+=5,this.progress.percent>94&&null!==this.progress.timer&&window.clearInterval(this.progress.timer)},this.progress.speed)}progressDone(){this.progress.percent=100,null!==this.progress.timer&&window.clearTimeout(this.progress.timer),this.progress.timer=null,window.setTimeout(()=>{this.progress.show=!1},this.progress.speed)}alertShow(n){this.alert.show=!0,this.alert.message=n,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=window.setTimeout(()=>{this.alertHide()},3e3)}alertHide(){this.alert.show=!1,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=null}};kr([lt()],Fr.prototype,"vssue",void 0),kr([bt("vssue.isLoadingComments")],Fr.prototype,"onLoadingCommentsChange",null),Fr=kr([ct({components:{TransitionFade:Ar}})],Fr);const Mr=Cr({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-notice"},[t("div",{directives:[{name:"show",rawName:"v-show",value:n.progress.show,expression:"progress.show"}],staticClass:"vssue-progress",style:{width:n.progress.percent+"%",transition:"all "+n.progress.speed+"ms linear"}}),n._v(" "),t("TransitionFade",[t("div",{directives:[{name:"show",rawName:"v-show",value:n.alert.show,expression:"alert.show"}],staticClass:"vssue-alert",domProps:{textContent:n._s(n.alert.message)},on:{click:function(e){return n.alertHide()}}})])],1)},staticRenderFns:[]},void 0,Fr,void 0,!1,void 0,!1,void 0,void 0,void 0);let Rr=class extends r.a{get status(){return this.vssue.isFailed?"failed":this.vssue.isInitializing?"initializing":this.vssue.isIssueNotCreated&&!this.vssue.isCreatingIssue?this.vssue.isAdmin||!this.vssue.isLogined?"issueNotCreated":"failed":this.vssue.isLoginRequired?"loginRequired":!this.vssue.comments||this.vssue.isCreatingIssue?"loadingComments":0===this.vssue.comments.data.length?"noComments":null}handleClick(){"issueNotCreated"===this.status?this.vssue.postIssue():"loginRequired"===this.status&&this.vssue.login()}};kr([lt()],Rr.prototype,"vssue",void 0),Rr=kr([ct({components:{TransitionFade:Ar,VssueIcon:Tr}})],Rr);const Nr=Cr({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("TransitionFade",[n.status?t("div",{key:n.status,staticClass:"vssue-status"},[["failed","loadingComments","initializing"].includes(n.status)?t("VssueIcon",{attrs:{name:"failed"===n.status?"error":"loading"}}):n._e(),n._v(" "),t("p",{staticClass:"vssue-status-info"},[t(["issueNotCreated","loginRequired"].includes(n.status)?"a":"span",{tag:"Component",on:{click:n.handleClick}},[n._v("\n        "+n._s(n.vssue.$t(n.status))+"\n      ")])],1)],1):n._e()])},staticRenderFns:[]},void 0,Rr,void 0,!1,void 0,!1,void 0,void 0,void 0);let qr=class extends r.a{};kr([lt()],qr.prototype,"vssue",void 0),qr=kr([ct({components:{TransitionFade:Ar,VssueIcon:Tr,VssueComments:Ir,VssueNewComment:Lr,VssueNotice:Mr,VssueStatus:Nr}})],qr);const Ur=Cr({render:function(){var n=this.$createElement,e=this._self._c||n;return e("TransitionFade",[this.vssue.isInitializing?e("VssueStatus"):e("div",{staticClass:"vssue-body"},[this.vssue.API?e("VssueNewComment"):this._e(),this._v(" "),e("VssueNotice"),this._v(" "),e("TransitionFade",[this.vssue.comments&&this.vssue.comments.data.length>0?e("VssueComments"):e("VssueStatus")],1)],1)],1)},staticRenderFns:[]},void 0,qr,void 0,!1,void 0,!1,void 0,void 0,void 0);let Hr=class extends r.a{};kr([lt()],Hr.prototype,"vssue",void 0),Hr=kr([ct],Hr);const $r=Cr({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-header"},[t("a",{staticClass:"vssue-header-comments-count",attrs:{href:n.vssue.issue?n.vssue.issue.link:null,target:"_blank",rel:"noopener noreferrer"}},[t("span",[n._v("\n      "+n._s(n.vssue.comments?n.vssue.$tc("comments",n.vssue.comments.count,{count:n.vssue.comments.count}):n.vssue.$tc("comments",0))+"\n    ")])]),n._v(" "),t("span",{staticClass:"vssue-header-powered-by"},[t("span",[n._v("Powered by")]),n._v(" "),n.vssue.API?t("span",[t("a",{attrs:{href:n.vssue.API.platform.link,title:n.vssue.API.platform.name+" API "+n.vssue.API.platform.version,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n        "+n._s(n.vssue.API.platform.name)+"\n      ")]),n._v(" "),t("span",[n._v("&")])]):n._e(),n._v(" "),t("a",{attrs:{href:"https://github.com/meteorlxy/vssue",title:"Vssue v"+n.vssue.version,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n      Vssue\n    ")])])])},staticRenderFns:[]},void 0,Hr,void 0,!1,void 0,!1,void 0,void 0,void 0),Jr={login:"Login with {platform}",logout:"Logout",currentUser:"Current User",loading:"Loading",submit:"Submit",submitting:"Submitting",submitComment:"Submit Comment",cancel:"Cancel",edit:"Edit",editMode:"Edit Mode",delete:"Delete",reply:"Reply",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comments per page",sort:"Click to change the sort direction",page:"Page",prev:"Previous Page",next:"Next Page",comments:"Comments | {count} Comment | {count} Comments",loginToComment:"Login with {platform} account to leave a comment",placeholder:"Leave a comment. Styling with Markdown is supported. Ctrl + Enter to submit.",noLoginPlaceHolder:"Login to leave a comment. Styling with Markdown is supported. ",failed:"Failed to load comments",initializing:"Initializing...",issueNotCreated:"Click to create issue",loadingComments:"Loading comments...",loginRequired:"Login to view comments",noComments:"No comments yet. Leave the first comment !",reactionGiven:"Already given '{reaction}' reaction",deleteConfirm:"Confirm to delete this comment ?",deleteFailed:"Failed to delete comment"},Vr={login:"使用 {platform} 登录",logout:"退出登录",currentUser:"当前用户",loading:"加载中",submit:"提交",submitting:"发表中",submitComment:"发表评论",cancel:"取消",edit:"编辑",editMode:"编辑模式",delete:"删除",reply:"回复",heart:"喜欢",like:"赞",unlike:"踩",perPage:"每页评论数",sort:"点击改变排序方式",page:"页数",prev:"上一页",next:"下一页",comments:"评论 | {count} 条评论 | {count} 条评论",loginToComment:"使用 {platform} 帐号登录后发表评论",placeholder:"留下你的评论丨支持 Markdown 语法丨Ctrl + Enter 发表评论",noLoginPlaceHolder:"登录后才能发表评论丨支持 Markdown 语法",failed:"评论加载失败",initializing:"正在初始化...",issueNotCreated:"点击创建 Issue",loadingComments:"正在加载评论...",loginRequired:"登录后查看评论",noComments:"还没有评论，来发表第一条评论吧！",reactionGiven:"已经添加过 '{reaction}' 了",deleteConfirm:"确认要删除该评论吗？",deleteFailed:"评论删除失败"},Wr={login:"Entrar com {platform}",logout:"Sair",currentUser:"Usuário Atual",loading:"Carregando",submit:"Enviar",submitting:"Enviando",submitComment:"Enviar Comentário",cancel:"Cancelar",edit:"Editar",editMode:"Modo de Edição",delete:"Apagar",reply:"Responder",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comentários por página",sort:"Clique para alterar a ordenação",page:"Página",prev:"Página Anterior",next:"Próxima Página",comments:"Comentários | {count} Comentário | {count} Comentários",loginToComment:"Entre com uma conta {platform} para deixar um comentário",placeholder:"Deixe um comentário. Estilos com Markdown suportados. Ctrl + Enter para enviar.",noLoginPlaceHolder:"Entre para deixar um comentário. Estilos com Markdown suportados. ",failed:"Falha ao carregar comentários",initializing:"Inicializando...",issueNotCreated:"Click to create issue",loadingComments:"Carregando comentários...",loginRequired:"Entrar para visualizar comentários",noComments:"Nenhum comentário. Deixe o primeiro comentário!",reactionGiven:"Já reagiu com '{reaction}'",deleteConfirm:"Apagar este comentário?",deleteFailed:"Falha ao apagar comentário"},Qr={login:"{platform} でログイン",logout:"ログアウト",currentUser:"現在のユーザー",loading:"読み込み中",submit:"送信",submitting:"送信中",submitComment:"コメントを送信",cancel:"キャンセル",edit:"編集",editMode:"編集モード",delete:"削除",reply:"返信",heart:"ハート",like:"高評価",unlike:"低評価",perPage:"コメント/ページ",sort:"並び順を変更するにはクリックしてください",page:"ページ",prev:"前のページ",next:"次のページ",comments:"コメント | {count} コメント | {count} コメント",loginToComment:"コメントを残すには {platform} アカウントでログインしてください。",placeholder:"コメントを残してください。Markdown 記法をサポートしています。 Ctrl + Enter で送信できます。",noLoginPlaceHolder:"コメントを残すにはログインしてください。マークダウン記法をサポートしています。",failed:"コメントの読み込みに失敗しました",initializing:"初期化中...",issueNotCreated:"Click to create issue",loadingComments:"コメントの読み込み中...",loginRequired:"コメントを見るにはログインしてください",noComments:"まだコメントがありません。最初のコメントを残しましょう！",reactionGiven:"既に '{reaction}' のリアクションをしています",deleteConfirm:"本当にコメントを削除してもいいですか？",deleteFailed:"コメントの削除に失敗しました"},Kr={login:"התחברו עם {platform}",logout:"התנתקו",currentUser:"משתמש/ת נוכחי/ת",loading:"טוען",submit:"שליחה",submitting:"שולח",submitComment:"שליחת תגובה",cancel:"ביטל",edit:"עריכה",editMode:"מצב עריכה",delete:"מחיקה",reply:"תשובה",heart:"לב",like:"לייק",unlike:"אנלייק",perPage:"תגובות לדף",sort:"לחצו כדי לשנות את כיוון המיון",page:"דף",prev:"הדף הקודם",next:"הדף הבא",comments:"תגובות | {count} תגובה | {count} תגובות",loginToComment:"התחברו עם חשבון {platform} כדי להשאיר תגובה",placeholder:"השאירו תגובה. יש תמיכה בעיצוב בעזרת Markdown. Ctrl + Enter כדי לשלוח.",noLoginPlaceHolder:"התחברו כדי להשאיר תגובה. יש תמיכה בעיצוב בעזרת Markdown. ",failed:"כשלון בטעינת התגובות",initializing:"מאתחל...",issueNotCreated:"לחצו ליצירת issue",loadingComments:"טוען תגובות...",loginRequired:"התחברו כדי לצפות בתגובות",noComments:"עדיין אין תגובות. השאירו תגובה ראשונה !",reactionGiven:"כבר ניתן חיווי '{reaction}'",deleteConfirm:"בטוחים במחיקת התגובה ?",deleteFailed:"כשלון במחיקת התגובה"};Object.prototype.hasOwnProperty.call(r.a,"$i18n")||r.a.use(wr);const Gr=new wr({locale:"en",fallbackLocale:"en",messages:{en:Jr,"en-US":Jr,zh:Vr,"zh-CN":Vr,pt:Wr,"pt-BR":Wr,ja:Qr,"ja-JP":Qr,he:Kr,"he-IL":Kr}});let Xr=class extends r.a{constructor(){super(...arguments),this.title=n=>`${n.prefix}${document.title}`,this.issueId=null,this.options=null,this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:10,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1}get version(){return"1.4.8"}get issueTitle(){return null===this.options?"":"function"==typeof this.title?this.title(this.options):`${this.options.prefix}${this.title}`}get isPending(){return this.isLoadingComments||this.isCreatingComment||this.isUpdatingComment}get isLogined(){return null!==this.accessToken&&null!==this.user}get isAdmin(){return null!==this.options&&null!==this.accessToken&&null!==this.user&&(this.user.username===this.options.owner||this.options.admins.includes(this.user.username))}get accessTokenKey(){return this.API?`Vssue.${this.API.platform.name.toLowerCase()}.access_token`:""}onQueryPerPageChange(){this.query.page=1,this.getComments()}onQueryChange(){this.getComments()}setOptions(n){this.options=Object.assign({labels:["Vssue"],state:"Vssue",prefix:"[Vssue]",admins:[],perPage:10,proxy:n=>"https://cors-anywhere.azm.workers.dev/"+n,issueContent:({url:n})=>n,autoCreateIssue:!1},n);const e=["api","owner","repo","clientId"];for(const n of e)this.options[n]||console.warn(`[Vssue] the option '${n}' is required`);if(this.options.locale)this.$i18n.locale=this.options.locale;else{const n=Object.keys(this.$i18n.messages),e=window.navigator.languages;this.$i18n.locale=e.filter(e=>n.includes(e)).shift()||"en"}}async init(){try{await this.initStore(),await this.initComments()}catch(n){n.response&&[401,403].includes(n.response.status)?this.isLoginRequired=!0:this.isFailed=!0,console.error(n)}}async initStore(){try{if(!this.options)throw new Error("Options are required to initialize Vssue");this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:this.options.perPage,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1;const n=this.options.api;this.API=new n({baseURL:this.options.baseURL,labels:this.options.labels,state:this.options.state,owner:this.options.owner,repo:this.options.repo,clientId:this.options.clientId,clientSecret:this.options.clientSecret,proxy:this.options.proxy}),await this.handleAuth()}finally{this.isInitializing=!1}}async initComments(){if(this.API&&this.options)if(this.issueId){const[n,e]=await Promise.all([this.API.getIssue({accessToken:this.accessToken,issueId:this.issueId}),this.API.getComments({accessToken:this.accessToken,issueId:this.issueId,query:this.query})]);this.issue=n,this.comments=e}else this.issue=await this.API.getIssue({accessToken:this.accessToken,issueTitle:this.issueTitle}),null===this.issue?(this.isIssueNotCreated=!0,this.options.autoCreateIssue&&await this.postIssue()):await this.getComments()}async postIssue(){if(this.API&&this.options&&!this.issue&&!this.issueId&&(this.isLogined||this.login(),this.isAdmin))try{this.isCreatingIssue=!0;const n=await this.API.postIssue({title:this.issueTitle,content:await this.options.issueContent({options:this.options,url:jt(window.location.href)}),accessToken:this.accessToken});this.issue=n,this.isIssueNotCreated=!1,await this.getComments()}catch(n){this.isFailed=!0}finally{this.isCreatingIssue=!1}}async getComments(){try{if(!this.API||!this.issue||this.isLoadingComments)return;this.isLoadingComments=!0;const n=await this.API.getComments({accessToken:this.accessToken,issueId:this.issue.id,query:this.query});return this.comments=n,this.query.page!==n.page&&(this.query.page=n.page),this.query.perPage!==n.perPage&&(this.query.perPage=n.perPage),n}catch(n){if(!n.response||![401,403].includes(n.response.status)||this.isLogined)throw this.$emit("error",n),n;this.isLoginRequired=!0}finally{this.isLoadingComments=!1}}async postComment({content:n}){try{if(!this.API||!this.issue||this.isCreatingComment)return;this.isCreatingComment=!0;return await this.API.postComment({accessToken:this.accessToken,content:n,issueId:this.issue.id})}catch(n){throw this.$emit("error",n),n}finally{this.isCreatingComment=!1}}async putComment({commentId:n,content:e}){try{if(!this.API||!this.issue)return;return await this.API.putComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,content:e})}catch(n){throw this.$emit("error",n),n}}async deleteComment({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.deleteComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async getCommentReactions({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.getCommentReactions({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async postCommentReaction({commentId:n,reaction:e}){try{if(!this.API||!this.issue)return!1;return await this.API.postCommentReaction({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,reaction:e})}catch(n){throw this.$emit("error",n),n}}login(){this.API&&this.API.redirectAuth()}logout(){this.setAccessToken(null),this.user=null}async handleAuth(){if(!this.API)return;const n=await this.API.handleAuth();n?(this.setAccessToken(n),this.user=await this.API.getUser({accessToken:n})):this.getAccessToken()?this.user=await this.API.getUser({accessToken:this.accessToken}):(this.setAccessToken(null),this.user=null)}getAccessToken(){return this.accessToken=window.localStorage.getItem(this.accessTokenKey),this.accessToken}setAccessToken(n){null===n?window.localStorage.removeItem(this.accessTokenKey):window.localStorage.setItem(this.accessTokenKey,n),this.accessToken=n}};kr([bt("query.perPage")],Xr.prototype,"onQueryPerPageChange",null),kr([bt("query.page"),bt("query.sort")],Xr.prototype,"onQueryChange",null),Xr=kr([ct({i18n:Gr})],Xr);var Zr=Xr;let Yr=class extends r.a{constructor(){super(...arguments),this.vssue=new Zr}onOptionsChange(n){this.vssue.setOptions(n)}mounted(){null!==this.title&&(this.vssue.title=this.title),null!==this.issueId&&(this.vssue.issueId=this.issueId),this.vssue.setOptions(this.options),this.vssue.init()}};var na;kr([ft({type:[String,Function],required:!1,default:null})],Yr.prototype,"title",void 0),kr([ft({type:[String,Number],required:!1,default:null})],Yr.prototype,"issueId",void 0),kr([ft({type:Object,required:!1,default:()=>({})})],Yr.prototype,"options",void 0),kr([(na="vssue",et((function(n,e){var t=n.provide;mt(n),pt(t)&&(t=n.provide=ut(t)),t.managed[e]=na||e})))],Yr.prototype,"vssue",void 0),kr([bt("options",{deep:!0})],Yr.prototype,"onOptionsChange",null),Yr=kr([ct({components:{Iconfont:jr,VssueBody:Ur,VssueHeader:$r}})],Yr);const ea=Cr({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue"},[e("Iconfont"),this._v(" "),e("VssueHeader"),this._v(" "),e("VssueBody")],1)},staticRenderFns:[]},void 0,Yr,void 0,!1,void 0,!1,void 0,void 0,void 0);var ta=t(4),ra=t.n(ta);function aa(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function oa(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function ia(n){return{like:n["+1"],unlike:n[-1],heart:n.heart}}function sa(n){return{id:n.id,content:n.body_html,contentRaw:n.body,author:aa(n.user),createdAt:n.created_at,updatedAt:n.updated_at,reactions:ia(n.reactions)}}function ca(n){return"like"===n?"+1":"unlike"===n?"-1":n}class la{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:r,clientId:a,clientSecret:o,state:i,proxy:s}){if(void 0===o||void 0===s)throw new Error("clientSecret and proxy is required for GitHub V3");this.baseURL=n,this.owner=e,this.repo=t,this.labels=r,this.clientId=a,this.clientSecret=o,this.state=i,this.proxy=s,this.$http=ra.a.create({baseURL:"https://github.com"===n?"https://api.github.com":wt(n,"api/v3"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data&&n.data.error?Promise.reject(new Error(n.data.error_description)):n,n=>(void 0===n.response&&"Network Error"===n.message&&(n.response={status:403}),Promise.reject(n)))}get platform(){return{name:"GitHub",link:this.baseURL,version:"v3",meta:{reactable:!0,sortable:!1}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=At(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=xt(jt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=wt(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:r}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return r.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"token "+n}});return aa(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={};if(n&&(r.headers={Authorization:"token "+n}),!e){r.params={q:[`"${t}"`,"is:issue","in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>"label:"+n)].join(" "),timestamp:Date.now()};const{data:n}=await this.$http.get("search/issues",r);return n.items.map(oa).find(n=>n.title===t)||null}try{r.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,r);return oa(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:"token "+n}});return oa(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10}={}}){const a={params:{timestamp:Date.now()}},o={params:{page:t,per_page:r,timestamp:Date.now()},headers:{Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}};n&&(a.headers={Authorization:"token "+n},o.headers.Authorization="token "+n);const[i,s]=await Promise.all([this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,a),this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,o)]),c=s.headers.link||null,l=/rel="next"/.test(c)?Number(c.replace(/^.*[^_]page=(\d*).*rel="next".*$/,"$1"))-1:/rel="prev"/.test(c)?Number(c.replace(/^.*[^_]page=(\d*).*rel="prev".*$/,"$1"))+1:1,p=c?Number(c.replace(/^.*per_page=(\d*).*$/,"$1")):r;return{count:Number(i.data.comments),page:l,perPage:p,data:s.data.map(sa)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t},{headers:{Authorization:"token "+n,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return sa(r)}async putComment({accessToken:n,commentId:e,content:t}){const{data:r}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t},{headers:{Authorization:"token "+n,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return sa(r)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{headers:{Authorization:"token "+n}});return 204===t}async getCommentReactions({accessToken:n,commentId:e}){const{data:t}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{timestamp:Date.now()},headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}});return ia(t.reactions)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){const r=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions`,{content:ca(t)},{headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}});return 200===r.status?this.deleteCommentReaction({accessToken:n,commentId:e,reactionId:r.data.id}):201===r.status}async deleteCommentReaction({accessToken:n,commentId:e,reactionId:t}){return 204===(await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions/${t}`,{headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}})).status}}function pa(n){return null===n?{username:"ghost",avatar:"https://avatars3.githubusercontent.com/u/10137?v=4",homepage:"https://github.com/ghost"}:{username:n.login,avatar:n.avatarUrl,homepage:n.url}}function ua(n){return{id:n.number,title:n.title,content:n.body,link:n.url}}function da(n){return{like:n.find(n=>"THUMBS_UP"===n.content).users.totalCount,unlike:n.find(n=>"THUMBS_DOWN"===n.content).users.totalCount,heart:n.find(n=>"HEART"===n.content).users.totalCount}}function ma(n){return{id:n.id,content:n.bodyHTML,contentRaw:n.body,author:pa(n.author),createdAt:n.createdAt,updatedAt:n.updatedAt,reactions:da(n.reactionGroups)}}function ha(n){return"like"===n?"THUMBS_UP":"unlike"===n?"THUMBS_DOWN":"heart"===n?"HEART":n}class fa{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:r,clientId:a,clientSecret:o,state:i,proxy:s}){if(void 0===o||void 0===s)throw new Error("clientSecret and proxy is required for GitHub V4");this.baseURL=n,this.owner=e,this.repo=t,this.labels=r,this.clientId=a,this.clientSecret=o,this.state=i,this.proxy=s,this._pageInfo={page:1,startCursor:null,endCursor:null,sort:null,perPage:null},this._issueNodeId=null,this.$http=ra.a.create({baseURL:"https://github.com"===n?"https://api.github.com":wt(n,"api"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data.error?Promise.reject(n.data.error_description):n.data.errors?Promise.reject(n.data.errors[0].message):n)}get platform(){return{name:"GitHub",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=At(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=xt(jt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=wt(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:r}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return r.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.post("graphql",{query:"query getUser {\n  viewer {\n    login\n    avatarUrl\n    url\n  }\n}"},{headers:{Authorization:"token "+n}});return pa(e.data.viewer)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={};if(n&&(r.headers={Authorization:"token "+n}),!e){const n=[`"${t}"`,"in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>"label:"+n)].join(" "),{data:e}=await this.$http.post("graphql",{variables:{query:n},query:"query getIssueByTitle(\n  $query: String!\n) {\n  search(\n    query: $query\n    type: ISSUE\n    first: 20\n    ) {\n      nodes {\n      ... on Issue {\n        id\n        number\n        title\n        body\n        url\n      }\n    }\n  }\n}"},r),a=e.data.search.nodes.find(n=>n.title===t);return a?(this._issueNodeId=a.id,ua(a)):null}try{const{data:n}=await this.$http.post("graphql",{query:`query getIssueById {\n  repository(owner: "${this.owner}", name: "${this.repo}") {\n    issue (number: ${e}) {\n      id\n      number\n      title\n      body\n      url\n    }\n  }\n}`},r);return this._issueNodeId=n.data.repository.issue.id,ua(n.data.repository.issue)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:"token "+n}});return r.url=r.html_url,this._issueNodeId=r.node_id,ua(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10,sort:a="desc"}={}}){const o={};n&&(o.headers={Authorization:"token "+n}),null!==this._pageInfo.sort&&a!==this._pageInfo.sort&&(t=1);const{firstOrLast:i,afterOrBefore:s,cursor:c}=this._getQueryParams({page:t,sort:a}),{data:l}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:r},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${i}: $perPage\n        ${null===s?"":`${s}: "${c}"`}\n      ) {\n        totalCount\n        pageInfo {\n          endCursor\n          startCursor\n        }\n        nodes {\n          id\n          body\n          bodyHTML\n          createdAt\n          updatedAt\n          author {\n            avatarUrl\n            login\n            url\n          }\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},o),p=l.data.repository.issue.comments;return"desc"===a&&p.nodes.reverse(),this._pageInfo={page:t,startCursor:p.pageInfo.startCursor,endCursor:p.pageInfo.endCursor,sort:a,perPage:r},{count:p.totalCount,page:t,perPage:r,data:p.nodes.map(ma)}}async postComment({accessToken:n,content:e}){const{data:t}=await this.$http.post("graphql",{variables:{issueNodeId:this._issueNodeId,content:e},query:"mutation postComment(\n  $issueNodeId: ID!\n  $content: String!\n) {\n  addComment(\n    input: {\n      subjectId: $issueNodeId\n      body: $content\n    }\n  ) {\n    commentEdge {\n      node {\n        id\n        body\n        bodyHTML\n        createdAt\n        updatedAt\n        author {\n          avatarUrl\n          login\n          url\n        }\n        reactionGroups {\n          users (first: 0) {\n            totalCount\n          }\n          content\n        }\n      }\n    }\n  }\n}"},{headers:{Authorization:"token "+n}});return ma(t.data.addComment.commentEdge.node)}async putComment({accessToken:n,commentId:e,content:t}){const{data:r}=await this.$http.post("graphql",{variables:{commentId:e,content:t},query:"mutation putComment(\n  $commentId: ID!,\n  $content: String!,\n) {\n  updateIssueComment(input: {\n    id: $commentId\n    body: $content\n  }) {\n    issueComment {\n      id\n      body\n      bodyHTML\n      createdAt\n      updatedAt\n      author {\n        avatarUrl\n        login\n        url\n      }\n      reactionGroups {\n        users (first: 0) {\n          totalCount\n        }\n        content\n      }\n    }\n  }\n}"},{headers:{Authorization:"token "+n}});return ma(r.data.updateIssueComment.issueComment)}async deleteComment({accessToken:n,commentId:e}){return await this.$http.post("graphql",{variables:{commentId:e},query:"mutation deleteComment(\n  $commentId: ID!,\n) {\n  deleteIssueComment(input: {\n    id: $commentId\n  }) {\n    clientMutationId\n  }\n}"},{headers:{Authorization:"token "+n}}),!0}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{firstOrLast:r,afterOrBefore:a,cursor:o}=this._getQueryParams(),{data:i}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:this._pageInfo.perPage},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${r}: $perPage\n        ${null===a?"":`${a}: "${o}"`}\n      ) {\n        nodes {\n          id\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},{headers:{Authorization:"token "+n}});return da(i.data.repository.issue.comments.nodes.find(n=>n.id===t).reactionGroups)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){return await this.$http.post("graphql",{variables:{commentId:e,content:ha(t)},query:"mutation postCommentReaction(\n  $commentId: ID!,\n  $content: ReactionContent!,\n) {\n  addReaction(input: {\n    subjectId: $commentId\n    content: $content\n  }) {\n    reaction {\n      databaseId\n    }\n  }\n}"},{headers:{Authorization:"token "+n}}),!0}_getQueryParams({page:n=this._pageInfo.page,sort:e=this._pageInfo.sort}={}){let t,r,a;return 1===n?(t="asc"===e?"first":"last",r=null,a=null):"asc"===e?n>this._pageInfo.page?(t="first",r="after",a=this._pageInfo.endCursor):(t="last",r="before",a=this._pageInfo.startCursor):n>this._pageInfo.page?(t="last",r="before",a=this._pageInfo.startCursor):(t="first",r="after",a=this._pageInfo.endCursor),{firstOrLast:t,afterOrBefore:r,cursor:a}}}function ba(n){return{username:n.username,avatar:n.avatar_url,homepage:n.web_url}}function va(n){return{id:n.iid,title:n.title,content:n.description,link:n.web_url}}function ya(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:ba(n.author),createdAt:n.created_at,updatedAt:n.updated_at,reactions:n.reactions}}function xa(n){return{like:n.filter(n=>"thumbsup"===n.name).length,unlike:n.filter(n=>"thumbsdown"===n.name).length,heart:n.filter(n=>"heart"===n.name).length}}function wa(n){return"like"===n?"thumbsup":"unlike"===n?"thumbsdown":n}class ka{constructor({baseURL:n="https://gitlab.com",owner:e,repo:t,labels:r,clientId:a,state:o}){this.baseURL=n,this.owner=e,this.repo=t,this.labels=r,this.clientId=a,this.state=o,this._encodedRepo=encodeURIComponent(`${this.owner}/${this.repo}`),this.$http=ra.a.create({baseURL:wt(n,"api/v4"),headers:{Accept:"application/json"}})}get platform(){return{name:"GitLab",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=At(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state;const t=yt(n),r=t?"#"+t:"",a=`${jt(window.location.href)}${window.location.search}${r}`;return window.history.replaceState(null,"",a),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"Bearer "+n}});return ba(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={};if(n&&(r.headers={Authorization:"Bearer "+n}),!e){r.params={labels:this.labels.join(","),order_by:"created_at",sort:"asc",search:t};const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues`,r);return n.map(va).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}`,r);return va(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`projects/${this._encodedRepo}/issues`,{title:e,description:t,labels:this.labels.join(",")},{headers:{Authorization:"Bearer "+n}});return va(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10,sort:a="desc"}={}}){const o={params:{page:t,per_page:r,order_by:"created_at",sort:a}};n&&(o.headers={Authorization:"Bearer "+n});const i=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes`,o),s=i.data,c=[];for(const t of s)c.push((async()=>{t.body_html=await this.getMarkdownContent({accessToken:n,contentRaw:t.body})})()),c.push((async()=>{t.reactions=await this.getCommentReactions({accessToken:n,issueId:e,commentId:t.id})})());return await Promise.all(c),{count:Number(i.headers["x-total"]),page:Number(i.headers["x-page"]),perPage:Number(i.headers["x-per-page"]),data:s.map(ya)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:r}=await this.$http.post(`projects/${this._encodedRepo}/issues/${e}/notes`,{body:t},{headers:{Authorization:"Bearer "+n}});return ya(r)}async putComment({accessToken:n,issueId:e,commentId:t,content:r}){const{data:a}=await this.$http.put(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{body:r},{headers:{Authorization:"Bearer "+n}}),[o,i]=await Promise.all([this.getMarkdownContent({accessToken:n,contentRaw:a.body}),this.getCommentReactions({accessToken:n,issueId:e,commentId:a.id})]);return a.body_html=o,a.reactions=i,ya(a)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:r}=await this.$http.delete(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{headers:{Authorization:"Bearer "+n}});return 204===r}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{data:r}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes/${t}/award_emoji`,{headers:{Authorization:"Bearer "+n}});return xa(r)}async postCommentReaction({issueId:n,commentId:e,reaction:t,accessToken:r}){try{return 201===(await this.$http.post(`projects/${this._encodedRepo}/issues/${n}/notes/${e}/award_emoji`,{name:wa(t)},{headers:{Authorization:"Bearer "+r}})).status}catch(n){if(n.response&&404===n.response.status)return!1;throw n}}async getMarkdownContent({accessToken:n,contentRaw:e}){const t={};n&&(t.headers={Authorization:"Bearer "+n});const{data:r}=await this.$http.post("markdown",{text:e,gfm:!0},t);return r.html}}function Sa(n){return{username:n.nickname,avatar:n.links.avatar.href,homepage:n.links.html.href}}function Ca(n){return{id:n.id,title:n.title,content:n.content.raw,link:n.links.html.href}}function ja(n){return{id:n.id,content:n.content.html,contentRaw:n.content.raw,author:Sa(n.user),createdAt:n.created_on,updatedAt:n.updated_on,reactions:null}}class Aa{constructor({baseURL:n="https://bitbucket.org",owner:e,repo:t,clientId:r,state:a}){this.baseURL=n,this.owner=e,this.repo=t,this.clientId=r,this.state=a,this.$http=ra.a.create({baseURL:"https://api.bitbucket.org/2.0",headers:{Accept:"application/json"}})}get platform(){return{name:"Bitbucket",link:this.baseURL,version:"v2",meta:{reactable:!1,sortable:!0}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"site/oauth2/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=At(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state,delete n.scopes;const t=yt(n),r=t?"#"+t:"",a=`${jt(window.location.href)}${window.location.search}${r}`;return window.history.replaceState(null,"",a),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"Bearer "+n}});return Sa(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={};if(n&&(r.headers={Authorization:"Bearer "+n}),!e){r.params={sort:"created_on",q:`title="${t}"`,timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues`,r);return n.size>0?Ca(n.values[0]):null}try{r.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}`,r);return Ca(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues`,{title:e,content:{raw:t},priority:"trivial",kind:"task"},{headers:{Authorization:"Bearer "+n}});return r.links.html={href:wt(this.baseURL,`${this.owner}/${this.repo}/issues/${r.id}`)},Ca(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10,sort:a="desc"}={}}){const o={params:{page:t,pagelen:r,sort:"desc"===a?"-created_on":"created_on",timestamp:Date.now()}};n&&(o.headers={Authorization:"Bearer "+n});const{data:i}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,o);return{count:i.size,page:i.page,perPage:i.pagelen,data:i.values.filter(n=>null!==n.content.raw).map(ja)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:r}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,{content:{raw:t}},{headers:{Authorization:"Bearer "+n}});return ja(r)}async putComment({accessToken:n,issueId:e,commentId:t,content:r}){const{data:a}=await this.$http.put(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{content:{raw:r}},{headers:{Authorization:"Bearer "+n}});return ja(a)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:r}=await this.$http.delete(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{headers:{Authorization:"Bearer "+n}});return 204===r}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}function Ta(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function Ea(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function Pa(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:Ta(n.user),createdAt:n.created_at,updatedAt:n.updated_at||"",reactions:null}}class Da{constructor({baseURL:n="https://gitee.com",owner:e,repo:t,labels:r,clientId:a,clientSecret:o,state:i,proxy:s}){if(void 0===o||void 0===s)throw new Error("clientSecret and proxy is required for Gitee V5");this.baseURL=n,this.owner=e,this.repo=t,this.labels=r,this.clientId=a,this.clientSecret=o,this.state=i,this.proxy=s,this.$http=ra.a.create({baseURL:wt(n,"api/v5")}),this.$http.interceptors.response.use(n=>n,n=>(n.response.data&&n.response.data.message&&(n.message=n.response.data.message),Promise.reject(n)))}get platform(){return{name:"Gitee",link:this.baseURL,version:"v5",meta:{reactable:!1,sortable:!1}}}redirectAuth(){window.location.href=xt(wt(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"user_info issues notes",response_type:"code",state:this.state})}async handleAuth(){const n=At(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=xt(jt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=wt(this.baseURL,"oauth/token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:r}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n,grant_type:"authorization_code",redirect_uri:window.location.href});return r.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{params:{access_token:n}});return Ta(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={params:{timestamp:Date.now()}};if(n&&(r.params.access_token=n),!e){Object.assign(r.params,{q:t,repo:`${this.owner}/${this.repo}`,per_page:1});const{data:n}=await this.$http.get("search/issues",r);return n.map(Ea).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,r);return Ea(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/issues`,{access_token:n,repo:this.repo,title:e,body:t,labels:this.labels.join(",")});return Ea(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10}={}}){const a={params:{page:t,per_page:r,timestamp:Date.now()},headers:{Accept:["application/vnd.gitee.html+json"]}};n&&(a.params.access_token=n);const o=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,a);return{count:Number(o.headers.total_count),page:t,perPage:r,data:o.data.map(Pa)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Pa(r)}async putComment({accessToken:n,commentId:e,content:t}){const{data:r}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Pa(r)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{access_token:n}});return 204===t}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}t(332);var za={name:"Vssue",components:{VssueComponent:ea},props:{options:{type:Object,default:()=>({})}},data:()=>({key:"key",platformOptions:{github:la,"github-v4":fa,gitlab:ka,bitbucket:Aa,gitee:Da}}),computed:{vssueOptions(){const{platformOptions:n,options:e}=this,t=n[e.platform];return{...e,api:t}}},watch:{$route(n,e){n.path!==e.path&&setTimeout(()=>{this.key="reco-"+(new Date).getTime()},300)}}},Ba=(t(333),{components:{Valine:We,Vssue:Object(Ce.a)(za,(function(){return(0,this._self._c)("VssueComponent",{key:this.key,staticClass:"vssue-wrapper",attrs:{options:this.vssueOptions}})}),[],!1,null,null,null).exports},props:{isShowComments:{type:Boolean,default:!0}},data:()=>({commentsOptions:{}}),computed:{solution(){const{commentsOptions:{solution:n},$themeConfig:{valineConfig:e,vssueConfig:t},$themeLocaleConfig:{valineConfig:r,vssueConfig:a}}=this;let o="";return void 0!==n?o=n:void 0!==r||void 0!==e?o="valine":void 0===a&&void 0===t||(o="vssue"),o},options(){const{commentsOptions:{options:n},$themeConfig:{valineConfig:e,vssueConfig:t},$themeLocaleConfig:{valineConfig:r,vssueConfig:a}}=this;return void 0!==n?n:void 0!==r||void 0!==e?r||e:void 0!==a||void 0!==t?a||t:null},componentName(){const n=this.solution;return"valine"===n?"Valine":"vssue"===n?"Vssue":""}},mounted(){this.$themeConfig.commentsSolution=this.solution}}),Ia=Object(Ce.a)(Ba,(function(){var n=this._self._c;return n("div",{directives:[{name:"show",rawName:"v-show",value:this.isShowComments,expression:"isShowComments"}],staticClass:"comments-wrapper"},[n("ClientOnly",[n(this.componentName,{tag:"component",attrs:{options:this.options}})],1)],1)}),[],!1,null,null,null).exports,Oa={props:{idVal:String,numStyle:Object,flagTitle:{type:String,default:"Your Article Title"}},methods:{getIdVal(n){const e=this.$site.base;return e.slice(0,e.length-1)+n}}},_a=Object(Ce.a)(Oa,(function(){var n=this._self._c;return n("span",{staticClass:"leancloud-visitors",attrs:{id:this.getIdVal(this.idVal),"data-flag-title":this.flagTitle}},[n("a",{staticClass:"leancloud-visitors-count",style:this.numStyle})])}),[],!1,null,null,null).exports,La=(t(334),{tags:{"源码分析":{key:"源码分析",scope:"tags",path:"/tag/源码分析/",pageKeys:["v-59e792f7","v-59596aa5","v-0a438352","v-93974ed2","v-3c7afeb6","v-3e9083fd","v-55af23a5","v-a2fc25ba","v-0754b6a1","v-8e0b6cc6","v-6027801f","v-11cd131b","v-1bebd69a"]},Java:{key:"Java",scope:"tags",path:"/tag/Java/",pageKeys:["v-59e792f7","v-59596aa5","v-0a438352","v-8b8c23d2","v-b07ca2b2","v-93974ed2","v-9ebad7d2","v-74fedb77","v-3c7afeb6","v-a3d48a82","v-6dc818d2","v-cdecc45e","v-196b8f52","v-04d0dd31","v-6bf3fa77","v-3e9083fd","v-42002a52","v-55af23a5","v-a2fc25ba","v-0754b6a1","v-8e0b6cc6","v-6027801f","v-11cd131b","v-3c54cc77","v-1bebd69a","v-0eb0312f","v-6a4aab62","v-65899d47","v-f1f5b922","v-b3ebfa12","v-2830159a","v-1f63dd63","v-0008eb77"]},"多线程":{key:"多线程",scope:"tags",path:"/tag/多线程/",pageKeys:["v-59596aa5","v-b07ca2b2","v-93974ed2","v-74fedb77","v-a3d48a82","v-6dc818d2","v-cdecc45e","v-42002a52","v-3c54cc77"]},poi:{key:"poi",scope:"tags",path:"/tag/poi/",pageKeys:["v-229bb1b7","v-42002a52"]},"分布式":{key:"分布式",scope:"tags",path:"/tag/分布式/",pageKeys:["v-229bb1b7","v-1c8f87f8","v-2b4237af","v-345c456d","v-24ae108a","v-d12af5d4","v-5cb8f20a","v-1e6887d2","v-5d6482c8"]},SPI:{key:"SPI",scope:"tags",path:"/tag/SPI/",pageKeys:["v-6ebf631e","v-65a6b7f7"]},"定时任务":{key:"定时任务",scope:"tags",path:"/tag/定时任务/",pageKeys:["v-0b69064b","v-77367395"]},"网关":{key:"网关",scope:"tags",path:"/tag/网关/",pageKeys:["v-1c8f87f8"]},"日志":{key:"日志",scope:"tags",path:"/tag/日志/",pageKeys:["v-8cb01f92"]},pdf:{key:"pdf",scope:"tags",path:"/tag/pdf/",pageKeys:["v-196b8f52"]},Docker:{key:"Docker",scope:"tags",path:"/tag/Docker/",pageKeys:["v-989d2c6a"]},"IO模型":{key:"IO模型",scope:"tags",path:"/tag/IO模型/",pageKeys:["v-1ba7191d"]},jvm:{key:"jvm",scope:"tags",path:"/tag/jvm/",pageKeys:["v-6bf3fa77"]},jwt:{key:"jwt",scope:"tags",path:"/tag/jwt/",pageKeys:["v-2ed49eb7"]},MyBatis:{key:"MyBatis",scope:"tags",path:"/tag/MyBatis/",pageKeys:["v-90af05e8"]},"sql优化":{key:"sql优化",scope:"tags",path:"/tag/sql优化/",pageKeys:["v-73fde4d7"]},RabbitMQ:{key:"RabbitMQ",scope:"tags",path:"/tag/RabbitMQ/",pageKeys:["v-f59ecb92","v-24839ad2","v-65899d47"]},Redis:{key:"Redis",scope:"tags",path:"/tag/Redis/",pageKeys:["v-6dd97e97","v-f711c112","v-1e51bcb2"]},"Spring Security":{key:"Spring Security",scope:"tags",path:"/tag/Spring Security/",pageKeys:["v-2b4237af","v-345c456d"]},Swagger2:{key:"Swagger2",scope:"tags",path:"/tag/Swagger2/",pageKeys:["v-24ae108a"]},"Spring Boot":{key:"Spring Boot",scope:"tags",path:"/tag/Spring Boot/",pageKeys:["v-3456e51e"]},ZooKeeper:{key:"ZooKeeper",scope:"tags",path:"/tag/ZooKeeper/",pageKeys:["v-d12af5d4","v-1e6887d2"]},"单元测试":{key:"单元测试",scope:"tags",path:"/tag/单元测试/",pageKeys:["v-0eb0312f","v-6a4aab62","v-f1f5b922"]},"随笔":{key:"随笔",scope:"tags",path:"/tag/随笔/",pageKeys:["v-5d97d573","v-5dec17bf","v-bed2e2f2","v-25eb7c17","v-09c6eb57","v-57f1379d","v-1cf9f311","v-6b8bff0f","v-56da6351","v-33ecb7b6","v-3274a2d6","v-011bc3d7"]},"网络协议":{key:"网络协议",scope:"tags",path:"/tag/网络协议/",pageKeys:["v-b517ba06"]},JavaScript:{key:"JavaScript",scope:"tags",path:"/tag/JavaScript/",pageKeys:["v-3419df1d"]},json:{key:"json",scope:"tags",path:"/tag/json/",pageKeys:["v-3419df1d"]},vuepress:{key:"vuepress",scope:"tags",path:"/tag/vuepress/",pageKeys:["v-28ad82bd","v-193cdd9e","v-309fb177"]},Via:{key:"Via",scope:"tags",path:"/tag/Via/",pageKeys:["v-fd18a65e"]},Vue:{key:"Vue",scope:"tags",path:"/tag/Vue/",pageKeys:["v-209f2ade"]},"复习":{key:"复习",scope:"tags",path:"/tag/复习/",pageKeys:["v-21bc8b46","v-7ad83f1b","v-59d18056","v-5cfc5853","v-10c74a0d","v-3b409fbd","v-0727fa02","v-7a153c7b","v-7d39c359"]},"开发规范":{key:"开发规范",scope:"tags",path:"/tag/开发规范/",pageKeys:["v-b3ebfa12","v-b9441912","v-2830159a","v-1f63dd63","v-0008eb77"]},git:{key:"git",scope:"tags",path:"/tag/git/",pageKeys:["v-b9441912"]},k8s:{key:"k8s",scope:"tags",path:"/tag/k8s/",pageKeys:["v-5d6482c8"]},linux:{key:"linux",scope:"tags",path:"/tag/linux/",pageKeys:["v-90c76f52","v-660e1712"]},ECharts:{key:"ECharts",scope:"tags",path:"/tag/ECharts/",pageKeys:["v-4789f531"]}},categories:{"后端 Back-end":{key:"后端 Back-end",scope:"categories",path:"/categories/后端 Back-end/",pageKeys:["v-59e792f7","v-59596aa5","v-0a438352","v-8b8c23d2","v-229bb1b7","v-b07ca2b2","v-93974ed2","v-6ebf631e","v-0b69064b","v-9ebad7d2","v-74fedb77","v-3c7afeb6","v-1c8f87f8","v-a3d48a82","v-6dc818d2","v-cdecc45e","v-8cb01f92","v-196b8f52","v-989d2c6a","v-04d0dd31","v-1ba7191d","v-6bf3fa77","v-2ed49eb7","v-90af05e8","v-73fde4d7","v-3e9083fd","v-42002a52","v-f59ecb92","v-77367395","v-24839ad2","v-6dd97e97","v-f711c112","v-1e51bcb2","v-2b4237af","v-345c456d","v-55af23a5","v-a2fc25ba","v-0754b6a1","v-8e0b6cc6","v-6027801f","v-11cd131b","v-65a6b7f7","v-24ae108a","v-3456e51e","v-d12af5d4","v-3c54cc77","v-5cb8f20a","v-1bebd69a","v-0eb0312f","v-1e6887d2","v-6a4aab62","v-65899d47","v-f1f5b922","v-5d6482c8"]},"随笔 Essay":{key:"随笔 Essay",scope:"categories",path:"/categories/随笔 Essay/",pageKeys:["v-5d97d573","v-5dec17bf","v-bed2e2f2","v-25eb7c17","v-09c6eb57","v-57f1379d","v-1cf9f311","v-6b8bff0f","v-56da6351","v-33ecb7b6","v-3274a2d6","v-011bc3d7"]},"前端 Front-end":{key:"前端 Front-end",scope:"categories",path:"/categories/前端 Front-end/",pageKeys:["v-b517ba06","v-3419df1d","v-28ad82bd","v-fd18a65e","v-209f2ade","v-193cdd9e","v-4789f531"]},"规范 Standard":{key:"规范 Standard",scope:"categories",path:"/categories/规范 Standard/",pageKeys:["v-b517ba06","v-b3ebfa12","v-b9441912","v-309fb177","v-2830159a","v-90c76f52","v-660e1712","v-1f63dd63","v-0008eb77"]},"知识晶体 Q&A":{key:"知识晶体 Q&A",scope:"categories",path:"/categories/知识晶体 Q&A/",pageKeys:["v-21bc8b46","v-7ad83f1b","v-59d18056","v-5cfc5853","v-10c74a0d","v-3b409fbd","v-0727fa02","v-7a153c7b","v-7d39c359"]}},timeline:{}});class Fa{constructor(n,e){this._metaMap=Object.assign({},n),Object.keys(this._metaMap).forEach(n=>{const{pageKeys:t}=this._metaMap[n];this._metaMap[n].pages=t.map(n=>Object(Kn.b)(e,n))})}get length(){return Object.keys(this._metaMap).length}get map(){return this._metaMap}get pages(){return this.list}get list(){return this.toArray()}toArray(){const n=[];return Object.keys(this._metaMap).forEach(e=>{const{pages:t,path:r}=this._metaMap[e];n.push({name:e,pages:t,path:r})}),n}getItemByName(n){return this._metaMap[n]}}var Ma={tags:(n,e)=>{const r=t(126);return r(n.frontmatter.date)-r(e.frontmatter.date)>0?-1:1},categories:(n,e)=>{const r=t(126);return r(n.frontmatter.date)-r(e.frontmatter.date)>0?-1:1}},Ra={tags:function(n,e,t){const r=e;return["tags"].some(e=>{const t=n.frontmatter[e];return Array.isArray(t)?t.some(n=>n===r):t===r})},categories:function(n,e,t){const r=e;return["categories"].some(e=>{const t=n.frontmatter[e];return Array.isArray(t)?t.some(n=>n===r):t===r})}},Na=[{pid:"tags",id:"源码分析",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/源码分析/",interval:[0,9]},{path:"/tag/源码分析/page/2/",interval:[10,13]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Java",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/Java/",interval:[0,9]},{path:"/tag/Java/page/2/",interval:[10,19]},{path:"/tag/Java/page/3/",interval:[20,29]},{path:"/tag/Java/page/4/",interval:[30,33]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"多线程",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/多线程/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"poi",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/poi/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"分布式",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/分布式/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"SPI",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/SPI/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"定时任务",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/定时任务/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"网关",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/网关/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"日志",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/日志/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"pdf",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/pdf/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Docker",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/Docker/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"IO模型",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/IO模型/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"jvm",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/jvm/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"jwt",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/jwt/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"MyBatis",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/MyBatis/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"sql优化",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/sql优化/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"RabbitMQ",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/RabbitMQ/",interval:[0,3]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Redis",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/Redis/",interval:[0,3]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Spring Security",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/Spring Security/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Swagger2",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/Swagger2/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Spring Boot",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/Spring Boot/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"ZooKeeper",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/ZooKeeper/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"单元测试",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/单元测试/",interval:[0,3]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"随笔",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/随笔/",interval:[0,9]},{path:"/tag/随笔/page/2/",interval:[10,12]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"网络协议",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/网络协议/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"JavaScript",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/JavaScript/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"json",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/json/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"vuepress",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/vuepress/",interval:[0,3]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Via",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/Via/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"Vue",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/Vue/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"复习",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/复习/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"开发规范",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/开发规范/",interval:[0,5]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"git",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/git/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"k8s",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/k8s/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"linux",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/linux/",interval:[0,2]}],prevText:"Prev",nextText:"Next"},{pid:"tags",id:"ECharts",filter:Ra.tags,sorter:Ma.tags,pages:[{path:"/tag/ECharts/",interval:[0,1]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"后端 Back-end",filter:Ra.categories,sorter:Ma.categories,pages:[{path:"/categories/后端 Back-end/",interval:[0,9]},{path:"/categories/后端 Back-end/page/2/",interval:[10,19]},{path:"/categories/后端 Back-end/page/3/",interval:[20,29]},{path:"/categories/后端 Back-end/page/4/",interval:[30,39]},{path:"/categories/后端 Back-end/page/5/",interval:[40,49]},{path:"/categories/后端 Back-end/page/6/",interval:[50,54]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"随笔 Essay",filter:Ra.categories,sorter:Ma.categories,pages:[{path:"/categories/随笔 Essay/",interval:[0,9]},{path:"/categories/随笔 Essay/page/2/",interval:[10,12]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"前端 Front-end",filter:Ra.categories,sorter:Ma.categories,pages:[{path:"/categories/前端 Front-end/",interval:[0,7]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"规范 Standard",filter:Ra.categories,sorter:Ma.categories,pages:[{path:"/categories/规范 Standard/",interval:[0,9]}],prevText:"Prev",nextText:"Next"},{pid:"categories",id:"知识晶体 Q&A",filter:Ra.categories,sorter:Ma.categories,pages:[{path:"/categories/知识晶体 Q&A/",interval:[0,9]}],prevText:"Prev",nextText:"Next"}],qa=t(137);const Ua=t.n(qa)()("plugin-blog:pagination");class Ha{constructor(n,e,t){Ua("pagination",n);const{pages:r,prevText:a,nextText:o}=n,{path:i}=t;this._prevText=a,this._nextText=o;for(let n=0,e=r.length;n<e;n++){if(r[n].path===i){this.paginationIndex=n;break}}this.paginationIndex||(this.paginationIndex=0),this._paginationPages=r,this._currentPage=r[this.paginationIndex],this._matchedPages=e.filter(e=>n.filter(e,n.id,n.pid)).sort(n.sorter)}setIndexPage(n){this._indexPage=n}get length(){return this._paginationPages.length}get pages(){const[n,e]=this._currentPage.interval;return this._matchedPages.slice(n,e+1)}get hasPrev(){return 0!==this.paginationIndex}get prevLink(){return this.hasPrev?this.paginationIndex-1==0&&this._indexPage?this._indexPage:this._paginationPages[this.paginationIndex-1].path:null}get hasNext(){return this.paginationIndex!==this.length-1}get nextLink(){return this.hasNext?this._paginationPages[this.paginationIndex+1].path:null}get prevText(){return this._prevText}get nextText(){return this._nextText}getSpecificPageLink(n){return this._paginationPages[n].path}}const $a=new class{constructor(n){this.paginations=n}get pages(){return r.a.$vuepress.$get("siteData").pages}getPagination(n,e,t){Ua("id",e),Ua("pid",n);const r=this.paginations.filter(t=>t.id===e&&t.pid===n)[0];return new Ha(r,this.pages,t)}}(Na);var Ja={comment:{enabled:!1,service:""},email:{enabled:!1},feed:{rss:!1,atom:!1,json:!1}};class Va{constructor(n){Object.defineProperty(this,"registration",{value:n,configurable:!0,writable:!0})}update(){return this.registration.update()}skipWaiting(){const n=this.registration.waiting;return n?(console.log("[vuepress:sw] Doing worker.skipWaiting()."),new Promise((e,t)=>{const r=new MessageChannel;r.port1.onmessage=n=>{console.log("[vuepress:sw] Done worker.skipWaiting()."),n.data.error?t(n.data.error):e(n.data)},n.postMessage({type:"skip-waiting"},[r.port2])})):Promise.resolve()}}var Wa=t(21);r.a.component("SWUpdatePopup",()=>Promise.all([t.e(0),t.e(18)]).then(t.bind(null,476)));var Qa={data:()=>({showButtonFlag:!1,openFlag:!1,text:"展开",visible:!1,interval:null,isMoving:!1,detailsStyle:{right:"1rem",bottom:"9rem",width:"2.5rem",height:"2.5rem","border-radius":".25rem","line-height":"2.5rem","font-size":"14px","font-weight":"500"},visibilityHeight:400}),methods:{updateOpen(){this.openFlag=!this.openFlag;var n=document.getElementsByTagName("details");if(this.openFlag){for(var e=0;e<n.length;e++)n[e].setAttribute("open","");this.text="合起"}else{for(e=0;e<n.length;e++)n[e].removeAttribute("open");this.text="展开"}},showButton(){var n=document.getElementsByTagName("details");null!=n&&n.length>2?this.showButtonFlag=!0:this.showButtonFlag=!1},handleScroll(){this.visible=window.pageYOffset>this.visibilityHeight}},watch:{$route(n,e){n.path==e.path?this.showButton():"/"==n.path||"/about/"==n.path?this.showButtonFlag=!1:(this.openFlag=!1,this.text="展开",this.showButton())}},created(){},mounted(){},beforeDestroy(){}},Ka=(t(337),Object(Ce.a)(Qa,(function(){var n=this,e=n._self._c;return e("div",[e("div",{directives:[{name:"show",rawName:"v-show",value:n.showButtonFlag,expression:"showButtonFlag"}],staticClass:"DetailsOpenFlag",style:n.detailsStyle,on:{click:function(e){return n.updateOpen()}}},[n._v("\n "+n._s(n.text)+"\n\n")])])}),[],!1,null,"3338c3f8",null).exports);const Ga="https://neteasecloudmusicapi-zpj80231.vercel.app/";var Xa=t(138),Za=t.n(Xa),Ya=t(139),no=t.n(Ya),eo=t(64),to=t.n(eo),ro=t(140),ao=t.n(ro),oo=t(141),io=t.n(oo),so=t(142),co=t.n(so),lo=t(143),po=t.n(lo),uo=t(65),mo=t.n(uo),ho=t(144),go=t.n(ho),fo=t(145),bo=t.n(fo),vo=t(3),yo=t.n(vo);var xo={name:"Player",data:()=>({o:0,top:0,pan:Za.a,play:no.a,pause:to.a,add:ao.a,shlter:io.a,listPlay:co.a,state0:po.a,state1:mo.a,talkicon1:go.a,talkicon2:bo.a,playState:!0,playIcon:to.a,musicImg:"",musicUrl:"",musicWords:[],musicTitle:"",musicName:"",wordsTime:[],wordsTop:0,wordIndex:0,currentProgress:"0%",musicList:[],myMusicList:[],thisMusicIndex:1,disActive:!1,listIsDis:!1,listButtonActiveIndex:-1,thisListPage:1,musicTypeList:[{name:"热歌榜",id:3778678},{name:"新歌榜",id:3779629},{name:"飙升榜",id:19723756},{name:"抖音榜",id:2250011882},{name:"我的单曲",id:3068309305},{name:"My Songs",id:-1}],thisMusicType:-1,notPlay:[],musicState:0,musicStateButton:mo.a,musicSearchVal:"",musicSearchList:[],musicAlertVal:"",musicAlertState:!1,musicAlertTimer:"",hotTalkList:[]}),mounted(){if(1==Math.floor(10*Math.random()+1)){if("/"!=this.$route.path)return;null==sessionStorage.getItem("zk")&&(window.location.href="/znote/view/index.html",sessionStorage.setItem("zk","zv"))}this.Player(),this._getMusicType(3068309305)},created(){},computed:{thisMusicList(){return[...this.musicList].splice(10*(this.thisListPage-1),10)}},watch:{musicSearchVal(){""==this.musicSearchVal?this.musicSearchList=[]:(n=>ra.a.get(`https://neteasecloudmusicapi-zpj80231.vercel.app/search?keywords=${n}&limit=8`))(this.musicSearchVal).then(n=>{null==n.data.result.songs?this.musicSearchList=[]:this.musicSearchList=n.data.result.songs})}},methods:{check:()=>!navigator.userAgent.match(/(phone|pod|iPhone|iPod|ios|Android|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),MusicAlert(n){this.musicAlertState=!0,this.musicAlertVal=n,clearTimeout(this.musicAlertTimer),this.musicAlertTimer=setTimeout(()=>{this.musicAlertState=!1,this.musicAlertVal=""},2e3)},ListAdd(n){var e;(e=n.id,ra.a.get(Ga+"song/detail?ids="+e)).then(n=>{this.musicSearchVal="",0==this.myMusicList.length?(this.myMusicList=[n.data.songs[0]],this._getMusicType(-1)):this.myMusicList.push(n.data.songs[0]),this.MusicAlert("添加成功")})},MusicStateChange(){0==this.musicState?(this.musicState=1,this.musicStateButton=this.state0,this.MusicAlert("已切换为单曲循环模式")):(this.musicState=0,this.musicStateButton=this.state1,this.MusicAlert("已切换为列表循环模式"))},DisList(){this.listIsDis=!this.listIsDis},ListChange(n){n?this.thisListPage--:this.thisListPage++},ListPlay(n){this.thisMusicIndex!=n&&(this.thisMusicIndex=n>this.musicList.length-1?0:n,this._getInfo(),this.top=0,this.o=0,this.wordIndex=0,this.wordsTop=0,this.currentProgress="0%",this.playState||yo()(".control_icon").click())},ButtonActive(n){this.listButtonActiveIndex=n},DisActive(){this.disActive=!this.disActive},_getMusicType(n){this.thisMusicType!=n&&(this.notPlay=[],-1==n?0!=this.myMusicList.length?(this.musicList=this.myMusicList,this.thisMusicType=n,this.thisMusicIndex=0,this.thisListPage=1,this._getInfo(),this.top=0,this.o=0,this.wordIndex=0,this.wordsTop=0,this.currentProgress="0%",this.playState||yo()(".control_icon").click()):this.MusicAlert("没有歌曲,需要自己添加"):(3068309305===n&&(n=>ra.a.get(Ga+"playlist/detail?id="+n))(n).then(e=>{this.getMusicDetail(e,n)}),(n=>ra.a.get(Ga+"playlist/detail?id="+n))(n).then(e=>{this.getMusicDetail(e,n)})))},getMusicDetail(n,e){this.musicList=n.data.playlist.tracks.splice(0,200),this.thisMusicType=e,this.thisMusicIndex=0,this.thisListPage=1,this._getInfo(),this.top=0,this.o=0,this.wordIndex=0,this.wordsTop=0,this.currentProgress="0%",this.playState||yo()(".control_icon").click()},_getInfo(){var n;(n=this.musicList[this.thisMusicIndex].id,ra.a.get(Ga+"song/url?id="+n)).then(n=>{if(null==n.data.data[0].url||""==n.data.data[0].url||null==n.data.data[0].url)if(this.notPlay.length!=this.musicList.length){let n=this.thisMusicIndex+1;-1==this.notPlay.indexOf(this.thisMusicIndex)&&this.notPlay.push(this.thisMusicIndex),this.MusicAlert(this.musicList[this.thisMusicIndex].name+"因为一些原因不能播放"),this.ListPlay(n)}else console.log("not"),this.MusicAlert("此列表所有歌都不能播放");else{this.musicUrl=n.data.data[0].url.replace("http://","https://"),this.musicImg=this.musicList[this.thisMusicIndex].al.picUrl.replace("http://","https://")+"?param=300y300",this.musicTitle=this.musicList[this.thisMusicIndex].name;let e=[];this.musicList[this.thisMusicIndex].ar.forEach(n=>{e.push(n.name)}),this.musicName=e.join("/"),(n=>ra.a.get(Ga+"lyric?id="+n))(this.musicList[this.thisMusicIndex].id).then(n=>{if(!n.data.nolyric){let e=this.Cut(n.data.lrc.lyric);this.musicWords=e.wordArr,this.wordsTime=e.timeArr}}),(n=>ra.a.get(`https://neteasecloudmusicapi-zpj80231.vercel.app/comment/music?id=${n}&limit=8`))(this.musicList[this.thisMusicIndex].id).then(n=>{let e=0;this.hotTalkList=n.data.hotComments.splice(0,3),this.hotTalkList.forEach(n=>{e+=n.content.length,n.user.avatarUrl=n.user.avatarUrl+"?param=50y50"}),e>=200&&(this.hotTalkList=this.hotTalkList.slice(0,2))})}})},Ltrim:n=>n.replace(/(^\s*)/g,""),Rtrim:n=>n.replace(/(\s*$)/g,""),Cut(n){let e=[],t=[];e=n.split("["),e.splice(0,1);for(let n=0;n<e.length;n++){let r=e[n].split("]"),a=r[0].split(".")[0].split(":");e[n]=60*Number.parseInt(a[0])+Number.parseInt(a[1]),e[n]=isNaN(e[n])?0:e[n],t[n]=this.Rtrim(this.Ltrim(r[1]))}return{timeArr:e,wordArr:t}},Player(){let n=this,e=yo()("#music")[0],t=setInterval(r,1e3);function r(){n.currentProgress=e.currentTime/e.duration*100+"%",e.currentTime>=n.wordsTime[n.o+1]&&(n.top+=Number.parseInt(yo()(".music_word").eq(n.o).height()+Number.parseInt(yo()(".music_word").eq(n.o).css("marginTop"))),n.top>=yo()(".music_words").height()/2-11&&(n.wordsTop+=-Number.parseInt(yo()(".music_word").eq(n.o).height()+Number.parseInt(yo()(".music_word").eq(n.o).css("marginTop")))),n.wordIndex=n.o+1,n.o++),e.currentTime>=e.duration&&(1!=n.musicList.length&&0==n.musicState&&(n.thisMusicIndex=n.thisMusicIndex>=n.musicList.length-1?0:n.thisMusicIndex+1,n._getInfo()),e.play(),n.top=0,n.o=0,n.wordIndex=0,n.wordsTop=0,n.currentProgress="0%")}yo()(".progress").on("mousedown",a=>{console.log();let o=((a||event).clientX-yo()(".progress").offset().left)/yo()(".progress").width();clearInterval(t),this.currentProgress=100*o+"%",yo()(document).on("mousemove",n=>{let e=n||event;o=(e.clientX-yo()(".progress").offset().left)/yo()(".progress").width(),this.currentProgress=100*o+"%"}),yo()(document).on("mouseup",()=>{e.currentTime=e.duration*o;let a=[...this.wordsTime];a.push(e.currentTime),a.sort((n,e)=>n-e);let i=a.indexOf(e.currentTime)-1,s=0;if(this.o<i)for(let n=this.o;n<i;n++)s+=-Number.parseInt(yo()(".music_word").eq(n).height()+Number.parseInt(yo()(".music_word").eq(n).css("marginTop")));else for(let n=i;n<this.o;n++)s+=Number.parseInt(yo()(".music_word").eq(n).height()+Number.parseInt(yo()(".music_word").eq(n).css("marginTop")));this.wordsTop+=s,n.wordIndex=this.o=i,clearInterval(t),t=setInterval(r,1e3),this.playState=!0,this.playIcon=this.pause,e.currentTime>=e.duration&&(this.top=0,this.o=0,this.wordIndex=0,this.wordsTop=0,this.currentProgress="0%"),e.play(),yo()(document).unbind("mousemove"),yo()(document).unbind("mouseup")})}),yo()(".control_icon").on("click",()=>{this.playState?(e.pause(),this.playState=!1,this.playIcon=this.play,clearInterval(t)):(e.play(),this.playState=!0,this.playIcon=this.pause,clearInterval(t),t=setInterval(r,1e3))})},Contorl(){yo()("#music")[0].currentTime=100}}},wo=(t(338),Object(Ce.a)(xo,(function(){var n=this,e=n._self._c;return e("div",{attrs:{id:"musicPlayer"}},[e("transition",{attrs:{name:"dis_list"}},[n.listIsDis?e("div",{staticClass:"list_box"},[e("transition",{attrs:{name:"music_alert"}},[n.musicAlertState?e("span",{staticClass:"music_alert"},[n._v(n._s(n.musicAlertVal))]):n._e()]),n._v(" "),e("div",{staticClass:"list_close",on:{click:n.DisList}},[n._v("x")]),n._v(" "),e("div",{staticClass:"music_list"},[e("div",{staticClass:"list_l"},[e("ul",{staticClass:"music_type"},n._l(n.musicTypeList,(function(t){return e("li",{class:{type_active:t.id==n.thisMusicType},on:{click:function(e){return n._getMusicType(t.id)}}},[n._v(n._s(t.name))])})),0),n._v(" "),e("div",{staticClass:"list_title"},[e("span",{staticStyle:{"font-size":"14px"}},[n._v("歌曲列表")]),n._v(" "),e("img",{staticClass:"music_state",attrs:{src:n.musicStateButton,alt:""},on:{click:n.MusicStateChange}}),n._v(" "),e("div",{staticClass:"music_search_box"},[e("input",{directives:[{name:"model",rawName:"v-model",value:n.musicSearchVal,expression:"musicSearchVal"}],staticClass:"music_search",attrs:{type:"text",placeholder:"搜索歌曲"},domProps:{value:n.musicSearchVal},on:{input:function(e){e.target.composing||(n.musicSearchVal=e.target.value)}}}),n._v(" "),e("transition",{attrs:{name:"music_search"}},[""!=n.musicSearchVal?e("ul",{staticClass:"search_list"},n._l(n.musicSearchList,(function(t){return e("li",{on:{click:function(e){return n.ListAdd(t)}}},[e("span",{staticClass:"music_search_name"},[n._v(n._s(t.name))]),n._v(" "),e("span",{staticClass:"music_search_ar"},[n._v(n._s(t.artists[0].name))])])})),0):n._e()])],1)]),n._v(" "),e("div",{staticClass:"music_ul_title"},[e("span",[n._v("歌曲")]),e("span",[n._v("歌手")]),e("span",[n._v("专辑")])]),n._v(" "),e("ul",{staticClass:"_list"},n._l(n.thisMusicList,(function(t,r){return e("li",{on:{mouseover:function(e){return n.ButtonActive(r)},dblclick:function(e){n.ListPlay(10*(n.thisListPage-1)+r)}}},[10*(n.thisListPage-1)+r==n.thisMusicIndex?e("div",{staticClass:"this_music_shlter"}):n._e(),n._v(" "),e("span",[n._v(n._s(t.name))]),e("span",[n._v(n._s(t.ar[0].name))]),e("span",[n._v(n._s(t.al.name))]),n._v(" "),e("transition",{attrs:{name:"list_button"}},[n.listButtonActiveIndex==r?e("div",{staticClass:"music_button"},[e("div",{staticClass:"list_play",style:{backgroundImage:"url("+n.listPlay+")"},attrs:{title:"播放这首歌"},on:{click:function(e){n.ListPlay(10*(n.thisListPage-1)+r)}}}),n._v(" "),-1!=n.thisMusicType?e("div",{staticClass:"list_play",style:{backgroundImage:"url("+n.add+")"},attrs:{title:"添加到 My Songs"},on:{click:function(e){return n.ListAdd(t)}}}):n._e()]):n._e()])],1)})),0),n._v(" "),e("div",{staticClass:"list_page"},[1!=n.thisListPage?e("div",{staticClass:"page_last",on:{click:function(e){return n.ListChange(!0)}}},[n._v("<")]):n._e(),n._v(" "),n.thisListPage!=Math.ceil(n.musicList.length/10)?e("div",{staticClass:"page_next",on:{click:function(e){return n.ListChange(!1)}}},[n._v(">")]):n._e()])]),n._v(" "),e("div",{staticClass:"list_r"},[e("img",{staticClass:"music_list_bg",attrs:{src:n.musicImg}}),n._v(" "),e("div",{staticClass:"music_list_shlter",style:{backgroundImage:"url("+n.shlter+")"}}),n._v(" "),e("ul",{staticClass:"music_talk_list"},n._l(n.hotTalkList,(function(t,r){return e("li",{key:r},[e("div",{staticClass:"talk_head"},[e("img",{staticClass:"talk_head_img",attrs:{src:t.user.avatarUrl,alt:""}}),n._v(" "),e("span",{staticClass:"talk_head_name"},[n._v(n._s(t.user.nickname))])]),n._v(" "),e("p",{staticClass:"talk_content"},[e("img",{staticClass:"talk_icon_l",attrs:{src:n.talkicon1}}),n._v("\n                                "+n._s(t.content)+"\n                                "),e("img",{staticClass:"talk_icon_r",attrs:{src:n.talkicon2}})])])})),0)])])],1):n._e()]),n._v(" "),e("div",{staticClass:"bbox",class:{bbox_active:n.disActive}},[e("div",{staticClass:"pan",class:{pan_active:n.disActive},style:{backgroundImage:"url("+n.pan+")"},on:{click:n.DisActive}},[e("img",{staticClass:"pan_c",attrs:{src:n.musicImg,alt:""}})]),n._v(" "),e("div",{staticClass:"box",class:{box_active:n.disActive},style:{backgroundImage:"url("+n.musicImg+")"},on:{dblclick:n.DisList}},[e("div",{staticClass:"music_shlter_2",class:{shlter_active:n.disActive},style:{backgroundImage:"url("+n.musicImg+")"}}),n._v(" "),e("div",{staticClass:"music_shlter",class:{shlter_active:n.disActive},style:{backgroundImage:"url("+n.musicImg+")"}}),n._v(" "),e("div",{staticClass:"music_shlter_3"}),n._v(" "),e("div",{staticClass:"music_dis"},[e("div",{staticClass:"dis_list",on:{click:n.DisList}},[n._v("···")]),n._v(" "),e("p",{staticClass:"music_title"},[n._v(n._s(n.musicTitle))]),n._v(" "),e("p",{staticClass:"music_intro"},[n._v("歌手: "+n._s(n.musicName))]),n._v(" "),e("ul",{staticClass:"music_words"},[e("div",{staticClass:"music_words_box",style:{top:n.wordsTop+"px"}},n._l(n.musicWords,(function(t,r){return e("li",{staticClass:"music_word",class:{word_highlight:n.wordIndex==r}},[n._v(n._s(t))])})),0)])]),n._v(" "),e("div",{staticClass:"control_box"},[e("div",{staticClass:"control_button"},[e("img",{staticClass:"control_icon",attrs:{src:n.playIcon,alt:""}})]),n._v(" "),e("div",{staticClass:"progress"},[e("div",{staticClass:"progress_c",style:{width:n.currentProgress}},[n._m(0)])])])]),n._v(" "),e("video",{attrs:{id:"music",autoplay:"autoplay",src:n.musicUrl,name:"media"}})])],1)}),[function(){var n=this._self._c;return n("div",{staticClass:"progress_circle"},[n("div",{staticClass:"progress_circle_c"})])}],!1,null,"3596b134",null).exports),ko={name:"MobilePlayer"},So=Object(Ce.a)(ko,(function(){return(0,this._self._c)("div")}),[],!1,null,"21669aef",null).exports,Co={name:"BackToTop",data:()=>({visible:!1,active:!0,closeBtn:!1}),mounted(){this.check()&&(this.setStepImg(),this.setRandomShow())},methods:{closeNote(){this.visible=!1,this.closeBtn=!0,setTimeout(()=>{this.closeBtn=!1},9e5)},check:()=>!navigator.userAgent.match(/(phone|pod|iPhone|iPod|ios|Android|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i),getVisible(){return this.visible=!this.closeBtn},setStepImg(){var n=1;setInterval(()=>{if(++n%2==0){var e=document.getElementsByClassName("notification-wrapper")[0];if(null==e||null==e||null==e.style)return;e.style.bottom=73*Math.random()+"%",e.style.zoom=Math.random()}this.visible=this.getVisible(),this.active=!this.active,this.noActive=!this.noActive},1e4)},setRandomShow(){var n=1;setInterval(()=>{this.closeBtn=!(n>=1),n=Math.floor(3*Math.random())},4e4)}}},jo=(t(339),Object(Ce.a)(Co,(function(){var n=this,e=n._self._c;return e("transition",{attrs:{name:"fade"}},[n.visible?e("div",{staticClass:"notification-wrapper"},[e("img",{class:n.active?"active":"noActive",staticStyle:{"pointer-events":"none",border:"1px solid #DDDDDD",width:"100%"},attrs:{src:n.$withBase("/img/other/person_lital.gif")}}),n._v(" "),e("i",{class:["btn-close1",n.active?"active":"noActive"],on:{click:n.closeNote}},[e("svg",{staticClass:"icon",attrs:{t:"1573745677073",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"4448",width:"22",height:"22"}},[e("path",{attrs:{d:"M512 34.133333a486.4 486.4 0 1 0 486.4 486.4A486.4 486.4 0 0 0 512 34.133333z m209.4848 632.8064l-55.6032 55.466667-151.517867-151.125333-151.517866 151.1168-55.6032-55.466667 151.517866-151.108267L307.242667 364.714667l55.6032-55.466667 151.517866 151.125333 151.517867-151.1168 55.6032 55.466667-151.517867 151.099733z m0 0","p-id":"4449"}})])]),n._v(" "),e("h4",{staticClass:"notification-title",staticStyle:{display:"none"}},[e("i",{staticClass:"iconfont reco-tongzhi"}),n._v(" "),e("span",[n._v(" 🎉🎉🎉")]),n._v(" "),e("i",{staticClass:"btn-close",on:{click:n.closeNote}},[e("svg",{staticClass:"icon",attrs:{t:"1573745677073",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"4448",width:"22",height:"22"}},[e("path",{attrs:{d:"M512 34.133333a486.4 486.4 0 1 0 486.4 486.4A486.4 486.4 0 0 0 512 34.133333z m209.4848 632.8064l-55.6032 55.466667-151.517867-151.125333-151.517866 151.1168-55.6032-55.466667 151.517866-151.108267L307.242667 364.714667l55.6032-55.466667 151.517866 151.125333 151.517867-151.1168 55.6032 55.466667-151.517867 151.099733z m0 0","p-id":"4449"}})])])]),n._v(" "),e("div",{staticClass:"notification-content",staticStyle:{display:"none"}},[e("img",{staticClass:"medium-zoom-image",staticStyle:{border:"1px solid #DDDDDD",width:"100%"},attrs:{src:n.$withBase("/img/other/person_lital.gif")}})])]):n._e()])}),[],!1,null,"b83d6b4e",null).exports),Ao={props:{type:{type:String,default:""},title:{type:String,default:""},content:{type:String,default:""},blockStyle:{type:Object,default:null},titleStyle:{type:Object,default:null},contentStyle:{type:Object,default:null},changeTime:{type:String,default:"false"}},data:()=>({boxx:{},class_boxx:"",list:Eo,type_boxx_list:To,show_content:!0,show_title:!0,style_boxx:{},style_title:{},style_content:{},interval:{}}),mounted(){this.getContent(),this.checkTitleAndConten(),this.checkStyleWithTitleAndContenAndBlock(),this.getShowType(this.type),this.dynamicUpdateType(this.changeTime)},watch:{changeTime(n,e){this.dynamicUpdateType(n)}},methods:{getContent(){this.list.length>=100||(ra.a.get("https://v1.jinrishici.com/all.json").then(n=>{let e=" • <span style='font-size: 13px;'>"+n.data.author+"</span>";this.list.push({title:n.data.origin+e,content:n.data.content})}),ra.a.get("https://v1.hitokoto.cn").then(n=>{if(""==n.data.hitokoto||n.data.hitokoto.length>40)return;let e="";null!=n.data.from_who&&(e=" • <span style='font-size: 13px;'>"+n.data.from_who+"</span>"),this.list.push({title:n.data.from+e,content:n.data.hitokoto})}))},getShowType(n){n!=To[2].type?n!=To[1].type?this.class_boxx=To[0].class:this.class_boxx=To[1].class:this.class_boxx=To[2].class},getboxx(){return this.boxx=Eo[Math.floor(Math.random()*Eo.length)]},checkTitleAndConten(){return""!=this.title&&""==this.content?(this.boxx.title=this.title,void(this.show_content=!1)):""==this.title&&""!=this.content?(this.boxx.content=this.content,this.style_content={"margin-top":"1rem","margin-bottom":"0.4rem"},void(this.show_title=!1)):void(""==this.title||""==this.content?this.getboxx():(this.boxx.title=this.title,this.boxx.content=this.content))},checkStyleWithTitleAndContenAndBlock(){null!=this.titleStyle&&(this.style_title=this.titleStyle),null!=this.contentStyle&&(this.style_content=this.contentStyle),null!=this.blockStyle&&(this.style_boxx=this.blockStyle)},dynamicUpdateType(n){if(this.getContent(),""!=n&&"false"!=n&&/^\d+$/.test(n)){var e=0;for(var t in To)this.type==To[t].type&&(e=t);clearInterval(this.interval),this.interval=setInterval(()=>{++e==To.length&&(e=0),this.getShowType(To[e].type),this.checkTitleAndConten()},n)}}}};const To=[{type:"tip",class:"tip custom-block"},{type:"warning",class:"warning custom-block"},{type:"danger",class:"danger custom-block"}],Eo=[{title:"佚名",content:"勇敢不是不害怕，而是害怕的时候你还能坚持去做"}];var Po=Ao,Do=Object(Ce.a)(Po,(function(){var n=this,e=n._self._c;return e("div",{attrs:{id:"boxx"}},[e("div",{class:n.class_boxx,style:n.style_boxx},[e("p",{staticClass:"custom-block-title",style:n.style_title,attrs:{"v-if":n.show_title},domProps:{innerHTML:n._s(n.boxx.title)}}),n._v(" "),e("p",{style:n.style_content,attrs:{"v-if":n.show_content},domProps:{innerHTML:n._s(n.boxx.content)}})])])}),[],!1,null,"f4ca0dac",null).exports;function zo(n){const e=document.documentElement.getBoundingClientRect(),t=n.getBoundingClientRect();return{x:t.left-e.left,y:t.top-e.top}}var Bo=[({Vue:n,options:e,router:t,siteData:r})=>{},({Vue:n})=>{n.mixin(_e)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},({Vue:n})=>{n.component("BackToTop",Me)},({Vue:n})=>{n.component("Pagation",Je)},({Vue:n})=>{n.mixin({computed:{$perPage:()=>10}})},({Vue:n})=>{n.component("Comments",Ia),n.component("AccessNumber",_a)},{},({Vue:n})=>{const e=Object.keys(La).map(n=>{const e=La[n],t="$"+n;return{[t](){const{pages:n}=this.$site;return new Fa(e,n)},["$current"+(n.charAt(0).toUpperCase()+n.slice(1))](){const n=this.$route.meta.id;return this[t].getItemByName(n)}}}).reduce((n,e)=>(Object.assign(n,e),n),{});e.$frontmatterKey=function(){const n=this["$"+this.$route.meta.id];return n||null},n.mixin({computed:e})},({Vue:n})=>{n.mixin({computed:{$pagination(){return this.$route.meta.pid&&this.$route.meta.id?this.$getPagination(this.$route.meta.pid,this.$route.meta.id):null}},methods:{$getPagination(n,e){return e=e||n,$a.getPagination(n,e,this.$route)}}})},({Vue:n})=>{const e={$service:()=>Ja};n.mixin({computed:e})},async({router:n,isServer:e})=>{if(!e){const{register:e}=await t.e(115).then(t.bind(null,473));n.onReady(()=>{e("/znote/service-worker.js",{registrationOptions:{},ready(){console.log("[vuepress:sw] Service worker is active."),Wa.a.$emit("sw-ready")},cached(n){console.log("[vuepress:sw] Content has been cached for offline use."),Wa.a.$emit("sw-cached",new Va(n))},updated(n){console.log("[vuepress:sw] Content updated."),Wa.a.$emit("sw-updated",new Va(n))},offline(){console.log("[vuepress:sw] No internet connection found. App is running in offline mode."),Wa.a.$emit("sw-offline")},error(n){console.error("[vuepress:sw] Error during service worker registration:",n),Wa.a.$emit("sw-error",n),ga("send","exception",{exDescription:n.message,exFatal:!1})}})})}},({router:n})=>{var e,t,r,a,o,i;"undefined"!=typeof window&&(e=window,t=document,r="script",a="ga",e.GoogleAnalyticsObject=a,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,o=t.createElement(r),i=t.getElementsByTagName(r)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",i.parentNode.insertBefore(o,i),ga("create","UA-128189152-1","auto"),ga("set","anonymizeIp",!0),n.afterEach((function(e){ga("set","page",n.app.$withBase(e.fullPath)),ga("send","pageview")})))},({Vue:n})=>{n.component("DetailsOpenFlag",Ka)},({Vue:n})=>{navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)?n.component("musicPlayer",So):n.component("musicPlayer",wo)},({Vue:n})=>{n.component("Notification",jo)},({Vue:n})=>{n.component("Boxx",Do)},({Vue:n,router:e})=>{e.options.scrollBehavior=(e,t,r)=>{if(r)return window.scrollTo({top:r.y,behavior:"smooth"});if(!e.hash)return window.scrollTo({top:0,behavior:"smooth"});{if(n.$vuepress.$get("disableScrollBehavior"))return;const t=e.hash.slice(1),r=document.getElementById(t)||document.querySelector(`[name='${t}']`);if(r)return window.scrollTo({top:zo(r).y,behavior:"smooth"})}}},({Vue:n})=>{n.component("CodeCopy",je)}],Io=["BackToTop","SWUpdatePopup","DetailsOpenFlag","musicPlayer","Notification"];class Oo extends class{constructor(){this.store=new r.a({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){r.a.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Oo.prototype,{getPageAsyncComponent:Kn.e,getLayoutAsyncComponent:Kn.d,getAsyncComponent:Kn.c,getVueComponent:Kn.f});var _o={install(n){const e=new Oo;n.$vuepress=e,n.prototype.$vuepress=e}};function Lo(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Fo={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return Object(Kn.i)("pageKey",e),r.a.component(e)||r.a.component(e,Object(Kn.e)(e)),r.a.component(e)?n(e):n("")}},Mo={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ro={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},No=(t(340),t(341),Object(Ce.a)(Ro,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),qo={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};r.a.config.productionTip=!1,r.a.use(Wn),r.a.use(_o),r.a.mixin(function(n,e,t=r.a){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(o).reduce((n,e)=>(e.startsWith("$")&&(n[e]=o[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Ie)),r.a.component("Content",Fo),r.a.component("ContentSlotsDistributor",Mo),r.a.component("OutboundLink",No),r.a.component("ClientOnly",qo),r.a.component("Layout",Object(Kn.d)("Layout")),r.a.component("NotFound",Object(Kn.d)("NotFound")),r.a.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.9",hash:"e7c8b65"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Ie.routerBase||Ie.base,t=new Wn({base:e,mode:"history",fallback:!1,routes:Be,scrollBehavior:(n,e,t)=>t||(n.hash?!r.a.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Lo(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Lo(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";Lo(n,a)?r(a):Lo(n,t)?r(t):r()}})}(t);const a={};try{await Promise.all(Bo.filter(n=>"function"==typeof n).map(e=>e({Vue:r.a,options:a,router:t,siteData:Ie,isServer:n})))}catch(n){console.error(n)}return{app:new r.a(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Io.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);